
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
4003000c:	0f 01 1d 4c 00 03 40 	lidtl  0x4003004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
40030013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
4003001c:	bc 4c 85 00 a8       	mov    $0xa800854c,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
40030021:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030027:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003002c:	be 28 db 03 40       	mov    $0x4003db28,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030031:	b9 00 01 00 00       	mov    $0x100,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
40030038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003003a:	bf 00 68 00 a8       	mov    $0xa8006800,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
4003003f:	b9 52 07 00 00       	mov    $0x752,%ecx
	cld
40030044:	fc                   	cld    
	rep
40030045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030047:	e9 44 9b 00 00       	jmp    40039b90 <_Cstart>

4003004c <_Idt>:
4003004c:	ff 07 a8 d2 03 40 66 90 66 90 66 90 66 90 66 90     .....@f.f.f.f.f.
4003005c:	66 90 66 90                                         f.f.

40030060 <_thread_entry_wrapper>:
40030060:	58                   	pop    %eax
40030061:	5a                   	pop    %edx
40030062:	59                   	pop    %ecx
40030063:	6a 00                	push   $0x0
40030065:	e9 e8 a3 00 00       	jmp    4003a452 <_thread_entry>

4003006a <memcpy>:
4003006a:	56                   	push   %esi
4003006b:	57                   	push   %edi
4003006c:	89 c7                	mov    %eax,%edi
4003006e:	89 d6                	mov    %edx,%esi
40030070:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40030072:	5f                   	pop    %edi
40030073:	5e                   	pop    %esi
40030074:	c3                   	ret    

40030075 <memset>:
40030075:	57                   	push   %edi
40030076:	89 c7                	mov    %eax,%edi
40030078:	0f b6 c2             	movzbl %dl,%eax
4003007b:	89 fa                	mov    %edi,%edx
4003007d:	f3 aa                	rep stos %al,%es:(%edi)
4003007f:	89 d0                	mov    %edx,%eax
40030081:	5f                   	pop    %edi
40030082:	c3                   	ret    

40030083 <memchr>:
40030083:	57                   	push   %edi
40030084:	89 c7                	mov    %eax,%edi
40030086:	89 d0                	mov    %edx,%eax
40030088:	31 d2                	xor    %edx,%edx
4003008a:	85 c9                	test   %ecx,%ecx
4003008c:	74 09                	je     40030097 <L20>
4003008e:	f2 ae                	repnz scas %es:(%edi),%al
40030090:	0f 95 c2             	setne  %dl
40030093:	4f                   	dec    %edi
40030094:	4a                   	dec    %edx
40030095:	21 fa                	and    %edi,%edx

40030097 <L20>:
40030097:	89 d0                	mov    %edx,%eax
40030099:	5f                   	pop    %edi
4003009a:	c3                   	ret    

4003009b <__udivdi3>:
4003009b:	55                   	push   %ebp
4003009c:	89 e5                	mov    %esp,%ebp
4003009e:	57                   	push   %edi
4003009f:	56                   	push   %esi
400300a0:	53                   	push   %ebx
400300a1:	83 ec 10             	sub    $0x10,%esp
400300a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
400300a7:	8b 45 08             	mov    0x8(%ebp),%eax
400300aa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400300ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
400300b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300b3:	89 d6                	mov    %edx,%esi
400300b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
400300b8:	89 d9                	mov    %ebx,%ecx
400300ba:	89 d0                	mov    %edx,%eax
400300bc:	85 db                	test   %ebx,%ebx
400300be:	8b 55 e8             	mov    -0x18(%ebp),%edx
400300c1:	75 30                	jne    400300f3 <__udivdi3+0x58>
400300c3:	89 d7                	mov    %edx,%edi
400300c5:	39 f2                	cmp    %esi,%edx
400300c7:	76 07                	jbe    400300d0 <__udivdi3+0x35>
400300c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300cc:	89 f2                	mov    %esi,%edx
400300ce:	eb 1a                	jmp    400300ea <__udivdi3+0x4f>
400300d0:	85 d2                	test   %edx,%edx
400300d2:	75 0b                	jne    400300df <__udivdi3+0x44>
400300d4:	b8 01 00 00 00       	mov    $0x1,%eax
400300d9:	31 d2                	xor    %edx,%edx
400300db:	f7 f7                	div    %edi
400300dd:	89 c7                	mov    %eax,%edi
400300df:	31 d2                	xor    %edx,%edx
400300e1:	89 f0                	mov    %esi,%eax
400300e3:	f7 f7                	div    %edi
400300e5:	89 c1                	mov    %eax,%ecx
400300e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300ea:	f7 f7                	div    %edi
400300ec:	89 c3                	mov    %eax,%ebx
400300ee:	e9 92 00 00 00       	jmp    40030185 <__udivdi3+0xea>
400300f3:	39 f3                	cmp    %esi,%ebx
400300f5:	0f 87 82 00 00 00    	ja     4003017d <__udivdi3+0xe2>
400300fb:	0f bd f3             	bsr    %ebx,%esi
400300fe:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030101:	83 75 f0 1f          	xorl   $0x1f,-0x10(%ebp)
40030105:	75 15                	jne    4003011c <__udivdi3+0x81>
40030107:	39 c3                	cmp    %eax,%ebx
40030109:	b9 00 00 00 00       	mov    $0x0,%ecx
4003010e:	72 05                	jb     40030115 <__udivdi3+0x7a>
40030110:	3b 55 ec             	cmp    -0x14(%ebp),%edx
40030113:	77 6a                	ja     4003017f <__udivdi3+0xe4>
40030115:	bb 01 00 00 00       	mov    $0x1,%ebx
4003011a:	eb 69                	jmp    40030185 <__udivdi3+0xea>
4003011c:	be 20 00 00 00       	mov    $0x20,%esi
40030121:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030124:	2b 75 f0             	sub    -0x10(%ebp),%esi
40030127:	89 d7                	mov    %edx,%edi
40030129:	d3 e3                	shl    %cl,%ebx
4003012b:	89 f1                	mov    %esi,%ecx
4003012d:	d3 ef                	shr    %cl,%edi
4003012f:	89 f9                	mov    %edi,%ecx
40030131:	09 d9                	or     %ebx,%ecx
40030133:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030136:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40030139:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003013c:	d3 e2                	shl    %cl,%edx
4003013e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030141:	89 f1                	mov    %esi,%ecx
40030143:	89 c2                	mov    %eax,%edx
40030145:	d3 ea                	shr    %cl,%edx
40030147:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003014a:	d3 e0                	shl    %cl,%eax
4003014c:	89 f1                	mov    %esi,%ecx
4003014e:	d3 eb                	shr    %cl,%ebx
40030150:	09 c3                	or     %eax,%ebx
40030152:	89 d8                	mov    %ebx,%eax
40030154:	f7 75 e8             	divl   -0x18(%ebp)
40030157:	89 d6                	mov    %edx,%esi
40030159:	89 c7                	mov    %eax,%edi
4003015b:	89 c3                	mov    %eax,%ebx
4003015d:	f7 65 e4             	mull   -0x1c(%ebp)
40030160:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030163:	39 d6                	cmp    %edx,%esi
40030165:	72 11                	jb     40030178 <__udivdi3+0xdd>
40030167:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003016a:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003016d:	d3 e0                	shl    %cl,%eax
4003016f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
40030172:	73 0f                	jae    40030183 <__udivdi3+0xe8>
40030174:	39 d6                	cmp    %edx,%esi
40030176:	75 0b                	jne    40030183 <__udivdi3+0xe8>
40030178:	8d 5f ff             	lea    -0x1(%edi),%ebx
4003017b:	eb 06                	jmp    40030183 <__udivdi3+0xe8>
4003017d:	31 c9                	xor    %ecx,%ecx
4003017f:	31 db                	xor    %ebx,%ebx
40030181:	eb 02                	jmp    40030185 <__udivdi3+0xea>
40030183:	31 c9                	xor    %ecx,%ecx
40030185:	89 d8                	mov    %ebx,%eax
40030187:	89 ca                	mov    %ecx,%edx
40030189:	83 c4 10             	add    $0x10,%esp
4003018c:	5b                   	pop    %ebx
4003018d:	5e                   	pop    %esi
4003018e:	5f                   	pop    %edi
4003018f:	5d                   	pop    %ebp
40030190:	c3                   	ret    

40030191 <__adddf3>:
40030191:	55                   	push   %ebp
40030192:	89 d1                	mov    %edx,%ecx
40030194:	c1 e9 14             	shr    $0x14,%ecx
40030197:	89 e5                	mov    %esp,%ebp
40030199:	57                   	push   %edi
4003019a:	56                   	push   %esi
4003019b:	53                   	push   %ebx
4003019c:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
400301a2:	83 ec 18             	sub    $0x18,%esp
400301a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
400301a8:	89 d0                	mov    %edx,%eax
400301aa:	8b 75 0c             	mov    0xc(%ebp),%esi
400301ad:	c1 ea 1f             	shr    $0x1f,%edx
400301b0:	25 ff ff 0f 00       	and    $0xfffff,%eax
400301b5:	89 55 ec             	mov    %edx,-0x14(%ebp)
400301b8:	8b 55 e0             	mov    -0x20(%ebp),%edx
400301bb:	c1 e0 03             	shl    $0x3,%eax
400301be:	89 f3                	mov    %esi,%ebx
400301c0:	c1 ea 1d             	shr    $0x1d,%edx
400301c3:	89 4d e8             	mov    %ecx,-0x18(%ebp)
400301c6:	c1 eb 14             	shr    $0x14,%ebx
400301c9:	09 c2                	or     %eax,%edx
400301cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
400301ce:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
400301d4:	8d 3c c5 00 00 00 00 	lea    0x0(,%eax,8),%edi
400301db:	8b 45 08             	mov    0x8(%ebp),%eax
400301de:	89 45 dc             	mov    %eax,-0x24(%ebp)
400301e1:	89 f0                	mov    %esi,%eax
400301e3:	c1 ee 1f             	shr    $0x1f,%esi
400301e6:	25 ff ff 0f 00       	and    $0xfffff,%eax
400301eb:	c1 e0 03             	shl    $0x3,%eax
400301ee:	89 75 e4             	mov    %esi,-0x1c(%ebp)
400301f1:	8b 75 dc             	mov    -0x24(%ebp),%esi
400301f4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400301f7:	c1 ee 1d             	shr    $0x1d,%esi
400301fa:	09 c6                	or     %eax,%esi
400301fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
400301ff:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030202:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
40030209:	8b 45 e8             	mov    -0x18(%ebp),%eax
4003020c:	29 d8                	sub    %ebx,%eax
4003020e:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40030211:	0f 85 ef 02 00 00    	jne    40030506 <__adddf3+0x375>
40030217:	83 f8 00             	cmp    $0x0,%eax
4003021a:	0f 8e e6 00 00 00    	jle    40030306 <__adddf3+0x175>
40030220:	85 db                	test   %ebx,%ebx
40030222:	75 3a                	jne    4003025e <__adddf3+0xcd>
40030224:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40030227:	09 f3                	or     %esi,%ebx
40030229:	0f 84 eb 02 00 00    	je     4003051a <__adddf3+0x389>
4003022f:	89 c3                	mov    %eax,%ebx
40030231:	4b                   	dec    %ebx
40030232:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40030235:	75 16                	jne    4003024d <__adddf3+0xbc>
40030237:	89 f8                	mov    %edi,%eax
40030239:	bb 01 00 00 00       	mov    $0x1,%ebx
4003023e:	01 f0                	add    %esi,%eax
40030240:	13 55 f0             	adc    -0x10(%ebp),%edx
40030243:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030246:	89 c6                	mov    %eax,%esi
40030248:	e9 7a 02 00 00       	jmp    400304c7 <__adddf3+0x336>
4003024d:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030252:	3d ff 07 00 00       	cmp    $0x7ff,%eax
40030257:	75 21                	jne    4003027a <__adddf3+0xe9>
40030259:	e9 fb 06 00 00       	jmp    40030959 <__adddf3+0x7c8>
4003025e:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030263:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
4003026a:	0f 84 e9 06 00 00    	je     40030959 <__adddf3+0x7c8>
40030270:	81 4d f0 00 00 80 00 	orl    $0x800000,-0x10(%ebp)
40030277:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003027a:	83 7d e4 38          	cmpl   $0x38,-0x1c(%ebp)
4003027e:	7f 69                	jg     400302e9 <__adddf3+0x158>
40030280:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
40030284:	7f 37                	jg     400302bd <__adddf3+0x12c>
40030286:	b8 20 00 00 00       	mov    $0x20,%eax
4003028b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003028e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
40030291:	88 c1                	mov    %al,%cl
40030293:	d3 e3                	shl    %cl,%ebx
40030295:	89 5d e0             	mov    %ebx,-0x20(%ebp)
40030298:	8a 4d e4             	mov    -0x1c(%ebp),%cl
4003029b:	89 f3                	mov    %esi,%ebx
4003029d:	d3 eb                	shr    %cl,%ebx
4003029f:	89 d9                	mov    %ebx,%ecx
400302a1:	8b 5d e0             	mov    -0x20(%ebp),%ebx
400302a4:	09 cb                	or     %ecx,%ebx
400302a6:	88 c1                	mov    %al,%cl
400302a8:	d3 e6                	shl    %cl,%esi
400302aa:	31 c0                	xor    %eax,%eax
400302ac:	85 f6                	test   %esi,%esi
400302ae:	0f 95 c0             	setne  %al
400302b1:	09 c3                	or     %eax,%ebx
400302b3:	8a 4d e4             	mov    -0x1c(%ebp),%cl
400302b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400302b9:	d3 e8                	shr    %cl,%eax
400302bb:	eb 38                	jmp    400302f5 <__adddf3+0x164>
400302bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400302c0:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400302c3:	8d 48 e0             	lea    -0x20(%eax),%ecx
400302c6:	31 c0                	xor    %eax,%eax
400302c8:	d3 eb                	shr    %cl,%ebx
400302ca:	83 7d e4 20          	cmpl   $0x20,-0x1c(%ebp)
400302ce:	74 0d                	je     400302dd <__adddf3+0x14c>
400302d0:	b9 40 00 00 00       	mov    $0x40,%ecx
400302d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400302d8:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
400302db:	d3 e0                	shl    %cl,%eax
400302dd:	09 f0                	or     %esi,%eax
400302df:	0f 95 c0             	setne  %al
400302e2:	0f b6 c0             	movzbl %al,%eax
400302e5:	09 c3                	or     %eax,%ebx
400302e7:	eb 0a                	jmp    400302f3 <__adddf3+0x162>
400302e9:	31 db                	xor    %ebx,%ebx
400302eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
400302ee:	09 f0                	or     %esi,%eax
400302f0:	0f 95 c3             	setne  %bl
400302f3:	31 c0                	xor    %eax,%eax
400302f5:	89 fe                	mov    %edi,%esi
400302f7:	01 de                	add    %ebx,%esi
400302f9:	11 c2                	adc    %eax,%edx
400302fb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
400302fe:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030301:	e9 c1 01 00 00       	jmp    400304c7 <__adddf3+0x336>
40030306:	0f 84 e1 00 00 00    	je     400303ed <__adddf3+0x25c>
4003030c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030310:	75 30                	jne    40030342 <__adddf3+0x1b1>
40030312:	89 d1                	mov    %edx,%ecx
40030314:	09 f9                	or     %edi,%ecx
40030316:	75 11                	jne    40030329 <__adddf3+0x198>
40030318:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
4003031e:	0f 85 d0 05 00 00    	jne    400308f4 <__adddf3+0x763>
40030324:	e9 f9 05 00 00       	jmp    40030922 <__adddf3+0x791>
40030329:	83 f0 ff             	xor    $0xffffffff,%eax
4003032c:	89 45 e8             	mov    %eax,-0x18(%ebp)
4003032f:	0f 84 a9 00 00 00    	je     400303de <__adddf3+0x24d>
40030335:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
4003033b:	75 1c                	jne    40030359 <__adddf3+0x1c8>
4003033d:	e9 e0 05 00 00       	jmp    40030922 <__adddf3+0x791>
40030342:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
40030348:	0f 84 d4 05 00 00    	je     40030922 <__adddf3+0x791>
4003034e:	f7 d8                	neg    %eax
40030350:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030353:	81 ca 00 00 80 00    	or     $0x800000,%edx
40030359:	83 7d e8 38          	cmpl   $0x38,-0x18(%ebp)
4003035d:	7f 74                	jg     400303d3 <__adddf3+0x242>
4003035f:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%ebp)
40030363:	7f 3f                	jg     400303a4 <__adddf3+0x213>
40030365:	b9 20 00 00 00       	mov    $0x20,%ecx
4003036a:	89 5d e0             	mov    %ebx,-0x20(%ebp)
4003036d:	2b 4d e8             	sub    -0x18(%ebp),%ecx
40030370:	89 d3                	mov    %edx,%ebx
40030372:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40030375:	8a 4d e4             	mov    -0x1c(%ebp),%cl
40030378:	d3 e3                	shl    %cl,%ebx
4003037a:	89 d8                	mov    %ebx,%eax
4003037c:	8a 4d e8             	mov    -0x18(%ebp),%cl
4003037f:	89 fb                	mov    %edi,%ebx
40030381:	d3 eb                	shr    %cl,%ebx
40030383:	89 d9                	mov    %ebx,%ecx
40030385:	8b 5d e0             	mov    -0x20(%ebp),%ebx
40030388:	09 c1                	or     %eax,%ecx
4003038a:	89 c8                	mov    %ecx,%eax
4003038c:	8a 4d e4             	mov    -0x1c(%ebp),%cl
4003038f:	d3 e7                	shl    %cl,%edi
40030391:	85 ff                	test   %edi,%edi
40030393:	89 c7                	mov    %eax,%edi
40030395:	0f 95 c1             	setne  %cl
40030398:	0f b6 c9             	movzbl %cl,%ecx
4003039b:	09 cf                	or     %ecx,%edi
4003039d:	8a 4d e8             	mov    -0x18(%ebp),%cl
400303a0:	d3 ea                	shr    %cl,%edx
400303a2:	eb 3a                	jmp    400303de <__adddf3+0x24d>
400303a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
400303a7:	8d 48 e0             	lea    -0x20(%eax),%ecx
400303aa:	89 d0                	mov    %edx,%eax
400303ac:	d3 e8                	shr    %cl,%eax
400303ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400303b1:	31 c9                	xor    %ecx,%ecx
400303b3:	83 7d e8 20          	cmpl   $0x20,-0x18(%ebp)
400303b7:	74 0c                	je     400303c5 <__adddf3+0x234>
400303b9:	b9 40 00 00 00       	mov    $0x40,%ecx
400303be:	2b 4d e8             	sub    -0x18(%ebp),%ecx
400303c1:	d3 e2                	shl    %cl,%edx
400303c3:	89 d1                	mov    %edx,%ecx
400303c5:	31 c0                	xor    %eax,%eax
400303c7:	09 f9                	or     %edi,%ecx
400303c9:	8b 7d e4             	mov    -0x1c(%ebp),%edi
400303cc:	0f 95 c0             	setne  %al
400303cf:	09 c7                	or     %eax,%edi
400303d1:	eb 09                	jmp    400303dc <__adddf3+0x24b>
400303d3:	31 c0                	xor    %eax,%eax
400303d5:	09 fa                	or     %edi,%edx
400303d7:	0f 95 c0             	setne  %al
400303da:	89 c7                	mov    %eax,%edi
400303dc:	31 d2                	xor    %edx,%edx
400303de:	8b 45 f0             	mov    -0x10(%ebp),%eax
400303e1:	01 fe                	add    %edi,%esi
400303e3:	11 d0                	adc    %edx,%eax
400303e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
400303e8:	e9 da 00 00 00       	jmp    400304c7 <__adddf3+0x336>
400303ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
400303f0:	8d 58 01             	lea    0x1(%eax),%ebx
400303f3:	89 d8                	mov    %ebx,%eax
400303f5:	25 ff 07 00 00       	and    $0x7ff,%eax
400303fa:	48                   	dec    %eax
400303fb:	0f 8f 9f 00 00 00    	jg     400304a0 <__adddf3+0x30f>
40030401:	89 d0                	mov    %edx,%eax
40030403:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030407:	75 36                	jne    4003043f <__adddf3+0x2ae>
40030409:	09 f8                	or     %edi,%eax
4003040b:	0f 84 ee 04 00 00    	je     400308ff <__adddf3+0x76e>
40030411:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030414:	09 f0                	or     %esi,%eax
40030416:	0f 84 f3 04 00 00    	je     4003090f <__adddf3+0x77e>
4003041c:	89 f8                	mov    %edi,%eax
4003041e:	01 f0                	add    %esi,%eax
40030420:	13 55 f0             	adc    -0x10(%ebp),%edx
40030423:	0f ba e2 17          	bt     $0x17,%edx
40030427:	89 c7                	mov    %eax,%edi
40030429:	0f 83 e0 04 00 00    	jae    4003090f <__adddf3+0x77e>
4003042f:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
40030435:	bb 01 00 00 00       	mov    $0x1,%ebx
4003043a:	e9 1a 05 00 00       	jmp    40030959 <__adddf3+0x7c8>
4003043f:	09 f8                	or     %edi,%eax
40030441:	0f 84 e2 04 00 00    	je     40030929 <__adddf3+0x798>
40030447:	bb ff 07 00 00       	mov    $0x7ff,%ebx
4003044c:	0b 75 f0             	or     -0x10(%ebp),%esi
4003044f:	0f 84 04 05 00 00    	je     40030959 <__adddf3+0x7c8>
40030455:	89 d0                	mov    %edx,%eax
40030457:	8b 75 e0             	mov    -0x20(%ebp),%esi
4003045a:	8b 7d f0             	mov    -0x10(%ebp),%edi
4003045d:	81 e6 ff ff ff 1f    	and    $0x1fffffff,%esi
40030463:	c1 e0 1d             	shl    $0x1d,%eax
40030466:	c1 ea 03             	shr    $0x3,%edx
40030469:	09 c6                	or     %eax,%esi
4003046b:	c1 ef 03             	shr    $0x3,%edi
4003046e:	39 fa                	cmp    %edi,%edx
40030470:	0f 87 65 03 00 00    	ja     400307db <__adddf3+0x64a>
40030476:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40030479:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003047c:	c1 e0 1d             	shl    $0x1d,%eax
4003047f:	81 e1 ff ff ff 1f    	and    $0x1fffffff,%ecx
40030485:	09 c8                	or     %ecx,%eax
40030487:	39 fa                	cmp    %edi,%edx
40030489:	0f 94 c1             	sete   %cl
4003048c:	39 c6                	cmp    %eax,%esi
4003048e:	0f 93 c3             	setae  %bl
40030491:	84 d9                	test   %bl,%cl
40030493:	0f 85 44 03 00 00    	jne    400307dd <__adddf3+0x64c>
40030499:	89 c6                	mov    %eax,%esi
4003049b:	e9 3d 03 00 00       	jmp    400307dd <__adddf3+0x64c>
400304a0:	89 f8                	mov    %edi,%eax
400304a2:	01 f0                	add    %esi,%eax
400304a4:	13 55 f0             	adc    -0x10(%ebp),%edx
400304a7:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
400304ad:	0f 84 82 04 00 00    	je     40030935 <__adddf3+0x7a4>
400304b3:	89 c1                	mov    %eax,%ecx
400304b5:	83 e0 01             	and    $0x1,%eax
400304b8:	d1 e9                	shr    %ecx
400304ba:	09 c8                	or     %ecx,%eax
400304bc:	89 d1                	mov    %edx,%ecx
400304be:	c1 e1 1f             	shl    $0x1f,%ecx
400304c1:	89 cf                	mov    %ecx,%edi
400304c3:	09 c7                	or     %eax,%edi
400304c5:	eb 38                	jmp    400304ff <__adddf3+0x36e>
400304c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
400304ca:	0f ba e0 17          	bt     $0x17,%eax
400304ce:	0f 83 20 04 00 00    	jae    400308f4 <__adddf3+0x763>
400304d4:	43                   	inc    %ebx
400304d5:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
400304db:	0f 84 54 04 00 00    	je     40030935 <__adddf3+0x7a4>
400304e1:	89 f1                	mov    %esi,%ecx
400304e3:	89 c2                	mov    %eax,%edx
400304e5:	d1 e9                	shr    %ecx
400304e7:	89 f0                	mov    %esi,%eax
400304e9:	83 e0 01             	and    $0x1,%eax
400304ec:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
400304f2:	89 ce                	mov    %ecx,%esi
400304f4:	09 c6                	or     %eax,%esi
400304f6:	89 d0                	mov    %edx,%eax
400304f8:	c1 e0 1f             	shl    $0x1f,%eax
400304fb:	09 f0                	or     %esi,%eax
400304fd:	89 c7                	mov    %eax,%edi
400304ff:	d1 ea                	shr    %edx
40030501:	e9 53 04 00 00       	jmp    40030959 <__adddf3+0x7c8>
40030506:	83 f8 00             	cmp    $0x0,%eax
40030509:	0f 8e f7 00 00 00    	jle    40030606 <__adddf3+0x475>
4003050f:	85 db                	test   %ebx,%ebx
40030511:	75 4b                	jne    4003055e <__adddf3+0x3cd>
40030513:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40030516:	09 f3                	or     %esi,%ebx
40030518:	75 15                	jne    4003052f <__adddf3+0x39e>
4003051a:	bb ff 07 00 00       	mov    $0x7ff,%ebx
4003051f:	3d ff 07 00 00       	cmp    $0x7ff,%eax
40030524:	0f 85 93 04 00 00    	jne    400309bd <__adddf3+0x82c>
4003052a:	e9 2a 04 00 00       	jmp    40030959 <__adddf3+0x7c8>
4003052f:	89 c3                	mov    %eax,%ebx
40030531:	4b                   	dec    %ebx
40030532:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
40030535:	75 16                	jne    4003054d <__adddf3+0x3bc>
40030537:	89 f8                	mov    %edi,%eax
40030539:	bb 01 00 00 00       	mov    $0x1,%ebx
4003053e:	29 f0                	sub    %esi,%eax
40030540:	1b 55 f0             	sbb    -0x10(%ebp),%edx
40030543:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030546:	89 c6                	mov    %eax,%esi
40030548:	e9 d8 02 00 00       	jmp    40030825 <__adddf3+0x694>
4003054d:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030552:	3d ff 07 00 00       	cmp    $0x7ff,%eax
40030557:	75 21                	jne    4003057a <__adddf3+0x3e9>
40030559:	e9 fb 03 00 00       	jmp    40030959 <__adddf3+0x7c8>
4003055e:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030563:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
4003056a:	0f 84 e9 03 00 00    	je     40030959 <__adddf3+0x7c8>
40030570:	81 4d f0 00 00 80 00 	orl    $0x800000,-0x10(%ebp)
40030577:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003057a:	83 7d e4 38          	cmpl   $0x38,-0x1c(%ebp)
4003057e:	7f 69                	jg     400305e9 <__adddf3+0x458>
40030580:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
40030584:	7f 37                	jg     400305bd <__adddf3+0x42c>
40030586:	b8 20 00 00 00       	mov    $0x20,%eax
4003058b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003058e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
40030591:	88 c1                	mov    %al,%cl
40030593:	d3 e3                	shl    %cl,%ebx
40030595:	89 5d e0             	mov    %ebx,-0x20(%ebp)
40030598:	8a 4d e4             	mov    -0x1c(%ebp),%cl
4003059b:	89 f3                	mov    %esi,%ebx
4003059d:	d3 eb                	shr    %cl,%ebx
4003059f:	89 d9                	mov    %ebx,%ecx
400305a1:	8b 5d e0             	mov    -0x20(%ebp),%ebx
400305a4:	09 cb                	or     %ecx,%ebx
400305a6:	88 c1                	mov    %al,%cl
400305a8:	d3 e6                	shl    %cl,%esi
400305aa:	31 c0                	xor    %eax,%eax
400305ac:	85 f6                	test   %esi,%esi
400305ae:	0f 95 c0             	setne  %al
400305b1:	09 c3                	or     %eax,%ebx
400305b3:	8a 4d e4             	mov    -0x1c(%ebp),%cl
400305b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400305b9:	d3 e8                	shr    %cl,%eax
400305bb:	eb 38                	jmp    400305f5 <__adddf3+0x464>
400305bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400305c0:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400305c3:	8d 48 e0             	lea    -0x20(%eax),%ecx
400305c6:	31 c0                	xor    %eax,%eax
400305c8:	d3 eb                	shr    %cl,%ebx
400305ca:	83 7d e4 20          	cmpl   $0x20,-0x1c(%ebp)
400305ce:	74 0d                	je     400305dd <__adddf3+0x44c>
400305d0:	b9 40 00 00 00       	mov    $0x40,%ecx
400305d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400305d8:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
400305db:	d3 e0                	shl    %cl,%eax
400305dd:	09 f0                	or     %esi,%eax
400305df:	0f 95 c0             	setne  %al
400305e2:	0f b6 c0             	movzbl %al,%eax
400305e5:	09 c3                	or     %eax,%ebx
400305e7:	eb 0a                	jmp    400305f3 <__adddf3+0x462>
400305e9:	31 db                	xor    %ebx,%ebx
400305eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
400305ee:	09 f0                	or     %esi,%eax
400305f0:	0f 95 c3             	setne  %bl
400305f3:	31 c0                	xor    %eax,%eax
400305f5:	89 fe                	mov    %edi,%esi
400305f7:	29 de                	sub    %ebx,%esi
400305f9:	19 c2                	sbb    %eax,%edx
400305fb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
400305fe:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030601:	e9 1f 02 00 00       	jmp    40030825 <__adddf3+0x694>
40030606:	0f 84 ed 00 00 00    	je     400306f9 <__adddf3+0x568>
4003060c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030610:	75 36                	jne    40030648 <__adddf3+0x4b7>
40030612:	89 d1                	mov    %edx,%ecx
40030614:	09 f9                	or     %edi,%ecx
40030616:	75 17                	jne    4003062f <__adddf3+0x49e>
40030618:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
4003061e:	0f 84 17 03 00 00    	je     4003093b <__adddf3+0x7aa>
40030624:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40030627:	89 45 ec             	mov    %eax,-0x14(%ebp)
4003062a:	e9 c5 02 00 00       	jmp    400308f4 <__adddf3+0x763>
4003062f:	83 f0 ff             	xor    $0xffffffff,%eax
40030632:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030635:	0f 84 a9 00 00 00    	je     400306e4 <__adddf3+0x553>
4003063b:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
40030641:	75 1c                	jne    4003065f <__adddf3+0x4ce>
40030643:	e9 f3 02 00 00       	jmp    4003093b <__adddf3+0x7aa>
40030648:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
4003064e:	0f 84 e7 02 00 00    	je     4003093b <__adddf3+0x7aa>
40030654:	f7 d8                	neg    %eax
40030656:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030659:	81 ca 00 00 80 00    	or     $0x800000,%edx
4003065f:	83 7d ec 38          	cmpl   $0x38,-0x14(%ebp)
40030663:	7f 74                	jg     400306d9 <__adddf3+0x548>
40030665:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
40030669:	7f 3f                	jg     400306aa <__adddf3+0x519>
4003066b:	b9 20 00 00 00       	mov    $0x20,%ecx
40030670:	89 5d e0             	mov    %ebx,-0x20(%ebp)
40030673:	2b 4d ec             	sub    -0x14(%ebp),%ecx
40030676:	89 d3                	mov    %edx,%ebx
40030678:	89 4d e8             	mov    %ecx,-0x18(%ebp)
4003067b:	8a 4d e8             	mov    -0x18(%ebp),%cl
4003067e:	d3 e3                	shl    %cl,%ebx
40030680:	89 d8                	mov    %ebx,%eax
40030682:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030685:	89 fb                	mov    %edi,%ebx
40030687:	d3 eb                	shr    %cl,%ebx
40030689:	89 d9                	mov    %ebx,%ecx
4003068b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
4003068e:	09 c1                	or     %eax,%ecx
40030690:	89 c8                	mov    %ecx,%eax
40030692:	8a 4d e8             	mov    -0x18(%ebp),%cl
40030695:	d3 e7                	shl    %cl,%edi
40030697:	85 ff                	test   %edi,%edi
40030699:	89 c7                	mov    %eax,%edi
4003069b:	0f 95 c1             	setne  %cl
4003069e:	0f b6 c9             	movzbl %cl,%ecx
400306a1:	09 cf                	or     %ecx,%edi
400306a3:	8a 4d ec             	mov    -0x14(%ebp),%cl
400306a6:	d3 ea                	shr    %cl,%edx
400306a8:	eb 3a                	jmp    400306e4 <__adddf3+0x553>
400306aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
400306ad:	8d 48 e0             	lea    -0x20(%eax),%ecx
400306b0:	89 d0                	mov    %edx,%eax
400306b2:	d3 e8                	shr    %cl,%eax
400306b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
400306b7:	31 c9                	xor    %ecx,%ecx
400306b9:	83 7d ec 20          	cmpl   $0x20,-0x14(%ebp)
400306bd:	74 0c                	je     400306cb <__adddf3+0x53a>
400306bf:	b9 40 00 00 00       	mov    $0x40,%ecx
400306c4:	2b 4d ec             	sub    -0x14(%ebp),%ecx
400306c7:	d3 e2                	shl    %cl,%edx
400306c9:	89 d1                	mov    %edx,%ecx
400306cb:	31 c0                	xor    %eax,%eax
400306cd:	09 f9                	or     %edi,%ecx
400306cf:	8b 7d e8             	mov    -0x18(%ebp),%edi
400306d2:	0f 95 c0             	setne  %al
400306d5:	09 c7                	or     %eax,%edi
400306d7:	eb 09                	jmp    400306e2 <__adddf3+0x551>
400306d9:	31 c0                	xor    %eax,%eax
400306db:	09 fa                	or     %edi,%edx
400306dd:	0f 95 c0             	setne  %al
400306e0:	89 c7                	mov    %eax,%edi
400306e2:	31 d2                	xor    %edx,%edx
400306e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400306e7:	29 fe                	sub    %edi,%esi
400306e9:	19 d0                	sbb    %edx,%eax
400306eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
400306ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400306f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
400306f4:	e9 2c 01 00 00       	jmp    40030825 <__adddf3+0x694>
400306f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
400306fc:	40                   	inc    %eax
400306fd:	25 ff 07 00 00       	and    $0x7ff,%eax
40030702:	48                   	dec    %eax
40030703:	0f 8f ea 00 00 00    	jg     400307f3 <__adddf3+0x662>
40030709:	89 d0                	mov    %edx,%eax
4003070b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
4003070f:	75 57                	jne    40030768 <__adddf3+0x5d7>
40030711:	09 f8                	or     %edi,%eax
40030713:	75 10                	jne    40030725 <__adddf3+0x594>
40030715:	8b 7d f0             	mov    -0x10(%ebp),%edi
40030718:	09 f7                	or     %esi,%edi
4003071a:	0f 84 e6 01 00 00    	je     40030906 <__adddf3+0x775>
40030720:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030723:	eb 23                	jmp    40030748 <__adddf3+0x5b7>
40030725:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030728:	09 f0                	or     %esi,%eax
4003072a:	0f 84 df 01 00 00    	je     4003090f <__adddf3+0x77e>
40030730:	89 d0                	mov    %edx,%eax
40030732:	89 f9                	mov    %edi,%ecx
40030734:	29 f1                	sub    %esi,%ecx
40030736:	1b 45 f0             	sbb    -0x10(%ebp),%eax
40030739:	0f ba e0 17          	bt     $0x17,%eax
4003073d:	73 16                	jae    40030755 <__adddf3+0x5c4>
4003073f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030742:	29 fe                	sub    %edi,%esi
40030744:	19 d0                	sbb    %edx,%eax
40030746:	89 c2                	mov    %eax,%edx
40030748:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4003074b:	89 f7                	mov    %esi,%edi
4003074d:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030750:	e9 ba 01 00 00       	jmp    4003090f <__adddf3+0x77e>
40030755:	89 c7                	mov    %eax,%edi
40030757:	09 cf                	or     %ecx,%edi
40030759:	0f 84 a7 01 00 00    	je     40030906 <__adddf3+0x775>
4003075f:	89 c2                	mov    %eax,%edx
40030761:	89 cf                	mov    %ecx,%edi
40030763:	e9 a7 01 00 00       	jmp    4003090f <__adddf3+0x77e>
40030768:	09 f8                	or     %edi,%eax
4003076a:	75 1b                	jne    40030787 <__adddf3+0x5f6>
4003076c:	8b 7d f0             	mov    -0x10(%ebp),%edi
4003076f:	09 f7                	or     %esi,%edi
40030771:	0f 84 d1 01 00 00    	je     40030948 <__adddf3+0x7b7>
40030777:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4003077a:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003077d:	89 f7                	mov    %esi,%edi
4003077f:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030782:	e9 a7 01 00 00       	jmp    4003092e <__adddf3+0x79d>
40030787:	bb ff 07 00 00       	mov    $0x7ff,%ebx
4003078c:	0b 75 f0             	or     -0x10(%ebp),%esi
4003078f:	0f 84 c4 01 00 00    	je     40030959 <__adddf3+0x7c8>
40030795:	89 d0                	mov    %edx,%eax
40030797:	8b 75 e0             	mov    -0x20(%ebp),%esi
4003079a:	8b 7d f0             	mov    -0x10(%ebp),%edi
4003079d:	81 e6 ff ff ff 1f    	and    $0x1fffffff,%esi
400307a3:	c1 e0 1d             	shl    $0x1d,%eax
400307a6:	c1 ea 03             	shr    $0x3,%edx
400307a9:	09 c6                	or     %eax,%esi
400307ab:	c1 ef 03             	shr    $0x3,%edi
400307ae:	39 fa                	cmp    %edi,%edx
400307b0:	77 29                	ja     400307db <__adddf3+0x64a>
400307b2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400307b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400307b8:	c1 e0 1d             	shl    $0x1d,%eax
400307bb:	81 e1 ff ff ff 1f    	and    $0x1fffffff,%ecx
400307c1:	09 c8                	or     %ecx,%eax
400307c3:	39 fa                	cmp    %edi,%edx
400307c5:	0f 94 c3             	sete   %bl
400307c8:	39 c6                	cmp    %eax,%esi
400307ca:	0f 93 c1             	setae  %cl
400307cd:	84 cb                	test   %cl,%bl
400307cf:	75 0c                	jne    400307dd <__adddf3+0x64c>
400307d1:	89 c6                	mov    %eax,%esi
400307d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400307d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
400307d9:	eb 02                	jmp    400307dd <__adddf3+0x64c>
400307db:	89 d7                	mov    %edx,%edi
400307dd:	c1 e7 03             	shl    $0x3,%edi
400307e0:	89 f2                	mov    %esi,%edx
400307e2:	c1 ea 1d             	shr    $0x1d,%edx
400307e5:	09 fa                	or     %edi,%edx
400307e7:	8d 3c f5 00 00 00 00 	lea    0x0(,%esi,8),%edi
400307ee:	e9 3b 01 00 00       	jmp    4003092e <__adddf3+0x79d>
400307f3:	89 d3                	mov    %edx,%ebx
400307f5:	89 f9                	mov    %edi,%ecx
400307f7:	29 f1                	sub    %esi,%ecx
400307f9:	1b 5d f0             	sbb    -0x10(%ebp),%ebx
400307fc:	89 d8                	mov    %ebx,%eax
400307fe:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40030801:	0f ba e3 17          	bt     $0x17,%ebx
40030805:	73 12                	jae    40030819 <__adddf3+0x688>
40030807:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003080a:	29 fe                	sub    %edi,%esi
4003080c:	19 d0                	sbb    %edx,%eax
4003080e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40030811:	89 75 e0             	mov    %esi,-0x20(%ebp)
40030814:	89 7d ec             	mov    %edi,-0x14(%ebp)
40030817:	eb 24                	jmp    4003083d <__adddf3+0x6ac>
40030819:	89 df                	mov    %ebx,%edi
4003081b:	09 cf                	or     %ecx,%edi
4003081d:	0f 84 e3 00 00 00    	je     40030906 <__adddf3+0x775>
40030823:	eb 18                	jmp    4003083d <__adddf3+0x6ac>
40030825:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030828:	0f ba e0 17          	bt     $0x17,%eax
4003082c:	0f 83 c2 00 00 00    	jae    400308f4 <__adddf3+0x763>
40030832:	25 ff ff 7f 00       	and    $0x7fffff,%eax
40030837:	89 75 e0             	mov    %esi,-0x20(%ebp)
4003083a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
4003083d:	85 c0                	test   %eax,%eax
4003083f:	74 08                	je     40030849 <__adddf3+0x6b8>
40030841:	0f bd c8             	bsr    %eax,%ecx
40030844:	83 f1 1f             	xor    $0x1f,%ecx
40030847:	eb 0a                	jmp    40030853 <__adddf3+0x6c2>
40030849:	0f bd 4d e0          	bsr    -0x20(%ebp),%ecx
4003084d:	83 f1 1f             	xor    $0x1f,%ecx
40030850:	83 c1 20             	add    $0x20,%ecx
40030853:	8d 59 f8             	lea    -0x8(%ecx),%ebx
40030856:	83 fb 1f             	cmp    $0x1f,%ebx
40030859:	7f 1b                	jg     40030876 <__adddf3+0x6e5>
4003085b:	88 d9                	mov    %bl,%cl
4003085d:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030860:	d3 e0                	shl    %cl,%eax
40030862:	b9 20 00 00 00       	mov    $0x20,%ecx
40030867:	8b 75 e0             	mov    -0x20(%ebp),%esi
4003086a:	29 d9                	sub    %ebx,%ecx
4003086c:	d3 ea                	shr    %cl,%edx
4003086e:	88 d9                	mov    %bl,%cl
40030870:	09 c2                	or     %eax,%edx
40030872:	d3 e6                	shl    %cl,%esi
40030874:	eb 0a                	jmp    40030880 <__adddf3+0x6ef>
40030876:	83 e9 28             	sub    $0x28,%ecx
40030879:	8b 55 e0             	mov    -0x20(%ebp),%edx
4003087c:	d3 e2                	shl    %cl,%edx
4003087e:	31 f6                	xor    %esi,%esi
40030880:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
40030883:	7f 5f                	jg     400308e4 <__adddf3+0x753>
40030885:	2b 5d e8             	sub    -0x18(%ebp),%ebx
40030888:	8d 43 01             	lea    0x1(%ebx),%eax
4003088b:	83 f8 1f             	cmp    $0x1f,%eax
4003088e:	7f 2c                	jg     400308bc <__adddf3+0x72b>
40030890:	bb 20 00 00 00       	mov    $0x20,%ebx
40030895:	89 d7                	mov    %edx,%edi
40030897:	29 c3                	sub    %eax,%ebx
40030899:	88 d9                	mov    %bl,%cl
4003089b:	d3 e7                	shl    %cl,%edi
4003089d:	89 7d f0             	mov    %edi,-0x10(%ebp)
400308a0:	88 c1                	mov    %al,%cl
400308a2:	89 f7                	mov    %esi,%edi
400308a4:	d3 ef                	shr    %cl,%edi
400308a6:	88 d9                	mov    %bl,%cl
400308a8:	0b 7d f0             	or     -0x10(%ebp),%edi
400308ab:	d3 e6                	shl    %cl,%esi
400308ad:	31 c9                	xor    %ecx,%ecx
400308af:	85 f6                	test   %esi,%esi
400308b1:	0f 95 c1             	setne  %cl
400308b4:	09 cf                	or     %ecx,%edi
400308b6:	88 c1                	mov    %al,%cl
400308b8:	d3 ea                	shr    %cl,%edx
400308ba:	eb 53                	jmp    4003090f <__adddf3+0x77e>
400308bc:	8d 4b e1             	lea    -0x1f(%ebx),%ecx
400308bf:	89 d3                	mov    %edx,%ebx
400308c1:	d3 eb                	shr    %cl,%ebx
400308c3:	31 c9                	xor    %ecx,%ecx
400308c5:	83 f8 20             	cmp    $0x20,%eax
400308c8:	74 0b                	je     400308d5 <__adddf3+0x744>
400308ca:	b9 40 00 00 00       	mov    $0x40,%ecx
400308cf:	29 c1                	sub    %eax,%ecx
400308d1:	d3 e2                	shl    %cl,%edx
400308d3:	89 d1                	mov    %edx,%ecx
400308d5:	31 c0                	xor    %eax,%eax
400308d7:	89 df                	mov    %ebx,%edi
400308d9:	09 ce                	or     %ecx,%esi
400308db:	0f 95 c0             	setne  %al
400308de:	09 c7                	or     %eax,%edi
400308e0:	31 d2                	xor    %edx,%edx
400308e2:	eb 2b                	jmp    4003090f <__adddf3+0x77e>
400308e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
400308e7:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
400308ed:	29 d8                	sub    %ebx,%eax
400308ef:	89 55 f0             	mov    %edx,-0x10(%ebp)
400308f2:	89 c3                	mov    %eax,%ebx
400308f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
400308f7:	89 f7                	mov    %esi,%edi
400308f9:	85 db                	test   %ebx,%ebx
400308fb:	74 12                	je     4003090f <__adddf3+0x77e>
400308fd:	eb 5a                	jmp    40030959 <__adddf3+0x7c8>
400308ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030902:	89 f7                	mov    %esi,%edi
40030904:	eb 09                	jmp    4003090f <__adddf3+0x77e>
40030906:	31 d2                	xor    %edx,%edx
40030908:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4003090f:	89 f8                	mov    %edi,%eax
40030911:	09 d0                	or     %edx,%eax
40030913:	0f 85 a0 00 00 00    	jne    400309b9 <__adddf3+0x828>
40030919:	31 d2                	xor    %edx,%edx
4003091b:	31 ff                	xor    %edi,%edi
4003091d:	e9 97 00 00 00       	jmp    400309b9 <__adddf3+0x828>
40030922:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030925:	89 f7                	mov    %esi,%edi
40030927:	eb 30                	jmp    40030959 <__adddf3+0x7c8>
40030929:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003092c:	89 f7                	mov    %esi,%edi
4003092e:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030933:	eb 24                	jmp    40030959 <__adddf3+0x7c8>
40030935:	31 d2                	xor    %edx,%edx
40030937:	31 ff                	xor    %edi,%edi
40030939:	eb 1e                	jmp    40030959 <__adddf3+0x7c8>
4003093b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4003093e:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030941:	89 f7                	mov    %esi,%edi
40030943:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030946:	eb 11                	jmp    40030959 <__adddf3+0x7c8>
40030948:	ba 00 00 40 00       	mov    $0x400000,%edx
4003094d:	bb ff 07 00 00       	mov    $0x7ff,%ebx
40030952:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40030959:	f7 c7 07 00 00 00    	test   $0x7,%edi
4003095f:	74 14                	je     40030975 <__adddf3+0x7e4>
40030961:	89 f8                	mov    %edi,%eax
40030963:	83 e0 0f             	and    $0xf,%eax
40030966:	83 f8 04             	cmp    $0x4,%eax
40030969:	74 0a                	je     40030975 <__adddf3+0x7e4>
4003096b:	89 f8                	mov    %edi,%eax
4003096d:	83 c0 04             	add    $0x4,%eax
40030970:	83 d2 00             	adc    $0x0,%edx
40030973:	89 c7                	mov    %eax,%edi
40030975:	0f ba e2 17          	bt     $0x17,%edx
40030979:	73 13                	jae    4003098e <__adddf3+0x7fd>
4003097b:	43                   	inc    %ebx
4003097c:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
40030982:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
40030988:	75 04                	jne    4003098e <__adddf3+0x7fd>
4003098a:	31 d2                	xor    %edx,%edx
4003098c:	31 ff                	xor    %edi,%edi
4003098e:	89 d6                	mov    %edx,%esi
40030990:	89 f8                	mov    %edi,%eax
40030992:	c1 e8 03             	shr    $0x3,%eax
40030995:	c1 e6 1d             	shl    $0x1d,%esi
40030998:	c1 ea 03             	shr    $0x3,%edx
4003099b:	09 c6                	or     %eax,%esi
4003099d:	89 d1                	mov    %edx,%ecx
4003099f:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
400309a5:	75 1a                	jne    400309c1 <__adddf3+0x830>
400309a7:	89 f0                	mov    %esi,%eax
400309a9:	09 d0                	or     %edx,%eax
400309ab:	74 08                	je     400309b5 <__adddf3+0x824>
400309ad:	81 c9 00 00 08 00    	or     $0x80000,%ecx
400309b3:	eb 0c                	jmp    400309c1 <__adddf3+0x830>
400309b5:	31 c9                	xor    %ecx,%ecx
400309b7:	eb 08                	jmp    400309c1 <__adddf3+0x830>
400309b9:	31 db                	xor    %ebx,%ebx
400309bb:	eb 9c                	jmp    40030959 <__adddf3+0x7c8>
400309bd:	89 c3                	mov    %eax,%ebx
400309bf:	eb 98                	jmp    40030959 <__adddf3+0x7c8>
400309c1:	31 d2                	xor    %edx,%edx
400309c3:	89 f0                	mov    %esi,%eax
400309c5:	89 d6                	mov    %edx,%esi
400309c7:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
400309cd:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
400309d3:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
400309d9:	c1 e3 14             	shl    $0x14,%ebx
400309dc:	09 f1                	or     %esi,%ecx
400309de:	81 e1 ff ff 0f 80    	and    $0x800fffff,%ecx
400309e4:	09 cb                	or     %ecx,%ebx
400309e6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400309e9:	c1 e1 1f             	shl    $0x1f,%ecx
400309ec:	83 c4 18             	add    $0x18,%esp
400309ef:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
400309f5:	09 cb                	or     %ecx,%ebx
400309f7:	89 da                	mov    %ebx,%edx
400309f9:	5b                   	pop    %ebx
400309fa:	5e                   	pop    %esi
400309fb:	5f                   	pop    %edi
400309fc:	5d                   	pop    %ebp
400309fd:	c3                   	ret    

400309fe <__divdf3>:
400309fe:	55                   	push   %ebp
400309ff:	89 d1                	mov    %edx,%ecx
40030a01:	c1 e9 14             	shr    $0x14,%ecx
40030a04:	89 e5                	mov    %esp,%ebp
40030a06:	57                   	push   %edi
40030a07:	56                   	push   %esi
40030a08:	53                   	push   %ebx
40030a09:	89 d3                	mov    %edx,%ebx
40030a0b:	c1 ea 1f             	shr    $0x1f,%edx
40030a0e:	83 ec 24             	sub    $0x24,%esp
40030a11:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40030a14:	8b 75 0c             	mov    0xc(%ebp),%esi
40030a17:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
40030a1b:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
40030a21:	89 75 e0             	mov    %esi,-0x20(%ebp)
40030a24:	66 81 e1 ff 07       	and    $0x7ff,%cx
40030a29:	8b 7d 08             	mov    0x8(%ebp),%edi
40030a2c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030a2f:	89 c6                	mov    %eax,%esi
40030a31:	74 29                	je     40030a5c <__divdf3+0x5e>
40030a33:	66 81 f9 ff 07       	cmp    $0x7ff,%cx
40030a38:	0f 84 85 00 00 00    	je     40030ac3 <__divdf3+0xc5>
40030a3e:	c1 e8 1d             	shr    $0x1d,%eax
40030a41:	c1 e3 03             	shl    $0x3,%ebx
40030a44:	0d 00 00 80 00       	or     $0x800000,%eax
40030a49:	0f b7 c9             	movzwl %cx,%ecx
40030a4c:	c1 e6 03             	shl    $0x3,%esi
40030a4f:	09 d8                	or     %ebx,%eax
40030a51:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030a54:	8d 81 01 fc ff ff    	lea    -0x3ff(%ecx),%eax
40030a5a:	eb 5b                	jmp    40030ab7 <__divdf3+0xb9>
40030a5c:	09 de                	or     %ebx,%esi
40030a5e:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030a61:	74 7a                	je     40030add <__divdf3+0xdf>
40030a63:	85 db                	test   %ebx,%ebx
40030a65:	74 08                	je     40030a6f <__divdf3+0x71>
40030a67:	0f bd d3             	bsr    %ebx,%edx
40030a6a:	83 f2 1f             	xor    $0x1f,%edx
40030a6d:	eb 09                	jmp    40030a78 <__divdf3+0x7a>
40030a6f:	0f bd d0             	bsr    %eax,%edx
40030a72:	83 f2 1f             	xor    $0x1f,%edx
40030a75:	83 c2 20             	add    $0x20,%edx
40030a78:	8d 72 f5             	lea    -0xb(%edx),%esi
40030a7b:	83 fe 1c             	cmp    $0x1c,%esi
40030a7e:	7f 26                	jg     40030aa6 <__divdf3+0xa8>
40030a80:	8d 4a f8             	lea    -0x8(%edx),%ecx
40030a83:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40030a86:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030a89:	d3 e3                	shl    %cl,%ebx
40030a8b:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40030a90:	29 f1                	sub    %esi,%ecx
40030a92:	89 c6                	mov    %eax,%esi
40030a94:	d3 ee                	shr    %cl,%esi
40030a96:	89 f1                	mov    %esi,%ecx
40030a98:	09 d9                	or     %ebx,%ecx
40030a9a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030a9d:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030aa0:	d3 e0                	shl    %cl,%eax
40030aa2:	89 c6                	mov    %eax,%esi
40030aa4:	eb 0a                	jmp    40030ab0 <__divdf3+0xb2>
40030aa6:	8d 4a d8             	lea    -0x28(%edx),%ecx
40030aa9:	31 f6                	xor    %esi,%esi
40030aab:	d3 e0                	shl    %cl,%eax
40030aad:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030ab0:	b8 0d fc ff ff       	mov    $0xfffffc0d,%eax
40030ab5:	29 d0                	sub    %edx,%eax
40030ab7:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030aba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40030ac1:	eb 3c                	jmp    40030aff <__divdf3+0x101>
40030ac3:	09 d8                	or     %ebx,%eax
40030ac5:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030ac8:	74 25                	je     40030aef <__divdf3+0xf1>
40030aca:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40030acd:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40030ad4:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
40030adb:	eb 22                	jmp    40030aff <__divdf3+0x101>
40030add:	31 f6                	xor    %esi,%esi
40030adf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40030ae6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40030aed:	eb 10                	jmp    40030aff <__divdf3+0x101>
40030aef:	31 f6                	xor    %esi,%esi
40030af1:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40030af8:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
40030aff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40030b02:	89 cb                	mov    %ecx,%ebx
40030b04:	89 c8                	mov    %ecx,%eax
40030b06:	c1 e9 1f             	shr    $0x1f,%ecx
40030b09:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
40030b0f:	c1 e8 14             	shr    $0x14,%eax
40030b12:	89 4d d0             	mov    %ecx,-0x30(%ebp)
40030b15:	0f b6 55 d0          	movzbl -0x30(%ebp),%edx
40030b19:	66 25 ff 07          	and    $0x7ff,%ax
40030b1d:	89 55 d8             	mov    %edx,-0x28(%ebp)
40030b20:	74 2f                	je     40030b51 <__divdf3+0x153>
40030b22:	66 3d ff 07          	cmp    $0x7ff,%ax
40030b26:	0f 84 83 00 00 00    	je     40030baf <__divdf3+0x1b1>
40030b2c:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
40030b33:	89 fb                	mov    %edi,%ebx
40030b35:	c1 eb 1d             	shr    $0x1d,%ebx
40030b38:	81 cb 00 00 80 00    	or     $0x800000,%ebx
40030b3e:	0f b7 c0             	movzwl %ax,%eax
40030b41:	09 cb                	or     %ecx,%ebx
40030b43:	2d ff 03 00 00       	sub    $0x3ff,%eax
40030b48:	8d 0c fd 00 00 00 00 	lea    0x0(,%edi,8),%ecx
40030b4f:	eb 5a                	jmp    40030bab <__divdf3+0x1ad>
40030b51:	89 f9                	mov    %edi,%ecx
40030b53:	09 d9                	or     %ebx,%ecx
40030b55:	74 6c                	je     40030bc3 <__divdf3+0x1c5>
40030b57:	85 db                	test   %ebx,%ebx
40030b59:	74 08                	je     40030b63 <__divdf3+0x165>
40030b5b:	0f bd c3             	bsr    %ebx,%eax
40030b5e:	83 f0 1f             	xor    $0x1f,%eax
40030b61:	eb 09                	jmp    40030b6c <__divdf3+0x16e>
40030b63:	0f bd c7             	bsr    %edi,%eax
40030b66:	83 f0 1f             	xor    $0x1f,%eax
40030b69:	83 c0 20             	add    $0x20,%eax
40030b6c:	8d 50 f5             	lea    -0xb(%eax),%edx
40030b6f:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030b72:	83 fa 1c             	cmp    $0x1c,%edx
40030b75:	7f 22                	jg     40030b99 <__divdf3+0x19b>
40030b77:	8d 50 f8             	lea    -0x8(%eax),%edx
40030b7a:	89 55 dc             	mov    %edx,-0x24(%ebp)
40030b7d:	89 fa                	mov    %edi,%edx
40030b7f:	8a 4d dc             	mov    -0x24(%ebp),%cl
40030b82:	d3 e3                	shl    %cl,%ebx
40030b84:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40030b89:	2b 4d e0             	sub    -0x20(%ebp),%ecx
40030b8c:	d3 ea                	shr    %cl,%edx
40030b8e:	8a 4d dc             	mov    -0x24(%ebp),%cl
40030b91:	09 d3                	or     %edx,%ebx
40030b93:	d3 e7                	shl    %cl,%edi
40030b95:	89 f9                	mov    %edi,%ecx
40030b97:	eb 09                	jmp    40030ba2 <__divdf3+0x1a4>
40030b99:	8d 48 d8             	lea    -0x28(%eax),%ecx
40030b9c:	d3 e7                	shl    %cl,%edi
40030b9e:	89 fb                	mov    %edi,%ebx
40030ba0:	31 c9                	xor    %ecx,%ecx
40030ba2:	bf 0d fc ff ff       	mov    $0xfffffc0d,%edi
40030ba7:	29 c7                	sub    %eax,%edi
40030ba9:	89 f8                	mov    %edi,%eax
40030bab:	31 ff                	xor    %edi,%edi
40030bad:	eb 2b                	jmp    40030bda <__divdf3+0x1dc>
40030baf:	89 f9                	mov    %edi,%ecx
40030bb1:	09 d9                	or     %ebx,%ecx
40030bb3:	74 19                	je     40030bce <__divdf3+0x1d0>
40030bb5:	89 f9                	mov    %edi,%ecx
40030bb7:	b8 ff 07 00 00       	mov    $0x7ff,%eax
40030bbc:	bf 03 00 00 00       	mov    $0x3,%edi
40030bc1:	eb 17                	jmp    40030bda <__divdf3+0x1dc>
40030bc3:	31 db                	xor    %ebx,%ebx
40030bc5:	31 c0                	xor    %eax,%eax
40030bc7:	bf 01 00 00 00       	mov    $0x1,%edi
40030bcc:	eb 0c                	jmp    40030bda <__divdf3+0x1dc>
40030bce:	31 db                	xor    %ebx,%ebx
40030bd0:	b8 ff 07 00 00       	mov    $0x7ff,%eax
40030bd5:	bf 02 00 00 00       	mov    $0x2,%edi
40030bda:	8a 55 d0             	mov    -0x30(%ebp),%dl
40030bdd:	33 55 d4             	xor    -0x2c(%ebp),%edx
40030be0:	0f b6 d2             	movzbl %dl,%edx
40030be3:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030be6:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030be9:	29 c2                	sub    %eax,%edx
40030beb:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030bee:	c1 e0 02             	shl    $0x2,%eax
40030bf1:	89 55 dc             	mov    %edx,-0x24(%ebp)
40030bf4:	09 f8                	or     %edi,%eax
40030bf6:	48                   	dec    %eax
40030bf7:	83 f8 0e             	cmp    $0xe,%eax
40030bfa:	77 07                	ja     40030c03 <__divdf3+0x205>
40030bfc:	ff 24 85 78 bb 03 40 	jmp    *0x4003bb78(,%eax,4)
40030c03:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
40030c06:	77 06                	ja     40030c0e <__divdf3+0x210>
40030c08:	75 1c                	jne    40030c26 <__divdf3+0x228>
40030c0a:	39 ce                	cmp    %ecx,%esi
40030c0c:	72 18                	jb     40030c26 <__divdf3+0x228>
40030c0e:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030c11:	89 f0                	mov    %esi,%eax
40030c13:	c1 e2 1f             	shl    $0x1f,%edx
40030c16:	c1 e6 1f             	shl    $0x1f,%esi
40030c19:	d1 e8                	shr    %eax
40030c1b:	89 f7                	mov    %esi,%edi
40030c1d:	89 d6                	mov    %edx,%esi
40030c1f:	09 c6                	or     %eax,%esi
40030c21:	d1 6d f0             	shrl   -0x10(%ebp)
40030c24:	eb 05                	jmp    40030c2b <__divdf3+0x22d>
40030c26:	ff 4d dc             	decl   -0x24(%ebp)
40030c29:	31 ff                	xor    %edi,%edi
40030c2b:	c1 e3 08             	shl    $0x8,%ebx
40030c2e:	89 c8                	mov    %ecx,%eax
40030c30:	c1 e8 18             	shr    $0x18,%eax
40030c33:	c1 e1 08             	shl    $0x8,%ecx
40030c36:	09 d8                	or     %ebx,%eax
40030c38:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40030c3b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40030c3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030c41:	89 ca                	mov    %ecx,%edx
40030c43:	89 f0                	mov    %esi,%eax
40030c45:	f7 75 ec             	divl   -0x14(%ebp)
40030c48:	89 d1                	mov    %edx,%ecx
40030c4a:	89 c6                	mov    %eax,%esi
40030c4c:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030c4f:	f7 65 e8             	mull   -0x18(%ebp)
40030c52:	89 45 d8             	mov    %eax,-0x28(%ebp)
40030c55:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40030c58:	39 d1                	cmp    %edx,%ecx
40030c5a:	72 06                	jb     40030c62 <__divdf3+0x264>
40030c5c:	75 47                	jne    40030ca5 <__divdf3+0x2a7>
40030c5e:	39 c7                	cmp    %eax,%edi
40030c60:	73 43                	jae    40030ca5 <__divdf3+0x2a7>
40030c62:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030c65:	8b 45 e8             	mov    -0x18(%ebp),%eax
40030c68:	8d 5e ff             	lea    -0x1(%esi),%ebx
40030c6b:	01 f8                	add    %edi,%eax
40030c6d:	11 ca                	adc    %ecx,%edx
40030c6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030c72:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030c75:	89 c7                	mov    %eax,%edi
40030c77:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40030c7a:	72 07                	jb     40030c83 <__divdf3+0x285>
40030c7c:	75 29                	jne    40030ca7 <__divdf3+0x2a9>
40030c7e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40030c81:	77 24                	ja     40030ca7 <__divdf3+0x2a9>
40030c83:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
40030c86:	77 0a                	ja     40030c92 <__divdf3+0x294>
40030c88:	75 1d                	jne    40030ca7 <__divdf3+0x2a9>
40030c8a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030c8d:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
40030c90:	76 15                	jbe    40030ca7 <__divdf3+0x2a9>
40030c92:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40030c95:	8b 7d e8             	mov    -0x18(%ebp),%edi
40030c98:	8d 5e fe             	lea    -0x2(%esi),%ebx
40030c9b:	03 7d e4             	add    -0x1c(%ebp),%edi
40030c9e:	11 d1                	adc    %edx,%ecx
40030ca0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030ca3:	eb 02                	jmp    40030ca7 <__divdf3+0x2a9>
40030ca5:	89 f3                	mov    %esi,%ebx
40030ca7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40030caa:	83 ce ff             	or     $0xffffffff,%esi
40030cad:	2b 7d d8             	sub    -0x28(%ebp),%edi
40030cb0:	1b 4d d4             	sbb    -0x2c(%ebp),%ecx
40030cb3:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40030cb6:	0f 84 dc 00 00 00    	je     40030d98 <__divdf3+0x39a>
40030cbc:	89 f8                	mov    %edi,%eax
40030cbe:	89 ca                	mov    %ecx,%edx
40030cc0:	f7 75 ec             	divl   -0x14(%ebp)
40030cc3:	89 d1                	mov    %edx,%ecx
40030cc5:	89 c7                	mov    %eax,%edi
40030cc7:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030cca:	f7 65 e8             	mull   -0x18(%ebp)
40030ccd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40030cd0:	89 55 d0             	mov    %edx,-0x30(%ebp)
40030cd3:	39 d1                	cmp    %edx,%ecx
40030cd5:	72 06                	jb     40030cdd <__divdf3+0x2df>
40030cd7:	75 50                	jne    40030d29 <__divdf3+0x32b>
40030cd9:	85 c0                	test   %eax,%eax
40030cdb:	74 4c                	je     40030d29 <__divdf3+0x32b>
40030cdd:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030ce0:	8d 77 ff             	lea    -0x1(%edi),%esi
40030ce3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030ce6:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030ce9:	83 c2 00             	add    $0x0,%edx
40030cec:	13 4d e4             	adc    -0x1c(%ebp),%ecx
40030cef:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40030cf2:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030cf5:	89 55 d8             	mov    %edx,-0x28(%ebp)
40030cf8:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40030cfb:	72 07                	jb     40030d04 <__divdf3+0x306>
40030cfd:	75 33                	jne    40030d32 <__divdf3+0x334>
40030cff:	39 55 e8             	cmp    %edx,-0x18(%ebp)
40030d02:	77 2e                	ja     40030d32 <__divdf3+0x334>
40030d04:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030d07:	39 4d d0             	cmp    %ecx,-0x30(%ebp)
40030d0a:	77 07                	ja     40030d13 <__divdf3+0x315>
40030d0c:	75 24                	jne    40030d32 <__divdf3+0x334>
40030d0e:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
40030d11:	76 1f                	jbe    40030d32 <__divdf3+0x334>
40030d13:	8d 77 fe             	lea    -0x2(%edi),%esi
40030d16:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40030d19:	8b 7d ec             	mov    -0x14(%ebp),%edi
40030d1c:	01 d1                	add    %edx,%ecx
40030d1e:	13 7d e4             	adc    -0x1c(%ebp),%edi
40030d21:	89 7d f0             	mov    %edi,-0x10(%ebp)
40030d24:	89 4d d8             	mov    %ecx,-0x28(%ebp)
40030d27:	eb 09                	jmp    40030d32 <__divdf3+0x334>
40030d29:	89 fe                	mov    %edi,%esi
40030d2b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
40030d32:	8b 7d d0             	mov    -0x30(%ebp),%edi
40030d35:	39 7d f0             	cmp    %edi,-0x10(%ebp)
40030d38:	75 08                	jne    40030d42 <__divdf3+0x344>
40030d3a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
40030d3d:	39 7d d8             	cmp    %edi,-0x28(%ebp)
40030d40:	74 56                	je     40030d98 <__divdf3+0x39a>
40030d42:	83 ce 01             	or     $0x1,%esi
40030d45:	eb 51                	jmp    40030d98 <__divdf3+0x39a>
40030d47:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
40030d4a:	0f 87 65 01 00 00    	ja     40030eb5 <__divdf3+0x4b7>
40030d50:	75 08                	jne    40030d5a <__divdf3+0x35c>
40030d52:	39 ce                	cmp    %ecx,%esi
40030d54:	0f 87 66 01 00 00    	ja     40030ec0 <__divdf3+0x4c2>
40030d5a:	89 ce                	mov    %ecx,%esi
40030d5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
40030d5f:	e9 59 01 00 00       	jmp    40030ebd <__divdf3+0x4bf>
40030d64:	8b 45 d8             	mov    -0x28(%ebp),%eax
40030d67:	89 ce                	mov    %ecx,%esi
40030d69:	89 45 e0             	mov    %eax,-0x20(%ebp)
40030d6c:	89 7d ec             	mov    %edi,-0x14(%ebp)
40030d6f:	eb 09                	jmp    40030d7a <__divdf3+0x37c>
40030d71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40030d74:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40030d77:	89 45 e0             	mov    %eax,-0x20(%ebp)
40030d7a:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
40030d7e:	0f 84 51 01 00 00    	je     40030ed5 <__divdf3+0x4d7>
40030d84:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
40030d88:	0f 84 2c 01 00 00    	je     40030eba <__divdf3+0x4bc>
40030d8e:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40030d92:	0f 84 37 01 00 00    	je     40030ecf <__divdf3+0x4d1>
40030d98:	8b 45 dc             	mov    -0x24(%ebp),%eax
40030d9b:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
40030da1:	85 d2                	test   %edx,%edx
40030da3:	7e 4d                	jle    40030df2 <__divdf3+0x3f4>
40030da5:	f7 c6 07 00 00 00    	test   $0x7,%esi
40030dab:	74 10                	je     40030dbd <__divdf3+0x3bf>
40030dad:	89 f0                	mov    %esi,%eax
40030daf:	83 e0 0f             	and    $0xf,%eax
40030db2:	83 f8 04             	cmp    $0x4,%eax
40030db5:	74 06                	je     40030dbd <__divdf3+0x3bf>
40030db7:	83 c6 04             	add    $0x4,%esi
40030dba:	83 d3 00             	adc    $0x0,%ebx
40030dbd:	0f ba e3 18          	bt     $0x18,%ebx
40030dc1:	73 0f                	jae    40030dd2 <__divdf3+0x3d4>
40030dc3:	8b 55 dc             	mov    -0x24(%ebp),%edx
40030dc6:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
40030dcc:	81 c2 00 04 00 00    	add    $0x400,%edx
40030dd2:	81 fa fe 07 00 00    	cmp    $0x7fe,%edx
40030dd8:	0f 8f f7 00 00 00    	jg     40030ed5 <__divdf3+0x4d7>
40030dde:	c1 ee 03             	shr    $0x3,%esi
40030de1:	89 d8                	mov    %ebx,%eax
40030de3:	c1 e0 1d             	shl    $0x1d,%eax
40030de6:	09 c6                	or     %eax,%esi
40030de8:	89 d8                	mov    %ebx,%eax
40030dea:	c1 e8 03             	shr    $0x3,%eax
40030ded:	e9 fd 00 00 00       	jmp    40030eef <__divdf3+0x4f1>
40030df2:	b9 01 00 00 00       	mov    $0x1,%ecx
40030df7:	89 c8                	mov    %ecx,%eax
40030df9:	29 d0                	sub    %edx,%eax
40030dfb:	83 f8 38             	cmp    $0x38,%eax
40030dfe:	0f 8f 8c 00 00 00    	jg     40030e90 <__divdf3+0x492>
40030e04:	83 f8 1f             	cmp    $0x1f,%eax
40030e07:	7f 30                	jg     40030e39 <__divdf3+0x43b>
40030e09:	ba 20 00 00 00       	mov    $0x20,%edx
40030e0e:	89 df                	mov    %ebx,%edi
40030e10:	29 c2                	sub    %eax,%edx
40030e12:	88 d1                	mov    %dl,%cl
40030e14:	d3 e7                	shl    %cl,%edi
40030e16:	89 7d f0             	mov    %edi,-0x10(%ebp)
40030e19:	88 c1                	mov    %al,%cl
40030e1b:	89 f7                	mov    %esi,%edi
40030e1d:	d3 ef                	shr    %cl,%edi
40030e1f:	89 f9                	mov    %edi,%ecx
40030e21:	8b 7d f0             	mov    -0x10(%ebp),%edi
40030e24:	09 cf                	or     %ecx,%edi
40030e26:	88 d1                	mov    %dl,%cl
40030e28:	d3 e6                	shl    %cl,%esi
40030e2a:	31 d2                	xor    %edx,%edx
40030e2c:	88 c1                	mov    %al,%cl
40030e2e:	85 f6                	test   %esi,%esi
40030e30:	0f 95 c2             	setne  %dl
40030e33:	09 d7                	or     %edx,%edi
40030e35:	d3 eb                	shr    %cl,%ebx
40030e37:	eb 28                	jmp    40030e61 <__divdf3+0x463>
40030e39:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
40030e3e:	89 df                	mov    %ebx,%edi
40030e40:	29 d1                	sub    %edx,%ecx
40030e42:	31 d2                	xor    %edx,%edx
40030e44:	d3 ef                	shr    %cl,%edi
40030e46:	83 f8 20             	cmp    $0x20,%eax
40030e49:	74 0b                	je     40030e56 <__divdf3+0x458>
40030e4b:	b9 40 00 00 00       	mov    $0x40,%ecx
40030e50:	29 c1                	sub    %eax,%ecx
40030e52:	d3 e3                	shl    %cl,%ebx
40030e54:	89 da                	mov    %ebx,%edx
40030e56:	31 c0                	xor    %eax,%eax
40030e58:	09 f2                	or     %esi,%edx
40030e5a:	0f 95 c0             	setne  %al
40030e5d:	09 c7                	or     %eax,%edi
40030e5f:	31 db                	xor    %ebx,%ebx
40030e61:	f7 c7 07 00 00 00    	test   $0x7,%edi
40030e67:	74 10                	je     40030e79 <__divdf3+0x47b>
40030e69:	89 f8                	mov    %edi,%eax
40030e6b:	83 e0 0f             	and    $0xf,%eax
40030e6e:	83 f8 04             	cmp    $0x4,%eax
40030e71:	74 06                	je     40030e79 <__divdf3+0x47b>
40030e73:	83 c7 04             	add    $0x4,%edi
40030e76:	83 d3 00             	adc    $0x0,%ebx
40030e79:	0f ba e3 17          	bt     $0x17,%ebx
40030e7d:	72 61                	jb     40030ee0 <__divdf3+0x4e2>
40030e7f:	89 de                	mov    %ebx,%esi
40030e81:	89 d8                	mov    %ebx,%eax
40030e83:	c1 ef 03             	shr    $0x3,%edi
40030e86:	c1 e6 1d             	shl    $0x1d,%esi
40030e89:	c1 e8 03             	shr    $0x3,%eax
40030e8c:	09 fe                	or     %edi,%esi
40030e8e:	eb 5d                	jmp    40030eed <__divdf3+0x4ef>
40030e90:	09 de                	or     %ebx,%esi
40030e92:	74 57                	je     40030eeb <__divdf3+0x4ed>
40030e94:	31 db                	xor    %ebx,%ebx
40030e96:	89 ce                	mov    %ecx,%esi
40030e98:	83 c6 04             	add    $0x4,%esi
40030e9b:	83 d3 00             	adc    $0x0,%ebx
40030e9e:	c1 ee 03             	shr    $0x3,%esi
40030ea1:	89 d8                	mov    %ebx,%eax
40030ea3:	eb 48                	jmp    40030eed <__divdf3+0x4ef>
40030ea5:	bb 00 00 08 00       	mov    $0x80000,%ebx
40030eaa:	31 f6                	xor    %esi,%esi
40030eac:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
40030eb3:	eb 0b                	jmp    40030ec0 <__divdf3+0x4c2>
40030eb5:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40030eb8:	eb 06                	jmp    40030ec0 <__divdf3+0x4c2>
40030eba:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030ebd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030ec0:	89 d8                	mov    %ebx,%eax
40030ec2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40030ec5:	0d 00 00 08 00       	or     $0x80000,%eax
40030eca:	89 7d e0             	mov    %edi,-0x20(%ebp)
40030ecd:	eb 0a                	jmp    40030ed9 <__divdf3+0x4db>
40030ecf:	31 c0                	xor    %eax,%eax
40030ed1:	31 f6                	xor    %esi,%esi
40030ed3:	eb 18                	jmp    40030eed <__divdf3+0x4ef>
40030ed5:	31 c0                	xor    %eax,%eax
40030ed7:	31 f6                	xor    %esi,%esi
40030ed9:	ba ff 07 00 00       	mov    $0x7ff,%edx
40030ede:	eb 0f                	jmp    40030eef <__divdf3+0x4f1>
40030ee0:	31 c0                	xor    %eax,%eax
40030ee2:	31 f6                	xor    %esi,%esi
40030ee4:	ba 01 00 00 00       	mov    $0x1,%edx
40030ee9:	eb 04                	jmp    40030eef <__divdf3+0x4f1>
40030eeb:	31 c0                	xor    %eax,%eax
40030eed:	31 d2                	xor    %edx,%edx
40030eef:	31 db                	xor    %ebx,%ebx
40030ef1:	25 ff ff 0f 00       	and    $0xfffff,%eax
40030ef6:	89 f1                	mov    %esi,%ecx
40030ef8:	89 c6                	mov    %eax,%esi
40030efa:	89 d8                	mov    %ebx,%eax
40030efc:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
40030f02:	c1 e2 14             	shl    $0x14,%edx
40030f05:	25 00 00 f0 ff       	and    $0xfff00000,%eax
40030f0a:	09 f0                	or     %esi,%eax
40030f0c:	25 ff ff 0f 80       	and    $0x800fffff,%eax
40030f11:	09 d0                	or     %edx,%eax
40030f13:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030f16:	c1 e2 1f             	shl    $0x1f,%edx
40030f19:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
40030f1e:	83 c4 24             	add    $0x24,%esp
40030f21:	09 d0                	or     %edx,%eax
40030f23:	89 c3                	mov    %eax,%ebx
40030f25:	89 c8                	mov    %ecx,%eax
40030f27:	89 da                	mov    %ebx,%edx
40030f29:	5b                   	pop    %ebx
40030f2a:	5e                   	pop    %esi
40030f2b:	5f                   	pop    %edi
40030f2c:	5d                   	pop    %ebp
40030f2d:	c3                   	ret    

40030f2e <__gedf2>:
40030f2e:	55                   	push   %ebp
40030f2f:	89 e5                	mov    %esp,%ebp
40030f31:	57                   	push   %edi
40030f32:	56                   	push   %esi
40030f33:	53                   	push   %ebx
40030f34:	83 ec 14             	sub    $0x14,%esp
40030f37:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030f3a:	89 d0                	mov    %edx,%eax
40030f3c:	89 d7                	mov    %edx,%edi
40030f3e:	c1 e8 14             	shr    $0x14,%eax
40030f41:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
40030f47:	c1 ea 1f             	shr    $0x1f,%edx
40030f4a:	25 ff 07 00 00       	and    $0x7ff,%eax
40030f4f:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030f52:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030f55:	8b 45 08             	mov    0x8(%ebp),%eax
40030f58:	8b 55 0c             	mov    0xc(%ebp),%edx
40030f5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030f5e:	89 d0                	mov    %edx,%eax
40030f60:	c1 e8 14             	shr    $0x14,%eax
40030f63:	89 d6                	mov    %edx,%esi
40030f65:	25 ff 07 00 00       	and    $0x7ff,%eax
40030f6a:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
40030f70:	c1 ea 1f             	shr    $0x1f,%edx
40030f73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030f76:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
40030f7d:	75 10                	jne    40030f8f <__gedf2+0x61>
40030f7f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40030f82:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
40030f87:	09 f9                	or     %edi,%ecx
40030f89:	0f 85 a8 00 00 00    	jne    40031037 <__gedf2+0x109>
40030f8f:	81 7d e4 ff 07 00 00 	cmpl   $0x7ff,-0x1c(%ebp)
40030f96:	75 10                	jne    40030fa8 <__gedf2+0x7a>
40030f98:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030f9b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
40030fa0:	09 f3                	or     %esi,%ebx
40030fa2:	0f 85 8f 00 00 00    	jne    40031037 <__gedf2+0x109>
40030fa8:	31 db                	xor    %ebx,%ebx
40030faa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030fae:	75 08                	jne    40030fb8 <__gedf2+0x8a>
40030fb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030fb3:	09 f8                	or     %edi,%eax
40030fb5:	0f 94 c3             	sete   %bl
40030fb8:	31 c9                	xor    %ecx,%ecx
40030fba:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
40030fbe:	75 08                	jne    40030fc8 <__gedf2+0x9a>
40030fc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030fc3:	09 f0                	or     %esi,%eax
40030fc5:	0f 94 c1             	sete   %cl
40030fc8:	84 db                	test   %bl,%bl
40030fca:	74 06                	je     40030fd2 <__gedf2+0xa4>
40030fcc:	31 c0                	xor    %eax,%eax
40030fce:	84 c9                	test   %cl,%cl
40030fd0:	75 65                	jne    40031037 <__gedf2+0x109>
40030fd2:	0f b6 d2             	movzbl %dl,%edx
40030fd5:	84 db                	test   %bl,%bl
40030fd7:	74 0b                	je     40030fe4 <__gedf2+0xb6>
40030fd9:	83 c8 ff             	or     $0xffffffff,%eax
40030fdc:	85 d2                	test   %edx,%edx
40030fde:	74 57                	je     40031037 <__gedf2+0x109>
40030fe0:	89 d0                	mov    %edx,%eax
40030fe2:	eb 53                	jmp    40031037 <__gedf2+0x109>
40030fe4:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
40030fe8:	84 c9                	test   %cl,%cl
40030fea:	75 29                	jne    40031015 <__gedf2+0xe7>
40030fec:	39 d0                	cmp    %edx,%eax
40030fee:	75 1d                	jne    4003100d <__gedf2+0xdf>
40030ff0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
40030ff3:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
40030ff6:	7f 15                	jg     4003100d <__gedf2+0xdf>
40030ff8:	7c 32                	jl     4003102c <__gedf2+0xfe>
40030ffa:	39 f7                	cmp    %esi,%edi
40030ffc:	77 0f                	ja     4003100d <__gedf2+0xdf>
40030ffe:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40031001:	0f 94 c2             	sete   %dl
40031004:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
40031007:	76 13                	jbe    4003101c <__gedf2+0xee>
40031009:	84 d2                	test   %dl,%dl
4003100b:	74 0f                	je     4003101c <__gedf2+0xee>
4003100d:	85 c0                	test   %eax,%eax
4003100f:	0f 95 c0             	setne  %al
40031012:	0f b6 c0             	movzbl %al,%eax
40031015:	f7 d8                	neg    %eax
40031017:	83 c8 01             	or     $0x1,%eax
4003101a:	eb 1b                	jmp    40031037 <__gedf2+0x109>
4003101c:	39 f7                	cmp    %esi,%edi
4003101e:	72 0c                	jb     4003102c <__gedf2+0xfe>
40031020:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031023:	39 7d f0             	cmp    %edi,-0x10(%ebp)
40031026:	73 0d                	jae    40031035 <__gedf2+0x107>
40031028:	84 d2                	test   %dl,%dl
4003102a:	74 09                	je     40031035 <__gedf2+0x107>
4003102c:	85 c0                	test   %eax,%eax
4003102e:	75 07                	jne    40031037 <__gedf2+0x109>
40031030:	83 c8 ff             	or     $0xffffffff,%eax
40031033:	eb 02                	jmp    40031037 <__gedf2+0x109>
40031035:	31 c0                	xor    %eax,%eax
40031037:	83 c4 14             	add    $0x14,%esp
4003103a:	5b                   	pop    %ebx
4003103b:	5e                   	pop    %esi
4003103c:	5f                   	pop    %edi
4003103d:	5d                   	pop    %ebp
4003103e:	c3                   	ret    

4003103f <__ledf2>:
4003103f:	55                   	push   %ebp
40031040:	89 e5                	mov    %esp,%ebp
40031042:	57                   	push   %edi
40031043:	56                   	push   %esi
40031044:	53                   	push   %ebx
40031045:	83 ec 14             	sub    $0x14,%esp
40031048:	89 45 f0             	mov    %eax,-0x10(%ebp)
4003104b:	89 d0                	mov    %edx,%eax
4003104d:	89 d7                	mov    %edx,%edi
4003104f:	c1 e8 14             	shr    $0x14,%eax
40031052:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
40031058:	c1 ea 1f             	shr    $0x1f,%edx
4003105b:	25 ff 07 00 00       	and    $0x7ff,%eax
40031060:	89 45 e8             	mov    %eax,-0x18(%ebp)
40031063:	89 55 e0             	mov    %edx,-0x20(%ebp)
40031066:	8b 45 08             	mov    0x8(%ebp),%eax
40031069:	8b 55 0c             	mov    0xc(%ebp),%edx
4003106c:	89 45 ec             	mov    %eax,-0x14(%ebp)
4003106f:	89 d0                	mov    %edx,%eax
40031071:	c1 e8 14             	shr    $0x14,%eax
40031074:	89 d6                	mov    %edx,%esi
40031076:	25 ff 07 00 00       	and    $0x7ff,%eax
4003107b:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
40031081:	c1 ea 1f             	shr    $0x1f,%edx
40031084:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40031087:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
4003108e:	75 10                	jne    400310a0 <__ledf2+0x61>
40031090:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40031093:	b8 02 00 00 00       	mov    $0x2,%eax
40031098:	09 f9                	or     %edi,%ecx
4003109a:	0f 85 a8 00 00 00    	jne    40031148 <__ledf2+0x109>
400310a0:	81 7d e4 ff 07 00 00 	cmpl   $0x7ff,-0x1c(%ebp)
400310a7:	75 10                	jne    400310b9 <__ledf2+0x7a>
400310a9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
400310ac:	b8 02 00 00 00       	mov    $0x2,%eax
400310b1:	09 f3                	or     %esi,%ebx
400310b3:	0f 85 8f 00 00 00    	jne    40031148 <__ledf2+0x109>
400310b9:	31 db                	xor    %ebx,%ebx
400310bb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
400310bf:	75 08                	jne    400310c9 <__ledf2+0x8a>
400310c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
400310c4:	09 f8                	or     %edi,%eax
400310c6:	0f 94 c3             	sete   %bl
400310c9:	31 c9                	xor    %ecx,%ecx
400310cb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
400310cf:	75 08                	jne    400310d9 <__ledf2+0x9a>
400310d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
400310d4:	09 f0                	or     %esi,%eax
400310d6:	0f 94 c1             	sete   %cl
400310d9:	84 db                	test   %bl,%bl
400310db:	74 06                	je     400310e3 <__ledf2+0xa4>
400310dd:	31 c0                	xor    %eax,%eax
400310df:	84 c9                	test   %cl,%cl
400310e1:	75 65                	jne    40031148 <__ledf2+0x109>
400310e3:	0f b6 d2             	movzbl %dl,%edx
400310e6:	84 db                	test   %bl,%bl
400310e8:	74 0b                	je     400310f5 <__ledf2+0xb6>
400310ea:	83 c8 ff             	or     $0xffffffff,%eax
400310ed:	85 d2                	test   %edx,%edx
400310ef:	74 57                	je     40031148 <__ledf2+0x109>
400310f1:	89 d0                	mov    %edx,%eax
400310f3:	eb 53                	jmp    40031148 <__ledf2+0x109>
400310f5:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
400310f9:	84 c9                	test   %cl,%cl
400310fb:	75 29                	jne    40031126 <__ledf2+0xe7>
400310fd:	39 d0                	cmp    %edx,%eax
400310ff:	75 1d                	jne    4003111e <__ledf2+0xdf>
40031101:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
40031104:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
40031107:	7f 15                	jg     4003111e <__ledf2+0xdf>
40031109:	7c 32                	jl     4003113d <__ledf2+0xfe>
4003110b:	39 f7                	cmp    %esi,%edi
4003110d:	77 0f                	ja     4003111e <__ledf2+0xdf>
4003110f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40031112:	0f 94 c2             	sete   %dl
40031115:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
40031118:	76 13                	jbe    4003112d <__ledf2+0xee>
4003111a:	84 d2                	test   %dl,%dl
4003111c:	74 0f                	je     4003112d <__ledf2+0xee>
4003111e:	85 c0                	test   %eax,%eax
40031120:	0f 95 c0             	setne  %al
40031123:	0f b6 c0             	movzbl %al,%eax
40031126:	f7 d8                	neg    %eax
40031128:	83 c8 01             	or     $0x1,%eax
4003112b:	eb 1b                	jmp    40031148 <__ledf2+0x109>
4003112d:	39 f7                	cmp    %esi,%edi
4003112f:	72 0c                	jb     4003113d <__ledf2+0xfe>
40031131:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031134:	39 7d f0             	cmp    %edi,-0x10(%ebp)
40031137:	73 0d                	jae    40031146 <__ledf2+0x107>
40031139:	84 d2                	test   %dl,%dl
4003113b:	74 09                	je     40031146 <__ledf2+0x107>
4003113d:	85 c0                	test   %eax,%eax
4003113f:	75 07                	jne    40031148 <__ledf2+0x109>
40031141:	83 c8 ff             	or     $0xffffffff,%eax
40031144:	eb 02                	jmp    40031148 <__ledf2+0x109>
40031146:	31 c0                	xor    %eax,%eax
40031148:	83 c4 14             	add    $0x14,%esp
4003114b:	5b                   	pop    %ebx
4003114c:	5e                   	pop    %esi
4003114d:	5f                   	pop    %edi
4003114e:	5d                   	pop    %ebp
4003114f:	c3                   	ret    

40031150 <__muldf3>:
40031150:	55                   	push   %ebp
40031151:	89 d1                	mov    %edx,%ecx
40031153:	c1 e9 14             	shr    $0x14,%ecx
40031156:	89 e5                	mov    %esp,%ebp
40031158:	57                   	push   %edi
40031159:	56                   	push   %esi
4003115a:	53                   	push   %ebx
4003115b:	89 d3                	mov    %edx,%ebx
4003115d:	c1 ea 1f             	shr    $0x1f,%edx
40031160:	83 ec 24             	sub    $0x24,%esp
40031163:	89 55 d4             	mov    %edx,-0x2c(%ebp)
40031166:	8b 75 08             	mov    0x8(%ebp),%esi
40031169:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
4003116d:	89 75 f0             	mov    %esi,-0x10(%ebp)
40031170:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
40031176:	8b 75 0c             	mov    0xc(%ebp),%esi
40031179:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4003117c:	66 81 e1 ff 07       	and    $0x7ff,%cx
40031181:	89 75 e0             	mov    %esi,-0x20(%ebp)
40031184:	74 2d                	je     400311b3 <__muldf3+0x63>
40031186:	66 81 f9 ff 07       	cmp    $0x7ff,%cx
4003118b:	74 7c                	je     40031209 <__muldf3+0xb9>
4003118d:	8d 14 dd 00 00 00 00 	lea    0x0(,%ebx,8),%edx
40031194:	89 c3                	mov    %eax,%ebx
40031196:	c1 eb 1d             	shr    $0x1d,%ebx
40031199:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
400311a0:	0f b7 c9             	movzwl %cx,%ecx
400311a3:	81 cb 00 00 80 00    	or     $0x800000,%ebx
400311a9:	09 d3                	or     %edx,%ebx
400311ab:	8d 81 01 fc ff ff    	lea    -0x3ff(%ecx),%eax
400311b1:	eb 4f                	jmp    40031202 <__muldf3+0xb2>
400311b3:	89 c6                	mov    %eax,%esi
400311b5:	09 de                	or     %ebx,%esi
400311b7:	74 66                	je     4003121f <__muldf3+0xcf>
400311b9:	85 db                	test   %ebx,%ebx
400311bb:	74 08                	je     400311c5 <__muldf3+0x75>
400311bd:	0f bd fb             	bsr    %ebx,%edi
400311c0:	83 f7 1f             	xor    $0x1f,%edi
400311c3:	eb 09                	jmp    400311ce <__muldf3+0x7e>
400311c5:	0f bd f8             	bsr    %eax,%edi
400311c8:	83 f7 1f             	xor    $0x1f,%edi
400311cb:	83 c7 20             	add    $0x20,%edi
400311ce:	8d 57 f5             	lea    -0xb(%edi),%edx
400311d1:	83 fa 1c             	cmp    $0x1c,%edx
400311d4:	7f 1c                	jg     400311f2 <__muldf3+0xa2>
400311d6:	8d 77 f8             	lea    -0x8(%edi),%esi
400311d9:	89 f1                	mov    %esi,%ecx
400311db:	d3 e3                	shl    %cl,%ebx
400311dd:	b9 1d 00 00 00       	mov    $0x1d,%ecx
400311e2:	29 d1                	sub    %edx,%ecx
400311e4:	89 c2                	mov    %eax,%edx
400311e6:	d3 ea                	shr    %cl,%edx
400311e8:	89 f1                	mov    %esi,%ecx
400311ea:	09 d3                	or     %edx,%ebx
400311ec:	d3 e0                	shl    %cl,%eax
400311ee:	89 c6                	mov    %eax,%esi
400311f0:	eb 09                	jmp    400311fb <__muldf3+0xab>
400311f2:	8d 4f d8             	lea    -0x28(%edi),%ecx
400311f5:	31 f6                	xor    %esi,%esi
400311f7:	d3 e0                	shl    %cl,%eax
400311f9:	89 c3                	mov    %eax,%ebx
400311fb:	b8 0d fc ff ff       	mov    $0xfffffc0d,%eax
40031200:	29 f8                	sub    %edi,%eax
40031202:	89 45 e8             	mov    %eax,-0x18(%ebp)
40031205:	31 d2                	xor    %edx,%edx
40031207:	eb 34                	jmp    4003123d <__muldf3+0xed>
40031209:	89 c6                	mov    %eax,%esi
4003120b:	09 de                	or     %ebx,%esi
4003120d:	74 20                	je     4003122f <__muldf3+0xdf>
4003120f:	89 c6                	mov    %eax,%esi
40031211:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40031218:	ba 03 00 00 00       	mov    $0x3,%edx
4003121d:	eb 1e                	jmp    4003123d <__muldf3+0xed>
4003121f:	31 db                	xor    %ebx,%ebx
40031221:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40031228:	ba 01 00 00 00       	mov    $0x1,%edx
4003122d:	eb 0e                	jmp    4003123d <__muldf3+0xed>
4003122f:	31 db                	xor    %ebx,%ebx
40031231:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40031238:	ba 02 00 00 00       	mov    $0x2,%edx
4003123d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031240:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40031243:	89 45 ec             	mov    %eax,-0x14(%ebp)
40031246:	89 c8                	mov    %ecx,%eax
40031248:	25 ff ff 0f 00       	and    $0xfffff,%eax
4003124d:	89 45 f0             	mov    %eax,-0x10(%ebp)
40031250:	89 c8                	mov    %ecx,%eax
40031252:	c1 e9 1f             	shr    $0x1f,%ecx
40031255:	c1 e8 14             	shr    $0x14,%eax
40031258:	89 4d d0             	mov    %ecx,-0x30(%ebp)
4003125b:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
4003125f:	66 25 ff 07          	and    $0x7ff,%ax
40031263:	89 4d dc             	mov    %ecx,-0x24(%ebp)
40031266:	74 34                	je     4003129c <__muldf3+0x14c>
40031268:	66 3d ff 07          	cmp    $0x7ff,%ax
4003126c:	0f 84 a5 00 00 00    	je     40031317 <__muldf3+0x1c7>
40031272:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031275:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40031278:	c1 ef 1d             	shr    $0x1d,%edi
4003127b:	c1 e1 03             	shl    $0x3,%ecx
4003127e:	81 cf 00 00 80 00    	or     $0x800000,%edi
40031284:	09 cf                	or     %ecx,%edi
40031286:	0f b7 c0             	movzwl %ax,%eax
40031289:	89 7d f0             	mov    %edi,-0x10(%ebp)
4003128c:	2d ff 03 00 00       	sub    $0x3ff,%eax
40031291:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031294:	89 45 ec             	mov    %eax,-0x14(%ebp)
40031297:	c1 e7 03             	shl    $0x3,%edi
4003129a:	eb 77                	jmp    40031313 <__muldf3+0x1c3>
4003129c:	8b 7d ec             	mov    -0x14(%ebp),%edi
4003129f:	0b 7d f0             	or     -0x10(%ebp),%edi
400312a2:	0f 84 88 00 00 00    	je     40031330 <__muldf3+0x1e0>
400312a8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400312ac:	74 09                	je     400312b7 <__muldf3+0x167>
400312ae:	0f bd 45 f0          	bsr    -0x10(%ebp),%eax
400312b2:	83 f0 1f             	xor    $0x1f,%eax
400312b5:	eb 0a                	jmp    400312c1 <__muldf3+0x171>
400312b7:	0f bd 7d ec          	bsr    -0x14(%ebp),%edi
400312bb:	83 f7 1f             	xor    $0x1f,%edi
400312be:	8d 47 20             	lea    0x20(%edi),%eax
400312c1:	8d 48 f5             	lea    -0xb(%eax),%ecx
400312c4:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400312c7:	83 f9 1c             	cmp    $0x1c,%ecx
400312ca:	7f 30                	jg     400312fc <__muldf3+0x1ac>
400312cc:	8d 48 f8             	lea    -0x8(%eax),%ecx
400312cf:	8b 7d f0             	mov    -0x10(%ebp),%edi
400312d2:	89 4d d8             	mov    %ecx,-0x28(%ebp)
400312d5:	8a 4d d8             	mov    -0x28(%ebp),%cl
400312d8:	d3 e7                	shl    %cl,%edi
400312da:	b9 1d 00 00 00       	mov    $0x1d,%ecx
400312df:	89 7d f0             	mov    %edi,-0x10(%ebp)
400312e2:	2b 4d e0             	sub    -0x20(%ebp),%ecx
400312e5:	8b 7d ec             	mov    -0x14(%ebp),%edi
400312e8:	d3 ef                	shr    %cl,%edi
400312ea:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400312ed:	09 f9                	or     %edi,%ecx
400312ef:	8b 7d ec             	mov    -0x14(%ebp),%edi
400312f2:	89 4d f0             	mov    %ecx,-0x10(%ebp)
400312f5:	8a 4d d8             	mov    -0x28(%ebp),%cl
400312f8:	d3 e7                	shl    %cl,%edi
400312fa:	eb 0d                	jmp    40031309 <__muldf3+0x1b9>
400312fc:	8d 48 d8             	lea    -0x28(%eax),%ecx
400312ff:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031302:	d3 e7                	shl    %cl,%edi
40031304:	89 7d f0             	mov    %edi,-0x10(%ebp)
40031307:	31 ff                	xor    %edi,%edi
40031309:	b9 0d fc ff ff       	mov    $0xfffffc0d,%ecx
4003130e:	29 c1                	sub    %eax,%ecx
40031310:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40031313:	31 c9                	xor    %ecx,%ecx
40031315:	eb 41                	jmp    40031358 <__muldf3+0x208>
40031317:	8b 7d ec             	mov    -0x14(%ebp),%edi
4003131a:	0b 7d f0             	or     -0x10(%ebp),%edi
4003131d:	74 26                	je     40031345 <__muldf3+0x1f5>
4003131f:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031322:	b9 03 00 00 00       	mov    $0x3,%ecx
40031327:	c7 45 ec ff 07 00 00 	movl   $0x7ff,-0x14(%ebp)
4003132e:	eb 28                	jmp    40031358 <__muldf3+0x208>
40031330:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
40031337:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4003133e:	b9 01 00 00 00       	mov    $0x1,%ecx
40031343:	eb 13                	jmp    40031358 <__muldf3+0x208>
40031345:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
4003134c:	c7 45 ec ff 07 00 00 	movl   $0x7ff,-0x14(%ebp)
40031353:	b9 02 00 00 00       	mov    $0x2,%ecx
40031358:	8a 45 d0             	mov    -0x30(%ebp),%al
4003135b:	33 45 d4             	xor    -0x2c(%ebp),%eax
4003135e:	0f b6 c0             	movzbl %al,%eax
40031361:	89 45 e0             	mov    %eax,-0x20(%ebp)
40031364:	8b 45 ec             	mov    -0x14(%ebp),%eax
40031367:	03 45 e8             	add    -0x18(%ebp),%eax
4003136a:	89 45 e8             	mov    %eax,-0x18(%ebp)
4003136d:	40                   	inc    %eax
4003136e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40031371:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
40031378:	09 c8                	or     %ecx,%eax
4003137a:	48                   	dec    %eax
4003137b:	83 f8 0e             	cmp    $0xe,%eax
4003137e:	77 11                	ja     40031391 <__muldf3+0x241>
40031380:	ff 24 85 b4 bb 03 40 	jmp    *0x4003bbb4(,%eax,4)
40031387:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003138a:	89 fe                	mov    %edi,%esi
4003138c:	e9 b1 00 00 00       	jmp    40031442 <__muldf3+0x2f2>
40031391:	89 f0                	mov    %esi,%eax
40031393:	f7 e7                	mul    %edi
40031395:	89 55 dc             	mov    %edx,-0x24(%ebp)
40031398:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003139b:	89 f0                	mov    %esi,%eax
4003139d:	f7 65 f0             	mull   -0x10(%ebp)
400313a0:	89 55 d8             	mov    %edx,-0x28(%ebp)
400313a3:	89 c6                	mov    %eax,%esi
400313a5:	89 d8                	mov    %ebx,%eax
400313a7:	f7 e7                	mul    %edi
400313a9:	89 d7                	mov    %edx,%edi
400313ab:	89 c1                	mov    %eax,%ecx
400313ad:	89 d8                	mov    %ebx,%eax
400313af:	8b 5d d8             	mov    -0x28(%ebp),%ebx
400313b2:	f7 65 f0             	mull   -0x10(%ebp)
400313b5:	89 55 d4             	mov    %edx,-0x2c(%ebp)
400313b8:	31 d2                	xor    %edx,%edx
400313ba:	03 75 dc             	add    -0x24(%ebp),%esi
400313bd:	11 c3                	adc    %eax,%ebx
400313bf:	13 55 d4             	adc    -0x2c(%ebp),%edx
400313c2:	89 5d f0             	mov    %ebx,-0x10(%ebp)
400313c5:	31 db                	xor    %ebx,%ebx
400313c7:	01 f1                	add    %esi,%ecx
400313c9:	13 7d f0             	adc    -0x10(%ebp),%edi
400313cc:	11 d3                	adc    %edx,%ebx
400313ce:	89 f8                	mov    %edi,%eax
400313d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400313d3:	c1 e8 17             	shr    $0x17,%eax
400313d6:	c1 e3 09             	shl    $0x9,%ebx
400313d9:	09 c3                	or     %eax,%ebx
400313db:	89 c8                	mov    %ecx,%eax
400313dd:	c1 e0 09             	shl    $0x9,%eax
400313e0:	09 c2                	or     %eax,%edx
400313e2:	0f 95 c0             	setne  %al
400313e5:	c1 e9 17             	shr    $0x17,%ecx
400313e8:	c1 e7 09             	shl    $0x9,%edi
400313eb:	09 cf                	or     %ecx,%edi
400313ed:	0f b6 c0             	movzbl %al,%eax
400313f0:	09 f8                	or     %edi,%eax
400313f2:	0f ba e3 18          	bt     $0x18,%ebx
400313f6:	89 c6                	mov    %eax,%esi
400313f8:	73 65                	jae    4003145f <__muldf3+0x30f>
400313fa:	d1 e8                	shr    %eax
400313fc:	83 e6 01             	and    $0x1,%esi
400313ff:	09 c6                	or     %eax,%esi
40031401:	89 d8                	mov    %ebx,%eax
40031403:	c1 e0 1f             	shl    $0x1f,%eax
40031406:	d1 eb                	shr    %ebx
40031408:	09 c6                	or     %eax,%esi
4003140a:	eb 59                	jmp    40031465 <__muldf3+0x315>
4003140c:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
4003140f:	0f 87 78 01 00 00    	ja     4003158d <__muldf3+0x43d>
40031415:	0f 94 c2             	sete   %dl
40031418:	39 fe                	cmp    %edi,%esi
4003141a:	0f 93 c0             	setae  %al
4003141d:	84 c2                	test   %al,%dl
4003141f:	0f 85 76 01 00 00    	jne    4003159b <__muldf3+0x44b>
40031425:	89 fe                	mov    %edi,%esi
40031427:	8b 45 dc             	mov    -0x24(%ebp),%eax
4003142a:	e9 69 01 00 00       	jmp    40031598 <__muldf3+0x448>
4003142f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40031432:	89 45 e0             	mov    %eax,-0x20(%ebp)
40031435:	eb 0d                	jmp    40031444 <__muldf3+0x2f4>
40031437:	8b 45 dc             	mov    -0x24(%ebp),%eax
4003143a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003143d:	89 fe                	mov    %edi,%esi
4003143f:	89 45 e0             	mov    %eax,-0x20(%ebp)
40031442:	89 ca                	mov    %ecx,%edx
40031444:	83 fa 02             	cmp    $0x2,%edx
40031447:	0f 84 65 01 00 00    	je     400315b2 <__muldf3+0x462>
4003144d:	83 fa 03             	cmp    $0x3,%edx
40031450:	0f 84 3c 01 00 00    	je     40031592 <__muldf3+0x442>
40031456:	4a                   	dec    %edx
40031457:	0f 84 4f 01 00 00    	je     400315ac <__muldf3+0x45c>
4003145d:	eb 06                	jmp    40031465 <__muldf3+0x315>
4003145f:	8b 45 e8             	mov    -0x18(%ebp),%eax
40031462:	89 45 ec             	mov    %eax,-0x14(%ebp)
40031465:	8b 45 ec             	mov    -0x14(%ebp),%eax
40031468:	8d b8 ff 03 00 00    	lea    0x3ff(%eax),%edi
4003146e:	85 ff                	test   %edi,%edi
40031470:	7e 4b                	jle    400314bd <__muldf3+0x36d>
40031472:	f7 c6 07 00 00 00    	test   $0x7,%esi
40031478:	74 10                	je     4003148a <__muldf3+0x33a>
4003147a:	89 f0                	mov    %esi,%eax
4003147c:	83 e0 0f             	and    $0xf,%eax
4003147f:	83 f8 04             	cmp    $0x4,%eax
40031482:	74 06                	je     4003148a <__muldf3+0x33a>
40031484:	83 c6 04             	add    $0x4,%esi
40031487:	83 d3 00             	adc    $0x0,%ebx
4003148a:	0f ba e3 18          	bt     $0x18,%ebx
4003148e:	73 0f                	jae    4003149f <__muldf3+0x34f>
40031490:	8b 7d ec             	mov    -0x14(%ebp),%edi
40031493:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
40031499:	81 c7 00 04 00 00    	add    $0x400,%edi
4003149f:	81 ff fe 07 00 00    	cmp    $0x7fe,%edi
400314a5:	0f 8f 07 01 00 00    	jg     400315b2 <__muldf3+0x462>
400314ab:	c1 ee 03             	shr    $0x3,%esi
400314ae:	89 d8                	mov    %ebx,%eax
400314b0:	c1 e0 1d             	shl    $0x1d,%eax
400314b3:	c1 eb 03             	shr    $0x3,%ebx
400314b6:	09 c6                	or     %eax,%esi
400314b8:	e9 0d 01 00 00       	jmp    400315ca <__muldf3+0x47a>
400314bd:	b9 01 00 00 00       	mov    $0x1,%ecx
400314c2:	89 c8                	mov    %ecx,%eax
400314c4:	29 f8                	sub    %edi,%eax
400314c6:	83 f8 38             	cmp    $0x38,%eax
400314c9:	0f 8f 96 00 00 00    	jg     40031565 <__muldf3+0x415>
400314cf:	83 f8 1f             	cmp    $0x1f,%eax
400314d2:	7f 34                	jg     40031508 <__muldf3+0x3b8>
400314d4:	ba 20 00 00 00       	mov    $0x20,%edx
400314d9:	89 df                	mov    %ebx,%edi
400314db:	29 c2                	sub    %eax,%edx
400314dd:	88 d1                	mov    %dl,%cl
400314df:	d3 e7                	shl    %cl,%edi
400314e1:	89 7d f0             	mov    %edi,-0x10(%ebp)
400314e4:	88 c1                	mov    %al,%cl
400314e6:	89 f7                	mov    %esi,%edi
400314e8:	d3 ef                	shr    %cl,%edi
400314ea:	89 f9                	mov    %edi,%ecx
400314ec:	8b 7d f0             	mov    -0x10(%ebp),%edi
400314ef:	09 cf                	or     %ecx,%edi
400314f1:	88 d1                	mov    %dl,%cl
400314f3:	d3 e6                	shl    %cl,%esi
400314f5:	31 d2                	xor    %edx,%edx
400314f7:	88 c1                	mov    %al,%cl
400314f9:	85 f6                	test   %esi,%esi
400314fb:	0f 95 c2             	setne  %dl
400314fe:	89 d6                	mov    %edx,%esi
40031500:	d3 eb                	shr    %cl,%ebx
40031502:	09 fe                	or     %edi,%esi
40031504:	89 d8                	mov    %ebx,%eax
40031506:	eb 2a                	jmp    40031532 <__muldf3+0x3e2>
40031508:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
4003150d:	31 d2                	xor    %edx,%edx
4003150f:	29 f9                	sub    %edi,%ecx
40031511:	89 df                	mov    %ebx,%edi
40031513:	d3 ef                	shr    %cl,%edi
40031515:	83 f8 20             	cmp    $0x20,%eax
40031518:	74 0b                	je     40031525 <__muldf3+0x3d5>
4003151a:	b9 40 00 00 00       	mov    $0x40,%ecx
4003151f:	89 da                	mov    %ebx,%edx
40031521:	29 c1                	sub    %eax,%ecx
40031523:	d3 e2                	shl    %cl,%edx
40031525:	31 c0                	xor    %eax,%eax
40031527:	09 f2                	or     %esi,%edx
40031529:	0f 95 c0             	setne  %al
4003152c:	89 c6                	mov    %eax,%esi
4003152e:	31 c0                	xor    %eax,%eax
40031530:	09 fe                	or     %edi,%esi
40031532:	f7 c6 07 00 00 00    	test   $0x7,%esi
40031538:	74 14                	je     4003154e <__muldf3+0x3fe>
4003153a:	89 f2                	mov    %esi,%edx
4003153c:	83 e2 0f             	and    $0xf,%edx
4003153f:	83 fa 04             	cmp    $0x4,%edx
40031542:	74 0a                	je     4003154e <__muldf3+0x3fe>
40031544:	89 c3                	mov    %eax,%ebx
40031546:	83 c6 04             	add    $0x4,%esi
40031549:	83 d3 00             	adc    $0x0,%ebx
4003154c:	89 d8                	mov    %ebx,%eax
4003154e:	0f ba e0 17          	bt     $0x17,%eax
40031552:	72 69                	jb     400315bd <__muldf3+0x46d>
40031554:	c1 ee 03             	shr    $0x3,%esi
40031557:	89 c2                	mov    %eax,%edx
40031559:	c1 e2 1d             	shl    $0x1d,%edx
4003155c:	c1 e8 03             	shr    $0x3,%eax
4003155f:	09 d6                	or     %edx,%esi
40031561:	89 c3                	mov    %eax,%ebx
40031563:	eb 63                	jmp    400315c8 <__muldf3+0x478>
40031565:	09 de                	or     %ebx,%esi
40031567:	bb 00 00 00 00       	mov    $0x0,%ebx
4003156c:	74 5a                	je     400315c8 <__muldf3+0x478>
4003156e:	89 ce                	mov    %ecx,%esi
40031570:	83 c6 04             	add    $0x4,%esi
40031573:	83 d3 00             	adc    $0x0,%ebx
40031576:	c1 ee 03             	shr    $0x3,%esi
40031579:	eb 4d                	jmp    400315c8 <__muldf3+0x478>
4003157b:	c7 45 f0 00 00 08 00 	movl   $0x80000,-0x10(%ebp)
40031582:	31 f6                	xor    %esi,%esi
40031584:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
4003158b:	eb 0e                	jmp    4003159b <__muldf3+0x44b>
4003158d:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40031590:	eb 09                	jmp    4003159b <__muldf3+0x44b>
40031592:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40031595:	8b 45 e0             	mov    -0x20(%ebp),%eax
40031598:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003159b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003159e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400315a1:	81 cb 00 00 08 00    	or     $0x80000,%ebx
400315a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
400315aa:	eb 0a                	jmp    400315b6 <__muldf3+0x466>
400315ac:	31 db                	xor    %ebx,%ebx
400315ae:	31 f6                	xor    %esi,%esi
400315b0:	eb 16                	jmp    400315c8 <__muldf3+0x478>
400315b2:	31 db                	xor    %ebx,%ebx
400315b4:	31 f6                	xor    %esi,%esi
400315b6:	bf ff 07 00 00       	mov    $0x7ff,%edi
400315bb:	eb 0d                	jmp    400315ca <__muldf3+0x47a>
400315bd:	31 db                	xor    %ebx,%ebx
400315bf:	31 f6                	xor    %esi,%esi
400315c1:	bf 01 00 00 00       	mov    $0x1,%edi
400315c6:	eb 02                	jmp    400315ca <__muldf3+0x47a>
400315c8:	31 ff                	xor    %edi,%edi
400315ca:	31 d2                	xor    %edx,%edx
400315cc:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
400315d2:	89 d1                	mov    %edx,%ecx
400315d4:	81 e7 ff 07 00 00    	and    $0x7ff,%edi
400315da:	81 e1 00 00 f0 ff    	and    $0xfff00000,%ecx
400315e0:	89 f0                	mov    %esi,%eax
400315e2:	c1 e7 14             	shl    $0x14,%edi
400315e5:	09 cb                	or     %ecx,%ebx
400315e7:	81 e3 ff ff 0f 80    	and    $0x800fffff,%ebx
400315ed:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400315f0:	09 df                	or     %ebx,%edi
400315f2:	83 c4 24             	add    $0x24,%esp
400315f5:	c1 e1 1f             	shl    $0x1f,%ecx
400315f8:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
400315fe:	09 cf                	or     %ecx,%edi
40031600:	5b                   	pop    %ebx
40031601:	89 fa                	mov    %edi,%edx
40031603:	5e                   	pop    %esi
40031604:	5f                   	pop    %edi
40031605:	5d                   	pop    %ebp
40031606:	c3                   	ret    

40031607 <__fixunsdfsi>:
40031607:	55                   	push   %ebp
40031608:	89 e5                	mov    %esp,%ebp
4003160a:	56                   	push   %esi
4003160b:	53                   	push   %ebx
4003160c:	89 d3                	mov    %edx,%ebx
4003160e:	c1 eb 14             	shr    $0x14,%ebx
40031611:	89 c6                	mov    %eax,%esi
40031613:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
40031619:	89 d0                	mov    %edx,%eax
4003161b:	c1 ea 1f             	shr    $0x1f,%edx
4003161e:	25 ff ff 0f 00       	and    $0xfffff,%eax
40031623:	81 fb fe 03 00 00    	cmp    $0x3fe,%ebx
40031629:	7e 43                	jle    4003166e <__fixunsdfsi+0x67>
4003162b:	85 d2                	test   %edx,%edx
4003162d:	75 37                	jne    40031666 <__fixunsdfsi+0x5f>
4003162f:	81 fb 1e 04 00 00    	cmp    $0x41e,%ebx
40031635:	7e 05                	jle    4003163c <__fixunsdfsi+0x35>
40031637:	8d 42 ff             	lea    -0x1(%edx),%eax
4003163a:	eb 34                	jmp    40031670 <__fixunsdfsi+0x69>
4003163c:	b9 33 04 00 00       	mov    $0x433,%ecx
40031641:	0d 00 00 10 00       	or     $0x100000,%eax
40031646:	29 d9                	sub    %ebx,%ecx
40031648:	83 f9 1f             	cmp    $0x1f,%ecx
4003164b:	7f 0e                	jg     4003165b <__fixunsdfsi+0x54>
4003164d:	d3 ee                	shr    %cl,%esi
4003164f:	8d 8b ed fb ff ff    	lea    -0x413(%ebx),%ecx
40031655:	d3 e0                	shl    %cl,%eax
40031657:	09 f0                	or     %esi,%eax
40031659:	eb 15                	jmp    40031670 <__fixunsdfsi+0x69>
4003165b:	b9 13 04 00 00       	mov    $0x413,%ecx
40031660:	29 d9                	sub    %ebx,%ecx
40031662:	d3 e8                	shr    %cl,%eax
40031664:	eb 0a                	jmp    40031670 <__fixunsdfsi+0x69>
40031666:	81 fb 1d 04 00 00    	cmp    $0x41d,%ebx
4003166c:	7f c9                	jg     40031637 <__fixunsdfsi+0x30>
4003166e:	31 c0                	xor    %eax,%eax
40031670:	5b                   	pop    %ebx
40031671:	5e                   	pop    %esi
40031672:	5d                   	pop    %ebp
40031673:	c3                   	ret    

40031674 <__floatsidf>:
40031674:	55                   	push   %ebp
40031675:	85 c0                	test   %eax,%eax
40031677:	89 e5                	mov    %esp,%ebp
40031679:	57                   	push   %edi
4003167a:	56                   	push   %esi
4003167b:	53                   	push   %ebx
4003167c:	74 43                	je     400316c1 <__floatsidf+0x4d>
4003167e:	99                   	cltd   
4003167f:	89 c7                	mov    %eax,%edi
40031681:	31 d0                	xor    %edx,%eax
40031683:	29 d0                	sub    %edx,%eax
40031685:	ba 1e 04 00 00       	mov    $0x41e,%edx
4003168a:	0f bd f0             	bsr    %eax,%esi
4003168d:	bb 33 04 00 00       	mov    $0x433,%ebx
40031692:	c1 ef 1f             	shr    $0x1f,%edi
40031695:	83 f6 1f             	xor    $0x1f,%esi
40031698:	29 f2                	sub    %esi,%edx
4003169a:	29 d3                	sub    %edx,%ebx
4003169c:	83 fb 1f             	cmp    $0x1f,%ebx
4003169f:	7f 11                	jg     400316b2 <__floatsidf+0x3e>
400316a1:	b9 0b 00 00 00       	mov    $0xb,%ecx
400316a6:	29 f1                	sub    %esi,%ecx
400316a8:	89 c6                	mov    %eax,%esi
400316aa:	d3 ee                	shr    %cl,%esi
400316ac:	88 d9                	mov    %bl,%cl
400316ae:	d3 e0                	shl    %cl,%eax
400316b0:	eb 17                	jmp    400316c9 <__floatsidf+0x55>
400316b2:	b9 13 04 00 00       	mov    $0x413,%ecx
400316b7:	29 d1                	sub    %edx,%ecx
400316b9:	d3 e0                	shl    %cl,%eax
400316bb:	89 c6                	mov    %eax,%esi
400316bd:	31 c0                	xor    %eax,%eax
400316bf:	eb 08                	jmp    400316c9 <__floatsidf+0x55>
400316c1:	31 f6                	xor    %esi,%esi
400316c3:	31 c0                	xor    %eax,%eax
400316c5:	31 d2                	xor    %edx,%edx
400316c7:	31 ff                	xor    %edi,%edi
400316c9:	31 db                	xor    %ebx,%ebx
400316cb:	89 c1                	mov    %eax,%ecx
400316cd:	89 f0                	mov    %esi,%eax
400316cf:	89 de                	mov    %ebx,%esi
400316d1:	25 ff ff 0f 00       	and    $0xfffff,%eax
400316d6:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
400316dc:	09 c6                	or     %eax,%esi
400316de:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
400316e4:	81 e6 ff ff 0f 80    	and    $0x800fffff,%esi
400316ea:	5b                   	pop    %ebx
400316eb:	c1 e2 14             	shl    $0x14,%edx
400316ee:	89 c8                	mov    %ecx,%eax
400316f0:	c1 e7 1f             	shl    $0x1f,%edi
400316f3:	09 f2                	or     %esi,%edx
400316f5:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
400316fb:	5e                   	pop    %esi
400316fc:	09 fa                	or     %edi,%edx
400316fe:	5f                   	pop    %edi
400316ff:	5d                   	pop    %ebp
40031700:	c3                   	ret    

40031701 <__floatunsidf>:
40031701:	55                   	push   %ebp
40031702:	85 c0                	test   %eax,%eax
40031704:	89 e5                	mov    %esp,%ebp
40031706:	57                   	push   %edi
40031707:	56                   	push   %esi
40031708:	53                   	push   %ebx
40031709:	74 39                	je     40031744 <__floatunsidf+0x43>
4003170b:	0f bd f8             	bsr    %eax,%edi
4003170e:	bb 1e 04 00 00       	mov    $0x41e,%ebx
40031713:	83 f7 1f             	xor    $0x1f,%edi
40031716:	be 33 04 00 00       	mov    $0x433,%esi
4003171b:	29 fb                	sub    %edi,%ebx
4003171d:	29 de                	sub    %ebx,%esi
4003171f:	83 fe 1f             	cmp    $0x1f,%esi
40031722:	7f 11                	jg     40031735 <__floatunsidf+0x34>
40031724:	b9 0b 00 00 00       	mov    $0xb,%ecx
40031729:	89 c2                	mov    %eax,%edx
4003172b:	29 f9                	sub    %edi,%ecx
4003172d:	d3 ea                	shr    %cl,%edx
4003172f:	89 f1                	mov    %esi,%ecx
40031731:	d3 e0                	shl    %cl,%eax
40031733:	eb 15                	jmp    4003174a <__floatunsidf+0x49>
40031735:	b9 13 04 00 00       	mov    $0x413,%ecx
4003173a:	29 d9                	sub    %ebx,%ecx
4003173c:	d3 e0                	shl    %cl,%eax
4003173e:	89 c2                	mov    %eax,%edx
40031740:	31 c0                	xor    %eax,%eax
40031742:	eb 06                	jmp    4003174a <__floatunsidf+0x49>
40031744:	31 d2                	xor    %edx,%edx
40031746:	31 c0                	xor    %eax,%eax
40031748:	31 db                	xor    %ebx,%ebx
4003174a:	31 ff                	xor    %edi,%edi
4003174c:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
40031752:	89 f9                	mov    %edi,%ecx
40031754:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
4003175a:	81 e1 00 00 f0 ff    	and    $0xfff00000,%ecx
40031760:	09 d1                	or     %edx,%ecx
40031762:	89 da                	mov    %ebx,%edx
40031764:	c1 e2 14             	shl    $0x14,%edx
40031767:	81 e1 ff ff 0f 80    	and    $0x800fffff,%ecx
4003176d:	09 ca                	or     %ecx,%edx
4003176f:	5b                   	pop    %ebx
40031770:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
40031776:	5e                   	pop    %esi
40031777:	5f                   	pop    %edi
40031778:	5d                   	pop    %ebp
40031779:	c3                   	ret    

4003177a <McpsConfirm>:
 *
 * \param   [IN] mcpsConfirm - Pointer to the confirm structure,
 *               containing confirm attributes.
 */
static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
4003177a:	55                   	push   %ebp
            }
            default:
                break;
        }
    }
    NextTx = true;
4003177b:	c6 05 b0 66 00 a8 01 	movb   $0x1,0xa80066b0
{
40031782:	89 e5                	mov    %esp,%ebp
}
40031784:	5d                   	pop    %ebp
40031785:	c3                   	ret    

40031786 <MlmeConfirm>:
 *
 * \param   [IN] mlmeConfirm - Pointer to the confirm structure,
 *               containing confirm attributes.
 */
static void MlmeConfirm( MlmeConfirm_t *mlmeConfirm )
{
40031786:	55                   	push   %ebp
    switch( mlmeConfirm->MlmeRequest )
40031787:	8b 10                	mov    (%eax),%edx
{
40031789:	89 e5                	mov    %esp,%ebp
    switch( mlmeConfirm->MlmeRequest )
4003178b:	85 d2                	test   %edx,%edx
4003178d:	74 05                	je     40031794 <MlmeConfirm+0xe>
4003178f:	4a                   	dec    %edx
40031790:	74 14                	je     400317a6 <MlmeConfirm+0x20>
40031792:	eb 39                	jmp    400317cd <MlmeConfirm+0x47>
        case MLME_JOIN:
        {
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
            {
                // Status is OK, node has joined the network
                DeviceState = DEVICE_STATE_SEND;
40031794:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
40031798:	0f 94 c0             	sete   %al
4003179b:	0f b6 c0             	movzbl %al,%eax
4003179e:	40                   	inc    %eax
4003179f:	a3 08 68 00 a8       	mov    %eax,0xa8006808
400317a4:	eb 27                	jmp    400317cd <MlmeConfirm+0x47>
            }
            break;
        }
        case MLME_LINK_CHECK:
        {
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
400317a6:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
400317aa:	75 21                	jne    400317cd <MlmeConfirm+0x47>
            {
                // Check DemodMargin
                // Check NbGateways
                if( ComplianceTest.Running == true )
400317ac:	80 3d 98 81 00 a8 00 	cmpb   $0x0,0xa8008198
400317b3:	74 18                	je     400317cd <MlmeConfirm+0x47>
                {
                    ComplianceTest.LinkCheck = true;
400317b5:	c6 05 a6 81 00 a8 01 	movb   $0x1,0xa80081a6
                    ComplianceTest.DemodMargin = mlmeConfirm->DemodMargin;
400317bc:	8a 50 0c             	mov    0xc(%eax),%dl
400317bf:	88 15 a7 81 00 a8    	mov    %dl,0xa80081a7
                    ComplianceTest.NbGateways = mlmeConfirm->NbGateways;
400317c5:	8a 40 0d             	mov    0xd(%eax),%al
400317c8:	a2 a8 81 00 a8       	mov    %al,0xa80081a8
            break;
        }
        default:
            break;
    }
    NextTx = true;
400317cd:	c6 05 b0 66 00 a8 01 	movb   $0x1,0xa80066b0
}
400317d4:	5d                   	pop    %ebp
400317d5:	c3                   	ret    

400317d6 <OnTxNextPacketTimerEvent>:
{
400317d6:	55                   	push   %ebp
    k_timer_stop(&TxNextPacketTimer);
400317d7:	b8 60 81 00 a8       	mov    $0xa8008160,%eax
{
400317dc:	89 e5                	mov    %esp,%ebp
400317de:	83 ec 0c             	sub    $0xc,%esp
    k_timer_stop(&TxNextPacketTimer);
400317e1:	e8 93 8f 00 00       	call   4003a779 <k_timer_stop>
    status = LoRaMacMibGetRequestConfirm( &mibReq );
400317e6:	8d 45 f4             	lea    -0xc(%ebp),%eax
    mibReq.Type = MIB_NETWORK_JOINED;
400317e9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    status = LoRaMacMibGetRequestConfirm( &mibReq );
400317f0:	e8 52 64 00 00       	call   40037c47 <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
400317f5:	85 c0                	test   %eax,%eax
400317f7:	75 23                	jne    4003181c <OnTxNextPacketTimerEvent+0x46>
        if( mibReq.Param.IsNetworkJoined == true )
400317f9:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
400317fd:	74 13                	je     40031812 <OnTxNextPacketTimerEvent+0x3c>
            DeviceState = DEVICE_STATE_SEND;
400317ff:	c7 05 08 68 00 a8 02 	movl   $0x2,0xa8006808
40031806:	00 00 00 
            NextTx = true;
40031809:	c6 05 b0 66 00 a8 01 	movb   $0x1,0xa80066b0
40031810:	eb 0a                	jmp    4003181c <OnTxNextPacketTimerEvent+0x46>
            DeviceState = DEVICE_STATE_JOIN;
40031812:	c7 05 08 68 00 a8 01 	movl   $0x1,0xa8006808
40031819:	00 00 00 
}
4003181c:	c9                   	leave  
4003181d:	c3                   	ret    

4003181e <McpsIndication>:
    if( mcpsIndication->Status != LORAMAC_EVENT_INFO_STATUS_OK )
4003181e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
40031822:	0f 85 02 02 00 00    	jne    40031a2a <McpsIndication+0x20c>
    if( ComplianceTest.Running == true )
40031828:	8a 15 98 81 00 a8    	mov    0xa8008198,%dl
4003182e:	84 d2                	test   %dl,%dl
40031830:	74 07                	je     40031839 <McpsIndication+0x1b>
        ComplianceTest.DownLinkCounter++;
40031832:	66 ff 05 a4 81 00 a8 	incw   0xa80081a4
    if( mcpsIndication->RxData == true )
40031839:	80 78 11 00          	cmpb   $0x0,0x11(%eax)
4003183d:	0f 84 e7 01 00 00    	je     40031a2a <McpsIndication+0x20c>
        switch( mcpsIndication->Port )
40031843:	80 78 09 e0          	cmpb   $0xe0,0x9(%eax)
40031847:	0f 85 dd 01 00 00    	jne    40031a2a <McpsIndication+0x20c>
{
4003184d:	55                   	push   %ebp
4003184e:	89 e5                	mov    %esp,%ebp
40031850:	53                   	push   %ebx
40031851:	83 ec 20             	sub    $0x20,%esp
            if( ComplianceTest.Running == false )
40031854:	84 d2                	test   %dl,%dl
40031856:	75 77                	jne    400318cf <McpsIndication+0xb1>
                if( ( mcpsIndication->BufferSize == 4 ) &&
40031858:	80 78 10 04          	cmpb   $0x4,0x10(%eax)
4003185c:	0f 85 c3 01 00 00    	jne    40031a25 <McpsIndication+0x207>
                    ( mcpsIndication->Buffer[0] == 0x01 ) &&
40031862:	8b 40 0c             	mov    0xc(%eax),%eax
                if( ( mcpsIndication->BufferSize == 4 ) &&
40031865:	80 38 01             	cmpb   $0x1,(%eax)
40031868:	0f 85 b7 01 00 00    	jne    40031a25 <McpsIndication+0x207>
                    ( mcpsIndication->Buffer[0] == 0x01 ) &&
4003186e:	80 78 01 01          	cmpb   $0x1,0x1(%eax)
40031872:	0f 85 ad 01 00 00    	jne    40031a25 <McpsIndication+0x207>
                    ( mcpsIndication->Buffer[1] == 0x01 ) &&
40031878:	80 78 02 01          	cmpb   $0x1,0x2(%eax)
4003187c:	0f 85 a3 01 00 00    	jne    40031a25 <McpsIndication+0x207>
                    ( mcpsIndication->Buffer[2] == 0x01 ) &&
40031882:	80 78 03 01          	cmpb   $0x1,0x3(%eax)
40031886:	0f 85 99 01 00 00    	jne    40031a25 <McpsIndication+0x207>
                    IsTxConfirmed = false;
4003188c:	c6 05 10 68 00 a8 00 	movb   $0x0,0xa8006810
                    AppPort = 224;
40031893:	c6 05 b2 66 00 a8 e0 	movb   $0xe0,0xa80066b2
                    AppDataSize = 2;
4003189a:	c6 05 b1 66 00 a8 02 	movb   $0x2,0xa80066b1
                    ComplianceTest.DownLinkCounter = 0;
400318a1:	66 c7 05 a4 81 00 a8 	movw   $0x0,0xa80081a4
400318a8:	00 00 
                    ComplianceTest.LinkCheck = false;
400318aa:	c6 05 a6 81 00 a8 00 	movb   $0x0,0xa80081a6
                    ComplianceTest.DemodMargin = 0;
400318b1:	c6 05 a7 81 00 a8 00 	movb   $0x0,0xa80081a7
                    ComplianceTest.NbGateways = 0;
400318b8:	c6 05 a8 81 00 a8 00 	movb   $0x0,0xa80081a8
                    ComplianceTest.Running = true;
400318bf:	c6 05 98 81 00 a8 01 	movb   $0x1,0xa8008198
                    ComplianceTest.State = 1;
400318c6:	c6 05 99 81 00 a8 01 	movb   $0x1,0xa8008199
400318cd:	eb 41                	jmp    40031910 <McpsIndication+0xf2>
                ComplianceTest.State = mcpsIndication->Buffer[0];
400318cf:	8b 48 0c             	mov    0xc(%eax),%ecx
400318d2:	0f b6 11             	movzbl (%ecx),%edx
400318d5:	88 15 99 81 00 a8    	mov    %dl,0xa8008199
                switch( ComplianceTest.State )
400318db:	80 fa 07             	cmp    $0x7,%dl
400318de:	0f 87 41 01 00 00    	ja     40031a25 <McpsIndication+0x207>
400318e4:	ff 24 95 f0 bb 03 40 	jmp    *0x4003bbf0(,%edx,4)
                    IsTxConfirmed = LORAWAN_CONFIRMED_MSG_ON;
400318eb:	c6 05 10 68 00 a8 00 	movb   $0x0,0xa8006810
                    AppPort = LORAWAN_APP_PORT;
400318f2:	c6 05 b2 66 00 a8 02 	movb   $0x2,0xa80066b2
                    AppDataSize = LORAWAN_APP_DATA_SIZE;
400318f9:	c6 05 b1 66 00 a8 0b 	movb   $0xb,0xa80066b1
                    ComplianceTest.DownLinkCounter = 0;
40031900:	66 c7 05 a4 81 00 a8 	movw   $0x0,0xa80081a4
40031907:	00 00 
                    ComplianceTest.Running = false;
40031909:	c6 05 98 81 00 a8 00 	movb   $0x0,0xa8008198
                    LoRaMacMibSetRequestConfirm( &mibReq );
40031910:	8d 45 e8             	lea    -0x18(%ebp),%eax
                    mibReq.Type = MIB_ADR;
40031913:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%ebp)
                    mibReq.Param.AdrEnable = LORAWAN_ADR_ON;
4003191a:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
                    LoRaMacMibSetRequestConfirm( &mibReq );
4003191e:	e8 53 64 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
40031923:	e9 fd 00 00 00       	jmp    40031a25 <McpsIndication+0x207>
                    AppDataSize = 2;
40031928:	c6 05 b1 66 00 a8 02 	movb   $0x2,0xa80066b1
4003192f:	e9 f1 00 00 00       	jmp    40031a25 <McpsIndication+0x207>
                    IsTxConfirmed = true;
40031934:	c6 05 10 68 00 a8 01 	movb   $0x1,0xa8006810
4003193b:	e9 de 00 00 00       	jmp    40031a1e <McpsIndication+0x200>
                    IsTxConfirmed = false;
40031940:	c6 05 10 68 00 a8 00 	movb   $0x0,0xa8006810
40031947:	e9 d2 00 00 00       	jmp    40031a1e <McpsIndication+0x200>
                    AppDataSize = mcpsIndication->BufferSize;
4003194c:	8a 58 10             	mov    0x10(%eax),%bl
                    AppData[0] = 4;
4003194f:	31 d2                	xor    %edx,%edx
                    AppDataSize = mcpsIndication->BufferSize;
40031951:	88 1d b1 66 00 a8    	mov    %bl,0xa80066b1
                    AppData[0] = 4;
40031957:	c6 05 20 68 00 a8 04 	movb   $0x4,0xa8006820
4003195e:	42                   	inc    %edx
                    for( uint8_t i = 1; i < AppDataSize; i++ )
4003195f:	38 d3                	cmp    %dl,%bl
40031961:	0f 86 be 00 00 00    	jbe    40031a25 <McpsIndication+0x207>
                        AppData[i] = mcpsIndication->Buffer[i] + 1;
40031967:	8b 48 0c             	mov    0xc(%eax),%ecx
4003196a:	8a 0c 11             	mov    (%ecx,%edx,1),%cl
4003196d:	41                   	inc    %ecx
4003196e:	88 8a 20 68 00 a8    	mov    %cl,-0x57ff97e0(%edx)
40031974:	eb e8                	jmp    4003195e <McpsIndication+0x140>
                        LoRaMacMlmeRequest( &mlmeReq );
40031976:	8d 45 e8             	lea    -0x18(%ebp),%eax
                        mlmeReq.Type = MLME_LINK_CHECK;
40031979:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
                        LoRaMacMlmeRequest( &mlmeReq );
40031980:	e8 99 6b 00 00       	call   4003851e <LoRaMacMlmeRequest>
40031985:	e9 9b 00 00 00       	jmp    40031a25 <McpsIndication+0x207>
                        LoRaMacMibSetRequestConfirm( &mibReq );
4003198a:	8d 45 dc             	lea    -0x24(%ebp),%eax
                        IsTxConfirmed = LORAWAN_CONFIRMED_MSG_ON;
4003198d:	c6 05 10 68 00 a8 00 	movb   $0x0,0xa8006810
                        AppPort = LORAWAN_APP_PORT;
40031994:	c6 05 b2 66 00 a8 02 	movb   $0x2,0xa80066b2
                        AppDataSize = LORAWAN_APP_DATA_SIZE;
4003199b:	c6 05 b1 66 00 a8 0b 	movb   $0xb,0xa80066b1
                        ComplianceTest.DownLinkCounter = 0;
400319a2:	66 c7 05 a4 81 00 a8 	movw   $0x0,0xa80081a4
400319a9:	00 00 
                        ComplianceTest.Running = false;
400319ab:	c6 05 98 81 00 a8 00 	movb   $0x0,0xa8008198
                        mibReq.Type = MIB_ADR;
400319b2:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
                        mibReq.Param.AdrEnable = LORAWAN_ADR_ON;
400319b9:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
                        LoRaMacMibSetRequestConfirm( &mibReq );
400319bd:	e8 b4 63 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                        LoRaMacMlmeRequest( &mlmeReq );
400319c2:	8d 45 e8             	lea    -0x18(%ebp),%eax
                        mlmeReq.Type = MLME_JOIN;
400319c5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
                        mlmeReq.Req.Join.DevEui = DevEui;
400319cc:	c7 45 ec 6c 68 00 a8 	movl   $0xa800686c,-0x14(%ebp)
                        mlmeReq.Req.Join.AppEui = AppEui;
400319d3:	c7 45 f0 64 68 00 a8 	movl   $0xa8006864,-0x10(%ebp)
                        mlmeReq.Req.Join.AppKey = AppKey;
400319da:	c7 45 f4 d4 66 00 a8 	movl   $0xa80066d4,-0xc(%ebp)
                        mlmeReq.Req.Join.NbTrials = 3;
400319e1:	c6 45 f8 03          	movb   $0x3,-0x8(%ebp)
                        LoRaMacMlmeRequest( &mlmeReq );
400319e5:	e8 34 6b 00 00       	call   4003851e <LoRaMacMlmeRequest>
                        DeviceState = DEVICE_STATE_SLEEP;
400319ea:	c7 05 08 68 00 a8 04 	movl   $0x4,0xa8006808
400319f1:	00 00 00 
400319f4:	eb 2f                	jmp    40031a25 <McpsIndication+0x207>
                        if( mcpsIndication->BufferSize == 3 )
400319f6:	80 78 10 03          	cmpb   $0x3,0x10(%eax)
400319fa:	75 22                	jne    40031a1e <McpsIndication+0x200>
                            mlmeReq.Type = MLME_TXCW;
400319fc:	c7 45 e8 02 00 00 00 	movl   $0x2,-0x18(%ebp)
                            mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
40031a03:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
40031a07:	c1 e0 08             	shl    $0x8,%eax
40031a0a:	89 c2                	mov    %eax,%edx
40031a0c:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
40031a10:	09 d0                	or     %edx,%eax
40031a12:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
                            LoRaMacMlmeRequest( &mlmeReq );
40031a16:	8d 45 e8             	lea    -0x18(%ebp),%eax
40031a19:	e8 00 6b 00 00       	call   4003851e <LoRaMacMlmeRequest>
                        ComplianceTest.State = 1;
40031a1e:	c6 05 99 81 00 a8 01 	movb   $0x1,0xa8008199
}
40031a25:	83 c4 20             	add    $0x20,%esp
40031a28:	5b                   	pop    %ebx
40031a29:	5d                   	pop    %ebp
40031a2a:	c3                   	ret    

40031a2b <main>:
                // not sure what to do here now
                break;
            }
            default:
            {
                DeviceState = DEVICE_STATE_INIT;
40031a2b:	c7 05 08 68 00 a8 00 	movl   $0x0,0xa8006808
40031a32:	00 00 00 
        switch( DeviceState )
40031a35:	a1 08 68 00 a8       	mov    0xa8006808,%eax
40031a3a:	83 f8 04             	cmp    $0x4,%eax
40031a3d:	77 ec                	ja     40031a2b <main>
{
40031a3f:	55                   	push   %ebp
40031a40:	89 e5                	mov    %esp,%ebp
40031a42:	83 ec 30             	sub    $0x30,%esp
        switch( DeviceState )
40031a45:	ff 24 85 60 bc 03 40 	jmp    *0x4003bc60(,%eax,4)
printf("entering device state init\n");
40031a4c:	68 10 bc 03 40       	push   $0x4003bc10
40031a51:	e8 22 92 00 00       	call   4003ac78 <iprintf>
40031a56:	58                   	pop    %eax
                LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks );
40031a57:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40031a5a:	8d 45 d8             	lea    -0x28(%ebp),%eax
                LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
40031a5d:	c7 45 d8 7a 17 03 40 	movl   $0x4003177a,-0x28(%ebp)
                LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
40031a64:	c7 45 dc 1e 18 03 40 	movl   $0x4003181e,-0x24(%ebp)
                LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
40031a6b:	c7 45 e0 86 17 03 40 	movl   $0x40031786,-0x20(%ebp)
                LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks );
40031a72:	e8 73 5e 00 00       	call   400378ea <LoRaMacInitialization>
printf("before setting up first timer\n");
40031a77:	68 2c bc 03 40       	push   $0x4003bc2c
40031a7c:	e8 f7 91 00 00       	call   4003ac78 <iprintf>
40031a81:	5a                   	pop    %edx
                k_timer_init(&TxNextPacketTimer, OnTxNextPacketTimerEvent, NULL);
40031a82:	31 c9                	xor    %ecx,%ecx
40031a84:	ba d6 17 03 40       	mov    $0x400317d6,%edx
40031a89:	b8 60 81 00 a8       	mov    $0xa8008160,%eax
40031a8e:	e8 49 8c 00 00       	call   4003a6dc <k_timer_init>
printf("setup first timer\n");
40031a93:	68 4b bc 03 40       	push   $0x4003bc4b
40031a98:	e8 db 91 00 00       	call   4003ac78 <iprintf>
                LoRaMacMibSetRequestConfirm( &mibReq );
40031a9d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
printf("setup first timer\n");
40031aa0:	59                   	pop    %ecx
                mibReq.Type = MIB_ADR;
40031aa1:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%ebp)
                mibReq.Param.AdrEnable = LORAWAN_ADR_ON;
40031aa8:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031aac:	e8 c5 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                LoRaMacMibSetRequestConfirm( &mibReq );
40031ab1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
                mibReq.Type = MIB_PUBLIC_NETWORK;
40031ab4:	c7 45 e4 07 00 00 00 	movl   $0x7,-0x1c(%ebp)
                mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
40031abb:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031abf:	e8 b2 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                DeviceState = DEVICE_STATE_JOIN;
40031ac4:	c7 05 08 68 00 a8 01 	movl   $0x1,0xa8006808
40031acb:	00 00 00 
        switch( DeviceState )
40031ace:	a1 08 68 00 a8       	mov    0xa8006808,%eax
40031ad3:	83 f8 04             	cmp    $0x4,%eax
40031ad6:	0f 86 69 ff ff ff    	jbe    40031a45 <main+0x1a>
                DeviceState = DEVICE_STATE_INIT;
40031adc:	c7 05 08 68 00 a8 00 	movl   $0x0,0xa8006808
40031ae3:	00 00 00 
                break;
40031ae6:	eb e6                	jmp    40031ace <main+0xa3>
                if( DevAddr == 0 )
40031ae8:	83 3d 60 68 00 a8 00 	cmpl   $0x0,0xa8006860
40031aef:	75 1b                	jne    40031b0c <main+0xe1>
                    srand(0x1FF800D0^0x1FF800D4^0x1FF800E4);
40031af1:	b8 e0 00 f8 1f       	mov    $0x1ff800e0,%eax
40031af6:	e8 95 91 00 00       	call   4003ac90 <srand>
                    DevAddr = upm_rand_range( 0, 0x01FFFFFF );
40031afb:	ba ff ff ff 01       	mov    $0x1ffffff,%edx
40031b00:	31 c0                	xor    %eax,%eax
40031b02:	e8 55 2a 00 00       	call   4003455c <upm_rand_range>
40031b07:	a3 60 68 00 a8       	mov    %eax,0xa8006860
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b0c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
                mibReq.Type = MIB_NET_ID;
40031b0f:	c7 45 e4 03 00 00 00 	movl   $0x3,-0x1c(%ebp)
                mibReq.Param.NetID = LORAWAN_NETWORK_ID;
40031b16:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b1d:	e8 54 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                mibReq.Param.DevAddr = DevAddr;
40031b22:	a1 60 68 00 a8       	mov    0xa8006860,%eax
                mibReq.Type = MIB_DEV_ADDR;
40031b27:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%ebp)
                mibReq.Param.DevAddr = DevAddr;
40031b2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40031b34:	e8 3d 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b39:	8d 45 e4             	lea    -0x1c(%ebp),%eax
                mibReq.Type = MIB_NWK_SKEY;
40031b3c:	c7 45 e4 05 00 00 00 	movl   $0x5,-0x1c(%ebp)
                mibReq.Param.NwkSKey = NwkSKey;
40031b43:	c7 45 e8 c4 66 00 a8 	movl   $0xa80066c4,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b4a:	e8 27 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b4f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
                mibReq.Type = MIB_APP_SKEY;
40031b52:	c7 45 e4 06 00 00 00 	movl   $0x6,-0x1c(%ebp)
                mibReq.Param.AppSKey = AppSKey;
40031b59:	c7 45 e8 b4 66 00 a8 	movl   $0xa80066b4,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b60:	e8 11 62 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b65:	8d 45 e4             	lea    -0x1c(%ebp),%eax
                mibReq.Type = MIB_NETWORK_JOINED;
40031b68:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
                mibReq.Param.IsNetworkJoined = true;
40031b6f:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
                LoRaMacMibSetRequestConfirm( &mibReq );
40031b73:	e8 fe 61 00 00       	call   40037d76 <LoRaMacMibSetRequestConfirm>
                DeviceState = DEVICE_STATE_SEND;
40031b78:	c7 05 08 68 00 a8 02 	movl   $0x2,0xa8006808
40031b7f:	00 00 00 
                break;
40031b82:	e9 47 ff ff ff       	jmp    40031ace <main+0xa3>
                if( NextTx == true )
40031b87:	80 3d b0 66 00 a8 00 	cmpb   $0x0,0xa80066b0
40031b8e:	0f 84 4c 01 00 00    	je     40031ce0 <main+0x2b5>
    switch( port )
40031b94:	a0 b2 66 00 a8       	mov    0xa80066b2,%al
40031b99:	3c 02                	cmp    $0x2,%al
40031b9b:	74 09                	je     40031ba6 <main+0x17b>
40031b9d:	3c e0                	cmp    $0xe0,%al
40031b9f:	74 54                	je     40031bf5 <main+0x1ca>
40031ba1:	e9 b6 00 00 00       	jmp    40031c5c <main+0x231>
            AppData[0] = 10;
40031ba6:	c6 05 20 68 00 a8 0a 	movb   $0xa,0xa8006820
            AppData[1] = 9;                                           // Signed degrees celsius in half degree units. So,  +/-63 C
40031bad:	c6 05 21 68 00 a8 09 	movb   $0x9,0xa8006821
            AppData[2] = 8;                                          // Per LoRaWAN spec; 0=Charging; 1...254 = level, 255 = N/A
40031bb4:	c6 05 22 68 00 a8 08 	movb   $0x8,0xa8006822
            AppData[3] = 7;
40031bbb:	c6 05 23 68 00 a8 07 	movb   $0x7,0xa8006823
            AppData[4] = 6;
40031bc2:	c6 05 24 68 00 a8 06 	movb   $0x6,0xa8006824
            AppData[5] = 5;
40031bc9:	c6 05 25 68 00 a8 05 	movb   $0x5,0xa8006825
            AppData[6] = 4;
40031bd0:	c6 05 26 68 00 a8 04 	movb   $0x4,0xa8006826
            AppData[7] = 3;
40031bd7:	c6 05 27 68 00 a8 03 	movb   $0x3,0xa8006827
            AppData[8] = 2;
40031bde:	c6 05 28 68 00 a8 02 	movb   $0x2,0xa8006828
            AppData[9] = 1;
40031be5:	c6 05 29 68 00 a8 01 	movb   $0x1,0xa8006829
            AppData[10] = 0;
40031bec:	c6 05 2a 68 00 a8 00 	movb   $0x0,0xa800682a
40031bf3:	eb 67                	jmp    40031c5c <main+0x231>
        if( ComplianceTest.LinkCheck == true )
40031bf5:	80 3d a6 81 00 a8 00 	cmpb   $0x0,0xa80081a6
40031bfc:	74 2b                	je     40031c29 <main+0x1fe>
            AppData[1] = ComplianceTest.DemodMargin;
40031bfe:	a0 a7 81 00 a8       	mov    0xa80081a7,%al
            ComplianceTest.LinkCheck = false;
40031c03:	c6 05 a6 81 00 a8 00 	movb   $0x0,0xa80081a6
            AppData[1] = ComplianceTest.DemodMargin;
40031c0a:	a2 21 68 00 a8       	mov    %al,0xa8006821
            AppData[2] = ComplianceTest.NbGateways;
40031c0f:	a0 a8 81 00 a8       	mov    0xa80081a8,%al
            AppDataSize = 3;
40031c14:	c6 05 b1 66 00 a8 03 	movb   $0x3,0xa80066b1
            AppData[0] = 5;
40031c1b:	c6 05 20 68 00 a8 05 	movb   $0x5,0xa8006820
            AppData[2] = ComplianceTest.NbGateways;
40031c22:	a2 22 68 00 a8       	mov    %al,0xa8006822
40031c27:	eb 0d                	jmp    40031c36 <main+0x20b>
            switch( ComplianceTest.State )
40031c29:	a0 99 81 00 a8       	mov    0xa8008199,%al
40031c2e:	3c 01                	cmp    $0x1,%al
40031c30:	74 0d                	je     40031c3f <main+0x214>
40031c32:	3c 04                	cmp    $0x4,%al
40031c34:	75 26                	jne    40031c5c <main+0x231>
                ComplianceTest.State = 1;
40031c36:	c6 05 99 81 00 a8 01 	movb   $0x1,0xa8008199
40031c3d:	eb 1d                	jmp    40031c5c <main+0x231>
                AppData[0] = ComplianceTest.DownLinkCounter >> 8;
40031c3f:	a1 a4 81 00 a8       	mov    0xa80081a4,%eax
                AppDataSize = 2;
40031c44:	c6 05 b1 66 00 a8 02 	movb   $0x2,0xa80066b1
                AppData[0] = ComplianceTest.DownLinkCounter >> 8;
40031c4b:	89 c2                	mov    %eax,%edx
                AppData[1] = ComplianceTest.DownLinkCounter;
40031c4d:	a2 21 68 00 a8       	mov    %al,0xa8006821
                AppData[0] = ComplianceTest.DownLinkCounter >> 8;
40031c52:	66 c1 ea 08          	shr    $0x8,%dx
40031c56:	88 15 20 68 00 a8    	mov    %dl,0xa8006820
    if( LoRaMacQueryTxPossible( AppDataSize, &txInfo ) != LORAMAC_STATUS_OK )
40031c5c:	0f b6 05 b1 66 00 a8 	movzbl 0xa80066b1,%eax
40031c63:	8d 55 d2             	lea    -0x2e(%ebp),%edx
40031c66:	e8 30 5f 00 00       	call   40037b9b <LoRaMacQueryTxPossible>
40031c6b:	85 c0                	test   %eax,%eax
40031c6d:	74 16                	je     40031c85 <main+0x25a>
        mcpsReq.Type = MCPS_UNCONFIRMED;
40031c6f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
40031c76:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
40031c7d:	66 c7 45 fc 00 00    	movw   $0x0,-0x4(%ebp)
40031c83:	eb 46                	jmp    40031ccb <main+0x2a0>
        if( IsTxConfirmed == false )
40031c85:	80 3d 10 68 00 a8 00 	cmpb   $0x0,0xa8006810
40031c8c:	8a 15 b2 66 00 a8    	mov    0xa80066b2,%dl
40031c92:	0f b6 05 b1 66 00 a8 	movzbl 0xa80066b1,%eax
40031c99:	75 17                	jne    40031cb2 <main+0x287>
            mcpsReq.Type = MCPS_UNCONFIRMED;
40031c9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            mcpsReq.Req.Unconfirmed.fPort = AppPort;
40031ca2:	88 55 f4             	mov    %dl,-0xc(%ebp)
            mcpsReq.Req.Unconfirmed.fBuffer = AppData;
40031ca5:	c7 45 f8 20 68 00 a8 	movl   $0xa8006820,-0x8(%ebp)
            mcpsReq.Req.Unconfirmed.fBufferSize = AppDataSize;
40031cac:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
40031cb0:	eb 19                	jmp    40031ccb <main+0x2a0>
            mcpsReq.Type = MCPS_CONFIRMED;
40031cb2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
            mcpsReq.Req.Confirmed.fPort = AppPort;
40031cb9:	88 55 f4             	mov    %dl,-0xc(%ebp)
            mcpsReq.Req.Confirmed.fBuffer = AppData;
40031cbc:	c7 45 f8 20 68 00 a8 	movl   $0xa8006820,-0x8(%ebp)
            mcpsReq.Req.Confirmed.fBufferSize = AppDataSize;
40031cc3:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
            mcpsReq.Req.Confirmed.NbTrials = 8;
40031cc7:	c6 45 ff 08          	movb   $0x8,-0x1(%ebp)
    if( LoRaMacMcpsRequest( &mcpsReq ) == LORAMAC_STATUS_OK )
40031ccb:	8d 45 f0             	lea    -0x10(%ebp),%eax
            mcpsReq.Req.Confirmed.Datarate = LORAWAN_DEFAULT_DATARATE;
40031cce:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)
    if( LoRaMacMcpsRequest( &mcpsReq ) == LORAMAC_STATUS_OK )
40031cd2:	e8 a8 69 00 00       	call   4003867f <LoRaMacMcpsRequest>
40031cd7:	85 c0                	test   %eax,%eax
                    NextTx = SendFrame( );
40031cd9:	0f 95 05 b0 66 00 a8 	setne  0xa80066b0
                if( ComplianceTest.Running == true )
40031ce0:	80 3d 98 81 00 a8 00 	cmpb   $0x0,0xa8008198
40031ce7:	74 0c                	je     40031cf5 <main+0x2ca>
                    TxDutyCycleTime = 5000; // 5000 ms
40031ce9:	c7 05 0c 68 00 a8 88 	movl   $0x1388,0xa800680c
40031cf0:	13 00 00 
40031cf3:	eb 19                	jmp    40031d0e <main+0x2e3>
                    TxDutyCycleTime = APP_TX_DUTYCYCLE + upm_rand_range( -APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND );
40031cf5:	ba e8 03 00 00       	mov    $0x3e8,%edx
40031cfa:	b8 18 fc ff ff       	mov    $0xfffffc18,%eax
40031cff:	e8 58 28 00 00       	call   4003455c <upm_rand_range>
40031d04:	05 88 13 00 00       	add    $0x1388,%eax
40031d09:	a3 0c 68 00 a8       	mov    %eax,0xa800680c
                DeviceState = DEVICE_STATE_CYCLE;
40031d0e:	c7 05 08 68 00 a8 03 	movl   $0x3,0xa8006808
40031d15:	00 00 00 
                break;
40031d18:	e9 b1 fd ff ff       	jmp    40031ace <main+0xa3>
                k_timer_start(&TxNextPacketTimer, TxDutyCycleTime, 0);
40031d1d:	31 c9                	xor    %ecx,%ecx
40031d1f:	8b 15 0c 68 00 a8    	mov    0xa800680c,%edx
40031d25:	b8 60 81 00 a8       	mov    $0xa8008160,%eax
                DeviceState = DEVICE_STATE_SLEEP;
40031d2a:	c7 05 08 68 00 a8 04 	movl   $0x4,0xa8006808
40031d31:	00 00 00 
                k_timer_start(&TxNextPacketTimer, TxDutyCycleTime, 0);
40031d34:	e8 e1 89 00 00       	call   4003a71a <k_timer_start>
                break;
40031d39:	e9 90 fd ff ff       	jmp    40031ace <main+0xa3>

40031d3e <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
40031d3e:	55                   	push   %ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
40031d3f:	83 f8 0a             	cmp    $0xa,%eax
{
40031d42:	89 e5                	mov    %esp,%ebp
40031d44:	53                   	push   %ebx
40031d45:	89 c3                	mov    %eax,%ebx
	if ('\n' == c) {
40031d47:	75 10                	jne    40031d59 <console_out+0x1b>
		uart_poll_out(uart_console_dev, '\r');
40031d49:	a1 74 68 00 a8       	mov    0xa8006874,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
40031d4e:	ba 0d 00 00 00       	mov    $0xd,%edx
40031d53:	8b 48 04             	mov    0x4(%eax),%ecx
40031d56:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
40031d59:	a1 74 68 00 a8       	mov    0xa8006874,%eax
40031d5e:	0f b6 d3             	movzbl %bl,%edx
40031d61:	8b 48 04             	mov    0x4(%eax),%ecx
40031d64:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
40031d67:	89 d8                	mov    %ebx,%eax
40031d69:	5b                   	pop    %ebx
40031d6a:	5d                   	pop    %ebp
40031d6b:	c3                   	ret    

40031d6c <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
40031d6c:	55                   	push   %ebp
	__stdout_hook_install(console_out);
40031d6d:	b8 3e 1d 03 40       	mov    $0x40031d3e,%eax
{
40031d72:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
40031d74:	e8 ad 0a 00 00       	call   40032826 <__stdout_hook_install>
	__printk_hook_install(console_out);
40031d79:	b8 3e 1d 03 40       	mov    $0x40031d3e,%eax
}
40031d7e:	5d                   	pop    %ebp
	__printk_hook_install(console_out);
40031d7f:	e9 23 0c 00 00       	jmp    400329a7 <__printk_hook_install>

40031d84 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
40031d84:	55                   	push   %ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40031d85:	b8 74 bc 03 40       	mov    $0x4003bc74,%eax
{
40031d8a:	89 e5                	mov    %esp,%ebp
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40031d8c:	e8 75 7d 00 00       	call   40039b06 <device_get_binding>
40031d91:	a3 74 68 00 a8       	mov    %eax,0xa8006874
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
40031d96:	e8 d1 ff ff ff       	call   40031d6c <uart_console_hook_install>

	return 0;
}
40031d9b:	31 c0                	xor    %eax,%eax
40031d9d:	5d                   	pop    %ebp
40031d9e:	c3                   	ret    

40031d9f <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
40031d9f:	55                   	push   %ebp
40031da0:	89 e5                	mov    %esp,%ebp
40031da2:	56                   	push   %esi
40031da3:	53                   	push   %ebx
40031da4:	89 c6                	mov    %eax,%esi
40031da6:	83 ec 0c             	sub    $0xc,%esp
	const struct uart_qmsi_config_info *config = dev->config->config_info;
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
40031da9:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
	const struct uart_qmsi_config_info *config = dev->config->config_info;
40031db0:	8b 00                	mov    (%eax),%eax
40031db2:	8b 58 08             	mov    0x8(%eax),%ebx
	cfg.baud_divisor = config->baud_divisor;
40031db5:	8b 43 08             	mov    0x8(%ebx),%eax
40031db8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cfg.hw_fc = config->hw_fc;
40031dbb:	8a 43 0c             	mov    0xc(%ebx),%al
40031dbe:	88 45 f4             	mov    %al,-0xc(%ebp)

	clk_periph_enable(config->clock_gate);
40031dc1:	8b 43 04             	mov    0x4(%ebx),%eax
40031dc4:	e8 9e 0e 00 00       	call   40032c67 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
40031dc9:	8d 55 ec             	lea    -0x14(%ebp),%edx
40031dcc:	8b 03                	mov    (%ebx),%eax
40031dce:	e8 db 0f 00 00       	call   40032dae <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
40031dd3:	c7 46 04 b0 bc 03 40 	movl   $0x4003bcb0,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
40031dda:	83 c4 0c             	add    $0xc,%esp
40031ddd:	31 c0                	xor    %eax,%eax
40031ddf:	5b                   	pop    %ebx
40031de0:	5e                   	pop    %esi
40031de1:	5d                   	pop    %ebp
40031de2:	c3                   	ret    

40031de3 <uart_qmsi_err_check>:
{
40031de3:	55                   	push   %ebp
40031de4:	89 e5                	mov    %esp,%ebp
40031de6:	52                   	push   %edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031de7:	8b 00                	mov    (%eax),%eax
	qm_uart_get_status(instance, &status);
40031de9:	8d 55 fc             	lea    -0x4(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031dec:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_get_status(instance, &status);
40031def:	8b 00                	mov    (%eax),%eax
40031df1:	e8 25 10 00 00       	call   40032e1b <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
40031df6:	8b 45 fc             	mov    -0x4(%ebp),%eax
40031df9:	83 e0 1e             	and    $0x1e,%eax
}
40031dfc:	c9                   	leave  
40031dfd:	c3                   	ret    

40031dfe <uart_qmsi_poll_out>:
{
40031dfe:	55                   	push   %ebp
40031dff:	89 e5                	mov    %esp,%ebp
40031e01:	53                   	push   %ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031e02:	8b 00                	mov    (%eax),%eax
{
40031e04:	89 d3                	mov    %edx,%ebx
	qm_uart_write(instance, data);
40031e06:	0f b6 d2             	movzbl %dl,%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031e09:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_write(instance, data);
40031e0c:	8b 00                	mov    (%eax),%eax
40031e0e:	e8 49 10 00 00       	call   40032e5c <qm_uart_write>
}
40031e13:	88 d8                	mov    %bl,%al
40031e15:	5b                   	pop    %ebx
40031e16:	5d                   	pop    %ebp
40031e17:	c3                   	ret    

40031e18 <uart_qmsi_poll_in>:
{
40031e18:	55                   	push   %ebp
40031e19:	89 e5                	mov    %esp,%ebp
40031e1b:	56                   	push   %esi
40031e1c:	53                   	push   %ebx
40031e1d:	51                   	push   %ecx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031e1e:	8b 00                	mov    (%eax),%eax
{
40031e20:	89 d6                	mov    %edx,%esi
	qm_uart_get_status(instance, &status);
40031e22:	8d 55 f4             	lea    -0xc(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40031e25:	8b 40 08             	mov    0x8(%eax),%eax
40031e28:	8b 18                	mov    (%eax),%ebx
	qm_uart_get_status(instance, &status);
40031e2a:	89 d8                	mov    %ebx,%eax
40031e2c:	e8 ea 0f 00 00       	call   40032e1b <qm_uart_get_status>
		return -1;
40031e31:	83 c8 ff             	or     $0xffffffff,%eax
	if (!(status & QM_UART_RX_BUSY))
40031e34:	f6 45 f4 40          	testb  $0x40,-0xc(%ebp)
40031e38:	74 0d                	je     40031e47 <uart_qmsi_poll_in+0x2f>
	qm_uart_read(instance, data, NULL);
40031e3a:	31 c9                	xor    %ecx,%ecx
40031e3c:	89 f2                	mov    %esi,%edx
40031e3e:	89 d8                	mov    %ebx,%eax
40031e40:	e8 3a 10 00 00       	call   40032e7f <qm_uart_read>
	return 0;
40031e45:	31 c0                	xor    %eax,%eax
}
40031e47:	5a                   	pop    %edx
40031e48:	5b                   	pop    %ebx
40031e49:	5e                   	pop    %esi
40031e4a:	5d                   	pop    %ebp
40031e4b:	c3                   	ret    

40031e4c <_timer_int_handler>:

	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick * _sys_idle_elapsed_ticks;
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
40031e4c:	a1 48 85 00 a8       	mov    0xa8008548,%eax
{
40031e51:	55                   	push   %ebp
	accumulated_cycle_count += cycles_per_tick;
40031e52:	01 05 88 68 00 a8    	add    %eax,0xa8006888

	_sys_clock_tick_announce();
40031e58:	a1 50 67 00 a8       	mov    0xa8006750,%eax
{
40031e5d:	89 e5                	mov    %esp,%ebp
#endif /*CONFIG_TICKLESS_IDLE*/

}
40031e5f:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
40031e60:	e9 b4 82 00 00       	jmp    4003a119 <_nano_sys_clock_tick_announce>

40031e65 <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40031e65:	a1 54 67 00 a8       	mov    0xa8006754,%eax
{
40031e6a:	55                   	push   %ebp
	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40031e6b:	a3 48 85 00 a8       	mov    %eax,0xa8008548
{
40031e70:	89 e5                	mov    %esp,%ebp
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
40031e72:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
40031e77:	83 e0 f0             	and    $0xfffffff0,%eax
40031e7a:	83 c8 0b             	or     $0xb,%eax
40031e7d:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
40031e82:	a1 48 85 00 a8       	mov    0xa8008548,%eax
40031e87:	48                   	dec    %eax
	*_REG_TIMER_ICR = count;
40031e88:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
40031e8d:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
40031e92:	0d 00 00 02 00       	or     $0x20000,%eax
40031e97:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
40031e9c:	0f b6 05 e8 da 03 40 	movzbl 0x4003dae8,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
40031ea3:	31 c9                	xor    %ecx,%ecx
40031ea5:	ba 40 00 00 00       	mov    $0x40,%edx
40031eaa:	e8 7b 01 00 00       	call   4003202a <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
40031eaf:	b8 40 00 00 00       	mov    $0x40,%eax
40031eb4:	e8 93 01 00 00       	call   4003204c <_arch_irq_enable>

	return 0;
}
40031eb9:	31 c0                	xor    %eax,%eax
40031ebb:	5d                   	pop    %ebp
40031ebc:	c3                   	ret    

40031ebd <_timer_int_handler_irq64_stub>:
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
40031ebd:	6a 00                	push   $0x0
40031ebf:	68 4c 1e 03 40       	push   $0x40031e4c
40031ec4:	e9 00 79 00 00       	jmp    400397c9 <_interrupt_enter>

40031ec9 <qm_spi_master_1_isr_irq3_stub>:
40031ec9:	6a 00                	push   $0x0
40031ecb:	68 52 33 03 40       	push   $0x40033352
40031ed0:	e9 f4 78 00 00       	jmp    400397c9 <_interrupt_enter>

40031ed5 <qm_spi_master_0_isr_irq2_stub>:
40031ed5:	6a 00                	push   $0x0
40031ed7:	68 47 33 03 40       	push   $0x40033347
40031edc:	e9 e8 78 00 00       	jmp    400397c9 <_interrupt_enter>

40031ee1 <qm_aon_gpio_0_isr_irq31_stub>:
40031ee1:	6a 00                	push   $0x0
40031ee3:	68 be 2c 03 40       	push   $0x40032cbe
40031ee8:	e9 dc 78 00 00       	jmp    400397c9 <_interrupt_enter>

40031eed <qm_gpio_0_isr_irq8_stub>:
40031eed:	6a 00                	push   $0x0
40031eef:	68 b3 2c 03 40       	push   $0x40032cb3
40031ef4:	e9 d0 78 00 00       	jmp    400397c9 <_interrupt_enter>

40031ef9 <_timer_cycle_get_32>:
	 * in the Initial Count Register (ICR).
	 */

#if !defined(CONFIG_TICKLESS_IDLE)
	/* The value in the ICR always matches cycles_per_tick. */
	val = accumulated_cycle_count - current_count_register_get() +
40031ef9:	a1 48 85 00 a8       	mov    0xa8008548,%eax
{
40031efe:	55                   	push   %ebp
	val = accumulated_cycle_count - current_count_register_get() +
40031eff:	03 05 88 68 00 a8    	add    0xa8006888,%eax
	return *_REG_TIMER_CCR;
40031f05:	8b 15 90 03 e0 fe    	mov    0xfee00390,%edx
{
40031f0b:	89 e5                	mov    %esp,%ebp
	val = accumulated_cycle_count - current_count_register_get() +
40031f0d:	29 d0                	sub    %edx,%eax
	val = accumulated_cycle_count - current_count_register_get() +
	      initial_count_register_get();
#endif

	return val;
}
40031f0f:	5d                   	pop    %ebp
40031f10:	c3                   	ret    

40031f11 <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
40031f11:	55                   	push   %ebp
40031f12:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
40031f14:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
40031f19:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
40031f1c:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40031f21:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
40031f26:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
40031f2d:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
40031f30:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
40031f33:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
40031f3a:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
40031f3d:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
40031f44:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
40031f47:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
40031f4e:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
40031f51:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
40031f57:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40031f5d:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
40031f60:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
40031f66:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
40031f6c:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40031f72:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40031f75:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
40031f78:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40031f7e:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
40031f81:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
40031f88:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
40031f8b:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
40031f92:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40031f95:	7e 19                	jle    40031fb0 <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
40031f97:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
40031f9e:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
40031fa1:	83 f8 04             	cmp    $0x4,%eax
40031fa4:	74 0a                	je     40031fb0 <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
40031fa6:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
40031fad:	00 01 00 
		| (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF);
#endif

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
40031fb0:	e8 53 77 00 00       	call   40039708 <_lakemont_eoi>
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
#endif

	return 0;
}
40031fb5:	31 c0                	xor    %eax,%eax
40031fb7:	5d                   	pop    %ebp
40031fb8:	c3                   	ret    

40031fb9 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
40031fb9:	55                   	push   %ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40031fba:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40031fbf:	c1 e0 04             	shl    $0x4,%eax
{
40031fc2:	89 e5                	mov    %esp,%ebp
40031fc4:	53                   	push   %ebx
	__asm__ volatile (
40031fc5:	9c                   	pushf  
40031fc6:	fa                   	cli    
40031fc7:	5b                   	pop    %ebx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
40031fc8:	8b 08                	mov    (%eax),%ecx
40031fca:	30 c9                	xor    %cl,%cl
40031fcc:	09 ca                	or     %ecx,%edx
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
40031fce:	0f ba e3 09          	bt     $0x9,%ebx
40031fd2:	89 10                	mov    %edx,(%eax)
40031fd4:	73 01                	jae    40031fd7 <_loapic_int_vec_set+0x1e>
	__asm__ volatile (
40031fd6:	fb                   	sti    
	irq_unlock(oldLevel);
}
40031fd7:	5b                   	pop    %ebx
40031fd8:	5d                   	pop    %ebp
40031fd9:	c3                   	ret    

40031fda <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
40031fda:	55                   	push   %ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40031fdb:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40031fe0:	c1 e0 04             	shl    $0x4,%eax
{
40031fe3:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40031fe5:	9c                   	pushf  
40031fe6:	fa                   	cli    
40031fe7:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
40031fe8:	8b 10                	mov    (%eax),%edx
40031fea:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40031ff0:	0f ba e1 09          	bt     $0x9,%ecx
40031ff4:	89 10                	mov    %edx,(%eax)
40031ff6:	73 01                	jae    40031ff9 <_loapic_irq_enable+0x1f>
	__asm__ volatile (
40031ff8:	fb                   	sti    
	irq_unlock(oldLevel);
}
40031ff9:	5d                   	pop    %ebp
40031ffa:	c3                   	ret    

40031ffb <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
40031ffb:	55                   	push   %ebp
40031ffc:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
40032001:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
40032003:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
40032008:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
4003200a:	85 d2                	test   %edx,%edx
4003200c:	74 11                	je     4003201f <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
4003200e:	0f bd d2             	bsr    %edx,%edx
40032011:	75 05                	jne    40032018 <__irq_controller_isr_vector_get+0x1d>
40032013:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
40032018:	c1 e0 05             	shl    $0x5,%eax
4003201b:	01 d0                	add    %edx,%eax
4003201d:	eb 09                	jmp    40032028 <__irq_controller_isr_vector_get+0x2d>
4003201f:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
40032022:	48                   	dec    %eax
40032023:	75 e3                	jne    40032008 <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
40032025:	83 c8 ff             	or     $0xffffffff,%eax
}
40032028:	5d                   	pop    %ebp
40032029:	c3                   	ret    

4003202a <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
4003202a:	55                   	push   %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
4003202b:	83 fa 3f             	cmp    $0x3f,%edx
{
4003202e:	89 e5                	mov    %esp,%ebp
40032030:	53                   	push   %ebx
40032031:	89 c3                	mov    %eax,%ebx
40032033:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
40032035:	77 09                	ja     40032040 <__irq_controller_irq_config+0x16>
		_ioapic_irq_set(irq, vector, flags);
40032037:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
40032039:	5b                   	pop    %ebx
4003203a:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
4003203b:	e9 a9 00 00 00       	jmp    400320e9 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40032040:	89 da                	mov    %ebx,%edx
40032042:	83 e8 40             	sub    $0x40,%eax
}
40032045:	5b                   	pop    %ebx
40032046:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40032047:	e9 6d ff ff ff       	jmp    40031fb9 <_loapic_int_vec_set>

4003204c <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
4003204c:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
4003204d:	83 f8 3f             	cmp    $0x3f,%eax
{
40032050:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
40032052:	77 06                	ja     4003205a <_arch_irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
40032054:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
40032055:	e9 7f 00 00 00       	jmp    400320d9 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
4003205a:	83 e8 40             	sub    $0x40,%eax
}
4003205d:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
4003205e:	e9 77 ff ff ff       	jmp    40031fda <_loapic_irq_enable>

40032063 <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
40032063:	55                   	push   %ebp
40032064:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40032066:	9c                   	pushf  
40032067:	fa                   	cli    
40032068:	59                   	pop    %ecx
40032069:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
4003206d:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
40032072:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
40032078:	73 01                	jae    4003207b <__IoApicSet+0x18>
	__asm__ volatile (
4003207a:	fb                   	sti    

	irq_unlock(key);
}
4003207b:	5d                   	pop    %ebp
4003207c:	c3                   	ret    

4003207d <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
4003207d:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
4003207e:	01 c0                	add    %eax,%eax
{
40032080:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40032082:	83 c0 10             	add    $0x10,%eax
{
40032085:	56                   	push   %esi
40032086:	53                   	push   %ebx
	__asm__ volatile (
40032087:	9c                   	pushf  
40032088:	fa                   	cli    
40032089:	5e                   	pop    %esi
4003208a:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
4003208e:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
40032093:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
40032099:	73 01                	jae    4003209c <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
4003209b:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
4003209c:	31 da                	xor    %ebx,%edx
4003209e:	21 ca                	and    %ecx,%edx
400320a0:	31 da                	xor    %ebx,%edx
}
400320a2:	5b                   	pop    %ebx
400320a3:	5e                   	pop    %esi
400320a4:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
400320a5:	e9 b9 ff ff ff       	jmp    40032063 <__IoApicSet>

400320aa <_ioapic_init>:
{
400320aa:	55                   	push   %ebp
400320ab:	89 e5                	mov    %esp,%ebp
400320ad:	53                   	push   %ebx
400320ae:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
400320b3:	31 d2                	xor    %edx,%edx
400320b5:	89 d8                	mov    %ebx,%eax
400320b7:	e8 a7 ff ff ff       	call   40032063 <__IoApicSet>
	__IoApicSet(offset, lower32);
400320bc:	8d 43 ff             	lea    -0x1(%ebx),%eax
400320bf:	ba 00 00 01 00       	mov    $0x10000,%edx
400320c4:	83 c3 02             	add    $0x2,%ebx
400320c7:	e8 97 ff ff ff       	call   40032063 <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
400320cc:	81 fb 91 00 00 00    	cmp    $0x91,%ebx
400320d2:	75 df                	jne    400320b3 <_ioapic_init+0x9>
}
400320d4:	31 c0                	xor    %eax,%eax
400320d6:	5b                   	pop    %ebx
400320d7:	5d                   	pop    %ebp
400320d8:	c3                   	ret    

400320d9 <_ioapic_irq_enable>:
{
400320d9:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
400320da:	b9 00 00 01 00       	mov    $0x10000,%ecx
400320df:	31 d2                	xor    %edx,%edx
{
400320e1:	89 e5                	mov    %esp,%ebp
}
400320e3:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
400320e4:	e9 94 ff ff ff       	jmp    4003207d <_IoApicRedUpdateLo>

400320e9 <_ioapic_irq_set>:
{
400320e9:	55                   	push   %ebp
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
400320ea:	81 c9 00 00 01 00    	or     $0x10000,%ecx
{
400320f0:	89 e5                	mov    %esp,%ebp
400320f2:	56                   	push   %esi
400320f3:	53                   	push   %ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
400320f4:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
400320f7:	0f b6 f2             	movzbl %dl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
400320fa:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
400320fd:	31 d2                	xor    %edx,%edx
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
400320ff:	09 ce                	or     %ecx,%esi
	__IoApicSet(offset, upper32);
40032101:	e8 5d ff ff ff       	call   40032063 <__IoApicSet>
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40032106:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
40032109:	89 f2                	mov    %esi,%edx
}
4003210b:	5b                   	pop    %ebx
4003210c:	5e                   	pop    %esi
4003210d:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
4003210e:	e9 50 ff ff ff       	jmp    40032063 <__IoApicSet>

40032113 <spi_qmsi_configure>:
	gpio_pin_write(gpio, config->cs_pin, !active);
}

static int spi_qmsi_configure(struct device *dev,
				struct spi_config *config)
{
40032113:	55                   	push   %ebp
40032114:	89 e5                	mov    %esp,%ebp
40032116:	56                   	push   %esi
40032117:	53                   	push   %ebx
40032118:	51                   	push   %ecx
	struct spi_qmsi_runtime *context = dev->driver_data;
40032119:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_spi_config_t *cfg = &context->cfg;

	cfg->frame_size = SPI_WORD_SIZE_GET(config->config) - 1;
4003211c:	8b 02                	mov    (%edx),%eax
4003211e:	89 c1                	mov    %eax,%ecx
40032120:	c1 e9 04             	shr    $0x4,%ecx
40032123:	0f b6 c9             	movzbl %cl,%ecx
40032126:	49                   	dec    %ecx
40032127:	89 4b 14             	mov    %ecx,0x14(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
4003212a:	89 c1                	mov    %eax,%ecx
4003212c:	83 e1 07             	and    $0x7,%ecx
4003212f:	49                   	dec    %ecx
40032130:	88 4d f7             	mov    %cl,-0x9(%ebp)
40032133:	31 c9                	xor    %ecx,%ecx
40032135:	80 7d f7 02          	cmpb   $0x2,-0x9(%ebp)
40032139:	77 0a                	ja     40032145 <spi_qmsi_configure+0x32>
4003213b:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
4003213f:	8a 89 dc bc 03 40    	mov    0x4003bcdc(%ecx),%cl
	/* As loopback is implemented inside the controller,
	 * the bus mode doesn't matter.
	 */
	context->loopback = SPI_MODE(config->config) & SPI_MODE_LOOP;
40032145:	c1 e8 02             	shr    $0x2,%eax
40032148:	83 e0 01             	and    $0x1,%eax
4003214b:	88 43 2c             	mov    %al,0x2c(%ebx)
	cfg->clk_divider = config->max_sys_freq;
4003214e:	8b 42 04             	mov    0x4(%edx),%eax
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40032151:	0f b6 f1             	movzbl %cl,%esi
	cfg->clk_divider = config->max_sys_freq;
40032154:	66 89 43 24          	mov    %ax,0x24(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40032158:	89 73 1c             	mov    %esi,0x1c(%ebx)

	/* Will set the configuration before the transfer starts */
	return 0;
}
4003215b:	5a                   	pop    %edx
4003215c:	31 c0                	xor    %eax,%eax
4003215e:	5b                   	pop    %ebx
4003215f:	5e                   	pop    %esi
40032160:	5d                   	pop    %ebp
40032161:	c3                   	ret    

40032162 <spi_qmsi_slave_select>:
	context->rc = error;
	k_sem_give(&context->device_sync_sem);
}

static int spi_qmsi_slave_select(struct device *dev, uint32_t slave)
{
40032162:	55                   	push   %ebp
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
	qm_spi_t spi = spi_config->spi;

	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40032163:	8d 4a ff             	lea    -0x1(%edx),%ecx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40032166:	8b 00                	mov    (%eax),%eax
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40032168:	ba 01 00 00 00       	mov    $0x1,%edx
4003216d:	d3 e2                	shl    %cl,%edx
	qm_spi_t spi = spi_config->spi;
4003216f:	8b 40 08             	mov    0x8(%eax),%eax
{
40032172:	89 e5                	mov    %esp,%ebp
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40032174:	8b 00                	mov    (%eax),%eax
40032176:	e8 4e 10 00 00       	call   400331c9 <qm_spi_slave_select>
4003217b:	85 c0                	test   %eax,%eax
4003217d:	74 05                	je     40032184 <spi_qmsi_slave_select+0x22>
4003217f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40032184:	5d                   	pop    %ebp
40032185:	c3                   	ret    

40032186 <spi_qmsi_init>:
#else
#define spi_master_set_power_state(...)
#endif

static int spi_qmsi_init(struct device *dev)
{
40032186:	55                   	push   %ebp
40032187:	89 e5                	mov    %esp,%ebp
40032189:	57                   	push   %edi
4003218a:	56                   	push   %esi
4003218b:	53                   	push   %ebx
4003218c:	83 ec 08             	sub    $0x8,%esp
4003218f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40032192:	8b 00                	mov    (%eax),%eax
40032194:	8b 70 08             	mov    0x8(%eax),%esi
	struct spi_qmsi_runtime *context = dev->driver_data;
40032197:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003219a:	8b 40 08             	mov    0x8(%eax),%eax
4003219d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	switch (spi_config->spi) {
400321a0:	8b 06                	mov    (%esi),%eax
400321a2:	85 c0                	test   %eax,%eax
400321a4:	74 40                	je     400321e6 <spi_qmsi_init+0x60>
400321a6:	48                   	dec    %eax
400321a7:	0f 85 ea 00 00 00    	jne    40032297 <spi_qmsi_init+0x111>
400321ad:	0f b6 05 ab da 03 40 	movzbl 0x4003daab,%eax
400321b4:	b9 00 80 00 00       	mov    $0x8000,%ecx
400321b9:	ba 03 00 00 00       	mov    $0x3,%edx
400321be:	e8 67 fe ff ff       	call   4003202a <__irq_controller_irq_config>
#ifdef CONFIG_SPI_1
	case QM_SPI_MST_1:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT),
			    CONFIG_SPI_1_IRQ_PRI, qm_spi_master_1_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT));
400321c3:	b8 03 00 00 00       	mov    $0x3,%eax
400321c8:	e8 7f fe ff ff       	call   4003204c <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M1_REGISTER);
400321cd:	b8 02 80 00 00       	mov    $0x8002,%eax
400321d2:	e8 90 0a 00 00       	call   40032c67 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
400321d7:	a1 58 04 80 b0       	mov    0xb0800458,%eax
400321dc:	83 e0 fe             	and    $0xfffffffe,%eax
400321df:	a3 58 04 80 b0       	mov    %eax,0xb0800458
				QM_INTERRUPT_ROUTER->spi_master_1_int_mask);
		break;
400321e4:	eb 37                	jmp    4003221d <spi_qmsi_init+0x97>
400321e6:	0f b6 05 aa da 03 40 	movzbl 0x4003daaa,%eax
400321ed:	b9 00 80 00 00       	mov    $0x8000,%ecx
400321f2:	ba 02 00 00 00       	mov    $0x2,%edx
400321f7:	e8 2e fe ff ff       	call   4003202a <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_0_INT));
400321fc:	b8 02 00 00 00       	mov    $0x2,%eax
40032201:	e8 46 fe ff ff       	call   4003204c <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M0_REGISTER);
40032206:	b8 02 40 00 00       	mov    $0x4002,%eax
4003220b:	e8 57 0a 00 00       	call   40032c67 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40032210:	a1 54 04 80 b0       	mov    0xb0800454,%eax
40032215:	83 e0 fe             	and    $0xfffffffe,%eax
40032218:	a3 54 04 80 b0       	mov    %eax,0xb0800454
	if (!config->cs_port)
4003221d:	8b 46 04             	mov    0x4(%esi),%eax
40032220:	85 c0                	test   %eax,%eax
40032222:	75 04                	jne    40032228 <spi_qmsi_init+0xa2>
		return NULL;
40032224:	31 db                	xor    %ebx,%ebx
40032226:	eb 35                	jmp    4003225d <spi_qmsi_init+0xd7>
	gpio = device_get_binding(config->cs_port);
40032228:	e8 d9 78 00 00       	call   40039b06 <device_get_binding>
4003222d:	89 c3                	mov    %eax,%ebx
	if (!gpio)
4003222f:	85 c0                	test   %eax,%eax
40032231:	74 f1                	je     40032224 <spi_qmsi_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40032233:	8b 40 04             	mov    0x4(%eax),%eax
40032236:	31 d2                	xor    %edx,%edx
40032238:	0f b6 4e 08          	movzbl 0x8(%esi),%ecx
4003223c:	89 c7                	mov    %eax,%edi
4003223e:	89 d8                	mov    %ebx,%eax
40032240:	6a 01                	push   $0x1
40032242:	ff 17                	call   *(%edi)
40032244:	59                   	pop    %ecx
	if (gpio_pin_configure(gpio, config->cs_pin, GPIO_DIR_OUT) != 0) {
40032245:	85 c0                	test   %eax,%eax
40032247:	75 db                	jne    40032224 <spi_qmsi_init+0x9e>
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40032249:	8b 4e 08             	mov    0x8(%esi),%ecx
4003224c:	8b 73 04             	mov    0x4(%ebx),%esi
4003224f:	31 d2                	xor    %edx,%edx
40032251:	89 d8                	mov    %ebx,%eax
40032253:	6a 01                	push   $0x1
40032255:	ff 56 04             	call   *0x4(%esi)
40032258:	5a                   	pop    %edx
	if (gpio_pin_write(gpio, config->cs_pin, 1) != 0) {
40032259:	85 c0                	test   %eax,%eax
4003225b:	75 c7                	jne    40032224 <spi_qmsi_init+0x9e>

	default:
		return -EIO;
	}

	context->gpio_cs = gpio_cs_init(spi_config);
4003225d:	8b 45 f0             	mov    -0x10(%ebp),%eax

	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40032260:	83 c9 ff             	or     $0xffffffff,%ecx
40032263:	83 c0 04             	add    $0x4,%eax
40032266:	31 d2                	xor    %edx,%edx
	context->gpio_cs = gpio_cs_init(spi_config);
40032268:	89 58 fc             	mov    %ebx,-0x4(%eax)
	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
4003226b:	e8 7d 7d 00 00       	call   40039fed <k_sem_init>
	k_sem_init(&context->sem, 0, UINT_MAX);
40032270:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032273:	8d 58 30             	lea    0x30(%eax),%ebx
40032276:	83 c9 ff             	or     $0xffffffff,%ecx
40032279:	31 d2                	xor    %edx,%edx
4003227b:	89 d8                	mov    %ebx,%eax
4003227d:	e8 6b 7d 00 00       	call   40039fed <k_sem_init>
	k_sem_give(&context->sem);
40032282:	89 d8                	mov    %ebx,%eax
40032284:	e8 74 7d 00 00       	call   40039ffd <k_sem_give>

	spi_master_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	dev->driver_api = &spi_qmsi_api;
40032289:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003228c:	c7 40 04 f8 bc 03 40 	movl   $0x4003bcf8,0x4(%eax)
	return 0;
40032293:	31 c0                	xor    %eax,%eax
40032295:	eb 05                	jmp    4003229c <spi_qmsi_init+0x116>
		return -EIO;
40032297:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
4003229c:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003229f:	5b                   	pop    %ebx
400322a0:	5e                   	pop    %esi
400322a1:	5f                   	pop    %edi
400322a2:	5d                   	pop    %ebp
400322a3:	c3                   	ret    

400322a4 <spi_control_cs>:
{
400322a4:	55                   	push   %ebp
400322a5:	89 e5                	mov    %esp,%ebp
400322a7:	56                   	push   %esi
400322a8:	53                   	push   %ebx
	struct device *gpio = context->gpio_cs;
400322a9:	8b 48 08             	mov    0x8(%eax),%ecx
400322ac:	8b 31                	mov    (%ecx),%esi
	if (!gpio)
400322ae:	85 f6                	test   %esi,%esi
400322b0:	74 1a                	je     400322cc <spi_control_cs+0x28>
	const struct spi_qmsi_config *config = dev->config->config_info;
400322b2:	8b 00                	mov    (%eax),%eax
	gpio_pin_write(gpio, config->cs_pin, !active);
400322b4:	83 f2 01             	xor    $0x1,%edx
400322b7:	8b 5e 04             	mov    0x4(%esi),%ebx
400322ba:	8b 40 08             	mov    0x8(%eax),%eax
400322bd:	0f b6 d2             	movzbl %dl,%edx
400322c0:	8b 48 08             	mov    0x8(%eax),%ecx
400322c3:	52                   	push   %edx
400322c4:	89 f0                	mov    %esi,%eax
400322c6:	31 d2                	xor    %edx,%edx
400322c8:	ff 53 04             	call   *0x4(%ebx)
400322cb:	58                   	pop    %eax
}
400322cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
400322cf:	5b                   	pop    %ebx
400322d0:	5e                   	pop    %esi
400322d1:	5d                   	pop    %ebp
400322d2:	c3                   	ret    

400322d3 <transfer_complete>:
{
400322d3:	55                   	push   %ebp
400322d4:	89 e5                	mov    %esp,%ebp
400322d6:	57                   	push   %edi
400322d7:	56                   	push   %esi
400322d8:	53                   	push   %ebx
	const struct spi_qmsi_config *spi_config =
400322d9:	8b 00                	mov    (%eax),%eax
	qm_spi_t spi = spi_config->spi;
400322db:	8b 40 08             	mov    0x8(%eax),%eax
	struct device *dev = pending->dev;
400322de:	6b 38 1c             	imul   $0x1c,(%eax),%edi
400322e1:	8b 87 20 69 00 a8    	mov    -0x57ff96e0(%edi),%eax
	if (!dev)
400322e7:	85 c0                	test   %eax,%eax
400322e9:	74 25                	je     40032310 <transfer_complete+0x3d>
400322eb:	89 d6                	mov    %edx,%esi
	spi_control_cs(dev, false);
400322ed:	31 d2                	xor    %edx,%edx
	context = dev->driver_data;
400322ef:	8b 58 08             	mov    0x8(%eax),%ebx
	spi_control_cs(dev, false);
400322f2:	e8 ad ff ff ff       	call   400322a4 <spi_control_cs>
	pending->dev = NULL;
400322f7:	c7 87 20 69 00 a8 00 	movl   $0x0,-0x57ff96e0(%edi)
400322fe:	00 00 00 
	k_sem_give(&context->device_sync_sem);
40032301:	8d 43 04             	lea    0x4(%ebx),%eax
	context->rc = error;
40032304:	89 73 28             	mov    %esi,0x28(%ebx)
}
40032307:	5b                   	pop    %ebx
40032308:	5e                   	pop    %esi
40032309:	5f                   	pop    %edi
4003230a:	5d                   	pop    %ebp
	k_sem_give(&context->device_sync_sem);
4003230b:	e9 ed 7c 00 00       	jmp    40039ffd <k_sem_give>
}
40032310:	5b                   	pop    %ebx
40032311:	5e                   	pop    %esi
40032312:	5f                   	pop    %edi
40032313:	5d                   	pop    %ebp
40032314:	c3                   	ret    

40032315 <spi_qmsi_transceive>:
{
40032315:	55                   	push   %ebp
40032316:	89 e5                	mov    %esp,%ebp
40032318:	57                   	push   %edi
40032319:	56                   	push   %esi
4003231a:	53                   	push   %ebx
4003231b:	83 ec 14             	sub    $0x14,%esp
4003231e:	89 c3                	mov    %eax,%ebx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40032320:	8b 00                	mov    (%eax),%eax
{
40032322:	89 55 e0             	mov    %edx,-0x20(%ebp)
	struct spi_qmsi_runtime *context = dev->driver_data;
40032325:	8b 73 08             	mov    0x8(%ebx),%esi
{
40032328:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	qm_spi_t spi = spi_config->spi;
4003232b:	8b 40 08             	mov    0x8(%eax),%eax
4003232e:	8b 00                	mov    (%eax),%eax
40032330:	89 45 f0             	mov    %eax,-0x10(%ebp)
	qm_spi_config_t *cfg = &context->cfg;
40032333:	8d 46 14             	lea    0x14(%esi),%eax
40032336:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8_t dfs = frame_size_to_dfs(cfg->frame_size);
40032339:	8b 46 14             	mov    0x14(%esi),%eax
		return 1;
4003233c:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_8_BIT)
40032340:	83 f8 07             	cmp    $0x7,%eax
40032343:	76 15                	jbe    4003235a <spi_qmsi_transceive+0x45>
		return 2;
40032345:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_16_BIT)
40032349:	83 f8 0f             	cmp    $0xf,%eax
4003234c:	76 0c                	jbe    4003235a <spi_qmsi_transceive+0x45>
	return 0;
4003234e:	83 f8 20             	cmp    $0x20,%eax
40032351:	0f 92 c0             	setb   %al
40032354:	c1 e0 02             	shl    $0x2,%eax
40032357:	88 45 ec             	mov    %al,-0x14(%ebp)
	k_sem_take(&context->sem, K_FOREVER);
4003235a:	8d 4e 30             	lea    0x30(%esi),%ecx
4003235d:	83 ca ff             	or     $0xffffffff,%edx
40032360:	89 c8                	mov    %ecx,%eax
40032362:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40032365:	e8 08 7d 00 00       	call   4003a072 <k_sem_take>
	if (pending_transfers[spi].dev) {
4003236a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4003236d:	6b 55 f0 1c          	imul   $0x1c,-0x10(%ebp),%edx
40032371:	8d ba 20 69 00 a8    	lea    -0x57ff96e0(%edx),%edi
40032377:	83 ba 20 69 00 a8 00 	cmpl   $0x0,-0x57ff96e0(%edx)
4003237e:	74 11                	je     40032391 <spi_qmsi_transceive+0x7c>
		k_sem_give(&context->sem);
40032380:	89 c8                	mov    %ecx,%eax
40032382:	e8 76 7c 00 00       	call   40039ffd <k_sem_give>
		return -EBUSY;
40032387:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
4003238c:	e9 ed 00 00 00       	jmp    4003247e <spi_qmsi_transceive+0x169>
	k_sem_give(&context->sem);
40032391:	89 c8                	mov    %ecx,%eax
	pending_transfers[spi].dev = dev;
40032393:	89 9a 20 69 00 a8    	mov    %ebx,-0x57ff96e0(%edx)
40032399:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_sem_give(&context->sem);
4003239c:	e8 5c 7c 00 00       	call   40039ffd <k_sem_give>
	device_busy_set(dev);
400323a1:	89 d8                	mov    %ebx,%eax
400323a3:	e8 96 77 00 00       	call   40039b3e <device_busy_set>
	xfer = &pending_transfers[spi].xfer;
400323a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400323ab:	8d 82 24 69 00 a8    	lea    -0x57ff96dc(%edx),%eax
	xfer->rx_len = rx_buf_len / dfs;
400323b1:	31 d2                	xor    %edx,%edx
400323b3:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
	xfer = &pending_transfers[spi].xfer;
400323b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	xfer->rx = rx_buf;
400323ba:	8b 45 08             	mov    0x8(%ebp),%eax
400323bd:	89 47 08             	mov    %eax,0x8(%edi)
	xfer->rx_len = rx_buf_len / dfs;
400323c0:	8b 45 0c             	mov    0xc(%ebp),%eax
400323c3:	f7 f1                	div    %ecx
400323c5:	66 89 47 0e          	mov    %ax,0xe(%edi)
	xfer->tx = (uint8_t *)tx_buf;
400323c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
	xfer->tx_len = tx_buf_len / dfs;
400323cc:	31 d2                	xor    %edx,%edx
	xfer->tx = (uint8_t *)tx_buf;
400323ce:	89 47 04             	mov    %eax,0x4(%edi)
	xfer->tx_len = tx_buf_len / dfs;
400323d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
	xfer->callback_data = dev;
400323d4:	89 5f 18             	mov    %ebx,0x18(%edi)
	xfer->tx_len = tx_buf_len / dfs;
400323d7:	f7 f1                	div    %ecx
400323d9:	66 89 47 0c          	mov    %ax,0xc(%edi)
	xfer->callback = transfer_complete;
400323dd:	c7 47 14 d3 22 03 40 	movl   $0x400322d3,0x14(%edi)
	if (tx_buf_len == 0)
400323e4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
400323e8:	75 09                	jne    400323f3 <spi_qmsi_transceive+0xde>
		cfg->transfer_mode = QM_SPI_TMOD_RX;
400323ea:	c7 46 18 02 00 00 00 	movl   $0x2,0x18(%esi)
400323f1:	eb 0c                	jmp    400323ff <spi_qmsi_transceive+0xea>
		cfg->transfer_mode = QM_SPI_TMOD_TX;
400323f3:	31 c0                	xor    %eax,%eax
400323f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
400323f9:	0f 94 c0             	sete   %al
400323fc:	89 46 18             	mov    %eax,0x18(%esi)
	if (context->loopback)
400323ff:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
40032403:	74 11                	je     40032416 <spi_qmsi_transceive+0x101>
		QM_SPI[spi]->ctrlr0 |= BIT(11);
40032405:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032408:	8b 14 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%edx
4003240f:	8b 02                	mov    (%edx),%eax
40032411:	80 cc 08             	or     $0x8,%ah
40032414:	89 02                	mov    %eax,(%edx)
	rc = qm_spi_set_config(spi, cfg);
40032416:	8d 56 14             	lea    0x14(%esi),%edx
40032419:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003241c:	e8 3b 0d 00 00       	call   4003315c <qm_spi_set_config>
	if (rc != 0) {
40032421:	85 c0                	test   %eax,%eax
40032423:	74 0e                	je     40032433 <spi_qmsi_transceive+0x11e>
		device_busy_clear(dev);
40032425:	89 d8                	mov    %ebx,%eax
40032427:	e8 17 77 00 00       	call   40039b43 <device_busy_clear>
		return -EINVAL;
4003242c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
40032431:	eb 4b                	jmp    4003247e <spi_qmsi_transceive+0x169>
	spi_control_cs(dev, true);
40032433:	ba 01 00 00 00       	mov    $0x1,%edx
40032438:	89 d8                	mov    %ebx,%eax
4003243a:	e8 65 fe ff ff       	call   400322a4 <spi_control_cs>
	rc = qm_spi_irq_transfer(spi, xfer);
4003243f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40032442:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032445:	e8 01 0e 00 00       	call   4003324b <qm_spi_irq_transfer>
	if (rc != 0) {
4003244a:	85 c0                	test   %eax,%eax
4003244c:	74 12                	je     40032460 <spi_qmsi_transceive+0x14b>
		spi_control_cs(dev, false);
4003244e:	89 d8                	mov    %ebx,%eax
40032450:	31 d2                	xor    %edx,%edx
40032452:	e8 4d fe ff ff       	call   400322a4 <spi_control_cs>
		device_busy_clear(dev);
40032457:	89 d8                	mov    %ebx,%eax
40032459:	e8 e5 76 00 00       	call   40039b43 <device_busy_clear>
4003245e:	eb 19                	jmp    40032479 <spi_qmsi_transceive+0x164>
	k_sem_take(&context->device_sync_sem, K_FOREVER);
40032460:	83 ca ff             	or     $0xffffffff,%edx
40032463:	8d 46 04             	lea    0x4(%esi),%eax
40032466:	e8 07 7c 00 00       	call   4003a072 <k_sem_take>
	device_busy_clear(dev);
4003246b:	89 d8                	mov    %ebx,%eax
4003246d:	e8 d1 76 00 00       	call   40039b43 <device_busy_clear>
	return context->rc ? -EIO : 0;
40032472:	8b 46 28             	mov    0x28(%esi),%eax
40032475:	85 c0                	test   %eax,%eax
40032477:	74 05                	je     4003247e <spi_qmsi_transceive+0x169>
40032479:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
4003247e:	83 c4 14             	add    $0x14,%esp
40032481:	5b                   	pop    %ebx
40032482:	5e                   	pop    %esi
40032483:	5f                   	pop    %edi
40032484:	5d                   	pop    %ebp
40032485:	c3                   	ret    

40032486 <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
40032486:	55                   	push   %ebp
40032487:	89 e5                	mov    %esp,%ebp
40032489:	57                   	push   %edi
4003248a:	56                   	push   %esi
4003248b:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
4003248c:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
4003248f:	89 d6                	mov    %edx,%esi
40032491:	23 71 08             	and    0x8(%ecx),%esi
40032494:	74 1c                	je     400324b2 <gpio_qmsi_callback+0x2c>
40032496:	8b 19                	mov    (%ecx),%ebx
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
40032498:	85 db                	test   %ebx,%ebx
4003249a:	74 16                	je     400324b2 <gpio_qmsi_callback+0x2c>
4003249c:	89 c7                	mov    %eax,%edi
		if (cb->pin_mask & pins) {
4003249e:	85 73 08             	test   %esi,0x8(%ebx)
400324a1:	74 09                	je     400324ac <gpio_qmsi_callback+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
400324a3:	89 f1                	mov    %esi,%ecx
400324a5:	89 da                	mov    %ebx,%edx
400324a7:	89 f8                	mov    %edi,%eax
400324a9:	ff 53 04             	call   *0x4(%ebx)
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
400324ac:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
400324ae:	85 db                	test   %ebx,%ebx
400324b0:	75 ec                	jne    4003249e <gpio_qmsi_callback+0x18>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
400324b2:	5b                   	pop    %ebx
400324b3:	5e                   	pop    %esi
400324b4:	5f                   	pop    %edi
400324b5:	5d                   	pop    %ebp
400324b6:	c3                   	ret    

400324b7 <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
400324b7:	55                   	push   %ebp
	if (value) {
400324b8:	84 c9                	test   %cl,%cl
{
400324ba:	89 e5                	mov    %esp,%ebp
400324bc:	0f b6 d2             	movzbl %dl,%edx
	if (value) {
400324bf:	74 05                	je     400324c6 <qmsi_write_bit+0xf>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
400324c1:	0f ab 10             	bts    %edx,(%eax)
400324c4:	eb 03                	jmp    400324c9 <qmsi_write_bit+0x12>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
400324c6:	0f b3 10             	btr    %edx,(%eax)
		sys_set_bit((uintptr_t) target, bit);
	} else {
		sys_clear_bit((uintptr_t) target, bit);
	}
}
400324c9:	5d                   	pop    %ebp
400324ca:	c3                   	ret    

400324cb <gpio_qmsi_manage_callback>:

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
400324cb:	8b 40 08             	mov    0x8(%eax),%eax
	if (set) {
400324ce:	84 c9                	test   %cl,%cl
400324d0:	74 11                	je     400324e3 <gpio_qmsi_manage_callback+0x18>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
400324d2:	8b 08                	mov    (%eax),%ecx
400324d4:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
400324d6:	89 10                	mov    %edx,(%eax)

	if (!list->tail) {
400324d8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
400324dc:	75 44                	jne    40032522 <gpio_qmsi_manage_callback+0x57>
		list->tail = list->head;
400324de:	89 50 04             	mov    %edx,0x4(%eax)
400324e1:	eb 3f                	jmp    40032522 <gpio_qmsi_manage_callback+0x57>
{
400324e3:	55                   	push   %ebp
400324e4:	89 e5                	mov    %esp,%ebp
400324e6:	53                   	push   %ebx
400324e7:	8b 08                	mov    (%eax),%ecx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
400324e9:	31 db                	xor    %ebx,%ebx
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
400324eb:	85 c9                	test   %ecx,%ecx
400324ed:	74 2e                	je     4003251d <gpio_qmsi_manage_callback+0x52>
		if (test == node) {
400324ef:	39 ca                	cmp    %ecx,%edx
400324f1:	75 24                	jne    40032517 <gpio_qmsi_manage_callback+0x4c>
	if (!prev_node) {
400324f3:	85 db                	test   %ebx,%ebx
400324f5:	8b 0a                	mov    (%edx),%ecx
400324f7:	75 0c                	jne    40032505 <gpio_qmsi_manage_callback+0x3a>
		list->head = node->next;
400324f9:	89 08                	mov    %ecx,(%eax)
		if (list->tail == node) {
400324fb:	3b 50 04             	cmp    0x4(%eax),%edx
400324fe:	75 0f                	jne    4003250f <gpio_qmsi_manage_callback+0x44>
			list->tail = list->head;
40032500:	89 48 04             	mov    %ecx,0x4(%eax)
40032503:	eb 0a                	jmp    4003250f <gpio_qmsi_manage_callback+0x44>
		prev_node->next = node->next;
40032505:	89 0b                	mov    %ecx,(%ebx)
		if (list->tail == node) {
40032507:	3b 50 04             	cmp    0x4(%eax),%edx
4003250a:	75 03                	jne    4003250f <gpio_qmsi_manage_callback+0x44>
			list->tail = prev_node;
4003250c:	89 58 04             	mov    %ebx,0x4(%eax)
	node->next = NULL;
4003250f:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
40032515:	eb 06                	jmp    4003251d <gpio_qmsi_manage_callback+0x52>
	SYS_SLIST_FOR_EACH_NODE(list, test) {
40032517:	89 cb                	mov    %ecx,%ebx
40032519:	8b 09                	mov    (%ecx),%ecx
4003251b:	eb ce                	jmp    400324eb <gpio_qmsi_manage_callback+0x20>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
4003251d:	31 c0                	xor    %eax,%eax
4003251f:	5b                   	pop    %ebx
40032520:	5d                   	pop    %ebp
40032521:	c3                   	ret    
40032522:	31 c0                	xor    %eax,%eax
40032524:	c3                   	ret    

40032525 <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
40032525:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40032526:	85 d2                	test   %edx,%edx
{
40032528:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
4003252a:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
4003252d:	75 0c                	jne    4003253b <gpio_qmsi_enable_callback+0x16>
		context->pin_callbacks |= BIT(pin);
4003252f:	ba 01 00 00 00       	mov    $0x1,%edx
40032534:	d3 e2                	shl    %cl,%edx
40032536:	09 50 08             	or     %edx,0x8(%eax)
40032539:	eb 07                	jmp    40032542 <gpio_qmsi_enable_callback+0x1d>
	} else {
		context->pin_callbacks = 0xffffffff;
4003253b:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
40032542:	31 c0                	xor    %eax,%eax
40032544:	5d                   	pop    %ebp
40032545:	c3                   	ret    

40032546 <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
40032546:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40032547:	85 d2                	test   %edx,%edx
{
40032549:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
4003254b:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
4003254e:	75 0c                	jne    4003255c <gpio_qmsi_disable_callback+0x16>
		context->pin_callbacks &= ~BIT(pin);
40032550:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
40032555:	d3 c2                	rol    %cl,%edx
40032557:	21 50 08             	and    %edx,0x8(%eax)
4003255a:	eb 07                	jmp    40032563 <gpio_qmsi_disable_callback+0x1d>
	} else {
		context->pin_callbacks = 0;
4003255c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
40032563:	31 c0                	xor    %eax,%eax
40032565:	5d                   	pop    %ebp
40032566:	c3                   	ret    

40032567 <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
40032567:	55                   	push   %ebp
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
40032568:	8b 00                	mov    (%eax),%eax
{
4003256a:	89 e5                	mov    %esp,%ebp
	qm_gpio_t gpio = gpio_config->gpio;

	return QM_GPIO[gpio]->gpio_intstatus;
}
4003256c:	5d                   	pop    %ebp
	qm_gpio_t gpio = gpio_config->gpio;
4003256d:	8b 40 08             	mov    0x8(%eax),%eax
	return QM_GPIO[gpio]->gpio_intstatus;
40032570:	8b 00                	mov    (%eax),%eax
40032572:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
40032579:	8b 40 40             	mov    0x40(%eax),%eax
}
4003257c:	c3                   	ret    

4003257d <gpio_qmsi_read>:
{
4003257d:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
4003257e:	85 d2                	test   %edx,%edx
{
40032580:	89 e5                	mov    %esp,%ebp
40032582:	53                   	push   %ebx
40032583:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40032584:	8b 00                	mov    (%eax),%eax
{
40032586:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40032589:	8b 40 08             	mov    0x8(%eax),%eax
4003258c:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
4003258e:	75 12                	jne    400325a2 <gpio_qmsi_read+0x25>
		qm_gpio_read_pin(gpio, pin, &state);
40032590:	0f b6 d1             	movzbl %cl,%edx
40032593:	8d 4d f8             	lea    -0x8(%ebp),%ecx
40032596:	e8 90 07 00 00       	call   40032d2b <qm_gpio_read_pin>
		*value = state;
4003259b:	8b 45 f8             	mov    -0x8(%ebp),%eax
4003259e:	89 03                	mov    %eax,(%ebx)
400325a0:	eb 07                	jmp    400325a9 <gpio_qmsi_read+0x2c>
		qm_gpio_read_port(gpio, (uint32_t *const) value);
400325a2:	89 da                	mov    %ebx,%edx
400325a4:	e8 e2 07 00 00       	call   40032d8b <qm_gpio_read_port>
}
400325a9:	5a                   	pop    %edx
400325aa:	31 c0                	xor    %eax,%eax
400325ac:	5b                   	pop    %ebx
400325ad:	5d                   	pop    %ebp
400325ae:	c3                   	ret    

400325af <gpio_qmsi_write>:
{
400325af:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
400325b0:	85 d2                	test   %edx,%edx
{
400325b2:	89 e5                	mov    %esp,%ebp
400325b4:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400325b5:	8b 00                	mov    (%eax),%eax
{
400325b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
400325ba:	8b 40 08             	mov    0x8(%eax),%eax
400325bd:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
400325bf:	75 15                	jne    400325d6 <gpio_qmsi_write+0x27>
		if (value) {
400325c1:	85 db                	test   %ebx,%ebx
400325c3:	0f b6 d1             	movzbl %cl,%edx
400325c6:	74 07                	je     400325cf <gpio_qmsi_write+0x20>
			qm_gpio_set_pin(gpio, pin);
400325c8:	e8 7c 07 00 00       	call   40032d49 <qm_gpio_set_pin>
400325cd:	eb 0e                	jmp    400325dd <gpio_qmsi_write+0x2e>
			qm_gpio_clear_pin(gpio, pin);
400325cf:	e8 96 07 00 00       	call   40032d6a <qm_gpio_clear_pin>
400325d4:	eb 07                	jmp    400325dd <gpio_qmsi_write+0x2e>
		qm_gpio_write_port(gpio, value);
400325d6:	89 da                	mov    %ebx,%edx
400325d8:	e8 c1 07 00 00       	call   40032d9e <qm_gpio_write_port>
}
400325dd:	31 c0                	xor    %eax,%eax
400325df:	5b                   	pop    %ebx
400325e0:	5d                   	pop    %ebp
400325e1:	c3                   	ret    

400325e2 <qmsi_pin_config>:
{
400325e2:	55                   	push   %ebp
400325e3:	89 e5                	mov    %esp,%ebp
400325e5:	57                   	push   %edi
400325e6:	56                   	push   %esi
400325e7:	53                   	push   %ebx
400325e8:	83 ec 24             	sub    $0x24,%esp
400325eb:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400325ed:	8b 00                	mov    (%eax),%eax
{
400325ef:	89 ce                	mov    %ecx,%esi
	qm_gpio_port_config_t cfg = { 0 };
400325f1:	8d 7d d4             	lea    -0x2c(%ebp),%edi
400325f4:	b9 08 00 00 00       	mov    $0x8,%ecx
	qm_gpio_t gpio = gpio_config->gpio;
400325f9:	8b 40 08             	mov    0x8(%eax),%eax
400325fc:	8b 00                	mov    (%eax),%eax
400325fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
	qm_gpio_port_config_t cfg = { 0 };
40032601:	31 c0                	xor    %eax,%eax
40032603:	f3 ab                	rep stos %eax,%es:(%edi)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40032605:	8b 45 d0             	mov    -0x30(%ebp),%eax
40032608:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
4003260f:	8b 48 04             	mov    0x4(%eax),%ecx
	cfg.callback_data = port;
40032612:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40032615:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
40032618:	8b 48 30             	mov    0x30(%eax),%ecx
4003261b:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
4003261e:	8b 48 38             	mov    0x38(%eax),%ecx
40032621:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
40032624:	8b 48 3c             	mov    0x3c(%eax),%ecx
40032627:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
4003262a:	8b 48 48             	mov    0x48(%eax),%ecx
4003262d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40032630:	8b 40 68             	mov    0x68(%eax),%eax
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40032633:	0f b6 da             	movzbl %dl,%ebx
40032636:	89 f1                	mov    %esi,%ecx
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40032638:	89 45 e8             	mov    %eax,-0x18(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
4003263b:	83 e1 01             	and    $0x1,%ecx
4003263e:	89 da                	mov    %ebx,%edx
40032640:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	cfg.callback = gpio_qmsi_callback;
40032643:	c7 45 ec 86 24 03 40 	movl   $0x40032486,-0x14(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
4003264a:	e8 68 fe ff ff       	call   400324b7 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 0);
4003264f:	31 c9                	xor    %ecx,%ecx
	if (flags & GPIO_INT) {
40032651:	f7 c6 02 00 00 00    	test   $0x2,%esi
40032657:	74 41                	je     4003269a <qmsi_pin_config+0xb8>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
40032659:	89 f1                	mov    %esi,%ecx
4003265b:	89 da                	mov    %ebx,%edx
4003265d:	83 e1 20             	and    $0x20,%ecx
40032660:	8d 45 dc             	lea    -0x24(%ebp),%eax
40032663:	e8 4f fe ff ff       	call   400324b7 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
40032668:	89 f1                	mov    %esi,%ecx
4003266a:	83 e1 04             	and    $0x4,%ecx
4003266d:	89 da                	mov    %ebx,%edx
4003266f:	8d 45 e0             	lea    -0x20(%ebp),%eax
40032672:	e8 40 fe ff ff       	call   400324b7 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_debounce, pin,
40032677:	89 f1                	mov    %esi,%ecx
40032679:	83 e1 10             	and    $0x10,%ecx
4003267c:	89 da                	mov    %ebx,%edx
4003267e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		qmsi_write_bit(&cfg.int_bothedge, pin,
40032681:	83 e6 40             	and    $0x40,%esi
		qmsi_write_bit(&cfg.int_debounce, pin,
40032684:	e8 2e fe ff ff       	call   400324b7 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_bothedge, pin,
40032689:	89 f1                	mov    %esi,%ecx
4003268b:	89 da                	mov    %ebx,%edx
4003268d:	8d 45 e8             	lea    -0x18(%ebp),%eax
40032690:	e8 22 fe ff ff       	call   400324b7 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 1);
40032695:	b9 01 00 00 00       	mov    $0x1,%ecx
		qmsi_write_bit(&cfg.int_en, pin, 0);
4003269a:	89 da                	mov    %ebx,%edx
4003269c:	8d 45 d8             	lea    -0x28(%ebp),%eax
4003269f:	e8 13 fe ff ff       	call   400324b7 <qmsi_write_bit>
	qm_gpio_set_config(gpio, &cfg);
400326a4:	8d 55 d4             	lea    -0x2c(%ebp),%edx
400326a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
400326aa:	e8 1d 06 00 00       	call   40032ccc <qm_gpio_set_config>
}
400326af:	83 c4 24             	add    $0x24,%esp
400326b2:	5b                   	pop    %ebx
400326b3:	5e                   	pop    %esi
400326b4:	5f                   	pop    %edi
400326b5:	5d                   	pop    %ebp
400326b6:	c3                   	ret    

400326b7 <gpio_qmsi_config>:
{
400326b7:	55                   	push   %ebp
400326b8:	89 e5                	mov    %esp,%ebp
400326ba:	57                   	push   %edi
400326bb:	56                   	push   %esi
400326bc:	89 c6                	mov    %eax,%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400326be:	8b 45 08             	mov    0x8(%ebp),%eax
{
400326c1:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400326c2:	83 e0 03             	and    $0x3,%eax
		return -EINVAL;
400326c5:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400326ca:	83 f8 03             	cmp    $0x3,%eax
400326cd:	74 34                	je     40032703 <gpio_qmsi_config+0x4c>
400326cf:	89 d3                	mov    %edx,%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
400326d1:	85 d2                	test   %edx,%edx
400326d3:	75 0e                	jne    400326e3 <gpio_qmsi_config+0x2c>
400326d5:	89 ca                	mov    %ecx,%edx
		qmsi_pin_config(port, pin, flags);
400326d7:	89 f0                	mov    %esi,%eax
400326d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
400326dc:	e8 01 ff ff ff       	call   400325e2 <qmsi_pin_config>
400326e1:	eb 20                	jmp    40032703 <gpio_qmsi_config+0x4c>
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400326e3:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < num_pins; i++) {
400326e5:	31 db                	xor    %ebx,%ebx
	uint8_t num_pins = gpio_config->num_pins;
400326e7:	8b 40 08             	mov    0x8(%eax),%eax
	for (i = 0; i < num_pins; i++) {
400326ea:	0f b6 78 04          	movzbl 0x4(%eax),%edi
400326ee:	39 fb                	cmp    %edi,%ebx
400326f0:	7d 0f                	jge    40032701 <gpio_qmsi_config+0x4a>
		qmsi_pin_config(port, i, flags);
400326f2:	89 da                	mov    %ebx,%edx
400326f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
400326f7:	89 f0                	mov    %esi,%eax
	for (i = 0; i < num_pins; i++) {
400326f9:	43                   	inc    %ebx
		qmsi_pin_config(port, i, flags);
400326fa:	e8 e3 fe ff ff       	call   400325e2 <qmsi_pin_config>
400326ff:	eb ed                	jmp    400326ee <gpio_qmsi_config+0x37>
	return 0;
40032701:	31 db                	xor    %ebx,%ebx
}
40032703:	89 d8                	mov    %ebx,%eax
40032705:	5b                   	pop    %ebx
40032706:	5e                   	pop    %esi
40032707:	5f                   	pop    %edi
40032708:	5d                   	pop    %ebp
40032709:	c3                   	ret    

4003270a <gpio_qmsi_init>:
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
4003270a:	55                   	push   %ebp
4003270b:	89 e5                	mov    %esp,%ebp
4003270d:	53                   	push   %ebx
4003270e:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40032710:	8b 00                	mov    (%eax),%eax
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
40032712:	8b 40 08             	mov    0x8(%eax),%eax
40032715:	8b 00                	mov    (%eax),%eax
40032717:	85 c0                	test   %eax,%eax
40032719:	74 32                	je     4003274d <gpio_qmsi_init+0x43>
4003271b:	48                   	dec    %eax
4003271c:	75 71                	jne    4003278f <gpio_qmsi_init+0x85>
4003271e:	0f b6 05 c7 da 03 40 	movzbl 0x4003dac7,%eax
40032725:	b9 00 80 00 00       	mov    $0x8000,%ecx
4003272a:	ba 1f 00 00 00       	mov    $0x1f,%edx
4003272f:	e8 f6 f8 ff ff       	call   4003202a <__irq_controller_irq_config>
#ifdef CONFIG_GPIO_QMSI_1
	case QM_AON_GPIO_0:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_1_IRQ_PRI, qm_aon_gpio_0_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT));
40032734:	b8 1f 00 00 00       	mov    $0x1f,%eax
40032739:	e8 0e f9 ff ff       	call   4003204c <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
4003273e:	a1 d4 04 80 b0       	mov    0xb08004d4,%eax
40032743:	83 e0 fe             	and    $0xfffffffe,%eax
40032746:	a3 d4 04 80 b0       	mov    %eax,0xb08004d4
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
4003274b:	eb 37                	jmp    40032784 <gpio_qmsi_init+0x7a>
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
4003274d:	b8 82 21 00 00       	mov    $0x2182,%eax
40032752:	e8 10 05 00 00       	call   40032c67 <clk_periph_enable>
40032757:	0f b6 05 b0 da 03 40 	movzbl 0x4003dab0,%eax
4003275e:	b9 00 80 00 00       	mov    $0x8000,%ecx
40032763:	ba 08 00 00 00       	mov    $0x8,%edx
40032768:	e8 bd f8 ff ff       	call   4003202a <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
4003276d:	b8 08 00 00 00       	mov    $0x8,%eax
40032772:	e8 d5 f8 ff ff       	call   4003204c <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
40032777:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
4003277c:	83 e0 fe             	and    $0xfffffffe,%eax
4003277f:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
40032784:	c7 43 04 04 bd 03 40 	movl   $0x4003bd04,0x4(%ebx)
	return 0;
4003278b:	31 c0                	xor    %eax,%eax
4003278d:	eb 05                	jmp    40032794 <gpio_qmsi_init+0x8a>
		return -EIO;
4003278f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40032794:	5b                   	pop    %ebx
40032795:	5d                   	pop    %ebp
40032796:	c3                   	ret    

40032797 <pinmux_get>:
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
40032797:	89 d0                	mov    %edx,%eax
{
40032799:	55                   	push   %ebp
	uint32_t reg_offset = pin >> 4;
4003279a:	c1 e8 04             	shr    $0x4,%eax
{
4003279d:	89 e5                	mov    %esp,%ebp
4003279f:	53                   	push   %ebx
400327a0:	89 cb                	mov    %ecx,%ebx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400327a2:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
	uint32_t mode_mask = *mux_register & pin_mask;
400327a5:	8b 14 85 30 09 80 b0 	mov    -0x4f7ff6d0(,%eax,4),%edx
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400327ac:	83 e1 1e             	and    $0x1e,%ecx
400327af:	b8 03 00 00 00       	mov    $0x3,%eax
400327b4:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
400327b6:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
400327b8:	d3 e8                	shr    %cl,%eax
400327ba:	89 03                	mov    %eax,(%ebx)

	*func = mode;

	return 0;
}
400327bc:	31 c0                	xor    %eax,%eax
400327be:	5b                   	pop    %ebx
400327bf:	5d                   	pop    %ebp
400327c0:	c3                   	ret    

400327c1 <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(struct device *port)
{
400327c1:	55                   	push   %ebp
	return 0;
}
400327c2:	31 c0                	xor    %eax,%eax
{
400327c4:	89 e5                	mov    %esp,%ebp
}
400327c6:	5d                   	pop    %ebp
400327c7:	c3                   	ret    

400327c8 <pinmux_input>:
{
400327c8:	55                   	push   %ebp
400327c9:	89 d0                	mov    %edx,%eax
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
400327cb:	31 d2                	xor    %edx,%edx
{
400327cd:	89 e5                	mov    %esp,%ebp
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
400327cf:	84 c9                	test   %cl,%cl
400327d1:	0f 95 c2             	setne  %dl
400327d4:	e8 be 0b 00 00       	call   40033397 <qm_pmux_input_en>
400327d9:	85 c0                	test   %eax,%eax
400327db:	74 05                	je     400327e2 <pinmux_input+0x1a>
400327dd:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400327e2:	5d                   	pop    %ebp
400327e3:	c3                   	ret    

400327e4 <pinmux_pullup>:
{
400327e4:	55                   	push   %ebp
400327e5:	89 d0                	mov    %edx,%eax
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
400327e7:	31 d2                	xor    %edx,%edx
{
400327e9:	89 e5                	mov    %esp,%ebp
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
400327eb:	84 c9                	test   %cl,%cl
400327ed:	0f 95 c2             	setne  %dl
400327f0:	e8 d2 0b 00 00       	call   400333c7 <qm_pmux_pullup_en>
400327f5:	85 c0                	test   %eax,%eax
400327f7:	74 05                	je     400327fe <pinmux_pullup+0x1a>
400327f9:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400327fe:	5d                   	pop    %ebp
400327ff:	c3                   	ret    

40032800 <pinmux_set>:
{
40032800:	55                   	push   %ebp
40032801:	89 d0                	mov    %edx,%eax
40032803:	89 e5                	mov    %esp,%ebp
40032805:	89 ca                	mov    %ecx,%edx
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
40032807:	e8 54 0b 00 00       	call   40033360 <qm_pmux_select>
4003280c:	85 c0                	test   %eax,%eax
4003280e:	74 05                	je     40032815 <pinmux_set+0x15>
40032810:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40032815:	5d                   	pop    %ebp
40032816:	c3                   	ret    

40032817 <_stdin_hook_default>:
{
	_stdout_hook = hook;
}

static unsigned char _stdin_hook_default(void)
{
40032817:	55                   	push   %ebp
	return 0;
}
40032818:	31 c0                	xor    %eax,%eax
{
4003281a:	89 e5                	mov    %esp,%ebp
}
4003281c:	5d                   	pop    %ebp
4003281d:	c3                   	ret    

4003281e <_stdout_hook_default>:
4003281e:	55                   	push   %ebp
4003281f:	83 c8 ff             	or     $0xffffffff,%eax
40032822:	89 e5                	mov    %esp,%ebp
40032824:	5d                   	pop    %ebp
40032825:	c3                   	ret    

40032826 <__stdout_hook_install>:
{
40032826:	55                   	push   %ebp
	_stdout_hook = hook;
40032827:	a3 f8 66 00 a8       	mov    %eax,0xa80066f8
{
4003282c:	89 e5                	mov    %esp,%ebp
}
4003282e:	5d                   	pop    %ebp
4003282f:	c3                   	ret    

40032830 <_read>:
{
	_stdin_hook = hook;
}

int _read(int fd, char *buf, int nbytes)
{
40032830:	55                   	push   %ebp
40032831:	89 e5                	mov    %esp,%ebp
40032833:	57                   	push   %edi
40032834:	89 d7                	mov    %edx,%edi
40032836:	56                   	push   %esi
40032837:	89 ce                	mov    %ecx,%esi
40032839:	53                   	push   %ebx
	int i = 0;

	for (i = 0; i < nbytes; i++) {
4003283a:	31 db                	xor    %ebx,%ebx
4003283c:	39 f3                	cmp    %esi,%ebx
4003283e:	7d 14                	jge    40032854 <_read+0x24>
		*(buf + i) = _stdin_hook();
40032840:	ff 15 f4 66 00 a8    	call   *0xa80066f4
40032846:	88 04 1f             	mov    %al,(%edi,%ebx,1)
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
40032849:	3c 0a                	cmp    $0xa,%al
4003284b:	8d 5b 01             	lea    0x1(%ebx),%ebx
4003284e:	74 04                	je     40032854 <_read+0x24>
40032850:	3c 0d                	cmp    $0xd,%al
40032852:	75 e8                	jne    4003283c <_read+0xc>
			i++;
			break;
		}
	}
	return i;
}
40032854:	89 d8                	mov    %ebx,%eax
40032856:	5b                   	pop    %ebx
40032857:	5e                   	pop    %esi
40032858:	5f                   	pop    %edi
40032859:	5d                   	pop    %ebp
4003285a:	c3                   	ret    

4003285b <_write>:
FUNC_ALIAS(_read, read, int);

int _write(int fd, char *buf, int nbytes)
{
4003285b:	55                   	push   %ebp
4003285c:	89 e5                	mov    %esp,%ebp
4003285e:	57                   	push   %edi
4003285f:	89 d7                	mov    %edx,%edi
40032861:	56                   	push   %esi
40032862:	89 ce                	mov    %ecx,%esi
40032864:	53                   	push   %ebx
	int i;

	for (i = 0; i < nbytes; i++) {
40032865:	31 db                	xor    %ebx,%ebx
40032867:	39 f3                	cmp    %esi,%ebx
40032869:	7d 1e                	jge    40032889 <_write+0x2e>
		if (*(buf + i) == '\n') {
4003286b:	80 3c 1f 0a          	cmpb   $0xa,(%edi,%ebx,1)
4003286f:	75 0b                	jne    4003287c <_write+0x21>
			_stdout_hook('\r');
40032871:	b8 0d 00 00 00       	mov    $0xd,%eax
40032876:	ff 15 f8 66 00 a8    	call   *0xa80066f8
		}
		_stdout_hook(*(buf + i));
4003287c:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
	for (i = 0; i < nbytes; i++) {
40032880:	43                   	inc    %ebx
		_stdout_hook(*(buf + i));
40032881:	ff 15 f8 66 00 a8    	call   *0xa80066f8
40032887:	eb de                	jmp    40032867 <_write+0xc>
	}
	return nbytes;
}
40032889:	5b                   	pop    %ebx
4003288a:	89 f0                	mov    %esi,%eax
4003288c:	5e                   	pop    %esi
4003288d:	5f                   	pop    %edi
4003288e:	5d                   	pop    %ebp
4003288f:	c3                   	ret    

40032890 <_isatty>:
FUNC_ALIAS(_write, write, int);

int _isatty(int file)
{
40032890:	55                   	push   %ebp
	return 1;
}
40032891:	b8 01 00 00 00       	mov    $0x1,%eax
{
40032896:	89 e5                	mov    %esp,%ebp
}
40032898:	5d                   	pop    %ebp
40032899:	c3                   	ret    

4003289a <_fstat>:
	return 0;
}
FUNC_ALIAS(_getpid, getpid, int);

int _fstat(int file, struct stat *st)
{
4003289a:	55                   	push   %ebp
	st->st_mode = S_IFCHR;
	return 0;
}
4003289b:	31 c0                	xor    %eax,%eax
{
4003289d:	89 e5                	mov    %esp,%ebp
	st->st_mode = S_IFCHR;
4003289f:	c7 42 04 00 20 00 00 	movl   $0x2000,0x4(%edx)
}
400328a6:	5d                   	pop    %ebp
400328a7:	c3                   	ret    

400328a8 <_close>:
	return -1;
}
FUNC_ALIAS(_open, open, int);

int _close(int file)
{
400328a8:	55                   	push   %ebp
	return -1;
}
400328a9:	83 c8 ff             	or     $0xffffffff,%eax
{
400328ac:	89 e5                	mov    %esp,%ebp
}
400328ae:	5d                   	pop    %ebp
400328af:	c3                   	ret    

400328b0 <_lseek>:
FUNC_ALIAS(_close, close, int);

int _lseek(int file, int ptr, int dir)
{
400328b0:	55                   	push   %ebp
	return 0;
}
400328b1:	31 c0                	xor    %eax,%eax
{
400328b3:	89 e5                	mov    %esp,%ebp
}
400328b5:	5d                   	pop    %ebp
400328b6:	c3                   	ret    

400328b7 <_sbrk>:
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
	void *ptr = heap_base + heap_sz;
400328b7:	8b 15 8c 69 00 a8    	mov    0xa800698c,%edx
{
400328bd:	55                   	push   %ebp
400328be:	89 e5                	mov    %esp,%ebp

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
400328c0:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
400328c3:	b8 00 40 01 a8       	mov    $0xa8014000,%eax
400328c8:	2d 4c 92 00 a8       	sub    $0xa800924c,%eax
400328cd:	39 c1                	cmp    %eax,%ecx
400328cf:	73 0e                	jae    400328df <_sbrk+0x28>
	void *ptr = heap_base + heap_sz;
400328d1:	8d 82 4c 92 00 a8    	lea    -0x57ff6db4(%edx),%eax
		heap_sz += count;
400328d7:	89 0d 8c 69 00 a8    	mov    %ecx,0xa800698c
		return ptr;
400328dd:	eb 03                	jmp    400328e2 <_sbrk+0x2b>
	} else {
		return (void *)-1;
400328df:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
400328e2:	5d                   	pop    %ebp
400328e3:	c3                   	ret    

400328e4 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
400328e4:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
400328e5:	31 c0                	xor    %eax,%eax
{
400328e7:	89 e5                	mov    %esp,%ebp
}
400328e9:	5d                   	pop    %ebp
400328ea:	c3                   	ret    

400328eb <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
400328eb:	ff 02                	incl   (%edx)
{
400328ed:	55                   	push   %ebp
400328ee:	89 e5                	mov    %esp,%ebp
	return _char_out(c);
}
400328f0:	5d                   	pop    %ebp
	return _char_out(c);
400328f1:	ff 25 fc 66 00 a8    	jmp    *0xa80066fc

400328f7 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
400328f7:	55                   	push   %ebp
400328f8:	89 e5                	mov    %esp,%ebp
400328fa:	57                   	push   %edi
400328fb:	56                   	push   %esi
400328fc:	53                   	push   %ebx
400328fd:	83 ec 14             	sub    $0x14,%esp
40032900:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40032903:	8b 75 0c             	mov    0xc(%ebp),%esi
40032906:	89 55 e0             	mov    %edx,-0x20(%ebp)
40032909:	8b 45 08             	mov    0x8(%ebp),%eax
4003290c:	89 75 ec             	mov    %esi,-0x14(%ebp)
4003290f:	85 f6                	test   %esi,%esi
40032911:	7f 07                	jg     4003291a <_printk_dec_ulong+0x23>
40032913:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
4003291a:	83 f8 01             	cmp    $0x1,%eax
4003291d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40032920:	19 f6                	sbb    %esi,%esi
40032922:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
40032929:	83 e6 f0             	and    $0xfffffff0,%esi
4003292c:	31 ff                	xor    %edi,%edi
4003292e:	83 c6 30             	add    $0x30,%esi
40032931:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
40032936:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
40032939:	72 04                	jb     4003293f <_printk_dec_ulong+0x48>
4003293b:	85 ff                	test   %edi,%edi
4003293d:	74 1c                	je     4003295b <_printk_dec_ulong+0x64>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
4003293f:	8d 4b 01             	lea    0x1(%ebx),%ecx
40032942:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032945:	31 d2                	xor    %edx,%edx
40032947:	8b 7d e4             	mov    -0x1c(%ebp),%edi
4003294a:	f7 f1                	div    %ecx
4003294c:	83 c0 30             	add    $0x30,%eax
4003294f:	8b 55 e0             	mov    -0x20(%ebp),%edx
40032952:	ff d7                	call   *%edi
			found_largest_digit = 1;
40032954:	bf 01 00 00 00       	mov    $0x1,%edi
40032959:	eb 14                	jmp    4003296f <_printk_dec_ulong+0x78>
		} else if (remaining <= min_width) {
4003295b:	8b 55 e8             	mov    -0x18(%ebp),%edx
4003295e:	31 ff                	xor    %edi,%edi
40032960:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40032963:	7c 0a                	jl     4003296f <_printk_dec_ulong+0x78>
			out((int)(pad_zero ? '0' : ' '), ctx);
40032965:	8b 55 e0             	mov    -0x20(%ebp),%edx
40032968:	89 f0                	mov    %esi,%eax
4003296a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4003296d:	ff d1                	call   *%ecx
		}
		remaining--;
		remainder %= (pos + 1);
4003296f:	8d 4b 01             	lea    0x1(%ebx),%ecx
40032972:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032975:	31 d2                	xor    %edx,%edx
		remaining--;
40032977:	ff 4d e8             	decl   -0x18(%ebp)
		remainder %= (pos + 1);
4003297a:	f7 f1                	div    %ecx
4003297c:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
4003297f:	89 d8                	mov    %ebx,%eax
40032981:	31 d2                	xor    %edx,%edx
40032983:	b9 0a 00 00 00       	mov    $0xa,%ecx
40032988:	f7 f1                	div    %ecx
4003298a:	89 c3                	mov    %eax,%ebx
	while (pos >= 9) {
4003298c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40032990:	75 a4                	jne    40032936 <_printk_dec_ulong+0x3f>
	}
	out((int)(remainder + 48), ctx);
40032992:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032995:	8b 55 e0             	mov    -0x20(%ebp),%edx
40032998:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}
4003299b:	83 c4 14             	add    $0x14,%esp
	out((int)(remainder + 48), ctx);
4003299e:	83 c0 30             	add    $0x30,%eax
}
400329a1:	5b                   	pop    %ebx
400329a2:	5e                   	pop    %esi
400329a3:	5f                   	pop    %edi
400329a4:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
400329a5:	ff e1                	jmp    *%ecx

400329a7 <__printk_hook_install>:
{
400329a7:	55                   	push   %ebp
	_char_out = fn;
400329a8:	a3 fc 66 00 a8       	mov    %eax,0xa80066fc
{
400329ad:	89 e5                	mov    %esp,%ebp
}
400329af:	5d                   	pop    %ebp
400329b0:	c3                   	ret    

400329b1 <_vprintk>:
{
400329b1:	55                   	push   %ebp
400329b2:	89 e5                	mov    %esp,%ebp
400329b4:	57                   	push   %edi
400329b5:	56                   	push   %esi
400329b6:	53                   	push   %ebx
400329b7:	83 ec 20             	sub    $0x20,%esp
400329ba:	89 c7                	mov    %eax,%edi
400329bc:	89 55 f0             	mov    %edx,-0x10(%ebp)
400329bf:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400329c2:	8b 75 08             	mov    0x8(%ebp),%esi
	int min_width = -1;
400329c5:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	int pad_zero = 0;
400329cc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
400329d3:	31 db                	xor    %ebx,%ebx
	while (*fmt) {
400329d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
400329d8:	0f be 00             	movsbl (%eax),%eax
400329db:	84 c0                	test   %al,%al
400329dd:	0f 84 0d 02 00 00    	je     40032bf0 <_vprintk+0x23f>
		if (!might_format) {
400329e3:	85 db                	test   %ebx,%ebx
400329e5:	75 12                	jne    400329f9 <_vprintk+0x48>
			if (*fmt != '%') {
400329e7:	3c 25                	cmp    $0x25,%al
400329e9:	0f 84 e1 01 00 00    	je     40032bd0 <_vprintk+0x21f>
				out((int)*fmt, ctx);
400329ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
400329f2:	ff d7                	call   *%edi
400329f4:	e9 ef 01 00 00       	jmp    40032be8 <_vprintk+0x237>
			switch (*fmt) {
400329f9:	3c 68                	cmp    $0x68,%al
400329fb:	0f 84 e7 01 00 00    	je     40032be8 <_vprintk+0x237>
40032a01:	7f 3a                	jg     40032a3d <_vprintk+0x8c>
40032a03:	3c 39                	cmp    $0x39,%al
40032a05:	7f 19                	jg     40032a20 <_vprintk+0x6f>
40032a07:	3c 31                	cmp    $0x31,%al
40032a09:	0f 8d 89 00 00 00    	jge    40032a98 <_vprintk+0xe7>
40032a0f:	3c 25                	cmp    $0x25,%al
40032a11:	0f 84 96 01 00 00    	je     40032bad <_vprintk+0x1fc>
40032a17:	3c 30                	cmp    $0x30,%al
40032a19:	74 6b                	je     40032a86 <_vprintk+0xd5>
40032a1b:	e9 97 01 00 00       	jmp    40032bb7 <_vprintk+0x206>
40032a20:	3c 63                	cmp    $0x63,%al
40032a22:	0f 84 76 01 00 00    	je     40032b9e <_vprintk+0x1ed>
40032a28:	3c 64                	cmp    $0x64,%al
40032a2a:	0f 84 83 00 00 00    	je     40032ab3 <_vprintk+0x102>
40032a30:	3c 58                	cmp    $0x58,%al
40032a32:	0f 85 7f 01 00 00    	jne    40032bb7 <_vprintk+0x206>
40032a38:	e9 c7 00 00 00       	jmp    40032b04 <_vprintk+0x153>
40032a3d:	3c 73                	cmp    $0x73,%al
40032a3f:	0f 84 41 01 00 00    	je     40032b86 <_vprintk+0x1d5>
40032a45:	7f 1a                	jg     40032a61 <_vprintk+0xb0>
40032a47:	3c 6c                	cmp    $0x6c,%al
40032a49:	0f 84 99 01 00 00    	je     40032be8 <_vprintk+0x237>
40032a4f:	3c 70                	cmp    $0x70,%al
40032a51:	0f 84 8f 00 00 00    	je     40032ae6 <_vprintk+0x135>
40032a57:	3c 69                	cmp    $0x69,%al
40032a59:	0f 85 58 01 00 00    	jne    40032bb7 <_vprintk+0x206>
40032a5f:	eb 52                	jmp    40032ab3 <_vprintk+0x102>
40032a61:	3c 78                	cmp    $0x78,%al
40032a63:	0f 84 9b 00 00 00    	je     40032b04 <_vprintk+0x153>
40032a69:	3c 7a                	cmp    $0x7a,%al
40032a6b:	0f 84 77 01 00 00    	je     40032be8 <_vprintk+0x237>
40032a71:	3c 75                	cmp    $0x75,%al
40032a73:	0f 85 3e 01 00 00    	jne    40032bb7 <_vprintk+0x206>
				_printk_dec_ulong(out, ctx, u, pad_zero,
40032a79:	ff 75 ec             	pushl  -0x14(%ebp)
				unsigned long u = va_arg(
40032a7c:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40032a7f:	8b 0e                	mov    (%esi),%ecx
40032a81:	ff 75 e8             	pushl  -0x18(%ebp)
40032a84:	eb 4d                	jmp    40032ad3 <_vprintk+0x122>
				if (min_width < 0 && pad_zero == 0) {
40032a86:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40032a89:	c1 e9 1f             	shr    $0x1f,%ecx
40032a8c:	74 0a                	je     40032a98 <_vprintk+0xe7>
40032a8e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40032a92:	0f 84 4d 01 00 00    	je     40032be5 <_vprintk+0x234>
				if (min_width < 0) {
40032a98:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40032a9c:	79 05                	jns    40032aa3 <_vprintk+0xf2>
					min_width = *fmt - '0';
40032a9e:	83 e8 30             	sub    $0x30,%eax
40032aa1:	eb 08                	jmp    40032aab <_vprintk+0xfa>
					min_width = 10 * min_width + *fmt - '0';
40032aa3:	6b 55 ec 0a          	imul   $0xa,-0x14(%ebp),%edx
40032aa7:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
40032aab:	89 45 ec             	mov    %eax,-0x14(%ebp)
40032aae:	e9 35 01 00 00       	jmp    40032be8 <_vprintk+0x237>
				long d = va_arg(ap, long);
40032ab3:	8d 5e 04             	lea    0x4(%esi),%ebx
40032ab6:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
40032ab8:	85 f6                	test   %esi,%esi
40032aba:	79 0f                	jns    40032acb <_vprintk+0x11a>
					out((int)'-', ctx);
40032abc:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032abf:	b8 2d 00 00 00       	mov    $0x2d,%eax
40032ac4:	ff d7                	call   *%edi
					min_width--;
40032ac6:	ff 4d ec             	decl   -0x14(%ebp)
					d = -d;
40032ac9:	f7 de                	neg    %esi
				_printk_dec_ulong(out, ctx, d, pad_zero,
40032acb:	ff 75 ec             	pushl  -0x14(%ebp)
40032ace:	ff 75 e8             	pushl  -0x18(%ebp)
40032ad1:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40032ad3:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032ad6:	89 f8                	mov    %edi,%eax
40032ad8:	e8 1a fe ff ff       	call   400328f7 <_printk_dec_ulong>
40032add:	58                   	pop    %eax
40032ade:	5a                   	pop    %edx
				unsigned long u = va_arg(
40032adf:	89 de                	mov    %ebx,%esi
40032ae1:	e9 e6 00 00 00       	jmp    40032bcc <_vprintk+0x21b>
				  out('0', ctx);
40032ae6:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032ae9:	b8 30 00 00 00       	mov    $0x30,%eax
40032aee:	ff d7                	call   *%edi
				  out('x', ctx);
40032af0:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032af3:	b8 78 00 00 00       	mov    $0x78,%eax
40032af8:	ff d7                	call   *%edi
				  pad_zero = 1;
40032afa:	89 5d e8             	mov    %ebx,-0x18(%ebp)
				  min_width = 8;
40032afd:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
40032b04:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
				unsigned long x = va_arg(
40032b08:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
40032b0b:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
				unsigned long x = va_arg(
40032b12:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40032b15:	8b 06                	mov    (%esi),%eax
40032b17:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int size = sizeof(num) * 2;
40032b1a:	be 08 00 00 00       	mov    $0x8,%esi
40032b1f:	19 c0                	sbb    %eax,%eax
	int found_largest_digit = 0;
40032b21:	31 d2                	xor    %edx,%edx
40032b23:	89 45 dc             	mov    %eax,-0x24(%ebp)
40032b26:	83 65 dc f0          	andl   $0xfffffff0,-0x24(%ebp)
40032b2a:	83 45 dc 30          	addl   $0x30,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
40032b2e:	4e                   	dec    %esi
40032b2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
40032b32:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
40032b39:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
40032b3b:	24 0f                	and    $0xf,%al
40032b3d:	75 0c                	jne    40032b4b <_vprintk+0x19a>
40032b3f:	85 d2                	test   %edx,%edx
40032b41:	75 08                	jne    40032b4b <_vprintk+0x19a>
40032b43:	85 f6                	test   %esi,%esi
40032b45:	75 1e                	jne    40032b65 <_vprintk+0x1b4>
			nibble += nibble > 9 ? 87 : 48;
40032b47:	b2 30                	mov    $0x30,%dl
40032b49:	eb 0c                	jmp    40032b57 <_vprintk+0x1a6>
40032b4b:	3c 09                	cmp    $0x9,%al
40032b4d:	0f 9f c2             	setg   %dl
40032b50:	4a                   	dec    %edx
40032b51:	83 e2 d9             	and    $0xffffffd9,%edx
40032b54:	83 c2 57             	add    $0x57,%edx
40032b57:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
40032b59:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032b5c:	0f b6 c0             	movzbl %al,%eax
40032b5f:	ff d7                	call   *%edi
			found_largest_digit = 1;
40032b61:	89 da                	mov    %ebx,%edx
40032b63:	eb 18                	jmp    40032b7d <_vprintk+0x1cc>
		if (remaining-- <= min_width) {
40032b65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40032b68:	39 45 ec             	cmp    %eax,-0x14(%ebp)
40032b6b:	8d 48 ff             	lea    -0x1(%eax),%ecx
40032b6e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40032b71:	7c 08                	jl     40032b7b <_vprintk+0x1ca>
			out((int)(pad_zero ? '0' : ' '), ctx);
40032b73:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032b76:	8b 45 dc             	mov    -0x24(%ebp),%eax
40032b79:	ff d7                	call   *%edi
		if (remaining-- <= min_width) {
40032b7b:	31 d2                	xor    %edx,%edx
	for (; size; size--) {
40032b7d:	85 f6                	test   %esi,%esi
40032b7f:	75 ad                	jne    40032b2e <_vprintk+0x17d>
				unsigned long x = va_arg(
40032b81:	8b 75 d4             	mov    -0x2c(%ebp),%esi
40032b84:	eb 46                	jmp    40032bcc <_vprintk+0x21b>
				char *s = va_arg(ap, char *);
40032b86:	8d 5e 04             	lea    0x4(%esi),%ebx
40032b89:	8b 36                	mov    (%esi),%esi
				while (*s)
40032b8b:	0f be 06             	movsbl (%esi),%eax
40032b8e:	84 c0                	test   %al,%al
40032b90:	0f 84 49 ff ff ff    	je     40032adf <_vprintk+0x12e>
					out((int)(*s++), ctx);
40032b96:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032b99:	46                   	inc    %esi
40032b9a:	ff d7                	call   *%edi
40032b9c:	eb ed                	jmp    40032b8b <_vprintk+0x1da>
				out(c, ctx);
40032b9e:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032ba1:	8b 06                	mov    (%esi),%eax
				int c = va_arg(ap, int);
40032ba3:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
40032ba6:	ff d7                	call   *%edi
40032ba8:	e9 32 ff ff ff       	jmp    40032adf <_vprintk+0x12e>
				out((int)'%', ctx);
40032bad:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032bb0:	b8 25 00 00 00       	mov    $0x25,%eax
40032bb5:	eb 13                	jmp    40032bca <_vprintk+0x219>
				out((int)'%', ctx);
40032bb7:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032bba:	b8 25 00 00 00       	mov    $0x25,%eax
40032bbf:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
40032bc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40032bc4:	0f be 00             	movsbl (%eax),%eax
40032bc7:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032bca:	ff d7                	call   *%edi
			might_format = 0;
40032bcc:	31 db                	xor    %ebx,%ebx
				break;
40032bce:	eb 18                	jmp    40032be8 <_vprintk+0x237>
				pad_zero = 0;
40032bd0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
40032bd7:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				might_format = 1;
40032bde:	bb 01 00 00 00       	mov    $0x1,%ebx
40032be3:	eb 03                	jmp    40032be8 <_vprintk+0x237>
					pad_zero = 1;
40032be5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		++fmt;
40032be8:	ff 45 e0             	incl   -0x20(%ebp)
40032beb:	e9 e5 fd ff ff       	jmp    400329d5 <_vprintk+0x24>
}
40032bf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032bf3:	5b                   	pop    %ebx
40032bf4:	5e                   	pop    %esi
40032bf5:	5f                   	pop    %edi
40032bf6:	5d                   	pop    %ebp
40032bf7:	c3                   	ret    

40032bf8 <printk>:
{
40032bf8:	55                   	push   %ebp
40032bf9:	89 e5                	mov    %esp,%ebp
40032bfb:	50                   	push   %eax
	va_start(ap, fmt);
40032bfc:	8d 45 0c             	lea    0xc(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40032bff:	8d 55 fc             	lea    -0x4(%ebp),%edx
40032c02:	50                   	push   %eax
40032c03:	8b 4d 08             	mov    0x8(%ebp),%ecx
40032c06:	b8 eb 28 03 40       	mov    $0x400328eb,%eax
	struct out_context ctx = { 0 };
40032c0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40032c12:	e8 9a fd ff ff       	call   400329b1 <_vprintk>
}
40032c17:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40032c1a:	5a                   	pop    %edx
}
40032c1b:	c9                   	leave  
40032c1c:	c3                   	ret    

40032c1d <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40032c1d:	55                   	push   %ebp
40032c1e:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
40032c20:	5d                   	pop    %ebp
40032c21:	c3                   	ret    

40032c22 <pinmux_initialize>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static int pinmux_initialize(struct device *port)
{
40032c22:	55                   	push   %ebp
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
40032c23:	b8 30 09 80 b0       	mov    $0xb0800930,%eax
{
40032c28:	89 e5                	mov    %esp,%ebp
40032c2a:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  9, PINMUX_FUNC_C);
40032c2d:	c7 45 ec 55 00 0a 00 	movl   $0xa0055,-0x14(%ebp)
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
40032c34:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
	PIN_CONFIG(mux_config, 41, PINMUX_FUNC_B);
40032c3b:	c7 45 f4 04 00 05 00 	movl   $0x50004,-0xc(%ebp)
	PIN_CONFIG(mux_config, 63, PINMUX_FUNC_B);
40032c42:	c7 45 f8 00 40 15 40 	movl   $0x40154000,-0x8(%ebp)
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
40032c49:	c7 45 fc 15 00 00 00 	movl   $0x15,-0x4(%ebp)
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
40032c50:	8b 94 05 bc f6 7f 4f 	mov    0x4f7ff6bc(%ebp,%eax,1),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
40032c57:	89 10                	mov    %edx,(%eax)
40032c59:	83 c0 04             	add    $0x4,%eax
	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
40032c5c:	3d 44 09 80 b0       	cmp    $0xb0800944,%eax
40032c61:	75 ed                	jne    40032c50 <pinmux_initialize+0x2e>
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);

	return 0;
}
40032c63:	31 c0                	xor    %eax,%eax
40032c65:	c9                   	leave  
40032c66:	c3                   	ret    

40032c67 <clk_periph_enable>:

	return 0;
}

int clk_periph_enable(const clk_periph_t clocks)
{
40032c67:	55                   	push   %ebp
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
40032c68:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
{
40032c6e:	89 e5                	mov    %esp,%ebp
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
40032c70:	09 d0                	or     %edx,%eax
40032c72:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
40032c77:	31 c0                	xor    %eax,%eax
40032c79:	5d                   	pop    %ebp
40032c7a:	c3                   	ret    

40032c7b <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
40032c7b:	55                   	push   %ebp
40032c7c:	89 e5                	mov    %esp,%ebp
40032c7e:	56                   	push   %esi
40032c7f:	53                   	push   %ebx
40032c80:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
40032c82:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
		qm_power_soc_restore();
	}
#endif

	if (callback[gpio]) {
40032c89:	8b 0c 9d 98 69 00 a8 	mov    -0x57ff9668(,%ebx,4),%ecx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
40032c90:	8b 70 40             	mov    0x40(%eax),%esi
	if (callback[gpio]) {
40032c93:	85 c9                	test   %ecx,%ecx
40032c95:	74 0b                	je     40032ca2 <gpio_isr+0x27>
		(*callback[gpio])(callback_data[gpio], int_status);
40032c97:	8b 04 9d 90 69 00 a8 	mov    -0x57ff9670(,%ebx,4),%eax
40032c9e:	89 f2                	mov    %esi,%edx
40032ca0:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
40032ca2:	8b 04 9d 00 67 00 a8 	mov    -0x57ff9900(,%ebx,4),%eax
40032ca9:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
}
40032cac:	5b                   	pop    %ebx
	QM_GPIO[gpio]->gpio_porta_eoi;
40032cad:	8b 40 4c             	mov    0x4c(%eax),%eax
}
40032cb0:	5e                   	pop    %esi
40032cb1:	5d                   	pop    %ebp
40032cb2:	c3                   	ret    

40032cb3 <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
40032cb3:	55                   	push   %ebp
	gpio_isr(QM_GPIO_0);
40032cb4:	31 c0                	xor    %eax,%eax
{
40032cb6:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_GPIO_0_INT_VECTOR);
}
40032cb8:	5d                   	pop    %ebp
	gpio_isr(QM_GPIO_0);
40032cb9:	e9 bd ff ff ff       	jmp    40032c7b <gpio_isr>

40032cbe <qm_aon_gpio_0_isr>:

#if (HAS_AON_GPIO)
QM_ISR_DECLARE(qm_aon_gpio_0_isr)
{
40032cbe:	55                   	push   %ebp
	gpio_isr(QM_AON_GPIO_0);
40032cbf:	b8 01 00 00 00       	mov    $0x1,%eax
{
40032cc4:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_AON_GPIO_0_INT_VECTOR);
}
40032cc6:	5d                   	pop    %ebp
	gpio_isr(QM_AON_GPIO_0);
40032cc7:	e9 af ff ff ff       	jmp    40032c7b <gpio_isr>

40032ccc <qm_gpio_set_config>:
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
40032ccc:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
40032ccd:	8b 0c 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%ecx
{
40032cd4:	89 e5                	mov    %esp,%ebp
40032cd6:	56                   	push   %esi
40032cd7:	53                   	push   %ebx

	uint32_t mask = controller->gpio_intmask;
	controller->gpio_intmask = 0xffffffff;

	controller->gpio_swporta_ddr = cfg->direction;
40032cd8:	8b 1a                	mov    (%edx),%ebx
	uint32_t mask = controller->gpio_intmask;
40032cda:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
40032cdd:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)
	controller->gpio_swporta_ddr = cfg->direction;
40032ce4:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
40032ce7:	8b 5a 04             	mov    0x4(%edx),%ebx
40032cea:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
40032ced:	8b 5a 08             	mov    0x8(%edx),%ebx
40032cf0:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
40032cf3:	8b 5a 0c             	mov    0xc(%edx),%ebx
40032cf6:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
40032cf9:	8b 5a 10             	mov    0x10(%edx),%ebx
40032cfc:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
40032cff:	8b 5a 14             	mov    0x14(%edx),%ebx
40032d02:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
40032d05:	8b 59 60             	mov    0x60(%ecx),%ebx
40032d08:	83 cb 01             	or     $0x1,%ebx
40032d0b:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
40032d0e:	8b 5a 18             	mov    0x18(%edx),%ebx
	callback_data[gpio] = cfg->callback_data;
40032d11:	8b 52 1c             	mov    0x1c(%edx),%edx

	controller->gpio_intmask = mask;
40032d14:	89 71 34             	mov    %esi,0x34(%ecx)
	callback[gpio] = cfg->callback;
40032d17:	89 1c 85 98 69 00 a8 	mov    %ebx,-0x57ff9668(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
40032d1e:	89 14 85 90 69 00 a8 	mov    %edx,-0x57ff9670(,%eax,4)

	return 0;
}
40032d25:	5b                   	pop    %ebx
40032d26:	31 c0                	xor    %eax,%eax
40032d28:	5e                   	pop    %esi
40032d29:	5d                   	pop    %ebp
40032d2a:	c3                   	ret    

40032d2b <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
40032d2b:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40032d2c:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
{
40032d33:	89 e5                	mov    %esp,%ebp
40032d35:	53                   	push   %ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40032d36:	8b 40 50             	mov    0x50(%eax),%eax
{
40032d39:	89 cb                	mov    %ecx,%ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40032d3b:	88 d1                	mov    %dl,%cl
40032d3d:	d3 e8                	shr    %cl,%eax
40032d3f:	83 e0 01             	and    $0x1,%eax
40032d42:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40032d44:	31 c0                	xor    %eax,%eax
40032d46:	5b                   	pop    %ebx
40032d47:	5d                   	pop    %ebp
40032d48:	c3                   	ret    

40032d49 <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40032d49:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40032d4a:	88 d1                	mov    %dl,%cl
{
40032d4c:	89 e5                	mov    %esp,%ebp
40032d4e:	56                   	push   %esi
40032d4f:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40032d50:	8b 1c 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%ebx
40032d57:	b8 01 00 00 00       	mov    $0x1,%eax
40032d5c:	8b 33                	mov    (%ebx),%esi
40032d5e:	d3 e0                	shl    %cl,%eax
40032d60:	09 f0                	or     %esi,%eax
40032d62:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40032d64:	31 c0                	xor    %eax,%eax
40032d66:	5b                   	pop    %ebx
40032d67:	5e                   	pop    %esi
40032d68:	5d                   	pop    %ebp
40032d69:	c3                   	ret    

40032d6a <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40032d6a:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
40032d6b:	88 d1                	mov    %dl,%cl
{
40032d6d:	89 e5                	mov    %esp,%ebp
40032d6f:	56                   	push   %esi
40032d70:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
40032d71:	8b 1c 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%ebx
40032d78:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
40032d7d:	8b 33                	mov    (%ebx),%esi
40032d7f:	d3 c0                	rol    %cl,%eax
40032d81:	21 f0                	and    %esi,%eax
40032d83:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40032d85:	31 c0                	xor    %eax,%eax
40032d87:	5b                   	pop    %ebx
40032d88:	5e                   	pop    %esi
40032d89:	5d                   	pop    %ebp
40032d8a:	c3                   	ret    

40032d8b <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
40032d8b:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
{
40032d92:	55                   	push   %ebp
40032d93:	89 e5                	mov    %esp,%ebp

	return 0;
}
40032d95:	5d                   	pop    %ebp
	*port = QM_GPIO[gpio]->gpio_ext_porta;
40032d96:	8b 40 50             	mov    0x50(%eax),%eax
40032d99:	89 02                	mov    %eax,(%edx)
}
40032d9b:	31 c0                	xor    %eax,%eax
40032d9d:	c3                   	ret    

40032d9e <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
40032d9e:	8b 04 85 00 67 00 a8 	mov    -0x57ff9900(,%eax,4),%eax
{
40032da5:	55                   	push   %ebp
40032da6:	89 e5                	mov    %esp,%ebp
	QM_GPIO[gpio]->gpio_swporta_dr = val;
40032da8:	89 10                	mov    %edx,(%eax)

	return 0;
}
40032daa:	31 c0                	xor    %eax,%eax
40032dac:	5d                   	pop    %ebp
40032dad:	c3                   	ret    

40032dae <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
40032dae:	55                   	push   %ebp
40032daf:	89 e5                	mov    %esp,%ebp
40032db1:	53                   	push   %ebx
40032db2:	51                   	push   %ecx
	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40032db3:	8b 4a 04             	mov    0x4(%edx),%ecx
	qm_uart_reg_t *const regs = QM_UART[uart];
40032db6:	8b 04 85 08 67 00 a8 	mov    -0x57ff98f8(,%eax,4),%eax
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40032dbd:	89 cb                	mov    %ecx,%ebx
40032dbf:	c1 eb 10             	shr    $0x10,%ebx
	regs->lcr = 0;
40032dc2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40032dc9:	0f b6 db             	movzbl %bl,%ebx
	regs->lcr = QM_UART_LCR_DLAB;
40032dcc:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40032dd3:	89 58 04             	mov    %ebx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
40032dd6:	0f b6 dd             	movzbl %ch,%ebx
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
40032dd9:	0f b6 c9             	movzbl %cl,%ecx
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
40032ddc:	89 18                	mov    %ebx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
40032dde:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
40032de4:	8b 0a                	mov    (%edx),%ecx
40032de6:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
40032de9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
40032df0:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
40032df4:	74 09                	je     40032dff <qm_uart_set_config+0x51>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
40032df6:	8b 50 10             	mov    0x10(%eax),%edx
40032df9:	83 ca 22             	or     $0x22,%edx
40032dfc:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
40032dff:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
40032e06:	8b 50 04             	mov    0x4(%eax),%edx
40032e09:	80 ca 80             	or     $0x80,%dl
40032e0c:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
40032e0f:	8b 40 14             	mov    0x14(%eax),%eax
40032e12:	89 45 f8             	mov    %eax,-0x8(%ebp)

	return 0;
}
40032e15:	5a                   	pop    %edx
40032e16:	31 c0                	xor    %eax,%eax
40032e18:	5b                   	pop    %ebx
40032e19:	5d                   	pop    %ebp
40032e1a:	c3                   	ret    

40032e1b <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
40032e1b:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
40032e1c:	8b 0c 85 08 67 00 a8 	mov    -0x57ff98f8(,%eax,4),%ecx
{
40032e23:	89 e5                	mov    %esp,%ebp
40032e25:	56                   	push   %esi
40032e26:	53                   	push   %ebx
	uint32_t lsr = regs->lsr;
40032e27:	8b 59 14             	mov    0x14(%ecx),%ebx

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
40032e2a:	8b 71 1c             	mov    0x1c(%ecx),%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40032e2d:	89 d8                	mov    %ebx,%eax
40032e2f:	83 e0 1e             	and    $0x1e,%eax
	if (regs->scr & BIT(0)) {
40032e32:	83 e6 01             	and    $0x1,%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40032e35:	89 02                	mov    %eax,(%edx)
	if (regs->scr & BIT(0)) {
40032e37:	74 0b                	je     40032e44 <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
40032e39:	8b 41 1c             	mov    0x1c(%ecx),%eax
40032e3c:	83 e0 fe             	and    $0xfffffffe,%eax
40032e3f:	89 41 1c             	mov    %eax,0x1c(%ecx)
40032e42:	eb 0a                	jmp    40032e4e <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
40032e44:	f6 c3 40             	test   $0x40,%bl
40032e47:	75 05                	jne    40032e4e <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
40032e49:	83 c8 20             	or     $0x20,%eax
40032e4c:	89 02                	mov    %eax,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
40032e4e:	80 e3 01             	and    $0x1,%bl
40032e51:	74 03                	je     40032e56 <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
40032e53:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
40032e56:	5b                   	pop    %ebx
40032e57:	31 c0                	xor    %eax,%eax
40032e59:	5e                   	pop    %esi
40032e5a:	5d                   	pop    %ebp
40032e5b:	c3                   	ret    

40032e5c <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
40032e5c:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
40032e5d:	8b 04 85 08 67 00 a8 	mov    -0x57ff98f8(,%eax,4),%eax
{
40032e64:	89 e5                	mov    %esp,%ebp

	while (regs->lsr & QM_UART_LSR_THRE) {
40032e66:	8b 48 14             	mov    0x14(%eax),%ecx
40032e69:	80 e1 20             	and    $0x20,%cl
40032e6c:	75 f8                	jne    40032e66 <qm_uart_write+0xa>
	}
	regs->rbr_thr_dll = data;
40032e6e:	0f b6 d2             	movzbl %dl,%edx
40032e71:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
40032e73:	8b 50 14             	mov    0x14(%eax),%edx
40032e76:	80 e2 40             	and    $0x40,%dl
40032e79:	74 f8                	je     40032e73 <qm_uart_write+0x17>
	}

	return 0;
}
40032e7b:	31 c0                	xor    %eax,%eax
40032e7d:	5d                   	pop    %ebp
40032e7e:	c3                   	ret    

40032e7f <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
40032e7f:	55                   	push   %ebp
40032e80:	89 e5                	mov    %esp,%ebp
40032e82:	56                   	push   %esi
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
40032e83:	8b 34 85 08 67 00 a8 	mov    -0x57ff98f8(,%eax,4),%esi
{
40032e8a:	53                   	push   %ebx

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
		lsr = regs->lsr;
40032e8b:	8b 46 14             	mov    0x14(%esi),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
40032e8e:	a8 01                	test   $0x1,%al
40032e90:	74 f9                	je     40032e8b <qm_uart_read+0xc>
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
40032e92:	83 e0 1e             	and    $0x1e,%eax
40032e95:	89 c3                	mov    %eax,%ebx
40032e97:	74 0d                	je     40032ea6 <qm_uart_read+0x27>
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
40032e99:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		if (status) {
40032e9e:	85 c9                	test   %ecx,%ecx
40032ea0:	74 0a                	je     40032eac <qm_uart_read+0x2d>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
40032ea2:	89 19                	mov    %ebx,(%ecx)
40032ea4:	eb 06                	jmp    40032eac <qm_uart_read+0x2d>
	}
	*data = regs->rbr_thr_dll;
40032ea6:	8b 06                	mov    (%esi),%eax
40032ea8:	88 02                	mov    %al,(%edx)

	return 0;
40032eaa:	31 c0                	xor    %eax,%eax
}
40032eac:	5b                   	pop    %ebx
40032ead:	5e                   	pop    %esi
40032eae:	5d                   	pop    %ebp
40032eaf:	c3                   	ret    

40032eb0 <read_frame>:
static dma_context_t dma_context_rx[QM_SPI_NUM];
/* DMA core being used by each SPI controller. */
static qm_dma_t dma_core[QM_SPI_NUM];

static void read_frame(const qm_spi_t spi, uint8_t *const rx_buffer)
{
40032eb0:	55                   	push   %ebp
	const qm_spi_reg_t *const controller = QM_SPI[spi];
40032eb1:	8b 0c 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40032eb8:	8a 80 b8 69 00 a8    	mov    -0x57ff9648(%eax),%al
{
40032ebe:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40032ec0:	3c 01                	cmp    $0x1,%al
40032ec2:	75 07                	jne    40032ecb <read_frame+0x1b>
		*(uint8_t *)rx_buffer = controller->dr[0];
40032ec4:	8b 41 60             	mov    0x60(%ecx),%eax
40032ec7:	88 02                	mov    %al,(%edx)
40032ec9:	eb 0e                	jmp    40032ed9 <read_frame+0x29>
	} else if (frame_size == 2) {
40032ecb:	3c 02                	cmp    $0x2,%al
		*(uint16_t *)rx_buffer = controller->dr[0];
40032ecd:	8b 41 60             	mov    0x60(%ecx),%eax
	} else if (frame_size == 2) {
40032ed0:	75 05                	jne    40032ed7 <read_frame+0x27>
		*(uint16_t *)rx_buffer = controller->dr[0];
40032ed2:	66 89 02             	mov    %ax,(%edx)
40032ed5:	eb 02                	jmp    40032ed9 <read_frame+0x29>
	} else {
		*(uint32_t *)rx_buffer = controller->dr[0];
40032ed7:	89 02                	mov    %eax,(%edx)
	}
}
40032ed9:	5d                   	pop    %ebp
40032eda:	c3                   	ret    

40032edb <write_frame>:

static void write_frame(const qm_spi_t spi, const uint8_t *const tx_buffer)
{
40032edb:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40032edc:	8b 0c 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40032ee3:	8a 80 b8 69 00 a8    	mov    -0x57ff9648(%eax),%al
{
40032ee9:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40032eeb:	3c 01                	cmp    $0x1,%al
40032eed:	75 05                	jne    40032ef4 <write_frame+0x19>
		controller->dr[0] = *(uint8_t *)tx_buffer;
40032eef:	0f b6 02             	movzbl (%edx),%eax
40032ef2:	eb 0b                	jmp    40032eff <write_frame+0x24>
	} else if (frame_size == 2) {
40032ef4:	3c 02                	cmp    $0x2,%al
40032ef6:	75 05                	jne    40032efd <write_frame+0x22>
		controller->dr[0] = *(uint16_t *)tx_buffer;
40032ef8:	0f b7 02             	movzwl (%edx),%eax
40032efb:	eb 02                	jmp    40032eff <write_frame+0x24>
	} else {
		controller->dr[0] = *(uint32_t *)tx_buffer;
40032efd:	8b 02                	mov    (%edx),%eax
40032eff:	89 41 60             	mov    %eax,0x60(%ecx)
	}
}
40032f02:	5d                   	pop    %ebp
40032f03:	c3                   	ret    

40032f04 <handle_spi_overflow_interrupt>:
		controller->txftlr = 0;
	}
}

static void handle_spi_overflow_interrupt(const qm_spi_t spi)
{
40032f04:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
	const volatile qm_spi_async_transfer_t *transfer =
40032f05:	8b 0c 85 cc 69 00 a8 	mov    -0x57ff9634(,%eax,4),%ecx
{
40032f0c:	89 e5                	mov    %esp,%ebp
40032f0e:	56                   	push   %esi
40032f0f:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40032f10:	8b 1c 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%ebx
	    spi_async_transfer[spi];

	if (transfer->callback) {
40032f17:	8b 51 10             	mov    0x10(%ecx),%edx
40032f1a:	85 d2                	test   %edx,%edx
40032f1c:	74 1c                	je     40032f3a <handle_spi_overflow_interrupt+0x36>
		transfer->callback(transfer->callback_data, -EIO,
40032f1e:	8b 71 10             	mov    0x10(%ecx),%esi
				   QM_SPI_RX_OVERFLOW, rx_counter[spi]);
40032f21:	0f b7 94 00 bc 69 00 	movzwl -0x57ff9644(%eax,%eax,1),%edx
40032f28:	a8 
		transfer->callback(transfer->callback_data, -EIO,
40032f29:	8b 41 14             	mov    0x14(%ecx),%eax
40032f2c:	52                   	push   %edx
40032f2d:	b9 02 00 00 00       	mov    $0x2,%ecx
40032f32:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
40032f37:	ff d6                	call   *%esi
40032f39:	58                   	pop    %eax
	}

	/* Clear RX FIFO Overflow interrupt. */
	controller->rxoicr;
40032f3a:	8b 43 3c             	mov    0x3c(%ebx),%eax
	controller->imr = QM_SPI_IMR_MASK_ALL;
40032f3d:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	controller->ssienr = 0;
40032f44:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
40032f4b:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032f4e:	5b                   	pop    %ebx
40032f4f:	5e                   	pop    %esi
40032f50:	5d                   	pop    %ebp
40032f51:	c3                   	ret    

40032f52 <handle_spi_mst_interrupt>:

static void handle_spi_mst_interrupt(const qm_spi_t spi)
{
40032f52:	55                   	push   %ebp
40032f53:	89 e5                	mov    %esp,%ebp
40032f55:	57                   	push   %edi
40032f56:	56                   	push   %esi
40032f57:	53                   	push   %ebx
40032f58:	83 ec 0c             	sub    $0xc,%esp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40032f5b:	8b 3c 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%edi
40032f62:	89 7d f0             	mov    %edi,-0x10(%ebp)
	const volatile qm_spi_async_transfer_t *transfer =
	    spi_async_transfer[spi];
	const uint32_t int_status = controller->isr;
40032f65:	8b 4f 30             	mov    0x30(%edi),%ecx
40032f68:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	QM_ASSERT((int_status & (QM_SPI_ISR_TXOIS | QM_SPI_ISR_RXUIS)) == 0);

	/* RX FIFO Overflow interrupt. */
	if (int_status & QM_SPI_ISR_RXOIS) {
40032f6b:	80 e1 08             	and    $0x8,%cl
40032f6e:	74 0c                	je     40032f7c <handle_spi_mst_interrupt+0x2a>

	if (int_status & QM_SPI_ISR_TXEIS &&
	    transfer->tx_len > tx_counter[spi]) {
		handle_mst_tx_interrupt(spi);
	}
}
40032f70:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032f73:	5b                   	pop    %ebx
40032f74:	5e                   	pop    %esi
40032f75:	5f                   	pop    %edi
40032f76:	5d                   	pop    %ebp
		handle_spi_overflow_interrupt(spi);
40032f77:	e9 88 ff ff ff       	jmp    40032f04 <handle_spi_overflow_interrupt>
40032f7c:	89 c3                	mov    %eax,%ebx
	const volatile qm_spi_async_transfer_t *transfer =
40032f7e:	8b 34 85 cc 69 00 a8 	mov    -0x57ff9634(,%eax,4),%esi
	if (int_status & QM_SPI_ISR_RXFIS) {
40032f85:	f6 45 ec 10          	testb  $0x10,-0x14(%ebp)
40032f89:	0f 84 b6 00 00 00    	je     40033045 <handle_spi_mst_interrupt+0xf3>
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40032f8f:	8b 56 04             	mov    0x4(%esi),%edx
40032f92:	0f b7 8c 00 bc 69 00 	movzwl -0x57ff9644(%eax,%eax,1),%ecx
40032f99:	a8 
40032f9a:	0f b6 80 b8 69 00 a8 	movzbl -0x57ff9648(%eax),%eax
40032fa1:	0f af c8             	imul   %eax,%ecx
		rx_buffer += dfs[spi];
40032fa4:	89 c7                	mov    %eax,%edi
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40032fa6:	01 d1                	add    %edx,%ecx
	while (controller->rxflr) {
40032fa8:	8b 45 f0             	mov    -0x10(%ebp),%eax
40032fab:	8b 40 24             	mov    0x24(%eax),%eax
40032fae:	85 c0                	test   %eax,%eax
40032fb0:	74 77                	je     40033029 <handle_spi_mst_interrupt+0xd7>
		read_frame(spi, rx_buffer);
40032fb2:	89 ca                	mov    %ecx,%edx
40032fb4:	89 d8                	mov    %ebx,%eax
40032fb6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40032fb9:	e8 f2 fe ff ff       	call   40032eb0 <read_frame>
		rx_counter[spi]++;
40032fbe:	66 8b 84 1b bc 69 00 	mov    -0x57ff9644(%ebx,%ebx,1),%ax
40032fc5:	a8 
40032fc6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40032fc9:	40                   	inc    %eax
40032fca:	01 f9                	add    %edi,%ecx
40032fcc:	66 89 84 1b bc 69 00 	mov    %ax,-0x57ff9644(%ebx,%ebx,1)
40032fd3:	a8 
		if (transfer->rx_len == rx_counter[spi]) {
40032fd4:	66 8b 56 0a          	mov    0xa(%esi),%dx
40032fd8:	66 8b 84 1b bc 69 00 	mov    -0x57ff9644(%ebx,%ebx,1),%ax
40032fdf:	a8 
40032fe0:	66 39 c2             	cmp    %ax,%dx
40032fe3:	75 c3                	jne    40032fa8 <handle_spi_mst_interrupt+0x56>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40032fe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
			if (tmode[spi] == QM_SPI_TMOD_RX) {
40032fe8:	83 3c 9d ac 69 00 a8 	cmpl   $0x2,-0x57ff9654(,%ebx,4)
40032fef:	02 
40032ff0:	75 2b                	jne    4003301d <handle_spi_mst_interrupt+0xcb>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40032ff2:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				controller->ssienr = 0;
40032ff9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				if (transfer->callback) {
40033000:	8b 46 10             	mov    0x10(%esi),%eax
40033003:	85 c0                	test   %eax,%eax
40033005:	74 22                	je     40033029 <handle_spi_mst_interrupt+0xd7>
					transfer->callback(
40033007:	8b 46 10             	mov    0x10(%esi),%eax
4003300a:	31 c9                	xor    %ecx,%ecx
					    QM_SPI_IDLE, transfer->rx_len);
4003300c:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
					transfer->callback(
40033010:	89 c7                	mov    %eax,%edi
40033012:	8b 46 14             	mov    0x14(%esi),%eax
40033015:	52                   	push   %edx
40033016:	31 d2                	xor    %edx,%edx
40033018:	ff d7                	call   *%edi
4003301a:	5a                   	pop    %edx
4003301b:	eb 0c                	jmp    40033029 <handle_spi_mst_interrupt+0xd7>
				controller->imr &=
4003301d:	8b 40 2c             	mov    0x2c(%eax),%eax
40033020:	8b 7d f0             	mov    -0x10(%ebp),%edi
40033023:	83 e0 e3             	and    $0xffffffe3,%eax
40033026:	89 47 2c             	mov    %eax,0x2c(%edi)
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40033029:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (frames_left <= controller->rxftlr) {
4003302d:	8b 7d f0             	mov    -0x10(%ebp),%edi
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40033030:	0f b7 94 1b bc 69 00 	movzwl -0x57ff9644(%ebx,%ebx,1),%edx
40033037:	a8 
40033038:	29 d0                	sub    %edx,%eax
	if (frames_left <= controller->rxftlr) {
4003303a:	8b 57 1c             	mov    0x1c(%edi),%edx
4003303d:	39 d0                	cmp    %edx,%eax
4003303f:	77 04                	ja     40033045 <handle_spi_mst_interrupt+0xf3>
		controller->rxftlr = frames_left - 1;
40033041:	48                   	dec    %eax
40033042:	89 47 1c             	mov    %eax,0x1c(%edi)
	if (transfer->rx_len == rx_counter[spi] &&
40033045:	66 8b 56 0a          	mov    0xa(%esi),%dx
40033049:	66 8b 84 1b bc 69 00 	mov    -0x57ff9644(%ebx,%ebx,1),%ax
40033050:	a8 
40033051:	66 39 c2             	cmp    %ax,%dx
40033054:	75 66                	jne    400330bc <handle_spi_mst_interrupt+0x16a>
	    transfer->tx_len == tx_counter[spi] &&
40033056:	66 8b 56 08          	mov    0x8(%esi),%dx
4003305a:	66 8b 84 1b c4 69 00 	mov    -0x57ff963c(%ebx,%ebx,1),%ax
40033061:	a8 
	if (transfer->rx_len == rx_counter[spi] &&
40033062:	66 39 c2             	cmp    %ax,%dx
40033065:	75 55                	jne    400330bc <handle_spi_mst_interrupt+0x16a>
	    (controller->sr & QM_SPI_SR_TFE) &&
40033067:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003306a:	8b 40 28             	mov    0x28(%eax),%eax
	    transfer->tx_len == tx_counter[spi] &&
4003306d:	a8 04                	test   $0x4,%al
4003306f:	74 4b                	je     400330bc <handle_spi_mst_interrupt+0x16a>
	    !(controller->sr & QM_SPI_SR_BUSY)) {
40033071:	8b 45 f0             	mov    -0x10(%ebp),%eax
40033074:	8b 40 28             	mov    0x28(%eax),%eax
	    (controller->sr & QM_SPI_SR_TFE) &&
40033077:	a8 01                	test   $0x1,%al
40033079:	75 41                	jne    400330bc <handle_spi_mst_interrupt+0x16a>
		controller->imr = QM_SPI_IMR_MASK_ALL;
4003307b:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003307e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
		controller->ssienr = 0;
40033085:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (transfer->callback && tmode[spi] != QM_SPI_TMOD_RX) {
4003308c:	8b 46 10             	mov    0x10(%esi),%eax
4003308f:	85 c0                	test   %eax,%eax
40033091:	0f 84 bd 00 00 00    	je     40033154 <handle_spi_mst_interrupt+0x202>
40033097:	83 3c 9d ac 69 00 a8 	cmpl   $0x2,-0x57ff9654(,%ebx,4)
4003309e:	02 
4003309f:	0f 84 af 00 00 00    	je     40033154 <handle_spi_mst_interrupt+0x202>
			transfer->callback(transfer->callback_data, 0,
400330a5:	8b 5e 10             	mov    0x10(%esi),%ebx
400330a8:	31 c9                	xor    %ecx,%ecx
					   QM_SPI_IDLE, transfer->tx_len);
400330aa:	0f b7 56 08          	movzwl 0x8(%esi),%edx
			transfer->callback(transfer->callback_data, 0,
400330ae:	8b 46 14             	mov    0x14(%esi),%eax
400330b1:	52                   	push   %edx
400330b2:	31 d2                	xor    %edx,%edx
400330b4:	ff d3                	call   *%ebx
400330b6:	58                   	pop    %eax
400330b7:	e9 98 00 00 00       	jmp    40033154 <handle_spi_mst_interrupt+0x202>
	if (int_status & QM_SPI_ISR_TXEIS &&
400330bc:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
400330c0:	0f 84 8e 00 00 00    	je     40033154 <handle_spi_mst_interrupt+0x202>
	    transfer->tx_len > tx_counter[spi]) {
400330c6:	66 8b 56 08          	mov    0x8(%esi),%dx
400330ca:	66 8b 84 1b c4 69 00 	mov    -0x57ff963c(%ebx,%ebx,1),%ax
400330d1:	a8 
	if (int_status & QM_SPI_ISR_TXEIS &&
400330d2:	66 39 c2             	cmp    %ax,%dx
400330d5:	76 7d                	jbe    40033154 <handle_spi_mst_interrupt+0x202>
	const volatile qm_spi_async_transfer_t *const transfer =
400330d7:	8b 0c 9d cc 69 00 a8 	mov    -0x57ff9634(,%ebx,4),%ecx
	qm_spi_reg_t *const controller = QM_SPI[spi];
400330de:	8b 3c 9d 10 67 00 a8 	mov    -0x57ff98f0(,%ebx,4),%edi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
400330e5:	0f b6 93 b8 69 00 a8 	movzbl -0x57ff9648(%ebx),%edx
400330ec:	8b 31                	mov    (%ecx),%esi
		tx_buffer += dfs[spi];
400330ee:	89 55 ec             	mov    %edx,-0x14(%ebp)
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
400330f1:	0f b7 84 1b c4 69 00 	movzwl -0x57ff963c(%ebx,%ebx,1),%eax
400330f8:	a8 
400330f9:	0f af c2             	imul   %edx,%eax
400330fc:	01 f0                	add    %esi,%eax
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
400330fe:	8b 77 20             	mov    0x20(%edi),%esi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40033101:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40033104:	8b 47 24             	mov    0x24(%edi),%eax
40033107:	01 f0                	add    %esi,%eax
40033109:	be 07 00 00 00       	mov    $0x7,%esi
4003310e:	29 c6                	sub    %eax,%esi
	while (frames > 0) {
40033110:	85 f6                	test   %esi,%esi
40033112:	7e 40                	jle    40033154 <handle_spi_mst_interrupt+0x202>
		write_frame(spi, tx_buffer);
40033114:	8b 55 f0             	mov    -0x10(%ebp),%edx
40033117:	89 d8                	mov    %ebx,%eax
40033119:	89 4d e8             	mov    %ecx,-0x18(%ebp)
4003311c:	e8 ba fd ff ff       	call   40032edb <write_frame>
		tx_counter[spi]++;
40033121:	66 8b 84 1b c4 69 00 	mov    -0x57ff963c(%ebx,%ebx,1),%ax
40033128:	a8 
40033129:	8b 4d ec             	mov    -0x14(%ebp),%ecx
4003312c:	40                   	inc    %eax
4003312d:	01 4d f0             	add    %ecx,-0x10(%ebp)
		if (transfer->tx_len == tx_counter[spi]) {
40033130:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		tx_counter[spi]++;
40033133:	66 89 84 1b c4 69 00 	mov    %ax,-0x57ff963c(%ebx,%ebx,1)
4003313a:	a8 
		frames--;
4003313b:	4e                   	dec    %esi
		if (transfer->tx_len == tx_counter[spi]) {
4003313c:	66 8b 51 08          	mov    0x8(%ecx),%dx
40033140:	66 8b 84 1b c4 69 00 	mov    -0x57ff963c(%ebx,%ebx,1),%ax
40033147:	a8 
40033148:	66 39 c2             	cmp    %ax,%dx
4003314b:	75 c3                	jne    40033110 <handle_spi_mst_interrupt+0x1be>
			controller->txftlr = 0;
4003314d:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
}
40033154:	8d 65 f4             	lea    -0xc(%ebp),%esp
40033157:	5b                   	pop    %ebx
40033158:	5e                   	pop    %esi
40033159:	5f                   	pop    %edi
4003315a:	5d                   	pop    %ebp
4003315b:	c3                   	ret    

4003315c <qm_spi_set_config>:
		handle_slv_tx_interrupt(spi);
	}
}

int qm_spi_set_config(const qm_spi_t spi, const qm_spi_config_t *cfg)
{
4003315c:	55                   	push   %ebp
4003315d:	89 e5                	mov    %esp,%ebp
4003315f:	57                   	push   %edi
40033160:	56                   	push   %esi
40033161:	53                   	push   %ebx
40033162:	51                   	push   %ecx
	QM_CHECK(QM_SPI_SLV_0 == spi
		     ? cfg->transfer_mode != QM_SPI_TMOD_EEPROM_READ
		     : 1,
		 -EINVAL);

	if (0 != QM_SPI[spi]->ssienr) {
40033163:	8b 34 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%esi
4003316a:	8b 4e 08             	mov    0x8(%esi),%ecx
4003316d:	85 c9                	test   %ecx,%ecx
4003316f:	75 4d                	jne    400331be <qm_spi_set_config+0x62>
	}

	qm_spi_reg_t *const controller = QM_SPI[spi];

	/* Apply the selected cfg options. */
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40033171:	8b 3a                	mov    (%edx),%edi
40033173:	89 7d f0             	mov    %edi,-0x10(%ebp)
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40033176:	8b 7a 04             	mov    0x4(%edx),%edi
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40033179:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
4003317c:	89 f9                	mov    %edi,%ecx
4003317e:	c1 e1 08             	shl    $0x8,%ecx
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40033181:	c1 e3 10             	shl    $0x10,%ebx
40033184:	09 cb                	or     %ecx,%ebx
			     (cfg->bus_mode << QM_SPI_CTRLR0_SCPOL_SCPH_OFFSET);
40033186:	8b 4a 08             	mov    0x8(%edx),%ecx
40033189:	c1 e1 06             	shl    $0x6,%ecx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
4003318c:	09 cb                	or     %ecx,%ebx

	/*
	 * If the device is configured as a slave, an external master will
	 * set the baud rate.
	 */
	if (QM_SPI_SLV_0 != spi) {
4003318e:	83 f8 02             	cmp    $0x2,%eax
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40033191:	89 1e                	mov    %ebx,(%esi)
	if (QM_SPI_SLV_0 != spi) {
40033193:	74 07                	je     4003319c <qm_spi_set_config+0x40>
		controller->baudr = cfg->clk_divider;
40033195:	0f b7 5a 10          	movzwl 0x10(%edx),%ebx
40033199:	89 5e 14             	mov    %ebx,0x14(%esi)
	 * - 1 byte for DFS set from 4 to 8 bits;
	 * - 2 bytes for DFS set from 9 to 16 bits;
	 * - 3 bytes for DFS set from 17 to 24 bits;
	 * - 4 bytes for DFS set from 25 to 32 bits.
	 */
	dfs[spi] = (cfg->frame_size / 8) + 1;
4003319c:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	tmode[spi] = cfg->transfer_mode;
	frf[spi] = cfg->frame_format;
4003319f:	8b 52 0c             	mov    0xc(%edx),%edx
	dfs[spi] = (cfg->frame_size / 8) + 1;
400331a2:	c1 e9 03             	shr    $0x3,%ecx
	tmode[spi] = cfg->transfer_mode;
400331a5:	89 3c 85 ac 69 00 a8 	mov    %edi,-0x57ff9654(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
400331ac:	41                   	inc    %ecx
	frf[spi] = cfg->frame_format;
400331ad:	89 14 85 a0 69 00 a8 	mov    %edx,-0x57ff9660(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
400331b4:	88 88 b8 69 00 a8    	mov    %cl,-0x57ff9648(%eax)

	return 0;
400331ba:	31 c0                	xor    %eax,%eax
400331bc:	eb 05                	jmp    400331c3 <qm_spi_set_config+0x67>
		return -EBUSY;
400331be:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
400331c3:	5a                   	pop    %edx
400331c4:	5b                   	pop    %ebx
400331c5:	5e                   	pop    %esi
400331c6:	5f                   	pop    %edi
400331c7:	5d                   	pop    %ebp
400331c8:	c3                   	ret    

400331c9 <qm_spi_slave_select>:
int qm_spi_slave_select(const qm_spi_t spi, const qm_spi_slave_select_t ss)
{
	QM_CHECK((spi < QM_SPI_NUM) && (spi != QM_SPI_SLV_0), -EINVAL);

	/* Check if the device reports as busy. */
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
400331c9:	8b 04 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%eax
{
400331d0:	55                   	push   %ebp
400331d1:	89 e5                	mov    %esp,%ebp
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
400331d3:	8b 48 28             	mov    0x28(%eax),%ecx
400331d6:	80 e1 01             	and    $0x1,%cl
400331d9:	75 07                	jne    400331e2 <qm_spi_slave_select+0x19>
		return -EBUSY;
	}

	QM_SPI[spi]->ser = ss;
400331db:	89 50 10             	mov    %edx,0x10(%eax)

	return 0;
400331de:	31 c0                	xor    %eax,%eax
400331e0:	eb 05                	jmp    400331e7 <qm_spi_slave_select+0x1e>
		return -EBUSY;
400331e2:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
400331e7:	5d                   	pop    %ebp
400331e8:	c3                   	ret    

400331e9 <qm_spi_irq_update>:
}

int qm_spi_irq_update(const qm_spi_t spi,
		      const volatile qm_spi_async_transfer_t *const xfer,
		      const qm_spi_update_t update)
{
400331e9:	55                   	push   %ebp
	QM_CHECK((update & QM_SPI_UPDATE_RX) ? (tmode[spi] != QM_SPI_TMOD_TX)
					     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
	spi_async_transfer[spi] = xfer;
400331ea:	89 14 85 cc 69 00 a8 	mov    %edx,-0x57ff9634(,%eax,4)
{
400331f1:	89 e5                	mov    %esp,%ebp

	if (update == QM_SPI_UPDATE_RX) {
400331f3:	83 f9 01             	cmp    $0x1,%ecx
{
400331f6:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
400331f7:	8b 1c 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%ebx
	if (update == QM_SPI_UPDATE_RX) {
400331fe:	75 13                	jne    40033213 <qm_spi_irq_update+0x2a>
		rx_counter[spi] = 0;
40033200:	66 c7 84 00 bc 69 00 	movw   $0x0,-0x57ff9644(%eax,%eax,1)
40033207:	a8 00 00 
		/* Unmask RX interrupt sources. */
		controller->imr =
4003320a:	c7 43 2c 1c 00 00 00 	movl   $0x1c,0x2c(%ebx)
40033211:	eb 33                	jmp    40033246 <qm_spi_irq_update+0x5d>
		    QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM | QM_SPI_IMR_RXFIM;
	} else if (update == QM_SPI_UPDATE_TX) {
40033213:	83 f9 02             	cmp    $0x2,%ecx
40033216:	75 13                	jne    4003322b <qm_spi_irq_update+0x42>
		tx_counter[spi] = 0;
40033218:	66 c7 84 00 c4 69 00 	movw   $0x0,-0x57ff963c(%eax,%eax,1)
4003321f:	a8 00 00 
		/* Unmask TX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM;
40033222:	c7 43 2c 03 00 00 00 	movl   $0x3,0x2c(%ebx)
40033229:	eb 1b                	jmp    40033246 <qm_spi_irq_update+0x5d>
	} else {
		rx_counter[spi] = 0;
4003322b:	66 c7 84 00 bc 69 00 	movw   $0x0,-0x57ff9644(%eax,%eax,1)
40033232:	a8 00 00 
		tx_counter[spi] = 0;
40033235:	66 c7 84 00 c4 69 00 	movw   $0x0,-0x57ff963c(%eax,%eax,1)
4003323c:	a8 00 00 
		/* Unmask both TX and RX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM |
4003323f:	c7 43 2c 1f 00 00 00 	movl   $0x1f,0x2c(%ebx)
				  QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM |
				  QM_SPI_IMR_RXFIM;
	}

	return 0;
}
40033246:	31 c0                	xor    %eax,%eax
40033248:	5b                   	pop    %ebx
40033249:	5d                   	pop    %ebp
4003324a:	c3                   	ret    

4003324b <qm_spi_irq_transfer>:

int qm_spi_irq_transfer(const qm_spi_t spi,
			const volatile qm_spi_async_transfer_t *const xfer)
{
4003324b:	55                   	push   %ebp
4003324c:	89 e5                	mov    %esp,%ebp
4003324e:	57                   	push   %edi
4003324f:	56                   	push   %esi
40033250:	53                   	push   %ebx
40033251:	51                   	push   %ecx
40033252:	89 c3                	mov    %eax,%ebx
	QM_CHECK(tmode[spi] == QM_SPI_TMOD_TX_RX
		     ? (xfer->tx_len == xfer->rx_len)
		     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
40033254:	8b 34 85 10 67 00 a8 	mov    -0x57ff98f0(,%eax,4),%esi

	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
4003325b:	8b 04 85 ac 69 00 a8 	mov    -0x57ff9654(,%eax,4),%eax
40033262:	89 45 f0             	mov    %eax,-0x10(%ebp)
40033265:	83 e8 02             	sub    $0x2,%eax
40033268:	83 f8 01             	cmp    $0x1,%eax
{
4003326b:	89 d7                	mov    %edx,%edi
	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
4003326d:	0f 96 c1             	setbe  %cl
40033270:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40033274:	0f 94 c0             	sete   %al
	qm_spi_update_t update = 0;
40033277:	09 c1                	or     %eax,%ecx
40033279:	0f b6 c9             	movzbl %cl,%ecx
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_RX;
	}
	if ((tmode[spi] == QM_SPI_TMOD_TX) ||
4003327c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
40033280:	76 06                	jbe    40033288 <qm_spi_irq_transfer+0x3d>
40033282:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
40033286:	75 03                	jne    4003328b <qm_spi_irq_transfer+0x40>
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_TX;
40033288:	83 c9 02             	or     $0x2,%ecx
	}

	rx_counter[spi] = 0;
	tx_counter[spi] = 0;
	qm_spi_irq_update(spi, xfer, update);
4003328b:	89 fa                	mov    %edi,%edx
4003328d:	89 d8                	mov    %ebx,%eax
	rx_counter[spi] = 0;
4003328f:	66 c7 84 1b bc 69 00 	movw   $0x0,-0x57ff9644(%ebx,%ebx,1)
40033296:	a8 00 00 
	tx_counter[spi] = 0;
40033299:	66 c7 84 1b c4 69 00 	movw   $0x0,-0x57ff963c(%ebx,%ebx,1)
400332a0:	a8 00 00 
	qm_spi_irq_update(spi, xfer, update);
400332a3:	e8 41 ff ff ff       	call   400331e9 <qm_spi_irq_update>
		 * holds how many bytes the controller solicits, minus 1.
		 * We also set the same into rxftlr, so the controller only
		 * triggers a RX_FIFO_FULL interrupt when all frames are
		 * available at the FIFO for consumption.
		 */
		if (xfer->rx_len) {
400332a8:	66 8b 47 0a          	mov    0xa(%edi),%ax
	if (QM_SPI_SLV_0 != spi) {
400332ac:	83 fb 02             	cmp    $0x2,%ebx
400332af:	74 2d                	je     400332de <qm_spi_irq_transfer+0x93>
		if (xfer->rx_len) {
400332b1:	66 85 c0             	test   %ax,%ax
400332b4:	74 1f                	je     400332d5 <qm_spi_irq_transfer+0x8a>
			controller->ctrlr1 = xfer->rx_len - 1;
400332b6:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
400332ba:	48                   	dec    %eax
400332bb:	89 46 04             	mov    %eax,0x4(%esi)
400332be:	b8 05 00 00 00       	mov    $0x5,%eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
400332c3:	66 8b 57 0a          	mov    0xa(%edi),%dx
						 ? xfer->rx_len - 1
						 : SPI_MST_DEFAULT_RX_THRESHOLD;
400332c7:	66 83 fa 07          	cmp    $0x7,%dx
400332cb:	77 05                	ja     400332d2 <qm_spi_irq_transfer+0x87>
						 ? xfer->rx_len - 1
400332cd:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
400332d1:	48                   	dec    %eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
400332d2:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_MST_DEFAULT_TX_THRESHOLD;
400332d5:	c7 46 18 05 00 00 00 	movl   $0x5,0x18(%esi)
400332dc:	eb 35                	jmp    40033313 <qm_spi_irq_transfer+0xc8>
	} else {
		if (xfer->rx_len) {
400332de:	66 85 c0             	test   %ax,%ax
400332e1:	74 17                	je     400332fa <qm_spi_irq_transfer+0xaf>
			controller->rxftlr =
			    (xfer->rx_len < SPI_SLV_DEFAULT_RX_THRESHOLD)
400332e3:	66 8b 57 0a          	mov    0xa(%edi),%dx
400332e7:	b8 03 00 00 00       	mov    $0x3,%eax
				? xfer->rx_len - 1
				: SPI_SLV_DEFAULT_RX_THRESHOLD;
400332ec:	66 83 fa 02          	cmp    $0x2,%dx
400332f0:	77 05                	ja     400332f7 <qm_spi_irq_transfer+0xac>
				? xfer->rx_len - 1
400332f2:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
400332f6:	48                   	dec    %eax
			controller->rxftlr =
400332f7:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_SLV_DEFAULT_TX_THRESHOLD;
400332fa:	c7 46 18 04 00 00 00 	movl   $0x4,0x18(%esi)

		if (QM_SPI_TMOD_RX != tmode[spi]) {
40033301:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
			/* Enable MISO line. */
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40033305:	8b 06                	mov    (%esi),%eax
		if (QM_SPI_TMOD_RX != tmode[spi]) {
40033307:	74 05                	je     4003330e <qm_spi_irq_transfer+0xc3>
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40033309:	80 e4 fb             	and    $0xfb,%ah
4003330c:	eb 03                	jmp    40033311 <qm_spi_irq_transfer+0xc6>
		} else {
			/* Disable MISO line. */
			controller->ctrlr0 |= QM_SPI_CTRLR0_SLV_OE;
4003330e:	80 cc 04             	or     $0x4,%ah
40033311:	89 06                	mov    %eax,(%esi)
		}
	}

	/* Enable SPI controller. */
	controller->ssienr = QM_SPI_SSIENR_SSIENR;
40033313:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)

	if ((QM_SPI_SLV_0 != spi && QM_SPI_TMOD_RX == tmode[spi]) &&
4003331a:	83 fb 02             	cmp    $0x2,%ebx
4003331d:	74 20                	je     4003333f <qm_spi_irq_transfer+0xf4>
4003331f:	83 3c 9d ac 69 00 a8 	cmpl   $0x2,-0x57ff9654(,%ebx,4)
40033326:	02 
40033327:	75 16                	jne    4003333f <qm_spi_irq_transfer+0xf4>
40033329:	83 3c 9d a0 69 00 a8 	cmpl   $0x0,-0x57ff9660(,%ebx,4)
40033330:	00 
40033331:	75 0c                	jne    4003333f <qm_spi_irq_transfer+0xf4>
		/*
		 * In RX only, master is required to send
		 * a dummy frame in order to start the
		 * communication.
		 */
		write_frame(spi, (uint8_t *)&tx_dummy_frame);
40033333:	ba 30 bd 03 40       	mov    $0x4003bd30,%edx
40033338:	89 d8                	mov    %ebx,%eax
4003333a:	e8 9c fb ff ff       	call   40032edb <write_frame>
	}

	return 0;
}
4003333f:	5a                   	pop    %edx
40033340:	31 c0                	xor    %eax,%eax
40033342:	5b                   	pop    %ebx
40033343:	5e                   	pop    %esi
40033344:	5f                   	pop    %edi
40033345:	5d                   	pop    %ebp
40033346:	c3                   	ret    

40033347 <qm_spi_master_0_isr>:

QM_ISR_DECLARE(qm_spi_master_0_isr)
{
40033347:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40033348:	31 c0                	xor    %eax,%eax
{
4003334a:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_0_INT_VECTOR);
}
4003334c:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
4003334d:	e9 00 fc ff ff       	jmp    40032f52 <handle_spi_mst_interrupt>

40033352 <qm_spi_master_1_isr>:

#if (QUARK_SE)
QM_ISR_DECLARE(qm_spi_master_1_isr)
{
40033352:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40033353:	b8 01 00 00 00       	mov    $0x1,%eax
{
40033358:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_1_INT_VECTOR);
}
4003335a:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
4003335b:	e9 f2 fb ff ff       	jmp    40032f52 <handle_spi_mst_interrupt>

40033360 <qm_pmux_select>:
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
	return ((pin % (32 / width)) * width);
40033360:	89 c1                	mov    %eax,%ecx
}

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
40033362:	55                   	push   %ebp
	return (pin / (32 / width));
40033363:	c1 e8 04             	shr    $0x4,%eax
	return ((pin % (32 / width)) * width);
40033366:	83 e1 0f             	and    $0xf,%ecx
{
40033369:	89 e5                	mov    %esp,%ebp
	return ((pin % (32 / width)) * width);
4003336b:	01 c9                	add    %ecx,%ecx
{
4003336d:	56                   	push   %esi
4003336e:	53                   	push   %ebx
4003336f:	8d 1c 85 00 09 80 b0 	lea    -0x4f7ff700(,%eax,4),%ebx
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
	uint32_t offs = pin_to_offset(pin, 2);

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
40033376:	b8 03 00 00 00       	mov    $0x3,%eax
4003337b:	d3 e0                	shl    %cl,%eax
4003337d:	8b 73 30             	mov    0x30(%ebx),%esi
40033380:	f7 d0                	not    %eax
40033382:	21 f0                	and    %esi,%eax
40033384:	89 43 30             	mov    %eax,0x30(%ebx)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40033387:	8b 43 30             	mov    0x30(%ebx),%eax
4003338a:	d3 e2                	shl    %cl,%edx
4003338c:	09 c2                	or     %eax,%edx

	return 0;
}
4003338e:	31 c0                	xor    %eax,%eax
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40033390:	89 53 30             	mov    %edx,0x30(%ebx)
}
40033393:	5b                   	pop    %ebx
40033394:	5e                   	pop    %esi
40033395:	5d                   	pop    %ebp
40033396:	c3                   	ret    

40033397 <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
40033397:	55                   	push   %ebp
40033398:	89 c1                	mov    %eax,%ecx
4003339a:	89 e5                	mov    %esp,%ebp
4003339c:	53                   	push   %ebx
	return (pin / (32 / width));
4003339d:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
4003339f:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
400333a4:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400333a7:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
400333a9:	84 d2                	test   %dl,%dl
400333ab:	8d 14 9d 00 09 80 b0 	lea    -0x4f7ff700(,%ebx,4),%edx
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
400333b2:	8b 4a 20             	mov    0x20(%edx),%ecx
	if (enable == false) {
400333b5:	75 06                	jne    400333bd <qm_pmux_input_en+0x26>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
400333b7:	f7 d0                	not    %eax
400333b9:	21 c8                	and    %ecx,%eax
400333bb:	eb 02                	jmp    400333bf <qm_pmux_input_en+0x28>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
400333bd:	09 c8                	or     %ecx,%eax
400333bf:	89 42 20             	mov    %eax,0x20(%edx)
	}
	return 0;
}
400333c2:	31 c0                	xor    %eax,%eax
400333c4:	5b                   	pop    %ebx
400333c5:	5d                   	pop    %ebp
400333c6:	c3                   	ret    

400333c7 <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
400333c7:	55                   	push   %ebp
400333c8:	89 c1                	mov    %eax,%ecx
400333ca:	89 e5                	mov    %esp,%ebp
400333cc:	53                   	push   %ebx
	return (pin / (32 / width));
400333cd:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400333cf:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
400333d4:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400333d7:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
400333d9:	84 d2                	test   %dl,%dl
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
400333db:	8b 14 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edx
	if (enable == false) {
400333e2:	75 06                	jne    400333ea <qm_pmux_pullup_en+0x23>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
400333e4:	f7 d0                	not    %eax
400333e6:	21 d0                	and    %edx,%eax
400333e8:	eb 02                	jmp    400333ec <qm_pmux_pullup_en+0x25>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
400333ea:	09 d0                	or     %edx,%eax
400333ec:	89 04 9d 00 09 80 b0 	mov    %eax,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
400333f3:	31 c0                	xor    %eax,%eax
400333f5:	5b                   	pop    %ebx
400333f6:	5d                   	pop    %ebp
400333f7:	c3                   	ret    

400333f8 <mraa_init>:
mraa_board_t* plat = NULL;
struct _gpio _internalgpios[4];

mraa_result_t
mraa_init()
{
400333f8:	55                   	push   %ebp
400333f9:	89 e5                	mov    %esp,%ebp
#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
    plat = mraa_intel_arduino_101_sss();
#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
    plat = mraa_intel_d2k_crb();
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    plat = mraa_intel_quark_se_devboard();
400333fb:	e8 5a 06 00 00       	call   40033a5a <mraa_intel_quark_se_devboard>
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
    plat = mraa_intel_quark_se_ss_devboard();
printf("returned successfully from mraa init\n");
#endif
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
}
40033400:	5d                   	pop    %ebp
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40033401:	83 f8 01             	cmp    $0x1,%eax
    plat = mraa_intel_quark_se_devboard();
40033404:	a3 d8 69 00 a8       	mov    %eax,0xa80069d8
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40033409:	19 c0                	sbb    %eax,%eax
4003340b:	83 e0 06             	and    $0x6,%eax
}
4003340e:	c3                   	ret    

4003340f <mraa_setup_mux_mapped>:
    return false;
}

mraa_result_t
mraa_setup_mux_mapped(mraa_pin_t meta)
{
4003340f:	55                   	push   %ebp
    int mi;
    mraa_result_t ret;
    mraa_gpio_context mux_i = NULL;
    int last_pin = -1;
40033410:	83 c8 ff             	or     $0xffffffff,%eax
{
40033413:	89 e5                	mov    %esp,%ebp
40033415:	57                   	push   %edi
40033416:	56                   	push   %esi
40033417:	53                   	push   %ebx
40033418:	83 ec 08             	sub    $0x8,%esp
4003341b:	8d 7d 08             	lea    0x8(%ebp),%edi
    mraa_gpio_context mux_i = NULL;
4003341e:	31 db                	xor    %ebx,%ebx

    for (mi = 0; mi < meta.mux_total; mi++) {
40033420:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40033427:	0f b6 55 0a          	movzbl 0xa(%ebp),%edx
4003342b:	39 55 ec             	cmp    %edx,-0x14(%ebp)
4003342e:	0f 8d 8a 01 00 00    	jge    400335be <mraa_setup_mux_mapped+0x1af>

        switch (meta.mux[mi].pincmd) {
40033434:	80 7f 03 05          	cmpb   $0x5,0x3(%edi)
40033438:	0f 87 6f 01 00 00    	ja     400335ad <mraa_setup_mux_mapped+0x19e>
4003343e:	0f b6 57 03          	movzbl 0x3(%edi),%edx
40033442:	0f b6 77 04          	movzbl 0x4(%edi),%esi
                    return MRAA_ERROR_INVALID_RESOURCE;
                }
                break;

            case PINCMD_SET_MODE:
                if (meta.mux[mi].pin != last_pin) {
40033446:	89 75 f0             	mov    %esi,-0x10(%ebp)
40033449:	39 f0                	cmp    %esi,%eax
        switch (meta.mux[mi].pincmd) {
4003344b:	ff 24 95 34 bd 03 40 	jmp    *0x4003bd34(,%edx,4)
                if (meta.mux[mi].pin != last_pin) {
40033452:	74 2b                	je     4003347f <mraa_setup_mux_mapped+0x70>
                    if (mux_i != NULL) {
40033454:	85 db                	test   %ebx,%ebx
40033456:	74 10                	je     40033468 <mraa_setup_mux_mapped+0x59>
                        mraa_gpio_owner(mux_i, 0);
40033458:	31 d2                	xor    %edx,%edx
4003345a:	89 d8                	mov    %ebx,%eax
4003345c:	e8 98 04 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40033461:	89 d8                	mov    %ebx,%eax
40033463:	e8 ad 04 00 00       	call   40033915 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40033468:	89 f0                	mov    %esi,%eax
4003346a:	e8 ee 01 00 00       	call   4003365d <mraa_gpio_init_raw>
4003346f:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40033471:	85 c0                	test   %eax,%eax
40033473:	75 0a                	jne    4003347f <mraa_setup_mux_mapped+0x70>
                        return MRAA_ERROR_INVALID_HANDLE;
40033475:	b8 05 00 00 00       	mov    $0x5,%eax
4003347a:	e9 57 01 00 00       	jmp    400335d6 <mraa_setup_mux_mapped+0x1c7>
                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
4003347f:	31 d2                	xor    %edx,%edx
40033481:	89 d8                	mov    %ebx,%eax
40033483:	e8 03 03 00 00       	call   4003378b <mraa_gpio_dir>
40033488:	e9 c2 00 00 00       	jmp    4003354f <mraa_setup_mux_mapped+0x140>
                if (meta.mux[mi].pin != last_pin) {
4003348d:	0f 84 bc 00 00 00    	je     4003354f <mraa_setup_mux_mapped+0x140>
                    if (mux_i != NULL) {
40033493:	85 db                	test   %ebx,%ebx
40033495:	74 10                	je     400334a7 <mraa_setup_mux_mapped+0x98>
                        mraa_gpio_owner(mux_i, 0);
40033497:	31 d2                	xor    %edx,%edx
40033499:	89 d8                	mov    %ebx,%eax
4003349b:	e8 59 04 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400334a0:	89 d8                	mov    %ebx,%eax
400334a2:	e8 6e 04 00 00       	call   40033915 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400334a7:	89 f0                	mov    %esi,%eax
400334a9:	e8 af 01 00 00       	call   4003365d <mraa_gpio_init_raw>
400334ae:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400334b0:	85 c0                	test   %eax,%eax
400334b2:	0f 85 97 00 00 00    	jne    4003354f <mraa_setup_mux_mapped+0x140>
400334b8:	eb bb                	jmp    40033475 <mraa_setup_mux_mapped+0x66>
                if (meta.mux[mi].pin != last_pin) {
400334ba:	74 21                	je     400334dd <mraa_setup_mux_mapped+0xce>
                    if (mux_i != NULL) {
400334bc:	85 db                	test   %ebx,%ebx
400334be:	74 10                	je     400334d0 <mraa_setup_mux_mapped+0xc1>
                        mraa_gpio_owner(mux_i, 0);
400334c0:	31 d2                	xor    %edx,%edx
400334c2:	89 d8                	mov    %ebx,%eax
400334c4:	e8 30 04 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400334c9:	89 d8                	mov    %ebx,%eax
400334cb:	e8 45 04 00 00       	call   40033915 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400334d0:	89 f0                	mov    %esi,%eax
400334d2:	e8 86 01 00 00       	call   4003365d <mraa_gpio_init_raw>
400334d7:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400334d9:	85 c0                	test   %eax,%eax
400334db:	74 98                	je     40033475 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
400334dd:	0f b6 57 05          	movzbl 0x5(%edi),%edx
400334e1:	89 d8                	mov    %ebx,%eax
400334e3:	e8 a3 02 00 00       	call   4003378b <mraa_gpio_dir>
400334e8:	e9 a1 00 00 00       	jmp    4003358e <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
400334ed:	74 25                	je     40033514 <mraa_setup_mux_mapped+0x105>
                    if (mux_i != NULL) {
400334ef:	85 db                	test   %ebx,%ebx
400334f1:	74 10                	je     40033503 <mraa_setup_mux_mapped+0xf4>
                        mraa_gpio_owner(mux_i, 0);
400334f3:	31 d2                	xor    %edx,%edx
400334f5:	89 d8                	mov    %ebx,%eax
400334f7:	e8 fd 03 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400334fc:	89 d8                	mov    %ebx,%eax
400334fe:	e8 12 04 00 00       	call   40033915 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40033503:	89 f0                	mov    %esi,%eax
40033505:	e8 53 01 00 00       	call   4003365d <mraa_gpio_init_raw>
4003350a:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003350c:	85 c0                	test   %eax,%eax
4003350e:	0f 84 61 ff ff ff    	je     40033475 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
40033514:	ba 01 00 00 00       	mov    $0x1,%edx
40033519:	eb 29                	jmp    40033544 <mraa_setup_mux_mapped+0x135>
                if (meta.mux[mi].pin != last_pin) {
4003351b:	74 25                	je     40033542 <mraa_setup_mux_mapped+0x133>
                    if (mux_i != NULL) {
4003351d:	85 db                	test   %ebx,%ebx
4003351f:	74 10                	je     40033531 <mraa_setup_mux_mapped+0x122>
                        mraa_gpio_owner(mux_i, 0);
40033521:	31 d2                	xor    %edx,%edx
40033523:	89 d8                	mov    %ebx,%eax
40033525:	e8 cf 03 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003352a:	89 d8                	mov    %ebx,%eax
4003352c:	e8 e4 03 00 00       	call   40033915 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40033531:	89 f0                	mov    %esi,%eax
40033533:	e8 25 01 00 00       	call   4003365d <mraa_gpio_init_raw>
40033538:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003353a:	85 c0                	test   %eax,%eax
4003353c:	0f 84 33 ff ff ff    	je     40033475 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40033542:	31 d2                	xor    %edx,%edx
40033544:	89 d8                	mov    %ebx,%eax
40033546:	e8 40 02 00 00       	call   4003378b <mraa_gpio_dir>
                if (ret == MRAA_SUCCESS)
4003354b:	85 c0                	test   %eax,%eax
4003354d:	75 43                	jne    40033592 <mraa_setup_mux_mapped+0x183>
                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
4003354f:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40033553:	89 d8                	mov    %ebx,%eax
40033555:	e8 f4 02 00 00       	call   4003384e <mraa_gpio_write>
4003355a:	eb 32                	jmp    4003358e <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
4003355c:	74 25                	je     40033583 <mraa_setup_mux_mapped+0x174>
                    if (mux_i != NULL) {
4003355e:	85 db                	test   %ebx,%ebx
40033560:	74 10                	je     40033572 <mraa_setup_mux_mapped+0x163>
                        mraa_gpio_owner(mux_i, 0);
40033562:	31 d2                	xor    %edx,%edx
40033564:	89 d8                	mov    %ebx,%eax
40033566:	e8 8e 03 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003356b:	89 d8                	mov    %ebx,%eax
4003356d:	e8 a3 03 00 00       	call   40033915 <mraa_gpio_close>
                    }
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40033572:	89 f0                	mov    %esi,%eax
40033574:	e8 e4 00 00 00       	call   4003365d <mraa_gpio_init_raw>
40033579:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003357b:	85 c0                	test   %eax,%eax
4003357d:	0f 84 f2 fe ff ff    	je     40033475 <mraa_setup_mux_mapped+0x66>
                        return MRAA_ERROR_INVALID_HANDLE;
                    last_pin = meta.mux[mi].pin;
                }

                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
40033583:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40033587:	89 d8                	mov    %ebx,%eax
40033589:	e8 80 03 00 00       	call   4003390e <mraa_gpio_mode>

                if (ret != MRAA_SUCCESS) {
4003358e:	85 c0                	test   %eax,%eax
40033590:	74 1e                	je     400335b0 <mraa_setup_mux_mapped+0x1a1>
                    if (mux_i != NULL) {
40033592:	85 db                	test   %ebx,%ebx
40033594:	74 10                	je     400335a6 <mraa_setup_mux_mapped+0x197>
                        mraa_gpio_owner(mux_i, 0);
40033596:	31 d2                	xor    %edx,%edx
40033598:	89 d8                	mov    %ebx,%eax
4003359a:	e8 5a 03 00 00       	call   400338f9 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003359f:	89 d8                	mov    %ebx,%eax
400335a1:	e8 6f 03 00 00       	call   40033915 <mraa_gpio_close>
                    return MRAA_ERROR_INVALID_RESOURCE;
400335a6:	b8 07 00 00 00       	mov    $0x7,%eax
400335ab:	eb 29                	jmp    400335d6 <mraa_setup_mux_mapped+0x1c7>
        switch (meta.mux[mi].pincmd) {
400335ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (mi = 0; mi < meta.mux_total; mi++) {
400335b0:	ff 45 ec             	incl   -0x14(%ebp)
400335b3:	83 c7 03             	add    $0x3,%edi
400335b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
400335b9:	e9 69 fe ff ff       	jmp    40033427 <mraa_setup_mux_mapped+0x18>

    if (mux_i != NULL) {
        mraa_gpio_owner(mux_i, 0);
        mraa_gpio_close(mux_i);
    }
    return MRAA_SUCCESS;
400335be:	31 c0                	xor    %eax,%eax
    if (mux_i != NULL) {
400335c0:	85 db                	test   %ebx,%ebx
400335c2:	74 12                	je     400335d6 <mraa_setup_mux_mapped+0x1c7>
        mraa_gpio_owner(mux_i, 0);
400335c4:	31 d2                	xor    %edx,%edx
400335c6:	89 d8                	mov    %ebx,%eax
400335c8:	e8 2c 03 00 00       	call   400338f9 <mraa_gpio_owner>
        mraa_gpio_close(mux_i);
400335cd:	89 d8                	mov    %ebx,%eax
400335cf:	e8 41 03 00 00       	call   40033915 <mraa_gpio_close>
    return MRAA_SUCCESS;
400335d4:	31 c0                	xor    %eax,%eax
}
400335d6:	5a                   	pop    %edx
400335d7:	59                   	pop    %ecx
400335d8:	5b                   	pop    %ebx
400335d9:	5e                   	pop    %esi
400335da:	5f                   	pop    %edi
400335db:	5d                   	pop    %ebp
400335dc:	c3                   	ret    

400335dd <mraa_set_pininfo>:


// Internal functions
mraa_result_t
mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
{
400335dd:	55                   	push   %ebp
400335de:	89 e5                	mov    %esp,%ebp
400335e0:	53                   	push   %ebx
    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
    pin_info->gpio.pinmap = zephyr_pin;
400335e1:	6b da 44             	imul   $0x44,%edx,%ebx
#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB) || defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    pin_info->uart.pinmap = zephyr_pin;
#endif
    pin_info->pwm.pinmap = zephyr_pin;
    pin_info->gpio.mux_total = 0;
    pin_info->name = name;
400335e4:	42                   	inc    %edx
    pin_info->gpio.pinmap = zephyr_pin;
400335e5:	01 c3                	add    %eax,%ebx
    pin_info->name = name;
400335e7:	6b d2 44             	imul   $0x44,%edx,%edx
    pin_info->gpio.pinmap = zephyr_pin;
400335ea:	88 4b 4c             	mov    %cl,0x4c(%ebx)
    pin_info->uart.pinmap = zephyr_pin;
400335ed:	88 4b 7c             	mov    %cl,0x7c(%ebx)
    pin_info->pwm.pinmap = zephyr_pin;
400335f0:	88 4b 58             	mov    %cl,0x58(%ebx)
    pin_info->name = name;
400335f3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    pin_info->gpio.mux_total = 0;
400335f6:	c6 43 4e 00          	movb   $0x0,0x4e(%ebx)
    pin_info->name = name;
400335fa:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
    pin_info->capabilites = caps;
400335fd:	8a 45 0c             	mov    0xc(%ebp),%al
40033600:	88 43 48             	mov    %al,0x48(%ebx)
    return MRAA_SUCCESS;
}
40033603:	31 c0                	xor    %eax,%eax
40033605:	5b                   	pop    %ebx
40033606:	5d                   	pop    %ebp
40033607:	c3                   	ret    

40033608 <mraa_set_board_config>:


void
mraa_set_board_config(mraa_board_t* board)
{
40033608:	55                   	push   %ebp
    memset(board, 0, sizeof(mraa_board_t));
40033609:	b9 48 0d 00 00       	mov    $0xd48,%ecx
{
4003360e:	89 e5                	mov    %esp,%ebp
40033610:	53                   	push   %ebx
40033611:	89 c3                	mov    %eax,%ebx
    memset(board, 0, sizeof(mraa_board_t));
40033613:	31 d2                	xor    %edx,%edx
40033615:	e8 5b ca ff ff       	call   40030075 <memset>
    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
4003361a:	c6 03 31             	movb   $0x31,(%ebx)
    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
4003361d:	c6 43 01 1f          	movb   $0x1f,0x1(%ebx)
    board->aio_count = CONFIG_MRAA_AIO_COUNT;
40033621:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
40033625:	c6 43 03 02          	movb   $0x2,0x3(%ebx)
    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
40033629:	c6 43 0b 02          	movb   $0x2,0xb(%ebx)
    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
4003362d:	c6 43 1e 01          	movb   $0x1,0x1e(%ebx)
}
40033631:	5b                   	pop    %ebx
40033632:	5d                   	pop    %ebp
40033633:	c3                   	ret    

40033634 <gpio_pin_configure>:
{
40033634:	55                   	push   %ebp
40033635:	89 e5                	mov    %esp,%ebp
40033637:	53                   	push   %ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40033638:	8b 58 04             	mov    0x4(%eax),%ebx
4003363b:	51                   	push   %ecx
4003363c:	0f b6 d2             	movzbl %dl,%edx
4003363f:	89 d1                	mov    %edx,%ecx
40033641:	31 d2                	xor    %edx,%edx
40033643:	ff 13                	call   *(%ebx)
40033645:	5a                   	pop    %edx
}
40033646:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033649:	c9                   	leave  
4003364a:	c3                   	ret    

4003364b <gpio_internal_callback>:
 * ivan.briano: By design, use the callback_handler as a field in your
 *  struct and get it in the callback with container_of()
 */
static void
gpio_internal_callback(struct device* port, struct gpio_callback* cb, uint32_t pins)
{
4003364b:	55                   	push   %ebp
    mraa_gpio_context dev = CONTAINER_OF(cb, struct _gpio, zcallback);
    if (dev->isr != NULL)
4003364c:	8b 4a 10             	mov    0x10(%edx),%ecx
{
4003364f:	89 e5                	mov    %esp,%ebp
    if (dev->isr != NULL)
40033651:	85 c9                	test   %ecx,%ecx
40033653:	74 06                	je     4003365b <gpio_internal_callback+0x10>
        dev->isr(dev->isr_args);
40033655:	8b 42 14             	mov    0x14(%edx),%eax
}
40033658:	5d                   	pop    %ebp
        dev->isr(dev->isr_args);
40033659:	ff e1                	jmp    *%ecx
}
4003365b:	5d                   	pop    %ebp
4003365c:	c3                   	ret    

4003365d <mraa_gpio_init_raw>:
    return dev;
}

mraa_gpio_context
mraa_gpio_init_raw(int gpiopin)
{
4003365d:	55                   	push   %ebp
4003365e:	89 e5                	mov    %esp,%ebp
40033660:	56                   	push   %esi
40033661:	89 c6                	mov    %eax,%esi
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40033663:	b8 20 00 00 00       	mov    $0x20,%eax
{
40033668:	53                   	push   %ebx
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40033669:	e8 5e 74 00 00       	call   4003aacc <malloc>
4003366e:	89 c3                	mov    %eax,%ebx
    if (!dev) {
40033670:	85 c0                	test   %eax,%eax
40033672:	75 13                	jne    40033687 <mraa_gpio_init_raw+0x2a>
        printf("%s: context allocation failed\n", __FUNCTION__);
40033674:	68 18 be 03 40       	push   $0x4003be18
40033679:	68 4c bd 03 40       	push   $0x4003bd4c
4003367e:	e8 f5 75 00 00       	call   4003ac78 <iprintf>
40033683:	58                   	pop    %eax
40033684:	5a                   	pop    %edx
40033685:	eb 49                	jmp    400336d0 <mraa_gpio_init_raw+0x73>
        return NULL;
    }

    dev->phy_pin = gpiopin;
40033687:	89 f0                	mov    %esi,%eax
40033689:	88 43 01             	mov    %al,0x1(%ebx)
    dev->zdev = device_get_binding(GPIO_DRV_NAME);
4003368c:	b8 9f bc 03 40       	mov    $0x4003bc9f,%eax
40033691:	e8 70 64 00 00       	call   40039b06 <device_get_binding>
40033696:	89 43 04             	mov    %eax,0x4(%ebx)
//printf("GPIO : %s", GPIO_DRV_NAME);
    if (dev->zdev == NULL) {
40033699:	85 c0                	test   %eax,%eax
4003369b:	74 2a                	je     400336c7 <mraa_gpio_init_raw+0x6a>
        free(dev);
        return NULL;
    }
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
4003369d:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
400336a1:	b9 01 00 00 00       	mov    $0x1,%ecx
400336a6:	e8 89 ff ff ff       	call   40033634 <gpio_pin_configure>
    if (ret) {
400336ab:	85 c0                	test   %eax,%eax
400336ad:	74 21                	je     400336d0 <mraa_gpio_init_raw+0x73>
        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
400336af:	0f be 53 01          	movsbl 0x1(%ebx),%edx
400336b3:	52                   	push   %edx
400336b4:	68 9f bc 03 40       	push   $0x4003bc9f
400336b9:	50                   	push   %eax
400336ba:	68 6b bd 03 40       	push   $0x4003bd6b
400336bf:	e8 b4 75 00 00       	call   4003ac78 <iprintf>
400336c4:	83 c4 10             	add    $0x10,%esp
        free(dev);
400336c7:	89 d8                	mov    %ebx,%eax
        return NULL;
400336c9:	31 db                	xor    %ebx,%ebx
        free(dev);
400336cb:	e8 0c 74 00 00       	call   4003aadc <free>
    }
    return dev;
}
400336d0:	8d 65 f8             	lea    -0x8(%ebp),%esp
400336d3:	89 d8                	mov    %ebx,%eax
400336d5:	5b                   	pop    %ebx
400336d6:	5e                   	pop    %esi
400336d7:	5d                   	pop    %ebp
400336d8:	c3                   	ret    

400336d9 <mraa_gpio_init>:
{
400336d9:	55                   	push   %ebp
400336da:	89 e5                	mov    %esp,%ebp
400336dc:	57                   	push   %edi
400336dd:	56                   	push   %esi
400336de:	53                   	push   %ebx
400336df:	53                   	push   %ebx
    mraa_board_t* board = plat;
400336e0:	8b 15 d8 69 00 a8    	mov    0xa80069d8,%edx
    if (board == NULL) {
400336e6:	85 d2                	test   %edx,%edx
400336e8:	75 07                	jne    400336f1 <mraa_gpio_init+0x18>
        printf("gpio: platform not initialised\n");
400336ea:	68 8b bd 03 40       	push   $0x4003bd8b
400336ef:	eb 37                	jmp    40033728 <mraa_gpio_init+0x4f>
400336f1:	89 c3                	mov    %eax,%ebx
    if (pin < 0 || pin >= board->phy_pin_count) {
400336f3:	85 c0                	test   %eax,%eax
400336f5:	78 07                	js     400336fe <mraa_gpio_init+0x25>
400336f7:	0f b6 02             	movzbl (%edx),%eax
400336fa:	39 c3                	cmp    %eax,%ebx
400336fc:	7c 11                	jl     4003370f <mraa_gpio_init+0x36>
        printf("gpio: pin %i beyond platform definition\n", pin);
400336fe:	53                   	push   %ebx
400336ff:	68 ab bd 03 40       	push   $0x4003bdab
40033704:	e8 6f 75 00 00       	call   4003ac78 <iprintf>
40033709:	5a                   	pop    %edx
4003370a:	59                   	pop    %ecx
        return NULL;
4003370b:	31 c0                	xor    %eax,%eax
4003370d:	eb 74                	jmp    40033783 <mraa_gpio_init+0xaa>
    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
4003370f:	b8 a6 bc 03 40       	mov    $0x4003bca6,%eax
40033714:	89 55 f0             	mov    %edx,-0x10(%ebp)
40033717:	e8 ea 63 00 00       	call   40039b06 <device_get_binding>
    if (pinmux_dev == NULL) {
4003371c:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003371f:	85 c0                	test   %eax,%eax
40033721:	75 0d                	jne    40033730 <mraa_gpio_init+0x57>
        printf("Failed to get binding for pinmux\n");
40033723:	68 d4 bd 03 40       	push   $0x4003bdd4
40033728:	e8 4b 75 00 00       	call   4003ac78 <iprintf>
4003372d:	58                   	pop    %eax
4003372e:	eb db                	jmp    4003370b <mraa_gpio_init+0x32>
    if (board->pins[pin].capabilites.gpio != 1) {
40033730:	6b f3 44             	imul   $0x44,%ebx,%esi
40033733:	01 d6                	add    %edx,%esi
40033735:	f6 46 48 02          	testb  $0x2,0x48(%esi)
40033739:	75 08                	jne    40033743 <mraa_gpio_init+0x6a>
        printf("gpio: pin %i not capable of gpio\n", pin);
4003373b:	53                   	push   %ebx
4003373c:	68 f6 bd 03 40       	push   $0x4003bdf6
40033741:	eb c1                	jmp    40033704 <mraa_gpio_init+0x2b>
    if (board->pins[pin].gpio.mux_total > 0) {
40033743:	80 7e 4e 00          	cmpb   $0x0,0x4e(%esi)
40033747:	75 15                	jne    4003375e <mraa_gpio_init+0x85>
    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
40033749:	6b c3 44             	imul   $0x44,%ebx,%eax
4003374c:	0f b6 44 02 4c       	movzbl 0x4c(%edx,%eax,1),%eax
40033751:	e8 07 ff ff ff       	call   4003365d <mraa_gpio_init_raw>
    if (dev) {
40033756:	85 c0                	test   %eax,%eax
40033758:	74 29                	je     40033783 <mraa_gpio_init+0xaa>
        dev->pin = pin;
4003375a:	88 18                	mov    %bl,(%eax)
4003375c:	eb 25                	jmp    40033783 <mraa_gpio_init+0xaa>
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
4003375e:	83 ec 0c             	sub    $0xc,%esp
40033761:	83 c6 4c             	add    $0x4c,%esi
40033764:	89 e7                	mov    %esp,%edi
40033766:	b9 03 00 00 00       	mov    $0x3,%ecx
4003376b:	89 55 f0             	mov    %edx,-0x10(%ebp)
4003376e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40033770:	e8 9a fc ff ff       	call   4003340f <mraa_setup_mux_mapped>
40033775:	83 c4 0c             	add    $0xc,%esp
40033778:	89 c1                	mov    %eax,%ecx
4003377a:	8b 55 f0             	mov    -0x10(%ebp),%edx
            return NULL;
4003377d:	31 c0                	xor    %eax,%eax
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
4003377f:	85 c9                	test   %ecx,%ecx
40033781:	74 c6                	je     40033749 <mraa_gpio_init+0x70>
}
40033783:	8d 65 f4             	lea    -0xc(%ebp),%esp
40033786:	5b                   	pop    %ebx
40033787:	5e                   	pop    %esi
40033788:	5f                   	pop    %edi
40033789:	5d                   	pop    %ebp
4003378a:	c3                   	ret    

4003378b <mraa_gpio_dir>:

mraa_result_t
mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
{
4003378b:	55                   	push   %ebp
    int flags = 0;
    uint32_t value = 0;
    switch (dir) {
4003378c:	83 fa 01             	cmp    $0x1,%edx
{
4003378f:	89 e5                	mov    %esp,%ebp
40033791:	57                   	push   %edi
40033792:	56                   	push   %esi
40033793:	53                   	push   %ebx
    switch (dir) {
40033794:	74 0e                	je     400337a4 <mraa_gpio_dir+0x19>
40033796:	72 19                	jb     400337b1 <mraa_gpio_dir+0x26>
40033798:	83 fa 02             	cmp    $0x2,%edx
4003379b:	74 0d                	je     400337aa <mraa_gpio_dir+0x1f>
4003379d:	83 fa 03             	cmp    $0x3,%edx
400337a0:	75 52                	jne    400337f4 <mraa_gpio_dir+0x69>
400337a2:	eb 0d                	jmp    400337b1 <mraa_gpio_dir+0x26>
    uint32_t value = 0;
400337a4:	31 ff                	xor    %edi,%edi
        case MRAA_GPIO_OUT:
            flags = GPIO_DIR_OUT;
            break;
        case MRAA_GPIO_IN:
            flags = GPIO_DIR_IN;
400337a6:	31 c9                	xor    %ecx,%ecx
400337a8:	eb 0e                	jmp    400337b8 <mraa_gpio_dir+0x2d>
            break;
        case MRAA_GPIO_OUT_HIGH:
            flags = GPIO_DIR_OUT;
            value = 1;
400337aa:	bf 01 00 00 00       	mov    $0x1,%edi
400337af:	eb 02                	jmp    400337b3 <mraa_gpio_dir+0x28>
    uint32_t value = 0;
400337b1:	31 ff                	xor    %edi,%edi
            flags = GPIO_DIR_OUT;
400337b3:	b9 01 00 00 00       	mov    $0x1,%ecx
400337b8:	89 d3                	mov    %edx,%ebx
400337ba:	89 c6                	mov    %eax,%esi
            value = 0;
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }
    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
400337bc:	0f b6 50 01          	movzbl 0x1(%eax),%edx
400337c0:	8b 40 04             	mov    0x4(%eax),%eax
400337c3:	e8 6c fe ff ff       	call   40033634 <gpio_pin_configure>
400337c8:	85 c0                	test   %eax,%eax
400337ca:	74 07                	je     400337d3 <mraa_gpio_dir+0x48>
        return MRAA_ERROR_UNSPECIFIED;
400337cc:	b8 63 00 00 00       	mov    $0x63,%eax
400337d1:	eb 26                	jmp    400337f9 <mraa_gpio_dir+0x6e>
    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
400337d3:	83 eb 02             	sub    $0x2,%ebx
400337d6:	83 fb 01             	cmp    $0x1,%ebx
400337d9:	77 15                	ja     400337f0 <mraa_gpio_dir+0x65>
        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
400337db:	8b 46 04             	mov    0x4(%esi),%eax
	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
400337de:	31 d2                	xor    %edx,%edx
400337e0:	0f be 4e 01          	movsbl 0x1(%esi),%ecx
400337e4:	8b 58 04             	mov    0x4(%eax),%ebx
400337e7:	57                   	push   %edi
400337e8:	ff 53 04             	call   *0x4(%ebx)
400337eb:	5a                   	pop    %edx
400337ec:	85 c0                	test   %eax,%eax
400337ee:	75 dc                	jne    400337cc <mraa_gpio_dir+0x41>
            return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
400337f0:	31 c0                	xor    %eax,%eax
400337f2:	eb 05                	jmp    400337f9 <mraa_gpio_dir+0x6e>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
400337f4:	b8 01 00 00 00       	mov    $0x1,%eax
}
400337f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
400337fc:	5b                   	pop    %ebx
400337fd:	5e                   	pop    %esi
400337fe:	5f                   	pop    %edi
400337ff:	5d                   	pop    %ebp
40033800:	c3                   	ret    

40033801 <mraa_gpio_edge_mode>:


mraa_result_t
mraa_gpio_edge_mode(mraa_gpio_context dev, mraa_gpio_edge_t mode)
{
40033801:	55                   	push   %ebp
    switch (mode) {
40033802:	83 fa 01             	cmp    $0x1,%edx
{
40033805:	89 e5                	mov    %esp,%ebp
    switch (mode) {
40033807:	74 24                	je     4003382d <mraa_gpio_edge_mode+0x2c>
40033809:	72 16                	jb     40033821 <mraa_gpio_edge_mode+0x20>
4003380b:	83 fa 02             	cmp    $0x2,%edx
4003380e:	74 29                	je     40033839 <mraa_gpio_edge_mode+0x38>
40033810:	83 fa 03             	cmp    $0x3,%edx
40033813:	75 32                	jne    40033847 <mraa_gpio_edge_mode+0x46>
            break;
        case MRAA_GPIO_EDGE_RISING:
            edge_flags = GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH;
            break;
        case MRAA_GPIO_EDGE_FALLING:
            edge_flags = GPIO_INT_EDGE | GPIO_INT_ACTIVE_LOW;
40033815:	c7 05 dc 69 00 a8 20 	movl   $0x20,0xa80069dc
4003381c:	00 00 00 
4003381f:	eb 22                	jmp    40033843 <mraa_gpio_edge_mode+0x42>
            edge_flags = 0;
40033821:	c7 05 dc 69 00 a8 00 	movl   $0x0,0xa80069dc
40033828:	00 00 00 
4003382b:	eb 16                	jmp    40033843 <mraa_gpio_edge_mode+0x42>
            edge_flags = GPIO_INT_EDGE | GPIO_INT_DOUBLE_EDGE;
4003382d:	c7 05 dc 69 00 a8 60 	movl   $0x60,0xa80069dc
40033834:	00 00 00 
40033837:	eb 0a                	jmp    40033843 <mraa_gpio_edge_mode+0x42>
            edge_flags = GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH;
40033839:	c7 05 dc 69 00 a8 24 	movl   $0x24,0xa80069dc
40033840:	00 00 00 
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }

    return MRAA_SUCCESS;
40033843:	31 c0                	xor    %eax,%eax
            break;
40033845:	eb 05                	jmp    4003384c <mraa_gpio_edge_mode+0x4b>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
40033847:	b8 01 00 00 00       	mov    $0x1,%eax
}
4003384c:	5d                   	pop    %ebp
4003384d:	c3                   	ret    

4003384e <mraa_gpio_write>:
        return (int) value;
}

mraa_result_t
mraa_gpio_write(mraa_gpio_context dev, int value)
{
4003384e:	55                   	push   %ebp
4003384f:	89 e5                	mov    %esp,%ebp
40033851:	56                   	push   %esi
40033852:	53                   	push   %ebx
    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
40033853:	8b 58 04             	mov    0x4(%eax),%ebx
40033856:	0f be 48 01          	movsbl 0x1(%eax),%ecx
4003385a:	8b 73 04             	mov    0x4(%ebx),%esi
4003385d:	89 d8                	mov    %ebx,%eax
4003385f:	52                   	push   %edx
40033860:	31 d2                	xor    %edx,%edx
40033862:	ff 56 04             	call   *0x4(%esi)
40033865:	5a                   	pop    %edx
        return MRAA_ERROR_UNSPECIFIED;
    return MRAA_SUCCESS;
40033866:	83 f8 01             	cmp    $0x1,%eax
40033869:	19 c0                	sbb    %eax,%eax
}
4003386b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    return MRAA_SUCCESS;
4003386e:	f7 d0                	not    %eax
}
40033870:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40033871:	83 e0 63             	and    $0x63,%eax
}
40033874:	5e                   	pop    %esi
40033875:	5d                   	pop    %ebp
40033876:	c3                   	ret    

40033877 <mraa_gpio_isr>:


mraa_result_t
mraa_gpio_isr(mraa_gpio_context dev, mraa_gpio_edge_t edge_mode, void (*fptr)(void*), void* args)
{
40033877:	55                   	push   %ebp
40033878:	89 e5                	mov    %esp,%ebp
4003387a:	57                   	push   %edi
4003387b:	56                   	push   %esi
4003387c:	53                   	push   %ebx
4003387d:	89 c3                	mov    %eax,%ebx
    if (MRAA_SUCCESS != mraa_gpio_edge_mode(dev, edge_mode)) {
4003387f:	e8 7d ff ff ff       	call   40033801 <mraa_gpio_edge_mode>
40033884:	85 c0                	test   %eax,%eax
40033886:	74 07                	je     4003388f <mraa_gpio_isr+0x18>
        return MRAA_ERROR_UNSPECIFIED;
40033888:	be 63 00 00 00       	mov    $0x63,%esi
4003388d:	eb 63                	jmp    400338f2 <mraa_gpio_isr+0x7b>
4003388f:	89 cf                	mov    %ecx,%edi
    }
    int flags = GPIO_DIR_IN | GPIO_INT | GPIO_INT_DEBOUNCE | edge_flags;
40033891:	8b 0d dc 69 00 a8    	mov    0xa80069dc,%ecx
    // printf("isr addr = %x, args = %x\n", fptr, args);
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, flags);
40033897:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    int flags = GPIO_DIR_IN | GPIO_INT | GPIO_INT_DEBOUNCE | edge_flags;
4003389b:	83 c9 12             	or     $0x12,%ecx
4003389e:	89 c6                	mov    %eax,%esi
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, flags);
400338a0:	8b 43 04             	mov    0x4(%ebx),%eax
400338a3:	e8 8c fd ff ff       	call   40033634 <gpio_pin_configure>
    if (ret) {
400338a8:	85 c0                	test   %eax,%eax
400338aa:	75 dc                	jne    40033888 <mraa_gpio_isr+0x11>
        return MRAA_ERROR_UNSPECIFIED;
    }
    dev->isr = fptr;
    dev->isr_args = args;
400338ac:	8b 45 08             	mov    0x8(%ebp),%eax
    dev->isr = fptr;
400338af:	89 7b 18             	mov    %edi,0x18(%ebx)
    gpio_init_callback(&(dev->zcallback), gpio_internal_callback, BIT(dev->phy_pin));
400338b2:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
    dev->isr_args = args;
400338b6:	89 43 1c             	mov    %eax,0x1c(%ebx)
    gpio_init_callback(&(dev->zcallback), gpio_internal_callback, BIT(dev->phy_pin));
400338b9:	b8 01 00 00 00       	mov    $0x1,%eax
400338be:	d3 e0                	shl    %cl,%eax
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
	callback->pin_mask = pin_mask;
400338c0:	89 43 10             	mov    %eax,0x10(%ebx)
    ret = gpio_add_callback(dev->zdev, &(dev->zcallback));
400338c3:	8b 43 04             	mov    0x4(%ebx),%eax
	callback->handler = handler;
400338c6:	c7 43 0c 4b 36 03 40 	movl   $0x4003364b,0xc(%ebx)
    gpio_init_callback(&(dev->zcallback), gpio_internal_callback, BIT(dev->phy_pin));
400338cd:	8d 53 08             	lea    0x8(%ebx),%edx
{
	const struct gpio_driver_api *api = port->driver_api;

	__ASSERT(callback, "Callback pointer should not be NULL");

	return api->manage_callback(port, callback, true);
400338d0:	8b 78 04             	mov    0x4(%eax),%edi
400338d3:	b9 01 00 00 00       	mov    $0x1,%ecx
400338d8:	ff 57 0c             	call   *0xc(%edi)
    if (ret) {
400338db:	85 c0                	test   %eax,%eax
400338dd:	75 a9                	jne    40033888 <mraa_gpio_isr+0x11>
        return MRAA_ERROR_UNSPECIFIED;
    }
    ret = gpio_pin_enable_callback(dev->zdev, dev->phy_pin);
400338df:	8b 43 04             	mov    0x4(%ebx),%eax
 */
static inline int gpio_pin_enable_callback(struct device *port, uint32_t pin)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->enable_callback(port, GPIO_ACCESS_BY_PIN, pin);
400338e2:	31 d2                	xor    %edx,%edx
400338e4:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
400338e8:	8b 58 04             	mov    0x4(%eax),%ebx
400338eb:	ff 53 10             	call   *0x10(%ebx)
    if (ret) {
400338ee:	85 c0                	test   %eax,%eax
400338f0:	75 96                	jne    40033888 <mraa_gpio_isr+0x11>
        return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
}
400338f2:	5b                   	pop    %ebx
400338f3:	89 f0                	mov    %esi,%eax
400338f5:	5e                   	pop    %esi
400338f6:	5f                   	pop    %edi
400338f7:	5d                   	pop    %ebp
400338f8:	c3                   	ret    

400338f9 <mraa_gpio_owner>:
}


mraa_result_t
mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
{
400338f9:	55                   	push   %ebp
    if (dev == NULL) {
400338fa:	85 c0                	test   %eax,%eax
{
400338fc:	89 e5                	mov    %esp,%ebp
    if (dev == NULL) {
400338fe:	74 07                	je     40033907 <mraa_gpio_owner+0xe>
        return MRAA_ERROR_INVALID_RESOURCE;
    }
    dev->owner = own;
40033900:	88 50 14             	mov    %dl,0x14(%eax)
    return MRAA_SUCCESS;
40033903:	31 c0                	xor    %eax,%eax
40033905:	eb 05                	jmp    4003390c <mraa_gpio_owner+0x13>
        return MRAA_ERROR_INVALID_RESOURCE;
40033907:	b8 07 00 00 00       	mov    $0x7,%eax
}
4003390c:	5d                   	pop    %ebp
4003390d:	c3                   	ret    

4003390e <mraa_gpio_mode>:

mraa_result_t
mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
{
4003390e:	55                   	push   %ebp
    return MRAA_SUCCESS;
}
4003390f:	31 c0                	xor    %eax,%eax
{
40033911:	89 e5                	mov    %esp,%ebp
}
40033913:	5d                   	pop    %ebp
40033914:	c3                   	ret    

40033915 <mraa_gpio_close>:
    return dev->pin;
}

mraa_result_t
mraa_gpio_close(mraa_gpio_context dev)
{
40033915:	55                   	push   %ebp
40033916:	89 e5                	mov    %esp,%ebp
    free(dev);
40033918:	e8 bf 71 00 00       	call   4003aadc <free>

    return MRAA_SUCCESS;
}
4003391d:	31 c0                	xor    %eax,%eax
4003391f:	5d                   	pop    %ebp
40033920:	c3                   	ret    

40033921 <spi_configure>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
40033921:	55                   	push   %ebp
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
40033922:	8b 48 04             	mov    0x4(%eax),%ecx
{
40033925:	89 e5                	mov    %esp,%ebp
}
40033927:	5d                   	pop    %ebp
	return api->configure(dev, config);
40033928:	8b 09                	mov    (%ecx),%ecx
4003392a:	ff e1                	jmp    *%ecx

4003392c <spi_transceive>:
 * @retval Negative errno code if failure.
 */
static inline int spi_transceive(struct device *dev,
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
4003392c:	55                   	push   %ebp
4003392d:	89 e5                	mov    %esp,%ebp
4003392f:	53                   	push   %ebx
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
40033930:	8b 58 04             	mov    0x4(%eax),%ebx
40033933:	ff 75 0c             	pushl  0xc(%ebp)
40033936:	ff 75 08             	pushl  0x8(%ebp)
40033939:	ff 53 08             	call   *0x8(%ebx)
4003393c:	5a                   	pop    %edx
4003393d:	59                   	pop    %ecx
}
4003393e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033941:	c9                   	leave  
40033942:	c3                   	ret    

40033943 <mraa_spi_init>:

typedef struct spi_config* spi_config_ptr;

mraa_spi_context
mraa_spi_init(int bus)
{
40033943:	55                   	push   %ebp
40033944:	89 e5                	mov    %esp,%ebp
40033946:	56                   	push   %esi
40033947:	89 c6                	mov    %eax,%esi
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40033949:	b8 10 00 00 00       	mov    $0x10,%eax
{
4003394e:	53                   	push   %ebx
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
4003394f:	e8 78 71 00 00       	call   4003aacc <malloc>
40033954:	89 c3                	mov    %eax,%ebx
    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);

    dev->pinmux_dev = pinmux_dev;
#endif

    dev->busnum = bus;
40033956:	89 f0                	mov    %esi,%eax
40033958:	88 03                	mov    %al,(%ebx)
    dev->zdev = device_get_binding(SPI_DRV_NAME);
4003395a:	b8 92 bc 03 40       	mov    $0x4003bc92,%eax
4003395f:	e8 a2 61 00 00       	call   40039b06 <device_get_binding>
40033964:	89 43 08             	mov    %eax,0x8(%ebx)
    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
40033967:	b8 08 00 00 00       	mov    $0x8,%eax
4003396c:	e8 5b 71 00 00       	call   4003aacc <malloc>
40033971:	89 c6                	mov    %eax,%esi
    // only default settings, can be changed by using the other functions provided
    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
40033973:	c7 00 83 00 00 00    	movl   $0x83,(%eax)
    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
40033979:	c7 40 04 80 00 00 00 	movl   $0x80,0x4(%eax)
    dev->config = conf;

    if (spi_configure(dev->zdev, dev->config) != 0) {
40033980:	89 f2                	mov    %esi,%edx
    dev->config = conf;
40033982:	89 43 04             	mov    %eax,0x4(%ebx)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40033985:	8b 43 08             	mov    0x8(%ebx),%eax
40033988:	e8 94 ff ff ff       	call   40033921 <spi_configure>
4003398d:	85 c0                	test   %eax,%eax
4003398f:	74 1d                	je     400339ae <mraa_spi_init+0x6b>
        printf("Unable to configure the SPI Driver\n");
40033991:	68 2b be 03 40       	push   $0x4003be2b
40033996:	e8 dd 72 00 00       	call   4003ac78 <iprintf>
4003399b:	58                   	pop    %eax
        free(conf);
4003399c:	89 f0                	mov    %esi,%eax
4003399e:	e8 39 71 00 00       	call   4003aadc <free>
        free(dev);
400339a3:	89 d8                	mov    %ebx,%eax
400339a5:	e8 32 71 00 00       	call   4003aadc <free>
        return NULL;
400339aa:	31 db                	xor    %ebx,%ebx
400339ac:	eb 14                	jmp    400339c2 <mraa_spi_init+0x7f>
    }

    spi_slave_select(dev->zdev, SPI_SLAVE);
400339ae:	8b 43 08             	mov    0x8(%ebx),%eax
	if (!api->slave_select) {
400339b1:	8b 50 04             	mov    0x4(%eax),%edx
400339b4:	8b 4a 04             	mov    0x4(%edx),%ecx
400339b7:	85 c9                	test   %ecx,%ecx
400339b9:	74 07                	je     400339c2 <mraa_spi_init+0x7f>
	return api->slave_select(dev, slave);
400339bb:	ba 01 00 00 00       	mov    $0x1,%edx
400339c0:	ff d1                	call   *%ecx

    return dev;
}
400339c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
400339c5:	89 d8                	mov    %ebx,%eax
400339c7:	5b                   	pop    %ebx
400339c8:	5e                   	pop    %esi
400339c9:	5d                   	pop    %ebp
400339ca:	c3                   	ret    

400339cb <mraa_spi_mode>:

mraa_result_t
mraa_spi_mode(mraa_spi_context dev, mraa_spi_mode_t mode)
{
400339cb:	55                   	push   %ebp
    switch (mode) {
400339cc:	83 fa 01             	cmp    $0x1,%edx
{
400339cf:	89 e5                	mov    %esp,%ebp
400339d1:	8b 48 04             	mov    0x4(%eax),%ecx
    switch (mode) {
400339d4:	74 0e                	je     400339e4 <mraa_spi_mode+0x19>
400339d6:	72 16                	jb     400339ee <mraa_spi_mode+0x23>
400339d8:	83 fa 02             	cmp    $0x2,%edx
400339db:	74 0c                	je     400339e9 <mraa_spi_mode+0x1e>
400339dd:	83 fa 03             	cmp    $0x3,%edx
400339e0:	74 0f                	je     400339f1 <mraa_spi_mode+0x26>
400339e2:	eb 0a                	jmp    400339ee <mraa_spi_mode+0x23>
        case MRAA_SPI_MODE0:
            dev->config->config = SET_MODE_MASK & dev->config->config;
            break;
        case MRAA_SPI_MODE1:
            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPHA) & dev->config->config;
400339e4:	83 21 fe             	andl   $0xfffffffe,(%ecx)
            break;
400339e7:	eb 08                	jmp    400339f1 <mraa_spi_mode+0x26>
        case MRAA_SPI_MODE2:
            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPOL) & dev->config->config;
400339e9:	83 21 fd             	andl   $0xfffffffd,(%ecx)
400339ec:	eb 03                	jmp    400339f1 <mraa_spi_mode+0x26>
        case MRAA_SPI_MODE3:
            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPOL | SPI_MODE_CPHA) & dev->config->config;
            break;
        default:
            dev->config->config = SET_MODE_MASK & dev->config->config;
400339ee:	83 21 fc             	andl   $0xfffffffc,(%ecx)
            break;
    }
    if (spi_configure(dev->zdev, dev->config) != 0) {
400339f1:	8b 40 08             	mov    0x8(%eax),%eax
400339f4:	89 ca                	mov    %ecx,%edx
400339f6:	e8 26 ff ff ff       	call   40033921 <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
400339fb:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
400339fc:	83 f8 01             	cmp    $0x1,%eax
400339ff:	19 c0                	sbb    %eax,%eax
40033a01:	f7 d0                	not    %eax
40033a03:	83 e0 63             	and    $0x63,%eax
}
40033a06:	c3                   	ret    

40033a07 <mraa_spi_frequency>:

mraa_result_t
mraa_spi_frequency(mraa_spi_context dev, int hz)
{
    uint32_t freq = 0;
    if (hz > 0) {
40033a07:	85 d2                	test   %edx,%edx
40033a09:	7e 2f                	jle    40033a3a <mraa_spi_frequency+0x33>
{
40033a0b:	55                   	push   %ebp
40033a0c:	89 d1                	mov    %edx,%ecx
40033a0e:	89 e5                	mov    %esp,%ebp
40033a10:	56                   	push   %esi
40033a11:	53                   	push   %ebx
40033a12:	89 c3                	mov    %eax,%ebx
        freq = sys_clock_hw_cycles_per_sec / hz;
    } else {
        return MRAA_ERROR_INVALID_PARAMETER;
    }

    dev->config->max_sys_freq = freq;
40033a14:	8b 70 04             	mov    0x4(%eax),%esi
        freq = sys_clock_hw_cycles_per_sec / hz;
40033a17:	b8 00 48 e8 01       	mov    $0x1e84800,%eax
40033a1c:	99                   	cltd   
40033a1d:	f7 f9                	idiv   %ecx
    dev->config->max_sys_freq = freq;
40033a1f:	89 46 04             	mov    %eax,0x4(%esi)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40033a22:	89 f2                	mov    %esi,%edx
40033a24:	8b 43 08             	mov    0x8(%ebx),%eax
40033a27:	e8 f5 fe ff ff       	call   40033921 <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
40033a2c:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40033a2d:	83 f8 01             	cmp    $0x1,%eax
}
40033a30:	5e                   	pop    %esi
    return MRAA_SUCCESS;
40033a31:	19 c0                	sbb    %eax,%eax
}
40033a33:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
40033a34:	f7 d0                	not    %eax
40033a36:	83 e0 63             	and    $0x63,%eax
}
40033a39:	c3                   	ret    
        return MRAA_ERROR_INVALID_PARAMETER;
40033a3a:	b8 04 00 00 00       	mov    $0x4,%eax
40033a3f:	c3                   	ret    

40033a40 <mraa_spi_transfer_buf>:
    return MRAA_SUCCESS;
}

mraa_result_t
mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
{
40033a40:	55                   	push   %ebp
40033a41:	89 e5                	mov    %esp,%ebp
40033a43:	53                   	push   %ebx
    mraa_result_t ret;
//printf("data %x %x\n", data[0], data[1]);
//k_busy_wait(1000);
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40033a44:	8b 40 08             	mov    0x8(%eax),%eax
{
40033a47:	8b 5d 08             	mov    0x8(%ebp),%ebx
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40033a4a:	53                   	push   %ebx
40033a4b:	51                   	push   %ecx
40033a4c:	89 d9                	mov    %ebx,%ecx
40033a4e:	e8 d9 fe ff ff       	call   4003392c <spi_transceive>
40033a53:	5a                   	pop    %edx
40033a54:	59                   	pop    %ecx

    return ret;
}
40033a55:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033a58:	c9                   	leave  
40033a59:	c3                   	ret    

40033a5a <mraa_intel_quark_se_devboard>:
#include "mraa/gpio.h"

static mraa_board_t _board;

mraa_board_t* mraa_intel_quark_se_devboard()
{
40033a5a:	55                   	push   %ebp
    mraa_board_t* b = &_board;
    mraa_set_board_config(b);
40033a5b:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
{
40033a60:	89 e5                	mov    %esp,%ebp
40033a62:	57                   	push   %edi
40033a63:	56                   	push   %esi
40033a64:	53                   	push   %ebx
40033a65:	83 ec 10             	sub    $0x10,%esp
    mraa_set_board_config(b);
40033a68:	e8 9b fb ff ff       	call   40033608 <mraa_set_board_config>
b->phy_pin_count = 94;
    //b->platform_type = MRAA_INTEL_QUARK_SE_DEVBOARD;

// header - J14
#if 1
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033a6d:	b9 01 00 00 00       	mov    $0x1,%ecx
40033a72:	ba 01 00 00 00       	mov    $0x1,%edx
40033a77:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033a7c:	6a 00                	push   $0x0
    b->platform_name = "Quark SE Devboard/C1000 x86";
40033a7e:	c7 05 1c 6a 00 a8 4f 	movl   $0x4003be4f,0xa8006a1c
40033a85:	be 03 40 
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033a88:	68 6b be 03 40       	push   $0x4003be6b
b->phy_pin_count = 94;
40033a8d:	c6 05 e0 69 00 a8 5e 	movb   $0x5e,0xa80069e0
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033a94:	e8 44 fb ff ff       	call   400335dd <mraa_set_pininfo>
40033a99:	5a                   	pop    %edx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40033a9a:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033a9f:	59                   	pop    %ecx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40033aa0:	ba 02 00 00 00       	mov    $0x2,%edx
40033aa5:	b9 02 00 00 00       	mov    $0x2,%ecx
40033aaa:	6a 00                	push   $0x0
40033aac:	68 6b be 03 40       	push   $0x4003be6b
40033ab1:	e8 27 fb ff ff       	call   400335dd <mraa_set_pininfo>
40033ab6:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033ab7:	b9 1f 00 00 00       	mov    $0x1f,%ecx
40033abc:	8a 1d 60 bb 03 40    	mov    0x4003bb60,%bl
40033ac2:	ba 03 00 00 00       	mov    $0x3,%edx
40033ac7:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40033acc:	5e                   	pop    %esi
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033acd:	53                   	push   %ebx
40033ace:	68 73 be 03 40       	push   $0x4003be73
40033ad3:	e8 05 fb ff ff       	call   400335dd <mraa_set_pininfo>
40033ad8:	5f                   	pop    %edi
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033ad9:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033adb:	58                   	pop    %eax
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033adc:	ba 04 00 00 00       	mov    $0x4,%edx
40033ae1:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033ae6:	53                   	push   %ebx
40033ae7:	68 87 be 03 40       	push   $0x4003be87
40033aec:	e8 ec fa ff ff       	call   400335dd <mraa_set_pininfo>
40033af1:	58                   	pop    %eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033af2:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033af7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033af8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033afd:	ba 05 00 00 00       	mov    $0x5,%edx
40033b02:	53                   	push   %ebx
40033b03:	68 9d be 03 40       	push   $0x4003be9d
40033b08:	e8 d0 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b0d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b0e:	ba 06 00 00 00       	mov    $0x6,%edx
40033b13:	b9 12 00 00 00       	mov    $0x12,%ecx
40033b18:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b1d:	5e                   	pop    %esi
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b1e:	53                   	push   %ebx
40033b1f:	68 b0 be 03 40       	push   $0x4003beb0
40033b24:	e8 b4 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b29:	5f                   	pop    %edi
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b2a:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b2f:	58                   	pop    %eax
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b30:	ba 07 00 00 00       	mov    $0x7,%edx
40033b35:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033b3a:	53                   	push   %ebx
40033b3b:	68 c6 be 03 40       	push   $0x4003bec6
40033b40:	e8 98 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b45:	58                   	pop    %eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b46:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b4b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b4c:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033b51:	ba 08 00 00 00       	mov    $0x8,%edx
40033b56:	53                   	push   %ebx
40033b57:	68 e3 be 03 40       	push   $0x4003bee3
40033b5c:	e8 7c fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b61:	59                   	pop    %ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b62:	ba 09 00 00 00       	mov    $0x9,%edx
40033b67:	b9 03 00 00 00       	mov    $0x3,%ecx
40033b6c:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b71:	5e                   	pop    %esi
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b72:	53                   	push   %ebx
40033b73:	68 ef be 03 40       	push   $0x4003beef
40033b78:	e8 60 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b7d:	5f                   	pop    %edi
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b7e:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b83:	58                   	pop    %eax
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b84:	ba 0a 00 00 00       	mov    $0xa,%edx
40033b89:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033b8e:	53                   	push   %ebx
40033b8f:	68 0c bf 03 40       	push   $0x4003bf0c
40033b94:	e8 44 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033b99:	58                   	pop    %eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033b9a:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40033b9f:	5a                   	pop    %edx
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ba0:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033ba5:	ba 0b 00 00 00       	mov    $0xb,%edx
40033baa:	6a 00                	push   $0x0
40033bac:	68 18 bf 03 40       	push   $0x4003bf18
40033bb1:	e8 27 fa ff ff       	call   400335dd <mraa_set_pininfo>
40033bb6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033bb7:	ba 0c 00 00 00       	mov    $0xc,%edx
40033bbc:	b9 0c 00 00 00       	mov    $0xc,%ecx
40033bc1:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033bc6:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033bc7:	6a 00                	push   $0x0
40033bc9:	68 18 bf 03 40       	push   $0x4003bf18
40033bce:	e8 0a fa ff ff       	call   400335dd <mraa_set_pininfo>
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033bd3:	8a 1d 61 bb 03 40    	mov    0x4003bb61,%bl
40033bd9:	b9 04 00 00 00       	mov    $0x4,%ecx
40033bde:	ba 0d 00 00 00       	mov    $0xd,%edx
40033be3:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033be8:	5e                   	pop    %esi
40033be9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033bea:	53                   	push   %ebx
40033beb:	68 1c bf 03 40       	push   $0x4003bf1c
40033bf0:	e8 e8 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033bf5:	58                   	pop    %eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033bf6:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033bfb:	5a                   	pop    %edx
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033bfc:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033c01:	ba 0e 00 00 00       	mov    $0xe,%edx
40033c06:	6a 01                	push   $0x1
40033c08:	68 2a bf 03 40       	push   $0x4003bf2a
40033c0d:	e8 cb f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033c12:	59                   	pop    %ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c13:	ba 0f 00 00 00       	mov    $0xf,%edx
40033c18:	b9 05 00 00 00       	mov    $0x5,%ecx
40033c1d:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c22:	5e                   	pop    %esi
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c23:	53                   	push   %ebx
40033c24:	68 3c bf 03 40       	push   $0x4003bf3c
40033c29:	e8 af f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033c2e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c2f:	b9 10 00 00 00       	mov    $0x10,%ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c34:	58                   	pop    %eax
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c35:	ba 10 00 00 00       	mov    $0x10,%edx
40033c3a:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033c3f:	6a 01                	push   $0x1
40033c41:	68 4a bf 03 40       	push   $0x4003bf4a
40033c46:	e8 92 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033c4b:	58                   	pop    %eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c4c:	b9 06 00 00 00       	mov    $0x6,%ecx
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c51:	5a                   	pop    %edx
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c52:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033c57:	ba 11 00 00 00       	mov    $0x11,%edx
40033c5c:	53                   	push   %ebx
40033c5d:	68 5c bf 03 40       	push   $0x4003bf5c
40033c62:	e8 76 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033c67:	59                   	pop    %ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c68:	ba 12 00 00 00       	mov    $0x12,%edx
40033c6d:	b9 12 00 00 00       	mov    $0x12,%ecx
40033c72:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40033c77:	5e                   	pop    %esi
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c78:	6a 01                	push   $0x1
40033c7a:	68 6e bf 03 40       	push   $0x4003bf6e
40033c7f:	e8 59 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033c84:	5f                   	pop    %edi
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033c85:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033c8a:	58                   	pop    %eax
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033c8b:	ba 13 00 00 00       	mov    $0x13,%edx
40033c90:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033c95:	53                   	push   %ebx
40033c96:	68 80 bf 03 40       	push   $0x4003bf80
40033c9b:	e8 3d f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033ca0:	58                   	pop    %eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033ca1:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033ca6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033ca7:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033cac:	ba 14 00 00 00       	mov    $0x14,%edx
40033cb1:	6a 01                	push   $0x1
40033cb3:	68 97 bf 03 40       	push   $0x4003bf97
40033cb8:	e8 20 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033cbd:	59                   	pop    %ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033cbe:	ba 15 00 00 00       	mov    $0x15,%edx
40033cc3:	b9 0f 00 00 00       	mov    $0xf,%ecx
40033cc8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033ccd:	5e                   	pop    %esi
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033cce:	53                   	push   %ebx
40033ccf:	68 a9 bf 03 40       	push   $0x4003bfa9
40033cd4:	e8 04 f9 ff ff       	call   400335dd <mraa_set_pininfo>
40033cd9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40033cda:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40033cdf:	58                   	pop    %eax
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40033ce0:	ba 16 00 00 00       	mov    $0x16,%edx
40033ce5:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033cea:	6a 01                	push   $0x1
40033cec:	68 c0 bf 03 40       	push   $0x4003bfc0
40033cf1:	e8 e7 f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033cf6:	58                   	pop    %eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033cf7:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40033cfc:	5a                   	pop    %edx
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033cfd:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033d02:	ba 17 00 00 00       	mov    $0x17,%edx
40033d07:	6a 00                	push   $0x0
40033d09:	68 6b be 03 40       	push   $0x4003be6b
40033d0e:	e8 ca f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033d13:	59                   	pop    %ecx
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033d14:	ba 18 00 00 00       	mov    $0x18,%edx
40033d19:	b9 14 00 00 00       	mov    $0x14,%ecx
40033d1e:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033d23:	5e                   	pop    %esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033d24:	6a 01                	push   $0x1
40033d26:	68 d2 bf 03 40       	push   $0x4003bfd2
40033d2b:	e8 ad f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033d30:	5f                   	pop    %edi
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d31:	0f b6 35 62 bb 03 40 	movzbl 0x4003bb62,%esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40033d38:	58                   	pop    %eax
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d39:	31 c9                	xor    %ecx,%ecx
40033d3b:	ba 19 00 00 00       	mov    $0x19,%edx
40033d40:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033d45:	56                   	push   %esi
40033d46:	68 e4 bf 03 40       	push   $0x4003bfe4
40033d4b:	e8 8d f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033d50:	58                   	pop    %eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033d51:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d56:	5a                   	pop    %edx
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033d57:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033d5c:	ba 1a 00 00 00       	mov    $0x1a,%edx
40033d61:	6a 00                	push   $0x0
40033d63:	68 6b be 03 40       	push   $0x4003be6b
40033d68:	e8 70 f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033d6d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d6e:	ba 1b 00 00 00       	mov    $0x1b,%edx
40033d73:	b9 01 00 00 00       	mov    $0x1,%ecx
40033d78:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033d7d:	5f                   	pop    %edi
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d7e:	56                   	push   %esi
40033d7f:	68 f6 bf 03 40       	push   $0x4003bff6
40033d84:	e8 54 f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033d89:	58                   	pop    %eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033d8a:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033d8f:	5a                   	pop    %edx
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033d90:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033d95:	ba 1c 00 00 00       	mov    $0x1c,%edx
40033d9a:	53                   	push   %ebx
40033d9b:	68 08 c0 03 40       	push   $0x4003c008
40033da0:	e8 38 f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033da5:	59                   	pop    %ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033da6:	ba 1d 00 00 00       	mov    $0x1d,%edx
40033dab:	b9 02 00 00 00       	mov    $0x2,%ecx
40033db0:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033db5:	5f                   	pop    %edi
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033db6:	56                   	push   %esi
40033db7:	68 1a c0 03 40       	push   $0x4003c01a
40033dbc:	e8 1c f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033dc1:	58                   	pop    %eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033dc2:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033dc7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033dc8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033dcd:	ba 1e 00 00 00       	mov    $0x1e,%edx
40033dd2:	53                   	push   %ebx
40033dd3:	68 2c c0 03 40       	push   $0x4003c02c
40033dd8:	e8 00 f8 ff ff       	call   400335dd <mraa_set_pininfo>
40033ddd:	59                   	pop    %ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033dde:	ba 1f 00 00 00       	mov    $0x1f,%edx
40033de3:	b9 03 00 00 00       	mov    $0x3,%ecx
40033de8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033ded:	5f                   	pop    %edi
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033dee:	56                   	push   %esi
40033def:	68 3f c0 03 40       	push   $0x4003c03f
40033df4:	e8 e4 f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033df9:	58                   	pop    %eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033dfa:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40033dff:	5a                   	pop    %edx
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e00:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033e05:	ba 20 00 00 00       	mov    $0x20,%edx
40033e0a:	53                   	push   %ebx
40033e0b:	68 51 c0 03 40       	push   $0x4003c051
40033e10:	e8 c8 f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e15:	59                   	pop    %ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033e16:	ba 21 00 00 00       	mov    $0x21,%edx
40033e1b:	b9 21 00 00 00       	mov    $0x21,%ecx
40033e20:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e25:	5e                   	pop    %esi
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033e26:	6a 00                	push   $0x0
40033e28:	68 18 bf 03 40       	push   $0x4003bf18
40033e2d:	e8 ab f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e32:	5f                   	pop    %edi
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e33:	b9 12 00 00 00       	mov    $0x12,%ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033e38:	58                   	pop    %eax
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e39:	ba 22 00 00 00       	mov    $0x22,%edx
40033e3e:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033e43:	53                   	push   %ebx
40033e44:	68 63 c0 03 40       	push   $0x4003c063
40033e49:	e8 8f f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e4e:	58                   	pop    %eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033e4f:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e51:	5a                   	pop    %edx
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033e52:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033e57:	ba 23 00 00 00       	mov    $0x23,%edx
40033e5c:	53                   	push   %ebx
40033e5d:	68 76 c0 03 40       	push   $0x4003c076
40033e62:	e8 76 f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e67:	59                   	pop    %ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e68:	ba 24 00 00 00       	mov    $0x24,%edx
40033e6d:	b9 13 00 00 00       	mov    $0x13,%ecx
40033e72:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033e77:	5e                   	pop    %esi
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e78:	53                   	push   %ebx
40033e79:	68 83 c0 03 40       	push   $0x4003c083
40033e7e:	e8 5a f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e83:	5f                   	pop    %edi
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033e84:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033e89:	58                   	pop    %eax
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033e8a:	ba 25 00 00 00       	mov    $0x25,%edx
40033e8f:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033e94:	53                   	push   %ebx
40033e95:	68 95 c0 03 40       	push   $0x4003c095
40033e9a:	e8 3e f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033e9f:	58                   	pop    %eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033ea0:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033ea5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033ea6:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033eab:	ba 26 00 00 00       	mov    $0x26,%edx
40033eb0:	53                   	push   %ebx
40033eb1:	68 a2 c0 03 40       	push   $0x4003c0a2
40033eb6:	e8 22 f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033ebb:	59                   	pop    %ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033ebc:	ba 27 00 00 00       	mov    $0x27,%edx
40033ec1:	b9 02 00 00 00       	mov    $0x2,%ecx
40033ec6:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033ecb:	5e                   	pop    %esi
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033ecc:	53                   	push   %ebx
40033ecd:	68 b4 c0 03 40       	push   $0x4003c0b4
40033ed2:	e8 06 f7 ff ff       	call   400335dd <mraa_set_pininfo>
40033ed7:	5f                   	pop    %edi
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ed8:	b9 28 00 00 00       	mov    $0x28,%ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033edd:	58                   	pop    %eax
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ede:	ba 28 00 00 00       	mov    $0x28,%edx
40033ee3:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033ee8:	6a 00                	push   $0x0
40033eea:	68 18 bf 03 40       	push   $0x4003bf18
40033eef:	e8 e9 f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033ef4:	58                   	pop    %eax
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033ef5:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033efa:	5a                   	pop    %edx
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033efb:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033f00:	ba 29 00 00 00       	mov    $0x29,%edx
40033f05:	53                   	push   %ebx
40033f06:	68 c1 c0 03 40       	push   $0x4003c0c1
40033f0b:	e8 cd f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033f10:	59                   	pop    %ecx
40033f11:	5e                   	pop    %esi
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40033f12:	b9 01 00 00 00       	mov    $0x1,%ecx
40033f17:	0f b6 35 63 bb 03 40 	movzbl 0x4003bb63,%esi
40033f1e:	ba 2a 00 00 00       	mov    $0x2a,%edx
40033f23:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033f28:	56                   	push   %esi
40033f29:	68 ce c0 03 40       	push   $0x4003c0ce
40033f2e:	e8 aa f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033f33:	5f                   	pop    %edi
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f34:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40033f39:	58                   	pop    %eax
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f3a:	ba 2b 00 00 00       	mov    $0x2b,%edx
40033f3f:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033f44:	53                   	push   %ebx
40033f45:	68 dd c0 03 40       	push   $0x4003c0dd
40033f4a:	e8 8e f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033f4f:	58                   	pop    %eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40033f50:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f55:	5a                   	pop    %edx
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40033f56:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033f5b:	ba 2c 00 00 00       	mov    $0x2c,%edx
40033f60:	56                   	push   %esi
40033f61:	68 ea c0 03 40       	push   $0x4003c0ea
40033f66:	e8 72 f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033f6b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f6c:	ba 2d 00 00 00       	mov    $0x2d,%edx
40033f71:	b9 05 00 00 00       	mov    $0x5,%ecx
40033f76:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40033f7b:	5f                   	pop    %edi
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f7c:	53                   	push   %ebx
40033f7d:	68 f9 c0 03 40       	push   $0x4003c0f9
40033f82:	e8 56 f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033f87:	58                   	pop    %eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033f88:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40033f8a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033f8b:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033f90:	ba 2e 00 00 00       	mov    $0x2e,%edx
40033f95:	6a 00                	push   $0x0
40033f97:	68 06 c1 03 40       	push   $0x4003c106
40033f9c:	e8 3c f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033fa1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033fa2:	ba 2f 00 00 00       	mov    $0x2f,%edx
40033fa7:	b9 07 00 00 00       	mov    $0x7,%ecx
40033fac:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fb1:	5f                   	pop    %edi
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033fb2:	53                   	push   %ebx
40033fb3:	68 0c c1 03 40       	push   $0x4003c10c
40033fb8:	e8 20 f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033fbd:	58                   	pop    %eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fbe:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40033fc0:	5a                   	pop    %edx
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fc1:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40033fc6:	ba 30 00 00 00       	mov    $0x30,%edx
40033fcb:	6a 00                	push   $0x0
40033fcd:	68 1a c1 03 40       	push   $0x4003c11a
40033fd2:	e8 06 f6 ff ff       	call   400335dd <mraa_set_pininfo>
40033fd7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fd8:	ba 31 00 00 00       	mov    $0x31,%edx
40033fdd:	b9 31 00 00 00       	mov    $0x31,%ecx
40033fe2:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fe7:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033fe8:	6a 00                	push   $0x0
40033fea:	68 6b be 03 40       	push   $0x4003be6b
40033fef:	e8 e9 f5 ff ff       	call   400335dd <mraa_set_pininfo>
40033ff4:	5f                   	pop    %edi
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ff5:	b9 32 00 00 00       	mov    $0x32,%ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ffa:	58                   	pop    %eax
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40033ffb:	ba 32 00 00 00       	mov    $0x32,%edx
40034000:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034005:	6a 00                	push   $0x0
40034007:	68 6b be 03 40       	push   $0x4003be6b
4003400c:	e8 cc f5 ff ff       	call   400335dd <mraa_set_pininfo>
40034011:	58                   	pop    %eax
#endif
// the other big header - J15
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034012:	b9 33 00 00 00       	mov    $0x33,%ecx
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034017:	5a                   	pop    %edx
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034018:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003401d:	ba 33 00 00 00       	mov    $0x33,%edx
40034022:	6a 00                	push   $0x0
40034024:	68 6b be 03 40       	push   $0x4003be6b
40034029:	e8 af f5 ff ff       	call   400335dd <mraa_set_pininfo>
4003402e:	59                   	pop    %ecx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003402f:	ba 34 00 00 00       	mov    $0x34,%edx
40034034:	b9 34 00 00 00       	mov    $0x34,%ecx
40034039:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003403e:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003403f:	6a 00                	push   $0x0
40034041:	68 6b be 03 40       	push   $0x4003be6b
40034046:	e8 92 f5 ff ff       	call   400335dd <mraa_set_pininfo>
4003404b:	5f                   	pop    %edi
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003404c:	0f b6 3d 64 bb 03 40 	movzbl 0x4003bb64,%edi
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034053:	58                   	pop    %eax
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034054:	31 c9                	xor    %ecx,%ecx
40034056:	ba 35 00 00 00       	mov    $0x35,%edx
4003405b:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034060:	57                   	push   %edi
40034061:	68 28 c1 03 40       	push   $0x4003c128
40034066:	e8 72 f5 ff ff       	call   400335dd <mraa_set_pininfo>
4003406b:	58                   	pop    %eax
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003406c:	8a 1d 65 bb 03 40    	mov    0x4003bb65,%bl
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034072:	5a                   	pop    %edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034073:	b9 15 00 00 00       	mov    $0x15,%ecx
40034078:	ba 36 00 00 00       	mov    $0x36,%edx
4003407d:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034082:	53                   	push   %ebx
40034083:	68 37 c1 03 40       	push   $0x4003c137
40034088:	e8 50 f5 ff ff       	call   400335dd <mraa_set_pininfo>
4003408d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003408e:	ba 37 00 00 00       	mov    $0x37,%edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034093:	58                   	pop    %eax
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034094:	31 c9                	xor    %ecx,%ecx
40034096:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003409b:	57                   	push   %edi
4003409c:	68 4c c1 03 40       	push   $0x4003c14c
400340a1:	e8 37 f5 ff ff       	call   400335dd <mraa_set_pininfo>
400340a6:	58                   	pop    %eax
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340a7:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340ac:	5a                   	pop    %edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340ad:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400340b2:	ba 38 00 00 00       	mov    $0x38,%edx
400340b7:	53                   	push   %ebx
400340b8:	68 5c c1 03 40       	push   $0x4003c15c
400340bd:	e8 1b f5 ff ff       	call   400335dd <mraa_set_pininfo>
400340c2:	59                   	pop    %ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340c3:	ba 39 00 00 00       	mov    $0x39,%edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340c8:	58                   	pop    %eax
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340c9:	31 c9                	xor    %ecx,%ecx
400340cb:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400340d0:	57                   	push   %edi
400340d1:	68 72 c1 03 40       	push   $0x4003c172
400340d6:	e8 02 f5 ff ff       	call   400335dd <mraa_set_pininfo>
400340db:	58                   	pop    %eax
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340dc:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340e1:	5a                   	pop    %edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340e2:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400340e7:	ba 3a 00 00 00       	mov    $0x3a,%edx
400340ec:	53                   	push   %ebx
400340ed:	68 82 c1 03 40       	push   $0x4003c182
400340f2:	e8 e6 f4 ff ff       	call   400335dd <mraa_set_pininfo>
400340f7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340f8:	ba 3b 00 00 00       	mov    $0x3b,%edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400340fd:	58                   	pop    %eax
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400340fe:	31 c9                	xor    %ecx,%ecx
40034100:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034105:	57                   	push   %edi
40034106:	68 98 c1 03 40       	push   $0x4003c198
4003410b:	e8 cd f4 ff ff       	call   400335dd <mraa_set_pininfo>
40034110:	58                   	pop    %eax
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034111:	b9 18 00 00 00       	mov    $0x18,%ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034116:	5a                   	pop    %edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034117:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003411c:	ba 3c 00 00 00       	mov    $0x3c,%edx
40034121:	53                   	push   %ebx
40034122:	68 a9 c1 03 40       	push   $0x4003c1a9
40034127:	e8 b1 f4 ff ff       	call   400335dd <mraa_set_pininfo>
4003412c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003412d:	ba 3d 00 00 00       	mov    $0x3d,%edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034132:	58                   	pop    %eax
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034133:	31 c9                	xor    %ecx,%ecx
40034135:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003413a:	57                   	push   %edi
4003413b:	68 c0 c1 03 40       	push   $0x4003c1c0
40034140:	e8 98 f4 ff ff       	call   400335dd <mraa_set_pininfo>
40034145:	58                   	pop    %eax
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034146:	b9 19 00 00 00       	mov    $0x19,%ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003414b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003414c:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034151:	ba 3e 00 00 00       	mov    $0x3e,%edx
40034156:	53                   	push   %ebx
40034157:	68 d1 c1 03 40       	push   $0x4003c1d1
4003415c:	e8 7c f4 ff ff       	call   400335dd <mraa_set_pininfo>
40034161:	59                   	pop    %ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034162:	ba 3f 00 00 00       	mov    $0x3f,%edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034167:	58                   	pop    %eax
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034168:	b9 1d 00 00 00       	mov    $0x1d,%ecx
4003416d:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034172:	53                   	push   %ebx
40034173:	68 e8 c1 03 40       	push   $0x4003c1e8
40034178:	e8 60 f4 ff ff       	call   400335dd <mraa_set_pininfo>
4003417d:	58                   	pop    %eax
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003417e:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034183:	5a                   	pop    %edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034184:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034189:	ba 40 00 00 00       	mov    $0x40,%edx
4003418e:	53                   	push   %ebx
4003418f:	68 00 c2 03 40       	push   $0x4003c200
40034194:	e8 44 f4 ff ff       	call   400335dd <mraa_set_pininfo>
40034199:	59                   	pop    %ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003419a:	ba 41 00 00 00       	mov    $0x41,%edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003419f:	58                   	pop    %eax
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400341a0:	b9 1e 00 00 00       	mov    $0x1e,%ecx
400341a5:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400341aa:	53                   	push   %ebx
400341ab:	68 17 c2 03 40       	push   $0x4003c217
400341b0:	e8 28 f4 ff ff       	call   400335dd <mraa_set_pininfo>
400341b5:	58                   	pop    %eax
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400341b6:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400341bb:	5a                   	pop    %edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400341bc:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400341c1:	ba 42 00 00 00       	mov    $0x42,%edx
400341c6:	53                   	push   %ebx
400341c7:	68 2f c2 03 40       	push   $0x4003c22f
400341cc:	e8 0c f4 ff ff       	call   400335dd <mraa_set_pininfo>
400341d1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400341d2:	ba 43 00 00 00       	mov    $0x43,%edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400341d7:	58                   	pop    %eax
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400341d8:	b9 43 00 00 00       	mov    $0x43,%ecx
400341dd:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400341e2:	6a 00                	push   $0x0
400341e4:	68 18 bf 03 40       	push   $0x4003bf18
400341e9:	e8 ef f3 ff ff       	call   400335dd <mraa_set_pininfo>
400341ee:	58                   	pop    %eax
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400341ef:	b9 44 00 00 00       	mov    $0x44,%ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400341f4:	5a                   	pop    %edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400341f5:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400341fa:	ba 44 00 00 00       	mov    $0x44,%edx
400341ff:	6a 00                	push   $0x0
40034201:	68 18 bf 03 40       	push   $0x4003bf18
40034206:	e8 d2 f3 ff ff       	call   400335dd <mraa_set_pininfo>
4003420b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003420c:	ba 45 00 00 00       	mov    $0x45,%edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034211:	58                   	pop    %eax
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034212:	31 c9                	xor    %ecx,%ecx
40034214:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034219:	57                   	push   %edi
4003421a:	68 4a c2 03 40       	push   $0x4003c24a
4003421f:	e8 b9 f3 ff ff       	call   400335dd <mraa_set_pininfo>
40034224:	58                   	pop    %eax
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034225:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003422a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003422b:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034230:	ba 46 00 00 00       	mov    $0x46,%edx
40034235:	53                   	push   %ebx
40034236:	68 59 c2 03 40       	push   $0x4003c259
4003423b:	e8 9d f3 ff ff       	call   400335dd <mraa_set_pininfo>
40034240:	59                   	pop    %ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034241:	ba 47 00 00 00       	mov    $0x47,%edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034246:	58                   	pop    %eax
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034247:	31 c9                	xor    %ecx,%ecx
40034249:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003424e:	57                   	push   %edi
4003424f:	68 6d c2 03 40       	push   $0x4003c26d
40034254:	e8 84 f3 ff ff       	call   400335dd <mraa_set_pininfo>
40034259:	58                   	pop    %eax
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003425a:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003425f:	5a                   	pop    %edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034260:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034265:	ba 48 00 00 00       	mov    $0x48,%edx
4003426a:	53                   	push   %ebx
4003426b:	68 7d c2 03 40       	push   $0x4003c27d
40034270:	e8 68 f3 ff ff       	call   400335dd <mraa_set_pininfo>
40034275:	59                   	pop    %ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034276:	ba 49 00 00 00       	mov    $0x49,%edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003427b:	58                   	pop    %eax
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003427c:	31 c9                	xor    %ecx,%ecx
4003427e:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034283:	57                   	push   %edi
40034284:	68 92 c2 03 40       	push   $0x4003c292
40034289:	e8 4f f3 ff ff       	call   400335dd <mraa_set_pininfo>
4003428e:	58                   	pop    %eax
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003428f:	b9 0a 00 00 00       	mov    $0xa,%ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40034294:	5a                   	pop    %edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034295:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003429a:	ba 4a 00 00 00       	mov    $0x4a,%edx
4003429f:	53                   	push   %ebx
400342a0:	68 a2 c2 03 40       	push   $0x4003c2a2
400342a5:	e8 33 f3 ff ff       	call   400335dd <mraa_set_pininfo>
400342aa:	59                   	pop    %ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342ab:	ba 4b 00 00 00       	mov    $0x4b,%edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342b0:	58                   	pop    %eax
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342b1:	31 c9                	xor    %ecx,%ecx
400342b3:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400342b8:	57                   	push   %edi
400342b9:	68 b8 c2 03 40       	push   $0x4003c2b8
400342be:	e8 1a f3 ff ff       	call   400335dd <mraa_set_pininfo>
400342c3:	58                   	pop    %eax
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342c4:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342c9:	5a                   	pop    %edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342ca:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400342cf:	ba 4c 00 00 00       	mov    $0x4c,%edx
400342d4:	53                   	push   %ebx
400342d5:	68 c9 c2 03 40       	push   $0x4003c2c9
400342da:	e8 fe f2 ff ff       	call   400335dd <mraa_set_pininfo>
400342df:	59                   	pop    %ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342e0:	ba 4d 00 00 00       	mov    $0x4d,%edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342e5:	58                   	pop    %eax
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342e6:	31 c9                	xor    %ecx,%ecx
400342e8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400342ed:	57                   	push   %edi
400342ee:	68 e0 c2 03 40       	push   $0x4003c2e0
400342f3:	e8 e5 f2 ff ff       	call   400335dd <mraa_set_pininfo>
400342f8:	58                   	pop    %eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342f9:	b9 0c 00 00 00       	mov    $0xc,%ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400342fe:	5a                   	pop    %edx
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400342ff:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034304:	ba 4e 00 00 00       	mov    $0x4e,%edx
40034309:	53                   	push   %ebx
4003430a:	68 f1 c2 03 40       	push   $0x4003c2f1
4003430f:	e8 c9 f2 ff ff       	call   400335dd <mraa_set_pininfo>
40034314:	59                   	pop    %ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034315:	ba 4f 00 00 00       	mov    $0x4f,%edx
4003431a:	b9 4f 00 00 00       	mov    $0x4f,%ecx
4003431f:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034324:	5f                   	pop    %edi
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034325:	6a 00                	push   $0x0
40034327:	68 6b be 03 40       	push   $0x4003be6b
4003432c:	e8 ac f2 ff ff       	call   400335dd <mraa_set_pininfo>
40034331:	58                   	pop    %eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034332:	b9 0d 00 00 00       	mov    $0xd,%ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40034337:	5a                   	pop    %edx
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034338:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003433d:	ba 50 00 00 00       	mov    $0x50,%edx
40034342:	53                   	push   %ebx
40034343:	68 08 c3 03 40       	push   $0x4003c308
40034348:	e8 90 f2 ff ff       	call   400335dd <mraa_set_pininfo>
4003434d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003434e:	ba 51 00 00 00       	mov    $0x51,%edx
40034353:	31 c9                	xor    %ecx,%ecx
40034355:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003435a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003435b:	56                   	push   %esi
4003435c:	68 1f c3 03 40       	push   $0x4003c31f
40034361:	e8 77 f2 ff ff       	call   400335dd <mraa_set_pininfo>
40034366:	58                   	pop    %eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034367:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003436c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003436d:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034372:	ba 52 00 00 00       	mov    $0x52,%edx
40034377:	53                   	push   %ebx
40034378:	68 2b c3 03 40       	push   $0x4003c32b
4003437d:	e8 5b f2 ff ff       	call   400335dd <mraa_set_pininfo>
40034382:	59                   	pop    %ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034383:	ba 53 00 00 00       	mov    $0x53,%edx
40034388:	31 c9                	xor    %ecx,%ecx
4003438a:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003438f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034390:	56                   	push   %esi
40034391:	68 42 c3 03 40       	push   $0x4003c342
40034396:	e8 42 f2 ff ff       	call   400335dd <mraa_set_pininfo>
4003439b:	58                   	pop    %eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003439c:	b9 54 00 00 00       	mov    $0x54,%ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343a1:	5a                   	pop    %edx
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400343a2:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400343a7:	ba 54 00 00 00       	mov    $0x54,%edx
400343ac:	6a 00                	push   $0x0
400343ae:	68 6b be 03 40       	push   $0x4003be6b
400343b3:	e8 25 f2 ff ff       	call   400335dd <mraa_set_pininfo>
400343b8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343b9:	ba 55 00 00 00       	mov    $0x55,%edx
400343be:	31 c9                	xor    %ecx,%ecx
400343c0:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400343c5:	5f                   	pop    %edi
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343c6:	56                   	push   %esi
400343c7:	68 4e c3 03 40       	push   $0x4003c34e
400343cc:	e8 0c f2 ff ff       	call   400335dd <mraa_set_pininfo>
400343d1:	58                   	pop    %eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400343d2:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343d7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400343d8:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
400343dd:	ba 56 00 00 00       	mov    $0x56,%edx
400343e2:	53                   	push   %ebx
400343e3:	68 5d c3 03 40       	push   $0x4003c35d
400343e8:	e8 f0 f1 ff ff       	call   400335dd <mraa_set_pininfo>
400343ed:	59                   	pop    %ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343ee:	ba 57 00 00 00       	mov    $0x57,%edx
400343f3:	31 c9                	xor    %ecx,%ecx
400343f5:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400343fa:	5f                   	pop    %edi
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400343fb:	56                   	push   %esi
400343fc:	68 75 c3 03 40       	push   $0x4003c375
40034401:	e8 d7 f1 ff ff       	call   400335dd <mraa_set_pininfo>
40034406:	58                   	pop    %eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034407:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003440c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003440d:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034412:	ba 58 00 00 00       	mov    $0x58,%edx
40034417:	53                   	push   %ebx
40034418:	68 84 c3 03 40       	push   $0x4003c384
4003441d:	e8 bb f1 ff ff       	call   400335dd <mraa_set_pininfo>
40034422:	59                   	pop    %ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034423:	ba 59 00 00 00       	mov    $0x59,%edx
40034428:	31 c9                	xor    %ecx,%ecx
4003442a:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003442f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034430:	56                   	push   %esi
40034431:	68 9d c3 03 40       	push   $0x4003c39d
40034436:	e8 a2 f1 ff ff       	call   400335dd <mraa_set_pininfo>
4003443b:	58                   	pop    %eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003443c:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034441:	5a                   	pop    %edx
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034442:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034447:	ba 5a 00 00 00       	mov    $0x5a,%edx
4003444c:	53                   	push   %ebx
4003444d:	68 a9 c3 03 40       	push   $0x4003c3a9
40034452:	e8 86 f1 ff ff       	call   400335dd <mraa_set_pininfo>
40034457:	59                   	pop    %ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034458:	ba 5b 00 00 00       	mov    $0x5b,%edx
4003445d:	31 c9                	xor    %ecx,%ecx
4003445f:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034464:	5f                   	pop    %edi
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034465:	56                   	push   %esi
40034466:	68 c2 c3 03 40       	push   $0x4003c3c2
4003446b:	e8 6d f1 ff ff       	call   400335dd <mraa_set_pininfo>
40034470:	58                   	pop    %eax
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034471:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40034473:	5a                   	pop    %edx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034474:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
40034479:	ba 5c 00 00 00       	mov    $0x5c,%edx
4003447e:	53                   	push   %ebx
    b->spi_bus[0].sclk = 13;
    b->spi_bus[0].mosi = 11;
    b->spi_bus[0].miso = 12;
    b->spi_bus[0].cs = 10;

    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
4003447f:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40034482:	68 ce c3 03 40       	push   $0x4003c3ce
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40034487:	be 68 bb 03 40       	mov    $0x4003bb68,%esi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003448c:	e8 4c f1 ff ff       	call   400335dd <mraa_set_pininfo>
40034491:	59                   	pop    %ecx
    struct device* zdev = device_get_binding("GPIO_0");
40034492:	b8 9f bc 03 40       	mov    $0x4003bc9f,%eax
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40034497:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003449c:	5b                   	pop    %ebx
    b->def_i2c_bus = 0;
4003449d:	c6 05 ea 69 00 a8 00 	movb   $0x0,0xa80069ea
    b->i2c_bus[0].bus_id = 0;
400344a4:	c6 05 e4 69 00 a8 00 	movb   $0x0,0xa80069e4
    b->pins[18].i2c.mux_total = 0;
400344ab:	c6 05 0e 6f 00 a8 00 	movb   $0x0,0xa8006f0e
    b->pins[19].i2c.mux_total = 0;
400344b2:	c6 05 52 6f 00 a8 00 	movb   $0x0,0xa8006f52
    b->i2c_bus[0].sda = 18;
400344b9:	c6 05 e6 69 00 a8 12 	movb   $0x12,0xa80069e6
    b->i2c_bus[0].scl = 19;
400344c0:	c6 05 e5 69 00 a8 13 	movb   $0x13,0xa80069e5
    b->spi_bus[0].bus_id = 0;
400344c7:	c6 05 ec 69 00 a8 00 	movb   $0x0,0xa80069ec
    b->spi_bus[0].sclk = 13;
400344ce:	c6 05 ef 69 00 a8 0d 	movb   $0xd,0xa80069ef
    b->spi_bus[0].mosi = 11;
400344d5:	c6 05 f0 69 00 a8 0b 	movb   $0xb,0xa80069f0
    b->spi_bus[0].miso = 12;
400344dc:	c6 05 f1 69 00 a8 0c 	movb   $0xc,0xa80069f1
    b->spi_bus[0].cs = 10;
400344e3:	c6 05 f2 69 00 a8 0a 	movb   $0xa,0xa80069f2
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
400344ea:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    struct device* zdev = device_get_binding("GPIO_0");
400344ec:	e8 15 56 00 00       	call   40039b06 <device_get_binding>
    if (zdev != NULL) {
400344f1:	85 c0                	test   %eax,%eax
400344f3:	74 1e                	je     40034513 <mraa_intel_quark_se_devboard+0xab9>
400344f5:	89 c6                	mov    %eax,%esi
400344f7:	31 db                	xor    %ebx,%ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
400344f9:	0f b6 4c 9d e4       	movzbl -0x1c(%ebp,%ebx,4),%ecx
400344fe:	8b 7e 04             	mov    0x4(%esi),%edi
40034501:	31 d2                	xor    %edx,%edx
40034503:	89 f0                	mov    %esi,%eax
        for (int i = 0; i<4; ++i) {
40034505:	43                   	inc    %ebx
40034506:	68 00 01 00 00       	push   $0x100
4003450b:	ff 17                	call   *(%edi)
4003450d:	58                   	pop    %eax
4003450e:	83 fb 04             	cmp    $0x4,%ebx
40034511:	75 e6                	jne    400344f9 <mraa_intel_quark_se_devboard+0xa9f>
        return NULL;
    }
#endif

    return b;
}
40034513:	8d 65 f4             	lea    -0xc(%ebp),%esp
40034516:	b8 e0 69 00 a8       	mov    $0xa80069e0,%eax
4003451b:	5b                   	pop    %ebx
4003451c:	5e                   	pop    %esi
4003451d:	5f                   	pop    %edi
4003451e:	5d                   	pop    %ebp
4003451f:	c3                   	ret    

40034520 <upm_delay_ms>:

#endif
}

void upm_delay_ms(int time)
{
40034520:	55                   	push   %ebp

#elif defined(UPM_PLATFORM_ZEPHYR)
# if KERNEL_VERSION_MAJOR == 1 && KERNEL_VERSION_MINOR >= 6

    struct k_timer timer;
    k_timer_init(&timer, NULL, NULL);
40034521:	31 d2                	xor    %edx,%edx
{
40034523:	89 e5                	mov    %esp,%ebp
40034525:	53                   	push   %ebx
40034526:	83 ec 34             	sub    $0x34,%esp
40034529:	89 c3                	mov    %eax,%ebx
    k_timer_init(&timer, NULL, NULL);
4003452b:	31 c9                	xor    %ecx,%ecx
4003452d:	8d 45 c8             	lea    -0x38(%ebp),%eax
40034530:	e8 a7 61 00 00       	call   4003a6dc <k_timer_init>
    k_timer_start(&timer, time, 0);
40034535:	ba 01 00 00 00       	mov    $0x1,%edx
4003453a:	85 db                	test   %ebx,%ebx
4003453c:	7e 02                	jle    40034540 <upm_delay_ms+0x20>
4003453e:	89 da                	mov    %ebx,%edx
40034540:	31 c9                	xor    %ecx,%ecx
40034542:	8d 45 c8             	lea    -0x38(%ebp),%eax
40034545:	e8 d0 61 00 00       	call   4003a71a <k_timer_start>
//printf("using k timer\n");
    //k_timer_status_sync(&timer);
    while(k_timer_status_get(&timer) == 0);
4003454a:	8d 45 c8             	lea    -0x38(%ebp),%eax
4003454d:	e8 b5 62 00 00       	call   4003a807 <k_timer_status_get>
40034552:	85 c0                	test   %eax,%eax
40034554:	74 f4                	je     4003454a <upm_delay_ms+0x2a>
    nano_timer_start(&timer, MSEC(time) + 1);
    nano_timer_test(&timer, TICKS_UNLIMITED);

# endif
#endif
}
40034556:	83 c4 34             	add    $0x34,%esp
40034559:	5b                   	pop    %ebx
4003455a:	5d                   	pop    %ebp
4003455b:	c3                   	ret    

4003455c <upm_rand_range>:

    return elapsed;
#endif
}

uint32_t upm_rand_range(int L, int H) {
4003455c:	55                   	push   %ebp
4003455d:	89 e5                	mov    %esp,%ebp
4003455f:	56                   	push   %esi
40034560:	89 c6                	mov    %eax,%esi
40034562:	53                   	push   %ebx
40034563:	89 d3                	mov    %edx,%ebx
    return (int32_t)((rand()%(H - L + 1)) + L); 
40034565:	e8 40 67 00 00       	call   4003acaa <rand>
4003456a:	29 f3                	sub    %esi,%ebx
4003456c:	99                   	cltd   
4003456d:	8d 4b 01             	lea    0x1(%ebx),%ecx
}
40034570:	5b                   	pop    %ebx
    return (int32_t)((rand()%(H - L + 1)) + L); 
40034571:	f7 f9                	idiv   %ecx
40034573:	8d 04 32             	lea    (%edx,%esi,1),%eax
}
40034576:	5e                   	pop    %esi
40034577:	5d                   	pop    %ebp
40034578:	c3                   	ret    

40034579 <sx1276_on_dio0_irq>:
        break;	
    }
    return UPM_SUCCESS;
}

void sx1276_on_dio0_irq() {
40034579:	55                   	push   %ebp
4003457a:	89 e5                	mov    %esp,%ebp
    printf("interrupt 0 detected\n");
4003457c:	68 e7 c3 03 40       	push   $0x4003c3e7
40034581:	e8 f2 66 00 00       	call   4003ac78 <iprintf>
40034586:	58                   	pop    %eax
    int_flag = int_flag | 1;
40034587:	a0 94 81 00 a8       	mov    0xa8008194,%al
4003458c:	83 c8 01             	or     $0x1,%eax
4003458f:	a2 94 81 00 a8       	mov    %al,0xa8008194
}
40034594:	c9                   	leave  
40034595:	c3                   	ret    

40034596 <sx1276_on_dio1_irq>:

void sx1276_on_dio1_irq() {
40034596:	55                   	push   %ebp
40034597:	89 e5                	mov    %esp,%ebp
    printf("interrupt 1 detected\n");
40034599:	68 fd c3 03 40       	push   $0x4003c3fd
4003459e:	e8 d5 66 00 00       	call   4003ac78 <iprintf>
400345a3:	58                   	pop    %eax
    int_flag = int_flag | 2;
400345a4:	a0 94 81 00 a8       	mov    0xa8008194,%al
400345a9:	83 c8 02             	or     $0x2,%eax
400345ac:	a2 94 81 00 a8       	mov    %al,0xa8008194
}
400345b1:	c9                   	leave  
400345b2:	c3                   	ret    

400345b3 <sx1276_on_dio2_irq>:

void sx1276_on_dio2_irq() {
400345b3:	55                   	push   %ebp
400345b4:	89 e5                	mov    %esp,%ebp
    printf("interrupt 2 detected\n");
400345b6:	68 13 c4 03 40       	push   $0x4003c413
400345bb:	e8 b8 66 00 00       	call   4003ac78 <iprintf>
400345c0:	58                   	pop    %eax
    int_flag = int_flag | 4;
400345c1:	a0 94 81 00 a8       	mov    0xa8008194,%al
400345c6:	83 c8 04             	or     $0x4,%eax
400345c9:	a2 94 81 00 a8       	mov    %al,0xa8008194
}
400345ce:	c9                   	leave  
400345cf:	c3                   	ret    

400345d0 <sx1276_on_dio3_irq>:

void sx1276_on_dio3_irq() {
400345d0:	55                   	push   %ebp
400345d1:	89 e5                	mov    %esp,%ebp
    printf("interrupt 3 detected\n");
400345d3:	68 29 c4 03 40       	push   $0x4003c429
400345d8:	e8 9b 66 00 00       	call   4003ac78 <iprintf>
400345dd:	58                   	pop    %eax
    int_flag = int_flag | 8;
400345de:	a0 94 81 00 a8       	mov    0xa8008194,%al
400345e3:	83 c8 08             	or     $0x8,%eax
400345e6:	a2 94 81 00 a8       	mov    %al,0xa8008194
}
400345eb:	c9                   	leave  
400345ec:	c3                   	ret    

400345ed <sx1276_on_dio4_irq>:

void sx1276_on_dio4_irq() {
400345ed:	55                   	push   %ebp
400345ee:	89 e5                	mov    %esp,%ebp
    printf("interrupt 4 detected\n");
400345f0:	68 3f c4 03 40       	push   $0x4003c43f
400345f5:	e8 7e 66 00 00       	call   4003ac78 <iprintf>
400345fa:	58                   	pop    %eax
    // not doing anything
    // unlock interrupts
}
400345fb:	c9                   	leave  
400345fc:	c3                   	ret    

400345fd <sx1276_reset>:
upm_result_t sx1276_reset(sx1276_context dev){
400345fd:	55                   	push   %ebp
    if(mraa_gpio_write(dev->gpio_reset, 0) != MRAA_SUCCESS) { 
400345fe:	31 d2                	xor    %edx,%edx
upm_result_t sx1276_reset(sx1276_context dev){
40034600:	89 e5                	mov    %esp,%ebp
40034602:	53                   	push   %ebx
40034603:	89 c3                	mov    %eax,%ebx
    if(mraa_gpio_write(dev->gpio_reset, 0) != MRAA_SUCCESS) { 
40034605:	8b 40 04             	mov    0x4(%eax),%eax
40034608:	e8 41 f2 ff ff       	call   4003384e <mraa_gpio_write>
4003460d:	85 c0                	test   %eax,%eax
4003460f:	74 0b                	je     4003461c <sx1276_reset+0x1f>
        printf("unable to write the reset pin\n");
40034611:	68 55 c4 03 40       	push   $0x4003c455
40034616:	e8 5d 66 00 00       	call   4003ac78 <iprintf>
4003461b:	5a                   	pop    %edx
    if(mraa_gpio_write(dev->gpio_reset, 1) != MRAA_SUCCESS) { 
4003461c:	8b 43 04             	mov    0x4(%ebx),%eax
4003461f:	ba 01 00 00 00       	mov    $0x1,%edx
40034624:	e8 25 f2 ff ff       	call   4003384e <mraa_gpio_write>
40034629:	85 c0                	test   %eax,%eax
4003462b:	74 0b                	je     40034638 <sx1276_reset+0x3b>
        printf("unable to write the reset pin\n");
4003462d:	68 55 c4 03 40       	push   $0x4003c455
40034632:	e8 41 66 00 00       	call   4003ac78 <iprintf>
40034637:	58                   	pop    %eax
}
40034638:	31 c0                	xor    %eax,%eax
4003463a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4003463d:	c9                   	leave  
4003463e:	c3                   	ret    

4003463f <sx1276_dio1_qos>:
upm_result_t sx1276_dio1_qos(sx1276_context dev) {
4003463f:	55                   	push   %ebp
    switch (dev->settings->state) {
40034640:	8b 40 24             	mov    0x24(%eax),%eax
upm_result_t sx1276_dio1_qos(sx1276_context dev) {
40034643:	89 e5                	mov    %esp,%ebp
    switch (dev->settings->state) {
40034645:	8b 50 04             	mov    0x4(%eax),%edx
40034648:	4a                   	dec    %edx
40034649:	75 16                	jne    40034661 <sx1276_dio1_qos+0x22>
            switch (dev->settings->modem) {
4003464b:	83 38 00             	cmpl   $0x0,(%eax)
4003464e:	75 11                	jne    40034661 <sx1276_dio1_qos+0x22>
                    dev->settings->state = STATE_IDLE;
40034650:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
                    r_event = REVENT_TIMEOUT;
40034657:	c7 05 ac 81 00 a8 03 	movl   $0x3,0xa80081ac
4003465e:	00 00 00 
    printf("r_event: %d\n", r_event);
40034661:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
40034666:	50                   	push   %eax
40034667:	68 74 c4 03 40       	push   $0x4003c474
4003466c:	e8 07 66 00 00       	call   4003ac78 <iprintf>
40034671:	58                   	pop    %eax
}
40034672:	31 c0                	xor    %eax,%eax
    printf("r_event: %d\n", r_event);
40034674:	5a                   	pop    %edx
}
40034675:	c9                   	leave  
40034676:	c3                   	ret    

40034677 <sx1276_cs_on>:

upm_result_t sx1276_cs_on(sx1276_context dev) {
40034677:	55                   	push   %ebp
    if(mraa_gpio_write(dev->gpio_cs, 0) != MRAA_SUCCESS) {
40034678:	31 d2                	xor    %edx,%edx
upm_result_t sx1276_cs_on(sx1276_context dev) {
4003467a:	89 e5                	mov    %esp,%ebp
    if(mraa_gpio_write(dev->gpio_cs, 0) != MRAA_SUCCESS) {
4003467c:	8b 00                	mov    (%eax),%eax
4003467e:	e8 cb f1 ff ff       	call   4003384e <mraa_gpio_write>
40034683:	85 c0                	test   %eax,%eax
40034685:	74 0b                	je     40034692 <sx1276_cs_on+0x1b>
        printf("unable to select chip\n");
40034687:	68 81 c4 03 40       	push   $0x4003c481
4003468c:	e8 e7 65 00 00       	call   4003ac78 <iprintf>
40034691:	58                   	pop    %eax
    }
    return UPM_SUCCESS;
}
40034692:	31 c0                	xor    %eax,%eax
40034694:	c9                   	leave  
40034695:	c3                   	ret    

40034696 <sx1276_cs_off>:
upm_result_t sx1276_cs_off(sx1276_context dev) {
40034696:	55                   	push   %ebp
    if(mraa_gpio_write(dev->gpio_cs, 1) != MRAA_SUCCESS) {
40034697:	ba 01 00 00 00       	mov    $0x1,%edx
upm_result_t sx1276_cs_off(sx1276_context dev) {
4003469c:	89 e5                	mov    %esp,%ebp
    if(mraa_gpio_write(dev->gpio_cs, 1) != MRAA_SUCCESS) {
4003469e:	8b 00                	mov    (%eax),%eax
400346a0:	e8 a9 f1 ff ff       	call   4003384e <mraa_gpio_write>
400346a5:	85 c0                	test   %eax,%eax
400346a7:	74 0b                	je     400346b4 <sx1276_cs_off+0x1e>
        printf("unable to select chip\n");
400346a9:	68 81 c4 03 40       	push   $0x4003c481
400346ae:	e8 c5 65 00 00       	call   4003ac78 <iprintf>
400346b3:	58                   	pop    %eax
    }
    return UPM_SUCCESS;
}
400346b4:	31 c0                	xor    %eax,%eax
400346b6:	c9                   	leave  
400346b7:	c3                   	ret    

400346b8 <sx1276_read_reg>:
uint8_t sx1276_read_reg(sx1276_context dev, uint8_t reg) {
400346b8:	55                   	push   %ebp
    uint8_t tx_buf[2] = { reg & 0x7f, 0 };
400346b9:	83 e2 7f             	and    $0x7f,%edx
uint8_t sx1276_read_reg(sx1276_context dev, uint8_t reg) {
400346bc:	89 e5                	mov    %esp,%ebp
400346be:	53                   	push   %ebx
400346bf:	89 c3                	mov    %eax,%ebx
400346c1:	51                   	push   %ecx
    uint8_t tx_buf[2] = { reg & 0x7f, 0 };
400346c2:	88 55 f8             	mov    %dl,-0x8(%ebp)
400346c5:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
    sx1276_cs_on(dev);
400346c9:	e8 a9 ff ff ff       	call   40034677 <sx1276_cs_on>
    if (mraa_spi_transfer_buf(dev->spi, tx_buf, rx_buf, 2) != MRAA_SUCCESS) {
400346ce:	8d 55 f8             	lea    -0x8(%ebp),%edx
400346d1:	8b 43 20             	mov    0x20(%ebx),%eax
400346d4:	8d 4d fa             	lea    -0x6(%ebp),%ecx
400346d7:	6a 02                	push   $0x2
400346d9:	e8 62 f3 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
400346de:	5a                   	pop    %edx
400346df:	85 c0                	test   %eax,%eax
400346e1:	74 22                	je     40034705 <sx1276_read_reg+0x4d>
        printf("Unable to transfer data over the SPI bus\n");
400346e3:	68 98 c4 03 40       	push   $0x4003c498
400346e8:	e8 8b 65 00 00       	call   4003ac78 <iprintf>
        printf("SPI operation failed\n");
400346ed:	c7 04 24 c2 c4 03 40 	movl   $0x4003c4c2,(%esp)
400346f4:	e8 7f 65 00 00       	call   4003ac78 <iprintf>
400346f9:	58                   	pop    %eax
        sx1276_cs_off(dev);
400346fa:	89 d8                	mov    %ebx,%eax
400346fc:	e8 95 ff ff ff       	call   40034696 <sx1276_cs_off>
40034701:	b0 ff                	mov    $0xff,%al
40034703:	eb 0a                	jmp    4003470f <sx1276_read_reg+0x57>
    sx1276_cs_off(dev);
40034705:	89 d8                	mov    %ebx,%eax
40034707:	e8 8a ff ff ff       	call   40034696 <sx1276_cs_off>
    return rx_buf[1];
4003470c:	8a 45 fb             	mov    -0x5(%ebp),%al
}
4003470f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40034712:	c9                   	leave  
40034713:	c3                   	ret    

40034714 <sx1276_get_chip_version>:
upm_result_t sx1276_get_chip_version(sx1276_context dev, uint8_t* chip_id) {
40034714:	55                   	push   %ebp
40034715:	89 e5                	mov    %esp,%ebp
40034717:	53                   	push   %ebx
40034718:	89 d3                	mov    %edx,%ebx
    uint8_t ret = sx1276_read_reg(dev, COM_RegVersion);
4003471a:	ba 42 00 00 00       	mov    $0x42,%edx
4003471f:	e8 94 ff ff ff       	call   400346b8 <sx1276_read_reg>
    *chip_id = ret;
40034724:	88 03                	mov    %al,(%ebx)
}
40034726:	31 c0                	xor    %eax,%eax
40034728:	5b                   	pop    %ebx
40034729:	5d                   	pop    %ebp
4003472a:	c3                   	ret    

4003472b <sx1276_write_reg>:
upm_result_t sx1276_write_reg(sx1276_context dev, uint8_t reg, uint8_t val) {
4003472b:	55                   	push   %ebp
    uint8_t pkt[2] = {(uint8_t)(reg | m_writeMode), val};
4003472c:	83 ca 80             	or     $0xffffff80,%edx
upm_result_t sx1276_write_reg(sx1276_context dev, uint8_t reg, uint8_t val) {
4003472f:	89 e5                	mov    %esp,%ebp
40034731:	53                   	push   %ebx
40034732:	53                   	push   %ebx
40034733:	89 c3                	mov    %eax,%ebx
    uint8_t pkt[2] = {(uint8_t)(reg | m_writeMode), val};
40034735:	88 55 fa             	mov    %dl,-0x6(%ebp)
40034738:	88 4d fb             	mov    %cl,-0x5(%ebp)
    sx1276_cs_on(dev);
4003473b:	e8 37 ff ff ff       	call   40034677 <sx1276_cs_on>
    if (mraa_spi_transfer_buf(dev->spi, pkt, NULL, 2) != MRAA_SUCCESS) {
40034740:	31 c9                	xor    %ecx,%ecx
40034742:	8d 55 fa             	lea    -0x6(%ebp),%edx
40034745:	8b 43 20             	mov    0x20(%ebx),%eax
40034748:	6a 02                	push   $0x2
4003474a:	e8 f1 f2 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
4003474f:	5a                   	pop    %edx
40034750:	85 c0                	test   %eax,%eax
40034752:	74 25                	je     40034779 <sx1276_write_reg+0x4e>
        printf("Unable to transfer data over the SPI bus\n");
40034754:	68 98 c4 03 40       	push   $0x4003c498
40034759:	e8 1a 65 00 00       	call   4003ac78 <iprintf>
        printf("SPI operation failed\n");
4003475e:	c7 04 24 c2 c4 03 40 	movl   $0x4003c4c2,(%esp)
40034765:	e8 0e 65 00 00       	call   4003ac78 <iprintf>
4003476a:	58                   	pop    %eax
        sx1276_cs_off(dev);
4003476b:	89 d8                	mov    %ebx,%eax
4003476d:	e8 24 ff ff ff       	call   40034696 <sx1276_cs_off>
40034772:	b8 08 00 00 00       	mov    $0x8,%eax
40034777:	eb 09                	jmp    40034782 <sx1276_write_reg+0x57>
    sx1276_cs_off(dev);
40034779:	89 d8                	mov    %ebx,%eax
4003477b:	e8 16 ff ff ff       	call   40034696 <sx1276_cs_off>
    return UPM_SUCCESS;
40034780:	31 c0                	xor    %eax,%eax
}
40034782:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40034785:	c9                   	leave  
40034786:	c3                   	ret    

40034787 <sx1276_set_channel>:
upm_result_t sx1276_set_channel(sx1276_context dev, uint32_t freq) {
40034787:	55                   	push   %ebp
40034788:	89 e5                	mov    %esp,%ebp
4003478a:	56                   	push   %esi
4003478b:	89 c6                	mov    %eax,%esi
4003478d:	89 d0                	mov    %edx,%eax
4003478f:	53                   	push   %ebx
    dev->settings->channel = freq;
40034790:	8b 56 24             	mov    0x24(%esi),%edx
40034793:	89 42 08             	mov    %eax,0x8(%edx)
    freq = ( uint32_t )( ( double )freq / FXOSC_STEP );
40034796:	e8 66 cf ff ff       	call   40031701 <__floatunsidf>
4003479b:	68 80 84 4e 40       	push   $0x404e8480
400347a0:	6a 00                	push   $0x0
400347a2:	e8 57 c2 ff ff       	call   400309fe <__divdf3>
400347a7:	59                   	pop    %ecx
400347a8:	5b                   	pop    %ebx
400347a9:	e8 59 ce ff ff       	call   40031607 <__fixunsdfsi>
    if(sx1276_write_reg(dev, COM_RegFrfMsb, ( uint8_t )( ( freq >> 16 ) & 0xff ) ) != UPM_SUCCESS) {
400347ae:	ba 06 00 00 00       	mov    $0x6,%edx
400347b3:	89 c1                	mov    %eax,%ecx
    freq = ( uint32_t )( ( double )freq / FXOSC_STEP );
400347b5:	89 c3                	mov    %eax,%ebx
    if(sx1276_write_reg(dev, COM_RegFrfMsb, ( uint8_t )( ( freq >> 16 ) & 0xff ) ) != UPM_SUCCESS) {
400347b7:	c1 e9 10             	shr    $0x10,%ecx
400347ba:	89 f0                	mov    %esi,%eax
400347bc:	0f b6 c9             	movzbl %cl,%ecx
400347bf:	e8 67 ff ff ff       	call   4003472b <sx1276_write_reg>
400347c4:	85 c0                	test   %eax,%eax
400347c6:	74 07                	je     400347cf <sx1276_set_channel+0x48>
        return UPM_ERROR_OPERATION_FAILED;
400347c8:	b8 08 00 00 00       	mov    $0x8,%eax
400347cd:	eb 26                	jmp    400347f5 <sx1276_set_channel+0x6e>
    if(sx1276_write_reg(dev, COM_RegFrfMid, ( uint8_t )( ( freq >> 8 ) & 0xff ) ) != UPM_SUCCESS) {
400347cf:	0f b6 cf             	movzbl %bh,%ecx
400347d2:	ba 07 00 00 00       	mov    $0x7,%edx
400347d7:	89 f0                	mov    %esi,%eax
400347d9:	e8 4d ff ff ff       	call   4003472b <sx1276_write_reg>
400347de:	85 c0                	test   %eax,%eax
400347e0:	75 e6                	jne    400347c8 <sx1276_set_channel+0x41>
    if(sx1276_write_reg(dev, COM_RegFrfLsb, ( uint8_t )( freq & 0xff ) ) != UPM_SUCCESS) {
400347e2:	0f b6 cb             	movzbl %bl,%ecx
400347e5:	ba 08 00 00 00       	mov    $0x8,%edx
400347ea:	89 f0                	mov    %esi,%eax
400347ec:	e8 3a ff ff ff       	call   4003472b <sx1276_write_reg>
400347f1:	85 c0                	test   %eax,%eax
400347f3:	75 d3                	jne    400347c8 <sx1276_set_channel+0x41>
}
400347f5:	8d 65 f8             	lea    -0x8(%ebp),%esp
400347f8:	5b                   	pop    %ebx
400347f9:	5e                   	pop    %esi
400347fa:	5d                   	pop    %ebp
400347fb:	c3                   	ret    

400347fc <sx1276_rx_chain_calibration>:
upm_result_t sx1276_rx_chain_calibration(sx1276_context dev){
400347fc:	55                   	push   %ebp
    regPaConfigInitVal = sx1276_read_reg(dev, COM_RegPaConfig);
400347fd:	ba 09 00 00 00       	mov    $0x9,%edx
upm_result_t sx1276_rx_chain_calibration(sx1276_context dev){
40034802:	89 e5                	mov    %esp,%ebp
40034804:	57                   	push   %edi
40034805:	56                   	push   %esi
40034806:	53                   	push   %ebx
40034807:	89 c3                	mov    %eax,%ebx
40034809:	57                   	push   %edi
    regPaConfigInitVal = sx1276_read_reg(dev, COM_RegPaConfig);
4003480a:	e8 a9 fe ff ff       	call   400346b8 <sx1276_read_reg>
                               (((uint32_t)sx1276_read_reg(dev, COM_RegFrfMsb) << 16) |
4003480f:	ba 06 00 00 00       	mov    $0x6,%edx
    regPaConfigInitVal = sx1276_read_reg(dev, COM_RegPaConfig);
40034814:	89 c7                	mov    %eax,%edi
                               (((uint32_t)sx1276_read_reg(dev, COM_RegFrfMsb) << 16) |
40034816:	89 d8                	mov    %ebx,%eax
40034818:	e8 9b fe ff ff       	call   400346b8 <sx1276_read_reg>
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
4003481d:	ba 07 00 00 00       	mov    $0x7,%edx
                               (((uint32_t)sx1276_read_reg(dev, COM_RegFrfMsb) << 16) |
40034822:	88 45 f3             	mov    %al,-0xd(%ebp)
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
40034825:	89 d8                	mov    %ebx,%eax
40034827:	e8 8c fe ff ff       	call   400346b8 <sx1276_read_reg>
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfLsb)) ) )
4003482c:	ba 08 00 00 00       	mov    $0x8,%edx
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
40034831:	89 c6                	mov    %eax,%esi
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfLsb)) ) )
40034833:	89 d8                	mov    %ebx,%eax
40034835:	e8 7e fe ff ff       	call   400346b8 <sx1276_read_reg>
    if(sx1276_write_reg(dev, COM_RegPaConfig, 0x00) != UPM_SUCCESS) {
4003483a:	31 c9                	xor    %ecx,%ecx
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfLsb)) ) )
4003483c:	88 45 f2             	mov    %al,-0xe(%ebp)
    if(sx1276_write_reg(dev, COM_RegPaConfig, 0x00) != UPM_SUCCESS) {
4003483f:	ba 09 00 00 00       	mov    $0x9,%edx
40034844:	89 d8                	mov    %ebx,%eax
40034846:	e8 e0 fe ff ff       	call   4003472b <sx1276_write_reg>
4003484b:	85 c0                	test   %eax,%eax
4003484d:	74 0a                	je     40034859 <sx1276_rx_chain_calibration+0x5d>
        return UPM_ERROR_OPERATION_FAILED;
4003484f:	b8 08 00 00 00       	mov    $0x8,%eax
40034854:	e9 e5 00 00 00       	jmp    4003493e <sx1276_rx_chain_calibration+0x142>
    reg = sx1276_read_reg(dev, FSK_RegImageCal);
40034859:	ba 3b 00 00 00       	mov    $0x3b,%edx
4003485e:	89 d8                	mov    %ebx,%eax
40034860:	e8 53 fe ff ff       	call   400346b8 <sx1276_read_reg>
    if(sx1276_write_reg(dev, FSK_RegImageCal, reg | IMAGECAL_ImageCalStart) != UPM_SUCCESS) {
40034865:	ba 3b 00 00 00       	mov    $0x3b,%edx
4003486a:	83 c8 40             	or     $0x40,%eax
4003486d:	0f b6 c8             	movzbl %al,%ecx
40034870:	89 d8                	mov    %ebx,%eax
40034872:	e8 b4 fe ff ff       	call   4003472b <sx1276_write_reg>
40034877:	85 c0                	test   %eax,%eax
40034879:	75 d4                	jne    4003484f <sx1276_rx_chain_calibration+0x53>
    while(sx1276_read_reg(dev, FSK_RegImageCal) & IMAGECAL_ImageCalRunning) {
4003487b:	ba 3b 00 00 00       	mov    $0x3b,%edx
40034880:	89 d8                	mov    %ebx,%eax
40034882:	e8 31 fe ff ff       	call   400346b8 <sx1276_read_reg>
40034887:	a8 20                	test   $0x20,%al
40034889:	74 0c                	je     40034897 <sx1276_rx_chain_calibration+0x9b>
        upm_delay_ms(1);
4003488b:	b8 01 00 00 00       	mov    $0x1,%eax
40034890:	e8 8b fc ff ff       	call   40034520 <upm_delay_ms>
40034895:	eb e4                	jmp    4003487b <sx1276_rx_chain_calibration+0x7f>
    if(sx1276_set_channel(dev, 868000000) != UPM_SUCCESS) {
40034897:	ba 00 a1 bc 33       	mov    $0x33bca100,%edx
4003489c:	89 d8                	mov    %ebx,%eax
4003489e:	e8 e4 fe ff ff       	call   40034787 <sx1276_set_channel>
400348a3:	85 c0                	test   %eax,%eax
400348a5:	75 a8                	jne    4003484f <sx1276_rx_chain_calibration+0x53>
    reg = sx1276_read_reg(dev, FSK_RegImageCal);
400348a7:	ba 3b 00 00 00       	mov    $0x3b,%edx
400348ac:	89 d8                	mov    %ebx,%eax
400348ae:	e8 05 fe ff ff       	call   400346b8 <sx1276_read_reg>
    if(sx1276_write_reg(dev, FSK_RegImageCal, reg | IMAGECAL_ImageCalStart) != UPM_SUCCESS) {
400348b3:	ba 3b 00 00 00       	mov    $0x3b,%edx
400348b8:	83 c8 40             	or     $0x40,%eax
400348bb:	0f b6 c8             	movzbl %al,%ecx
400348be:	89 d8                	mov    %ebx,%eax
400348c0:	e8 66 fe ff ff       	call   4003472b <sx1276_write_reg>
400348c5:	85 c0                	test   %eax,%eax
400348c7:	75 86                	jne    4003484f <sx1276_rx_chain_calibration+0x53>
    while(sx1276_read_reg(dev, FSK_RegImageCal) & IMAGECAL_ImageCalRunning) {
400348c9:	ba 3b 00 00 00       	mov    $0x3b,%edx
400348ce:	89 d8                	mov    %ebx,%eax
400348d0:	e8 e3 fd ff ff       	call   400346b8 <sx1276_read_reg>
400348d5:	a8 20                	test   $0x20,%al
400348d7:	74 0c                	je     400348e5 <sx1276_rx_chain_calibration+0xe9>
        upm_delay_ms(1);
400348d9:	b8 01 00 00 00       	mov    $0x1,%eax
400348de:	e8 3d fc ff ff       	call   40034520 <upm_delay_ms>
400348e3:	eb e4                	jmp    400348c9 <sx1276_rx_chain_calibration+0xcd>
    if(sx1276_write_reg(dev, COM_RegPaConfig, regPaConfigInitVal) != UPM_SUCCESS) {
400348e5:	89 f8                	mov    %edi,%eax
400348e7:	ba 09 00 00 00       	mov    $0x9,%edx
400348ec:	0f b6 c8             	movzbl %al,%ecx
400348ef:	89 d8                	mov    %ebx,%eax
400348f1:	e8 35 fe ff ff       	call   4003472b <sx1276_write_reg>
400348f6:	85 c0                	test   %eax,%eax
400348f8:	0f 85 51 ff ff ff    	jne    4003484f <sx1276_rx_chain_calibration+0x53>
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
400348fe:	89 f1                	mov    %esi,%ecx
                               (((uint32_t)sx1276_read_reg(dev, COM_RegFrfMsb) << 16) |
40034900:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
40034904:	0f b6 f1             	movzbl %cl,%esi
40034907:	c1 e6 08             	shl    $0x8,%esi
                               (((uint32_t)sx1276_read_reg(dev, COM_RegFrfMsb) << 16) |
4003490a:	c1 e0 10             	shl    $0x10,%eax
4003490d:	09 f0                	or     %esi,%eax
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfLsb)) ) )
4003490f:	0f b6 75 f2          	movzbl -0xe(%ebp),%esi
                               ((uint32_t)sx1276_read_reg(dev, COM_RegFrfMid) << 8) |
40034913:	09 f0                	or     %esi,%eax
    initialFreq = (uint32_t) ( ((double)
40034915:	e8 e7 cd ff ff       	call   40031701 <__floatunsidf>
                               * FXOSC_STEP);
4003491a:	68 80 84 4e 40       	push   $0x404e8480
4003491f:	6a 00                	push   $0x0
40034921:	e8 2a c8 ff ff       	call   40031150 <__muldf3>
40034926:	59                   	pop    %ecx
40034927:	5e                   	pop    %esi
    initialFreq = (uint32_t) ( ((double)
40034928:	e8 da cc ff ff       	call   40031607 <__fixunsdfsi>
    if(sx1276_set_channel(dev, initialFreq) != UPM_SUCCESS) {
4003492d:	89 c2                	mov    %eax,%edx
4003492f:	89 d8                	mov    %ebx,%eax
40034931:	e8 51 fe ff ff       	call   40034787 <sx1276_set_channel>
40034936:	85 c0                	test   %eax,%eax
40034938:	0f 85 11 ff ff ff    	jne    4003484f <sx1276_rx_chain_calibration+0x53>
}
4003493e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40034941:	5b                   	pop    %ebx
40034942:	5e                   	pop    %esi
40034943:	5f                   	pop    %edi
40034944:	5d                   	pop    %ebp
40034945:	c3                   	ret    

40034946 <sx1276_set_op_mode>:
upm_result_t sx1276_set_op_mode(sx1276_context dev, MODE_T op_mode){
40034946:	55                   	push   %ebp
40034947:	89 e5                	mov    %esp,%ebp
40034949:	56                   	push   %esi
4003494a:	89 d6                	mov    %edx,%esi
4003494c:	53                   	push   %ebx
    if(op_mode != opModePrev) {
4003494d:	0f b6 15 1c 67 00 a8 	movzbl 0xa800671c,%edx
40034954:	39 f2                	cmp    %esi,%edx
40034956:	74 2b                	je     40034983 <sx1276_set_op_mode+0x3d>
40034958:	89 c3                	mov    %eax,%ebx
        opModePrev = op_mode;
4003495a:	89 f0                	mov    %esi,%eax
4003495c:	a2 1c 67 00 a8       	mov    %al,0xa800671c
        uint8_t reg = sx1276_read_reg(dev, COM_RegOpMode) & 
40034961:	ba 01 00 00 00       	mov    $0x1,%edx
40034966:	89 d8                	mov    %ebx,%eax
40034968:	e8 4b fd ff ff       	call   400346b8 <sx1276_read_reg>
        sx1276_write_reg(dev, COM_RegOpMode, (reg | (op_mode << _OPMODE_Mode_SHIFT)) );
4003496d:	ba 01 00 00 00       	mov    $0x1,%edx
        uint8_t reg = sx1276_read_reg(dev, COM_RegOpMode) & 
40034972:	83 e0 f8             	and    $0xfffffff8,%eax
40034975:	88 c1                	mov    %al,%cl
        sx1276_write_reg(dev, COM_RegOpMode, (reg | (op_mode << _OPMODE_Mode_SHIFT)) );
40034977:	89 d8                	mov    %ebx,%eax
40034979:	09 f1                	or     %esi,%ecx
4003497b:	0f b6 c9             	movzbl %cl,%ecx
4003497e:	e8 a8 fd ff ff       	call   4003472b <sx1276_write_reg>
}
40034983:	5b                   	pop    %ebx
40034984:	31 c0                	xor    %eax,%eax
40034986:	5e                   	pop    %esi
40034987:	5d                   	pop    %ebp
40034988:	c3                   	ret    

40034989 <sx1276_set_stand_by>:
upm_result_t sx1276_set_stand_by(sx1276_context dev) {
40034989:	55                   	push   %ebp
    sx1276_set_op_mode(dev, MODE_Standby);
4003498a:	ba 01 00 00 00       	mov    $0x1,%edx
upm_result_t sx1276_set_stand_by(sx1276_context dev) {
4003498f:	89 e5                	mov    %esp,%ebp
40034991:	53                   	push   %ebx
40034992:	89 c3                	mov    %eax,%ebx
    sx1276_set_op_mode(dev, MODE_Standby);
40034994:	e8 ad ff ff ff       	call   40034946 <sx1276_set_op_mode>
    dev->settings->state = STATE_IDLE;
40034999:	8b 43 24             	mov    0x24(%ebx),%eax
4003499c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
400349a3:	31 c0                	xor    %eax,%eax
400349a5:	5b                   	pop    %ebx
400349a6:	5d                   	pop    %ebp
400349a7:	c3                   	ret    

400349a8 <sx1276_set_modem>:
upm_result_t sx1276_set_modem(sx1276_context dev, RADIO_MODEM_T modem) {
400349a8:	55                   	push   %ebp
400349a9:	89 e5                	mov    %esp,%ebp
400349ab:	53                   	push   %ebx
400349ac:	89 c3                	mov    %eax,%ebx
    if(dev->settings->modem == modem) {
400349ae:	8b 40 24             	mov    0x24(%eax),%eax
400349b1:	39 10                	cmp    %edx,(%eax)
400349b3:	75 0d                	jne    400349c2 <sx1276_set_modem+0x1a>
        printf("modem value is the same, returning\n");
400349b5:	68 d8 c4 03 40       	push   $0x4003c4d8
400349ba:	e8 b9 62 00 00       	call   4003ac78 <iprintf>
400349bf:	5a                   	pop    %edx
        return UPM_SUCCESS;
400349c0:	eb 56                	jmp    40034a18 <sx1276_set_modem+0x70>
    dev->settings->modem = modem;
400349c2:	89 10                	mov    %edx,(%eax)
    switch (dev->settings->modem) {
400349c4:	85 d2                	test   %edx,%edx
400349c6:	75 50                	jne    40034a18 <sx1276_set_modem+0x70>
            if(sx1276_set_op_mode(dev, MODE_Sleep) != UPM_SUCCESS) {
400349c8:	89 d8                	mov    %ebx,%eax
400349ca:	e8 77 ff ff ff       	call   40034946 <sx1276_set_op_mode>
400349cf:	85 c0                	test   %eax,%eax
400349d1:	74 0b                	je     400349de <sx1276_set_modem+0x36>
                printf("sx1276: unable to set op mode in set mode\n");
400349d3:	68 fc c4 03 40       	push   $0x4003c4fc
400349d8:	e8 9b 62 00 00       	call   4003ac78 <iprintf>
400349dd:	58                   	pop    %eax
            reg = (sx1276_read_reg(dev, COM_RegOpMode) | OPMODE_LongRangeMode);
400349de:	ba 01 00 00 00       	mov    $0x1,%edx
400349e3:	89 d8                	mov    %ebx,%eax
400349e5:	e8 ce fc ff ff       	call   400346b8 <sx1276_read_reg>
            sx1276_write_reg(dev, COM_RegOpMode, reg);
400349ea:	ba 01 00 00 00       	mov    $0x1,%edx
            reg = (sx1276_read_reg(dev, COM_RegOpMode) | OPMODE_LongRangeMode);
400349ef:	83 c8 80             	or     $0xffffff80,%eax
            sx1276_write_reg(dev, COM_RegOpMode, reg);
400349f2:	0f b6 c8             	movzbl %al,%ecx
400349f5:	89 d8                	mov    %ebx,%eax
400349f7:	e8 2f fd ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, COM_RegDioMapping1, 0x00);
400349fc:	31 c9                	xor    %ecx,%ecx
400349fe:	ba 40 00 00 00       	mov    $0x40,%edx
40034a03:	89 d8                	mov    %ebx,%eax
40034a05:	e8 21 fd ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, COM_RegDioMapping2, 0x00);
40034a0a:	31 c9                	xor    %ecx,%ecx
40034a0c:	ba 41 00 00 00       	mov    $0x41,%edx
40034a11:	89 d8                	mov    %ebx,%eax
40034a13:	e8 13 fd ff ff       	call   4003472b <sx1276_write_reg>
}
40034a18:	31 c0                	xor    %eax,%eax
40034a1a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40034a1d:	c9                   	leave  
40034a1e:	c3                   	ret    

40034a1f <sx1276_set_tx_config>:
                                  uint8_t hop_period, bool iq_inverted) {
40034a1f:	55                   	push   %ebp
40034a20:	89 e5                	mov    %esp,%ebp
40034a22:	57                   	push   %edi
40034a23:	56                   	push   %esi
40034a24:	53                   	push   %ebx
40034a25:	83 ec 24             	sub    $0x24,%esp
40034a28:	89 c3                	mov    %eax,%ebx
40034a2a:	8b 45 14             	mov    0x14(%ebp),%eax
40034a2d:	89 4d d0             	mov    %ecx,-0x30(%ebp)
40034a30:	89 45 e8             	mov    %eax,-0x18(%ebp)
40034a33:	8b 45 18             	mov    0x18(%ebp),%eax
40034a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
40034a39:	8b 45 1c             	mov    0x1c(%ebp),%eax
40034a3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40034a3f:	8b 45 20             	mov    0x20(%ebp),%eax
40034a42:	89 45 e0             	mov    %eax,-0x20(%ebp)
40034a45:	8b 45 24             	mov    0x24(%ebp),%eax
40034a48:	89 45 dc             	mov    %eax,-0x24(%ebp)
40034a4b:	8b 45 28             	mov    0x28(%ebp),%eax
40034a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
40034a51:	8b 45 2c             	mov    0x2c(%ebp),%eax
40034a54:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    sx1276_set_modem(dev, modem);
40034a57:	89 d8                	mov    %ebx,%eax
                                  uint8_t hop_period, bool iq_inverted) {
40034a59:	89 55 ec             	mov    %edx,-0x14(%ebp)
    sx1276_set_modem(dev, modem);
40034a5c:	e8 47 ff ff ff       	call   400349a8 <sx1276_set_modem>
    paConfig = sx1276_read_reg(dev, COM_RegPaConfig);
40034a61:	ba 09 00 00 00       	mov    $0x9,%edx
40034a66:	89 d8                	mov    %ebx,%eax
40034a68:	e8 4b fc ff ff       	call   400346b8 <sx1276_read_reg>
    paDac = sx1276_read_reg(dev, COM_RegPaDac);
40034a6d:	ba 4d 00 00 00       	mov    $0x4d,%edx
40034a72:	89 d8                	mov    %ebx,%eax
40034a74:	e8 3f fc ff ff       	call   400346b8 <sx1276_read_reg>
    if ((paConfig & PACONFIG_PaSelect)) {
40034a79:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    paDac = sx1276_read_reg(dev, COM_RegPaDac);
40034a7c:	89 c7                	mov    %eax,%edi
    if (dev->settings->channel < RF_MID_BAND_THRESH)
40034a7e:	8b 43 24             	mov    0x24(%ebx),%eax
    paSelect = PACONFIG_PaSelect; // PA_BOOST, +20dBm
40034a81:	81 78 08 40 dd 4a 1f 	cmpl   $0x1f4add40,0x8(%eax)
40034a88:	19 c0                	sbb    %eax,%eax
    if ((paConfig & PACONFIG_PaSelect)) {
40034a8a:	84 c0                	test   %al,%al
40034a8c:	79 4b                	jns    40034ad9 <sx1276_set_tx_config+0xba>
        if (power > 17) {
40034a8e:	80 f9 11             	cmp    $0x11,%cl
40034a91:	7e 05                	jle    40034a98 <sx1276_set_tx_config+0x79>
            paDac |= (PADAC_BOOST << _PADAC_PaDac_SHIFT);
40034a93:	83 cf 07             	or     $0x7,%edi
40034a96:	eb 06                	jmp    40034a9e <sx1276_set_tx_config+0x7f>
            paDac &= ~(_PADAC_PaDac_MASK << _PADAC_PaDac_SHIFT);
40034a98:	83 e7 f8             	and    $0xfffffff8,%edi
            paDac |= (PADAC_DEFAULT << _PADAC_PaDac_SHIFT);
40034a9b:	83 cf 04             	or     $0x4,%edi
        if ((paDac & PADAC_BOOST) == PADAC_BOOST) {
40034a9e:	89 f8                	mov    %edi,%eax
40034aa0:	89 ce                	mov    %ecx,%esi
40034aa2:	83 e0 07             	and    $0x7,%eax
40034aa5:	3c 07                	cmp    $0x7,%al
40034aa7:	75 18                	jne    40034ac1 <sx1276_set_tx_config+0xa2>
40034aa9:	80 f9 14             	cmp    $0x14,%cl
40034aac:	7e 07                	jle    40034ab5 <sx1276_set_tx_config+0x96>
40034aae:	be 14 00 00 00       	mov    $0x14,%esi
40034ab3:	eb 3b                	jmp    40034af0 <sx1276_set_tx_config+0xd1>
40034ab5:	80 f9 05             	cmp    $0x5,%cl
40034ab8:	7d 36                	jge    40034af0 <sx1276_set_tx_config+0xd1>
40034aba:	be 05 00 00 00       	mov    $0x5,%esi
40034abf:	eb 2f                	jmp    40034af0 <sx1276_set_tx_config+0xd1>
40034ac1:	80 f9 11             	cmp    $0x11,%cl
40034ac4:	7e 07                	jle    40034acd <sx1276_set_tx_config+0xae>
40034ac6:	be 11 00 00 00       	mov    $0x11,%esi
40034acb:	eb 23                	jmp    40034af0 <sx1276_set_tx_config+0xd1>
40034acd:	80 f9 02             	cmp    $0x2,%cl
40034ad0:	7d 1e                	jge    40034af0 <sx1276_set_tx_config+0xd1>
40034ad2:	be 02 00 00 00       	mov    $0x2,%esi
40034ad7:	eb 17                	jmp    40034af0 <sx1276_set_tx_config+0xd1>
40034ad9:	89 ce                	mov    %ecx,%esi
40034adb:	80 f9 0e             	cmp    $0xe,%cl
40034ade:	7e 07                	jle    40034ae7 <sx1276_set_tx_config+0xc8>
40034ae0:	be 0e 00 00 00       	mov    $0xe,%esi
40034ae5:	eb 09                	jmp    40034af0 <sx1276_set_tx_config+0xd1>
40034ae7:	84 c9                	test   %cl,%cl
40034ae9:	79 05                	jns    40034af0 <sx1276_set_tx_config+0xd1>
40034aeb:	be ff ff ff ff       	mov    $0xffffffff,%esi
    if(sx1276_write_reg(dev, COM_RegPaConfig, paConfig) != UPM_SUCCESS) {
40034af0:	b9 ff 00 00 00       	mov    $0xff,%ecx
40034af5:	ba 09 00 00 00       	mov    $0x9,%edx
40034afa:	89 d8                	mov    %ebx,%eax
40034afc:	e8 2a fc ff ff       	call   4003472b <sx1276_write_reg>
40034b01:	85 c0                	test   %eax,%eax
40034b03:	74 0a                	je     40034b0f <sx1276_set_tx_config+0xf0>
        return UPM_ERROR_OPERATION_FAILED;
40034b05:	bf 08 00 00 00       	mov    $0x8,%edi
40034b0a:	e9 65 02 00 00       	jmp    40034d74 <sx1276_set_tx_config+0x355>
    if(sx1276_write_reg(dev, COM_RegPaDac, paDac) != UPM_SUCCESS) {
40034b0f:	89 f8                	mov    %edi,%eax
40034b11:	ba 4d 00 00 00       	mov    $0x4d,%edx
40034b16:	0f b6 c8             	movzbl %al,%ecx
40034b19:	89 d8                	mov    %ebx,%eax
40034b1b:	e8 0b fc ff ff       	call   4003472b <sx1276_write_reg>
40034b20:	89 c7                	mov    %eax,%edi
40034b22:	85 c0                	test   %eax,%eax
40034b24:	75 df                	jne    40034b05 <sx1276_set_tx_config+0xe6>
    switch (modem) {
40034b26:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40034b2a:	0f 85 44 02 00 00    	jne    40034d74 <sx1276_set_tx_config+0x355>
            dev->settings->loraSettings->Power = power;
40034b30:	8b 43 24             	mov    0x24(%ebx),%eax
40034b33:	89 f2                	mov    %esi,%edx
            switch (bandwidth) {
40034b35:	81 7d 0c 90 d0 03 00 	cmpl   $0x3d090,0xc(%ebp)
            dev->settings->loraSettings->Power = power;
40034b3c:	8b 40 0c             	mov    0xc(%eax),%eax
40034b3f:	88 10                	mov    %dl,(%eax)
            switch (bandwidth) {
40034b41:	74 1f                	je     40034b62 <sx1276_set_tx_config+0x143>
40034b43:	81 7d 0c 20 a1 07 00 	cmpl   $0x7a120,0xc(%ebp)
40034b4a:	74 1f                	je     40034b6b <sx1276_set_tx_config+0x14c>
40034b4c:	81 7d 0c 48 e8 01 00 	cmpl   $0x1e848,0xc(%ebp)
40034b53:	74 1f                	je     40034b74 <sx1276_set_tx_config+0x155>
                printf("sx1276: LORA bandwidth must be 125000, 250000 or 500000\n");
40034b55:	68 27 c5 03 40       	push   $0x4003c527
40034b5a:	e8 19 61 00 00       	call   4003ac78 <iprintf>
40034b5f:	58                   	pop    %eax
40034b60:	eb 19                	jmp    40034b7b <sx1276_set_tx_config+0x15c>
                bandwidth = BW_250;
40034b62:	c7 45 0c 08 00 00 00 	movl   $0x8,0xc(%ebp)
40034b69:	eb 10                	jmp    40034b7b <sx1276_set_tx_config+0x15c>
                bandwidth = BW_500;
40034b6b:	c7 45 0c 09 00 00 00 	movl   $0x9,0xc(%ebp)
            break;
40034b72:	eb 07                	jmp    40034b7b <sx1276_set_tx_config+0x15c>
                bandwidth = BW_125;
40034b74:	c7 45 0c 07 00 00 00 	movl   $0x7,0xc(%ebp)
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034b7b:	8b 43 24             	mov    0x24(%ebx),%eax
            dev->settings->loraSettings->Coderate = coderate;
40034b7e:	8a 55 e8             	mov    -0x18(%ebp),%dl
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034b81:	8b 75 0c             	mov    0xc(%ebp),%esi
40034b84:	8b 40 0c             	mov    0xc(%eax),%eax
            if (datarate > 12) {
40034b87:	83 7d 10 0c          	cmpl   $0xc,0x10(%ebp)
            dev->settings->loraSettings->Coderate = coderate;
40034b8b:	88 50 0d             	mov    %dl,0xd(%eax)
            dev->settings->loraSettings->FixLen = fix_len;
40034b8e:	8a 55 e4             	mov    -0x1c(%ebp),%dl
40034b91:	88 50 10             	mov    %dl,0x10(%eax)
            dev->settings->loraSettings->FreqHopOn = freq_hop_on;
40034b94:	8a 55 dc             	mov    -0x24(%ebp),%dl
40034b97:	88 50 13             	mov    %dl,0x13(%eax)
            dev->settings->loraSettings->HopPeriod = hop_period;
40034b9a:	8a 55 d8             	mov    -0x28(%ebp),%dl
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034b9d:	89 70 04             	mov    %esi,0x4(%eax)
            dev->settings->loraSettings->HopPeriod = hop_period;
40034ba0:	88 50 14             	mov    %dl,0x14(%eax)
            dev->settings->loraSettings->Datarate = datarate;
40034ba3:	8b 75 10             	mov    0x10(%ebp),%esi
            dev->settings->loraSettings->CrcOn = crc_on;
40034ba6:	8a 55 e0             	mov    -0x20(%ebp),%dl
            dev->settings->loraSettings->Datarate = datarate;
40034ba9:	89 70 08             	mov    %esi,0x8(%eax)
            dev->settings->loraSettings->CrcOn = crc_on;
40034bac:	88 50 12             	mov    %dl,0x12(%eax)
            dev->settings->loraSettings->PreambleLen = preamble_len;
40034baf:	8b 75 f0             	mov    -0x10(%ebp),%esi
            dev->settings->loraSettings->IqInverted = iq_inverted;
40034bb2:	8a 55 d4             	mov    -0x2c(%ebp),%dl
            dev->settings->loraSettings->PreambleLen = preamble_len;
40034bb5:	66 89 70 0e          	mov    %si,0xe(%eax)
            dev->settings->loraSettings->IqInverted = iq_inverted;
40034bb9:	88 50 15             	mov    %dl,0x15(%eax)
            if (datarate > 12) {
40034bbc:	0f 87 9c 01 00 00    	ja     40034d5e <sx1276_set_tx_config+0x33f>
            } else if (datarate < 6) {
40034bc2:	83 7d 10 05          	cmpl   $0x5,0x10(%ebp)
40034bc6:	76 13                	jbe    40034bdb <sx1276_set_tx_config+0x1bc>
            if ( ((bandwidth == BW_125) && ((datarate == 11) || 
40034bc8:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
40034bcc:	75 14                	jne    40034be2 <sx1276_set_tx_config+0x1c3>
40034bce:	8b 75 10             	mov    0x10(%ebp),%esi
40034bd1:	8d 56 f5             	lea    -0xb(%esi),%edx
40034bd4:	83 fa 01             	cmp    $0x1,%edx
40034bd7:	77 09                	ja     40034be2 <sx1276_set_tx_config+0x1c3>
40034bd9:	eb 1a                	jmp    40034bf5 <sx1276_set_tx_config+0x1d6>
                datarate = 6;
40034bdb:	c7 45 10 06 00 00 00 	movl   $0x6,0x10(%ebp)
                                        (datarate == 12))) ||
40034be2:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
40034be6:	75 13                	jne    40034bfb <sx1276_set_tx_config+0x1dc>
40034be8:	83 7d 10 0c          	cmpl   $0xc,0x10(%ebp)
40034bec:	75 0d                	jne    40034bfb <sx1276_set_tx_config+0x1dc>
                datarate = 12;
40034bee:	c7 45 10 0c 00 00 00 	movl   $0xc,0x10(%ebp)
                dev->settings->loraSettings->LowDatarateOptimize = true;
40034bf5:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
40034bf9:	eb 04                	jmp    40034bff <sx1276_set_tx_config+0x1e0>
                dev->settings->loraSettings->LowDatarateOptimize = false;
40034bfb:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034bff:	ba 44 00 00 00       	mov    $0x44,%edx
40034c04:	89 d8                	mov    %ebx,%eax
            if (dev->settings->loraSettings->FreqHopOn == true) {
40034c06:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
40034c0a:	74 28                	je     40034c34 <sx1276_set_tx_config+0x215>
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034c0c:	e8 a7 fa ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034c11:	ba 44 00 00 00       	mov    $0x44,%edx
                reg |= PLLHOP_FastHopOn;
40034c16:	83 c8 80             	or     $0xffffff80,%eax
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034c19:	0f b6 c8             	movzbl %al,%ecx
40034c1c:	89 d8                	mov    %ebx,%eax
40034c1e:	e8 08 fb ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegHopPeriod, dev->settings->loraSettings->HopPeriod);
40034c23:	8b 43 24             	mov    0x24(%ebx),%eax
40034c26:	8b 40 0c             	mov    0xc(%eax),%eax
40034c29:	ba 24 00 00 00       	mov    $0x24,%edx
40034c2e:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
40034c32:	eb 0f                	jmp    40034c43 <sx1276_set_tx_config+0x224>
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034c34:	e8 7f fa ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034c39:	ba 44 00 00 00       	mov    $0x44,%edx
40034c3e:	89 c1                	mov    %eax,%ecx
40034c40:	83 e1 7f             	and    $0x7f,%ecx
40034c43:	89 d8                	mov    %ebx,%eax
40034c45:	e8 e1 fa ff ff       	call   4003472b <sx1276_write_reg>
            reg = sx1276_read_reg(dev, LOR_RegModemConfig1);
40034c4a:	ba 1d 00 00 00       	mov    $0x1d,%edx
40034c4f:	89 d8                	mov    %ebx,%eax
40034c51:	e8 62 fa ff ff       	call   400346b8 <sx1276_read_reg>
            reg &= ~((_MODEMCONFIG1_CodingRate_MASK << 
40034c56:	83 e0 08             	and    $0x8,%eax
            if (fix_len)
40034c59:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
40034c5d:	74 03                	je     40034c62 <sx1276_set_tx_config+0x243>
                reg |= MODEMCONFIG1_ImplicitHeaderModeOn;
40034c5f:	83 c8 01             	or     $0x1,%eax
            reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
40034c62:	8a 4d 0c             	mov    0xc(%ebp),%cl
            sx1276_write_reg(dev, LOR_RegModemConfig1, reg);
40034c65:	ba 1d 00 00 00       	mov    $0x1d,%edx
            reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
40034c6a:	c1 e1 04             	shl    $0x4,%ecx
40034c6d:	09 c1                	or     %eax,%ecx
            reg |= ((coderate & _MODEMCONFIG1_CodingRate_MASK) << 
40034c6f:	8a 45 e8             	mov    -0x18(%ebp),%al
40034c72:	83 e0 07             	and    $0x7,%eax
40034c75:	09 c1                	or     %eax,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig1, reg);
40034c77:	89 d8                	mov    %ebx,%eax
40034c79:	0f b6 c9             	movzbl %cl,%ecx
40034c7c:	e8 aa fa ff ff       	call   4003472b <sx1276_write_reg>
            reg = sx1276_read_reg(dev, LOR_RegModemConfig2);
40034c81:	ba 1e 00 00 00       	mov    $0x1e,%edx
40034c86:	89 d8                	mov    %ebx,%eax
40034c88:	e8 2b fa ff ff       	call   400346b8 <sx1276_read_reg>
            reg &= ~((_MODEMCONFIG2_SpreadingFactor_MASK << 
40034c8d:	83 e0 0b             	and    $0xb,%eax
            if (crc_on)
40034c90:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
40034c94:	74 03                	je     40034c99 <sx1276_set_tx_config+0x27a>
                reg |= MODEMCONFIG2_RxPayloadCrcOn;
40034c96:	83 c8 04             	or     $0x4,%eax
            reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
40034c99:	8a 4d 10             	mov    0x10(%ebp),%cl
            sx1276_write_reg(dev, LOR_RegModemConfig2, reg);
40034c9c:	ba 1e 00 00 00       	mov    $0x1e,%edx
            reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
40034ca1:	c1 e1 04             	shl    $0x4,%ecx
40034ca4:	09 c1                	or     %eax,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig2, reg);
40034ca6:	89 d8                	mov    %ebx,%eax
40034ca8:	0f b6 c9             	movzbl %cl,%ecx
40034cab:	e8 7b fa ff ff       	call   4003472b <sx1276_write_reg>
            reg = sx1276_read_reg(dev, LOR_RegModemConfig3);
40034cb0:	ba 26 00 00 00       	mov    $0x26,%edx
40034cb5:	89 d8                	mov    %ebx,%eax
40034cb7:	e8 fc f9 ff ff       	call   400346b8 <sx1276_read_reg>
            if (dev->settings->loraSettings->LowDatarateOptimize)
40034cbc:	8b 53 24             	mov    0x24(%ebx),%edx
40034cbf:	8b 52 0c             	mov    0xc(%edx),%edx
            reg &= ~MODEMCONFIG3_LowDataRateOptimize;
40034cc2:	83 e0 f7             	and    $0xfffffff7,%eax
            if (dev->settings->loraSettings->LowDatarateOptimize)
40034cc5:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
40034cc9:	74 03                	je     40034cce <sx1276_set_tx_config+0x2af>
                reg |= MODEMCONFIG3_LowDataRateOptimize;
40034ccb:	83 c8 08             	or     $0x8,%eax
            sx1276_write_reg(dev, LOR_RegModemConfig3, reg);
40034cce:	0f b6 c8             	movzbl %al,%ecx
40034cd1:	ba 26 00 00 00       	mov    $0x26,%edx
40034cd6:	89 d8                	mov    %ebx,%eax
40034cd8:	e8 4e fa ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegPreambleMsb, (uint8_t)((preamble_len >> 8) & 0xff));
40034cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
40034ce0:	0f b6 cc             	movzbl %ah,%ecx
40034ce3:	ba 20 00 00 00       	mov    $0x20,%edx
40034ce8:	89 d8                	mov    %ebx,%eax
40034cea:	e8 3c fa ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegPreambleLsb, (uint8_t)(preamble_len & 0xff));
40034cef:	ba 21 00 00 00       	mov    $0x21,%edx
40034cf4:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
40034cf8:	89 d8                	mov    %ebx,%eax
40034cfa:	e8 2c fa ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40034cff:	ba 31 00 00 00       	mov    $0x31,%edx
40034d04:	89 d8                	mov    %ebx,%eax
            if (datarate == 6) {
40034d06:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
40034d0a:	75 23                	jne    40034d2f <sx1276_set_tx_config+0x310>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40034d0c:	e8 a7 f9 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d11:	ba 31 00 00 00       	mov    $0x31,%edx
                reg |= (DETECTIONOPTIMIZE_SF6 << 
40034d16:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d18:	89 d8                	mov    %ebx,%eax
                reg |= (DETECTIONOPTIMIZE_SF6 << 
40034d1a:	81 e1 f8 00 00 00    	and    $0xf8,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d20:	83 c9 05             	or     $0x5,%ecx
40034d23:	e8 03 fa ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegDetectionThreshold, LOR_DetectionThreshold_SF6);
40034d28:	b9 0c 00 00 00       	mov    $0xc,%ecx
40034d2d:	eb 21                	jmp    40034d50 <sx1276_set_tx_config+0x331>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40034d2f:	e8 84 f9 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d34:	ba 31 00 00 00       	mov    $0x31,%edx
                reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
40034d39:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d3b:	89 d8                	mov    %ebx,%eax
                reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
40034d3d:	81 e1 f8 00 00 00    	and    $0xf8,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40034d43:	83 c9 03             	or     $0x3,%ecx
40034d46:	e8 e0 f9 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegDetectionThreshold, 
40034d4b:	b9 0a 00 00 00       	mov    $0xa,%ecx
40034d50:	ba 37 00 00 00       	mov    $0x37,%edx
40034d55:	89 d8                	mov    %ebx,%eax
40034d57:	e8 cf f9 ff ff       	call   4003472b <sx1276_write_reg>
40034d5c:	eb 16                	jmp    40034d74 <sx1276_set_tx_config+0x355>
            if ( ((bandwidth == BW_125) && ((datarate == 11) || 
40034d5e:	83 7d 0c 07          	cmpl   $0x7,0xc(%ebp)
40034d62:	0f 84 86 fe ff ff    	je     40034bee <sx1276_set_tx_config+0x1cf>
                datarate = 12;
40034d68:	c7 45 10 0c 00 00 00 	movl   $0xc,0x10(%ebp)
40034d6f:	e9 6e fe ff ff       	jmp    40034be2 <sx1276_set_tx_config+0x1c3>
}
40034d74:	8d 65 f4             	lea    -0xc(%ebp),%esp
40034d77:	89 f8                	mov    %edi,%eax
40034d79:	5b                   	pop    %ebx
40034d7a:	5e                   	pop    %esi
40034d7b:	5f                   	pop    %edi
40034d7c:	5d                   	pop    %ebp
40034d7d:	c3                   	ret    

40034d7e <sx1276_set_rx_config>:
                                  bool iq_inverted, bool rx_continuous) {
40034d7e:	55                   	push   %ebp
40034d7f:	89 e5                	mov    %esp,%ebp
40034d81:	57                   	push   %edi
40034d82:	56                   	push   %esi
40034d83:	53                   	push   %ebx
40034d84:	83 ec 2c             	sub    $0x2c,%esp
40034d87:	89 c3                	mov    %eax,%ebx
40034d89:	8b 45 0c             	mov    0xc(%ebp),%eax
40034d8c:	89 55 ec             	mov    %edx,-0x14(%ebp)
40034d8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
40034d92:	8b 45 14             	mov    0x14(%ebp),%eax
40034d95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40034d98:	8b 45 18             	mov    0x18(%ebp),%eax
40034d9b:	89 45 e0             	mov    %eax,-0x20(%ebp)
40034d9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
40034da1:	89 45 f0             	mov    %eax,-0x10(%ebp)
40034da4:	8b 45 20             	mov    0x20(%ebp),%eax
40034da7:	89 45 dc             	mov    %eax,-0x24(%ebp)
40034daa:	8b 45 24             	mov    0x24(%ebp),%eax
40034dad:	89 45 d8             	mov    %eax,-0x28(%ebp)
40034db0:	8b 45 28             	mov    0x28(%ebp),%eax
40034db3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40034db6:	8b 45 2c             	mov    0x2c(%ebp),%eax
40034db9:	89 45 d0             	mov    %eax,-0x30(%ebp)
40034dbc:	8b 45 30             	mov    0x30(%ebp),%eax
40034dbf:	89 45 cc             	mov    %eax,-0x34(%ebp)
40034dc2:	8b 45 34             	mov    0x34(%ebp),%eax
40034dc5:	89 45 c8             	mov    %eax,-0x38(%ebp)
    sx1276_set_modem(dev, modem);
40034dc8:	89 d8                	mov    %ebx,%eax
                                  bool iq_inverted, bool rx_continuous) {
40034dca:	89 ce                	mov    %ecx,%esi
40034dcc:	8b 7d 08             	mov    0x8(%ebp),%edi
    sx1276_set_modem(dev, modem);
40034dcf:	e8 d4 fb ff ff       	call   400349a8 <sx1276_set_modem>
    switch (modem) {
40034dd4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40034dd8:	0f 85 b0 02 00 00    	jne    4003508e <sx1276_set_rx_config+0x310>
            switch (bandwidth) {
40034dde:	81 fe 90 d0 03 00    	cmp    $0x3d090,%esi
40034de4:	74 1d                	je     40034e03 <sx1276_set_rx_config+0x85>
40034de6:	81 fe 20 a1 07 00    	cmp    $0x7a120,%esi
40034dec:	74 1c                	je     40034e0a <sx1276_set_rx_config+0x8c>
40034dee:	81 fe 48 e8 01 00    	cmp    $0x1e848,%esi
40034df4:	74 1b                	je     40034e11 <sx1276_set_rx_config+0x93>
                printf("sx1276: LORA bandwidth must be 125000, 250000 or 500000\n");
40034df6:	68 27 c5 03 40       	push   $0x4003c527
40034dfb:	e8 78 5e 00 00       	call   4003ac78 <iprintf>
40034e00:	58                   	pop    %eax
40034e01:	eb 13                	jmp    40034e16 <sx1276_set_rx_config+0x98>
                    bandwidth = BW_250;
40034e03:	be 08 00 00 00       	mov    $0x8,%esi
40034e08:	eb 0c                	jmp    40034e16 <sx1276_set_rx_config+0x98>
                    bandwidth = BW_500;
40034e0a:	be 09 00 00 00       	mov    $0x9,%esi
                break;
40034e0f:	eb 05                	jmp    40034e16 <sx1276_set_rx_config+0x98>
                    bandwidth = BW_125;
40034e11:	be 07 00 00 00       	mov    $0x7,%esi
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034e16:	8b 43 24             	mov    0x24(%ebx),%eax
            dev->settings->loraSettings->Coderate = coderate;
40034e19:	8a 55 e8             	mov    -0x18(%ebp),%dl
            if (datarate > 12) {
40034e1c:	83 ff 0c             	cmp    $0xc,%edi
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034e1f:	8b 40 0c             	mov    0xc(%eax),%eax
            dev->settings->loraSettings->Coderate = coderate;
40034e22:	88 50 0d             	mov    %dl,0xd(%eax)
            dev->settings->loraSettings->FixLen = fix_len;
40034e25:	8a 55 f0             	mov    -0x10(%ebp),%dl
40034e28:	88 50 10             	mov    %dl,0x10(%eax)
            dev->settings->loraSettings->PayloadLen = pay_load_len;
40034e2b:	8a 55 dc             	mov    -0x24(%ebp),%dl
40034e2e:	88 50 11             	mov    %dl,0x11(%eax)
            dev->settings->loraSettings->CrcOn = crc_on;
40034e31:	8a 55 d8             	mov    -0x28(%ebp),%dl
40034e34:	88 50 12             	mov    %dl,0x12(%eax)
            dev->settings->loraSettings->FreqHopOn = freq_hop_on;
40034e37:	8a 55 d4             	mov    -0x2c(%ebp),%dl
40034e3a:	88 50 13             	mov    %dl,0x13(%eax)
            dev->settings->loraSettings->HopPeriod = hop_period;
40034e3d:	8a 55 d0             	mov    -0x30(%ebp),%dl
40034e40:	88 50 14             	mov    %dl,0x14(%eax)
            dev->settings->loraSettings->IqInverted = iq_inverted;
40034e43:	8a 55 cc             	mov    -0x34(%ebp),%dl
40034e46:	88 50 15             	mov    %dl,0x15(%eax)
            dev->settings->loraSettings->RxContinuous = rx_continuous;
40034e49:	8a 55 c8             	mov    -0x38(%ebp),%dl
            dev->settings->loraSettings->Bandwidth = bandwidth;
40034e4c:	89 70 04             	mov    %esi,0x4(%eax)
            dev->settings->loraSettings->Datarate = datarate;
40034e4f:	89 78 08             	mov    %edi,0x8(%eax)
            dev->settings->loraSettings->RxContinuous = rx_continuous;
40034e52:	88 50 16             	mov    %dl,0x16(%eax)
            if (datarate > 12) {
40034e55:	0f 87 20 02 00 00    	ja     4003507b <sx1276_set_rx_config+0x2fd>
            } else if (datarate < 6) {
40034e5b:	83 ff 05             	cmp    $0x5,%edi
40034e5e:	76 0f                	jbe    40034e6f <sx1276_set_rx_config+0xf1>
            if ( ((bandwidth == BW_125) && ((datarate == 11) || 
40034e60:	83 fe 07             	cmp    $0x7,%esi
40034e63:	75 0f                	jne    40034e74 <sx1276_set_rx_config+0xf6>
40034e65:	8d 57 f5             	lea    -0xb(%edi),%edx
40034e68:	83 fa 01             	cmp    $0x1,%edx
40034e6b:	77 07                	ja     40034e74 <sx1276_set_rx_config+0xf6>
40034e6d:	eb 0f                	jmp    40034e7e <sx1276_set_rx_config+0x100>
                datarate = 6;
40034e6f:	bf 06 00 00 00       	mov    $0x6,%edi
                                        (datarate == 12))) ||
40034e74:	83 fe 08             	cmp    $0x8,%esi
40034e77:	75 0b                	jne    40034e84 <sx1276_set_rx_config+0x106>
40034e79:	83 ff 0c             	cmp    $0xc,%edi
40034e7c:	75 06                	jne    40034e84 <sx1276_set_rx_config+0x106>
                dev->settings->loraSettings->LowDatarateOptimize = true;
40034e7e:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
40034e82:	eb 04                	jmp    40034e88 <sx1276_set_rx_config+0x10a>
                dev->settings->loraSettings->LowDatarateOptimize = false;
40034e84:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
            reg = sx1276_read_reg(dev, LOR_RegModemConfig1);
40034e88:	ba 1d 00 00 00       	mov    $0x1d,%edx
40034e8d:	89 d8                	mov    %ebx,%eax
40034e8f:	e8 24 f8 ff ff       	call   400346b8 <sx1276_read_reg>
            reg &= ~((_MODEMCONFIG1_CodingRate_MASK << 
40034e94:	83 e0 08             	and    $0x8,%eax
            if (fix_len)
40034e97:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
40034e9b:	74 03                	je     40034ea0 <sx1276_set_rx_config+0x122>
                reg |= MODEMCONFIG1_ImplicitHeaderModeOn;
40034e9d:	83 c8 01             	or     $0x1,%eax
            reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
40034ea0:	89 f1                	mov    %esi,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig1, reg);
40034ea2:	ba 1d 00 00 00       	mov    $0x1d,%edx
            reg |= ((bandwidth & _MODEMCONFIG1_Bw_MASK) << _MODEMCONFIG1_Bw_SHIFT);
40034ea7:	c1 e1 04             	shl    $0x4,%ecx
40034eaa:	09 c1                	or     %eax,%ecx
            reg |= ((coderate & _MODEMCONFIG1_CodingRate_MASK) << 
40034eac:	8a 45 e8             	mov    -0x18(%ebp),%al
40034eaf:	83 e0 07             	and    $0x7,%eax
40034eb2:	09 c1                	or     %eax,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig1, reg);
40034eb4:	89 d8                	mov    %ebx,%eax
40034eb6:	0f b6 c9             	movzbl %cl,%ecx
40034eb9:	e8 6d f8 ff ff       	call   4003472b <sx1276_write_reg>
            reg = sx1276_read_reg(dev, LOR_RegModemConfig2);
40034ebe:	ba 1e 00 00 00       	mov    $0x1e,%edx
40034ec3:	89 d8                	mov    %ebx,%eax
40034ec5:	e8 ee f7 ff ff       	call   400346b8 <sx1276_read_reg>
            reg &= ~((_MODEMCONFIG2_SpreadingFactor_MASK << 
40034eca:	83 e0 08             	and    $0x8,%eax
            if (crc_on)
40034ecd:	80 7d d8 00          	cmpb   $0x0,-0x28(%ebp)
40034ed1:	74 03                	je     40034ed6 <sx1276_set_rx_config+0x158>
                reg |= MODEMCONFIG2_RxPayloadCrcOn;
40034ed3:	83 c8 04             	or     $0x4,%eax
            reg |= ( ((symb_time_out >> 8) & _MODEMCONFIG2_SymbTimeoutMsb_MASK) << 
40034ed6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
            reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
40034ed9:	89 fa                	mov    %edi,%edx
40034edb:	c1 e2 04             	shl    $0x4,%edx
            reg |= ( ((symb_time_out >> 8) & _MODEMCONFIG2_SymbTimeoutMsb_MASK) << 
40034ede:	66 c1 e9 08          	shr    $0x8,%cx
            reg |= ((datarate & _MODEMCONFIG2_SpreadingFactor_MASK) << 
40034ee2:	09 d0                	or     %edx,%eax
            reg |= ( ((symb_time_out >> 8) & _MODEMCONFIG2_SymbTimeoutMsb_MASK) << 
40034ee4:	83 e1 03             	and    $0x3,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig2, reg);
40034ee7:	ba 1e 00 00 00       	mov    $0x1e,%edx
            reg |= ( ((symb_time_out >> 8) & _MODEMCONFIG2_SymbTimeoutMsb_MASK) << 
40034eec:	09 c1                	or     %eax,%ecx
            sx1276_write_reg(dev, LOR_RegModemConfig2, reg);
40034eee:	89 d8                	mov    %ebx,%eax
40034ef0:	0f b6 c9             	movzbl %cl,%ecx
40034ef3:	e8 33 f8 ff ff       	call   4003472b <sx1276_write_reg>
            reg = sx1276_read_reg(dev, LOR_RegModemConfig3);
40034ef8:	ba 26 00 00 00       	mov    $0x26,%edx
40034efd:	89 d8                	mov    %ebx,%eax
40034eff:	e8 b4 f7 ff ff       	call   400346b8 <sx1276_read_reg>
            if (dev->settings->loraSettings->LowDatarateOptimize)
40034f04:	8b 53 24             	mov    0x24(%ebx),%edx
40034f07:	8b 52 0c             	mov    0xc(%edx),%edx
            reg &= ~MODEMCONFIG3_LowDataRateOptimize;
40034f0a:	83 e0 f7             	and    $0xfffffff7,%eax
            if (dev->settings->loraSettings->LowDatarateOptimize)
40034f0d:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
40034f11:	74 03                	je     40034f16 <sx1276_set_rx_config+0x198>
                reg |= MODEMCONFIG3_LowDataRateOptimize;
40034f13:	83 c8 08             	or     $0x8,%eax
            sx1276_write_reg(dev, LOR_RegModemConfig3, reg);
40034f16:	0f b6 c8             	movzbl %al,%ecx
40034f19:	ba 26 00 00 00       	mov    $0x26,%edx
40034f1e:	89 d8                	mov    %ebx,%eax
40034f20:	e8 06 f8 ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegSymbTimeoutLsb, (uint8_t)(symb_time_out & 0xff));
40034f25:	ba 1f 00 00 00       	mov    $0x1f,%edx
40034f2a:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
40034f2e:	89 d8                	mov    %ebx,%eax
40034f30:	e8 f6 f7 ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegPreambleMsb, (uint8_t)((preamble_len >> 8) & 0xff));
40034f35:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40034f38:	0f b6 cc             	movzbl %ah,%ecx
40034f3b:	ba 20 00 00 00       	mov    $0x20,%edx
40034f40:	89 d8                	mov    %ebx,%eax
40034f42:	e8 e4 f7 ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegPreambleLsb, (uint8_t)(preamble_len & 0xff));
40034f47:	ba 21 00 00 00       	mov    $0x21,%edx
40034f4c:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
40034f50:	89 d8                	mov    %ebx,%eax
40034f52:	e8 d4 f7 ff ff       	call   4003472b <sx1276_write_reg>
            if (fix_len == 1)
40034f57:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
40034f5b:	74 10                	je     40034f6d <sx1276_set_rx_config+0x1ef>
                sx1276_write_reg(dev, LOR_RegPayloadLength, pay_load_len);
40034f5d:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
40034f61:	ba 22 00 00 00       	mov    $0x22,%edx
40034f66:	89 d8                	mov    %ebx,%eax
40034f68:	e8 be f7 ff ff       	call   4003472b <sx1276_write_reg>
            if (dev->settings->loraSettings->FreqHopOn) {
40034f6d:	8b 43 24             	mov    0x24(%ebx),%eax
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034f70:	ba 44 00 00 00       	mov    $0x44,%edx
            if (dev->settings->loraSettings->FreqHopOn) {
40034f75:	8b 40 0c             	mov    0xc(%eax),%eax
40034f78:	80 78 13 00          	cmpb   $0x0,0x13(%eax)
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034f7c:	89 d8                	mov    %ebx,%eax
            if (dev->settings->loraSettings->FreqHopOn) {
40034f7e:	74 28                	je     40034fa8 <sx1276_set_rx_config+0x22a>
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034f80:	e8 33 f7 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034f85:	ba 44 00 00 00       	mov    $0x44,%edx
                reg |= PLLHOP_FastHopOn;
40034f8a:	83 c8 80             	or     $0xffffff80,%eax
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034f8d:	0f b6 c8             	movzbl %al,%ecx
40034f90:	89 d8                	mov    %ebx,%eax
40034f92:	e8 94 f7 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegHopPeriod, dev->settings->loraSettings->HopPeriod);
40034f97:	8b 43 24             	mov    0x24(%ebx),%eax
40034f9a:	8b 40 0c             	mov    0xc(%eax),%eax
40034f9d:	ba 24 00 00 00       	mov    $0x24,%edx
40034fa2:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
40034fa6:	eb 0f                	jmp    40034fb7 <sx1276_set_rx_config+0x239>
                reg = sx1276_read_reg(dev, LOR_RegPllHop);
40034fa8:	e8 0b f7 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegPllHop, reg);
40034fad:	ba 44 00 00 00       	mov    $0x44,%edx
40034fb2:	89 c1                	mov    %eax,%ecx
40034fb4:	83 e1 7f             	and    $0x7f,%ecx
40034fb7:	89 d8                	mov    %ebx,%eax
40034fb9:	e8 6d f7 ff ff       	call   4003472b <sx1276_write_reg>
            if ( (bandwidth == BW_500) && 
40034fbe:	83 fe 09             	cmp    $0x9,%esi
40034fc1:	75 49                	jne    4003500c <sx1276_set_rx_config+0x28e>
               (dev->settings->channel > RF_MID_BAND_THRESH) ) {
40034fc3:	8b 43 24             	mov    0x24(%ebx),%eax
40034fc6:	8b 40 08             	mov    0x8(%eax),%eax
            if ( (bandwidth == BW_500) && 
40034fc9:	3d 40 dd 4a 1f       	cmp    $0x1f4add40,%eax
40034fce:	76 18                	jbe    40034fe8 <sx1276_set_rx_config+0x26a>
                sx1276_write_reg(dev, LOR_Reserved36, 0x02);
40034fd0:	b9 02 00 00 00       	mov    $0x2,%ecx
40034fd5:	ba 36 00 00 00       	mov    $0x36,%edx
40034fda:	89 d8                	mov    %ebx,%eax
40034fdc:	e8 4a f7 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_Reserved3a, 0x64);
40034fe1:	b9 64 00 00 00       	mov    $0x64,%ecx
40034fe6:	eb 1d                	jmp    40035005 <sx1276_set_rx_config+0x287>
            } else if (bandwidth == BW_500 && 
40034fe8:	3d 7f 1a 70 18       	cmp    $0x18701a7f,%eax
40034fed:	76 1d                	jbe    4003500c <sx1276_set_rx_config+0x28e>
                sx1276_write_reg(dev, LOR_Reserved36, 0x02);
40034fef:	b9 02 00 00 00       	mov    $0x2,%ecx
40034ff4:	ba 36 00 00 00       	mov    $0x36,%edx
40034ff9:	89 d8                	mov    %ebx,%eax
40034ffb:	e8 2b f7 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_Reserved3a, 0x7f);
40035000:	b9 7f 00 00 00       	mov    $0x7f,%ecx
40035005:	ba 3a 00 00 00       	mov    $0x3a,%edx
4003500a:	eb 0a                	jmp    40035016 <sx1276_set_rx_config+0x298>
                sx1276_write_reg(dev, LOR_Reserved36, 0x03);
4003500c:	b9 03 00 00 00       	mov    $0x3,%ecx
40035011:	ba 36 00 00 00       	mov    $0x36,%edx
40035016:	89 d8                	mov    %ebx,%eax
40035018:	e8 0e f7 ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
4003501d:	ba 31 00 00 00       	mov    $0x31,%edx
40035022:	89 d8                	mov    %ebx,%eax
            if (datarate == 6) {
40035024:	83 ff 06             	cmp    $0x6,%edi
40035027:	75 23                	jne    4003504c <sx1276_set_rx_config+0x2ce>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40035029:	e8 8a f6 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
4003502e:	ba 31 00 00 00       	mov    $0x31,%edx
                reg |= (DETECTIONOPTIMIZE_SF6 << 
40035033:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035035:	89 d8                	mov    %ebx,%eax
                reg |= (DETECTIONOPTIMIZE_SF6 << 
40035037:	81 e1 f8 00 00 00    	and    $0xf8,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
4003503d:	83 c9 05             	or     $0x5,%ecx
40035040:	e8 e6 f6 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegDetectionThreshold, LOR_DetectionThreshold_SF6);
40035045:	b9 0c 00 00 00       	mov    $0xc,%ecx
4003504a:	eb 21                	jmp    4003506d <sx1276_set_rx_config+0x2ef>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
4003504c:	e8 67 f6 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035051:	ba 31 00 00 00       	mov    $0x31,%edx
                reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
40035056:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035058:	89 d8                	mov    %ebx,%eax
                reg |= (DETECTIONOPTIMIZE_SF7_SF12 << 
4003505a:	81 e1 f8 00 00 00    	and    $0xf8,%ecx
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035060:	83 c9 03             	or     $0x3,%ecx
40035063:	e8 c3 f6 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegDetectionThreshold, 
40035068:	b9 0a 00 00 00       	mov    $0xa,%ecx
4003506d:	ba 37 00 00 00       	mov    $0x37,%edx
40035072:	89 d8                	mov    %ebx,%eax
40035074:	e8 b2 f6 ff ff       	call   4003472b <sx1276_write_reg>
    return UPM_SUCCESS;
40035079:	eb 13                	jmp    4003508e <sx1276_set_rx_config+0x310>
                datarate = 12;
4003507b:	bf 0c 00 00 00       	mov    $0xc,%edi
            if ( ((bandwidth == BW_125) && ((datarate == 11) || 
40035080:	83 fe 07             	cmp    $0x7,%esi
40035083:	0f 85 eb fd ff ff    	jne    40034e74 <sx1276_set_rx_config+0xf6>
40035089:	e9 f0 fd ff ff       	jmp    40034e7e <sx1276_set_rx_config+0x100>
}
4003508e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40035091:	31 c0                	xor    %eax,%eax
40035093:	5b                   	pop    %ebx
40035094:	5e                   	pop    %esi
40035095:	5f                   	pop    %edi
40035096:	5d                   	pop    %ebp
40035097:	c3                   	ret    

40035098 <sx1276_set_rx>:
RADIO_EVENT_T sx1276_set_rx(sx1276_context dev, uint32_t timeout){
40035098:	55                   	push   %ebp
40035099:	89 e5                	mov    %esp,%ebp
4003509b:	56                   	push   %esi
4003509c:	53                   	push   %ebx
4003509d:	89 c3                	mov    %eax,%ebx
    switch (dev->settings->modem) {
4003509f:	8b 40 24             	mov    0x24(%eax),%eax
    bool rxContinuous = false;
400350a2:	31 f6                	xor    %esi,%esi
    switch (dev->settings->modem) {
400350a4:	83 38 00             	cmpl   $0x0,(%eax)
400350a7:	0f 85 5a 02 00 00    	jne    40035307 <sx1276_set_rx+0x26f>
            if (dev->settings->loraSettings->IqInverted == true) {
400350ad:	8b 40 0c             	mov    0xc(%eax),%eax
                reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
400350b0:	ba 33 00 00 00       	mov    $0x33,%edx
            if (dev->settings->loraSettings->IqInverted == true) {
400350b5:	80 78 15 00          	cmpb   $0x0,0x15(%eax)
                reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
400350b9:	89 d8                	mov    %ebx,%eax
            if (dev->settings->loraSettings->IqInverted == true) {
400350bb:	74 23                	je     400350e0 <sx1276_set_rx+0x48>
                reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
400350bd:	e8 f6 f5 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350c2:	ba 33 00 00 00       	mov    $0x33,%edx
                reg |= INVERTIQ_InvertIQRx;
400350c7:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350c9:	89 d8                	mov    %ebx,%eax
                reg |= INVERTIQ_InvertIQRx;
400350cb:	81 e1 be 00 00 00    	and    $0xbe,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350d1:	83 c9 40             	or     $0x40,%ecx
400350d4:	e8 52 f6 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ2, 0x19);
400350d9:	b9 19 00 00 00       	mov    $0x19,%ecx
400350de:	eb 21                	jmp    40035101 <sx1276_set_rx+0x69>
                reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
400350e0:	e8 d3 f5 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350e5:	ba 33 00 00 00       	mov    $0x33,%edx
                reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
400350ea:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350ec:	89 d8                	mov    %ebx,%eax
                reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
400350ee:	81 e1 be 00 00 00    	and    $0xbe,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
400350f4:	83 c9 01             	or     $0x1,%ecx
400350f7:	e8 2f f6 ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ2, 0x1d);
400350fc:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40035101:	ba 3b 00 00 00       	mov    $0x3b,%edx
40035106:	89 d8                	mov    %ebx,%eax
40035108:	e8 1e f6 ff ff       	call   4003472b <sx1276_write_reg>
            if (dev->settings->loraSettings->Bandwidth < 9) {
4003510d:	8b 43 24             	mov    0x24(%ebx),%eax
40035110:	8b 40 0c             	mov    0xc(%eax),%eax
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40035113:	ba 31 00 00 00       	mov    $0x31,%edx
            if (dev->settings->loraSettings->Bandwidth < 9) {
40035118:	83 78 04 08          	cmpl   $0x8,0x4(%eax)
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
4003511c:	89 d8                	mov    %ebx,%eax
            if (dev->settings->loraSettings->Bandwidth < 9) {
4003511e:	0f 87 4e 01 00 00    	ja     40035272 <sx1276_set_rx+0x1da>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40035124:	e8 8f f5 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035129:	ba 31 00 00 00       	mov    $0x31,%edx
4003512e:	89 c1                	mov    %eax,%ecx
40035130:	89 d8                	mov    %ebx,%eax
40035132:	83 e1 7f             	and    $0x7f,%ecx
40035135:	e8 f1 f5 ff ff       	call   4003472b <sx1276_write_reg>
                switch (dev->settings->loraSettings->Bandwidth) {
4003513a:	8b 43 24             	mov    0x24(%ebx),%eax
4003513d:	8b 40 0c             	mov    0xc(%eax),%eax
40035140:	83 78 04 08          	cmpl   $0x8,0x4(%eax)
40035144:	0f 87 3f 01 00 00    	ja     40035289 <sx1276_set_rx+0x1f1>
4003514a:	8b 40 04             	mov    0x4(%eax),%eax
4003514d:	ff 24 85 60 c5 03 40 	jmp    *0x4003c560(,%eax,4)
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x48);
40035154:	b9 48 00 00 00       	mov    $0x48,%ecx
40035159:	ba 2f 00 00 00       	mov    $0x2f,%edx
4003515e:	89 d8                	mov    %ebx,%eax
40035160:	e8 c6 f5 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 7.81e3);
40035165:	8b 43 24             	mov    0x24(%ebx),%eax
40035168:	8b 40 08             	mov    0x8(%eax),%eax
4003516b:	e8 91 c5 ff ff       	call   40031701 <__floatunsidf>
40035170:	68 00 82 be 40       	push   $0x40be8200
40035175:	6a 00                	push   $0x0
40035177:	e8 15 b0 ff ff       	call   40030191 <__adddf3>
4003517c:	e9 d3 00 00 00       	jmp    40035254 <sx1276_set_rx+0x1bc>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x44);
40035181:	b9 44 00 00 00       	mov    $0x44,%ecx
40035186:	ba 2f 00 00 00       	mov    $0x2f,%edx
4003518b:	89 d8                	mov    %ebx,%eax
4003518d:	e8 99 f5 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 10.42e3);
40035192:	8b 43 24             	mov    0x24(%ebx),%eax
40035195:	8b 40 08             	mov    0x8(%eax),%eax
40035198:	e8 64 c5 ff ff       	call   40031701 <__floatunsidf>
4003519d:	68 00 5a c4 40       	push   $0x40c45a00
400351a2:	6a 00                	push   $0x0
400351a4:	e8 e8 af ff ff       	call   40030191 <__adddf3>
400351a9:	e9 a6 00 00 00       	jmp    40035254 <sx1276_set_rx+0x1bc>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x44);
400351ae:	b9 44 00 00 00       	mov    $0x44,%ecx
400351b3:	ba 2f 00 00 00       	mov    $0x2f,%edx
400351b8:	89 d8                	mov    %ebx,%eax
400351ba:	e8 6c f5 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 15.62e3);
400351bf:	8b 43 24             	mov    0x24(%ebx),%eax
400351c2:	8b 40 08             	mov    0x8(%eax),%eax
400351c5:	e8 37 c5 ff ff       	call   40031701 <__floatunsidf>
400351ca:	68 00 82 ce 40       	push   $0x40ce8200
400351cf:	6a 00                	push   $0x0
400351d1:	e8 bb af ff ff       	call   40030191 <__adddf3>
400351d6:	eb 7c                	jmp    40035254 <sx1276_set_rx+0x1bc>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x44);
400351d8:	b9 44 00 00 00       	mov    $0x44,%ecx
400351dd:	ba 2f 00 00 00       	mov    $0x2f,%edx
400351e2:	89 d8                	mov    %ebx,%eax
400351e4:	e8 42 f5 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 20.83e3);
400351e9:	8b 43 24             	mov    0x24(%ebx),%eax
400351ec:	8b 40 08             	mov    0x8(%eax),%eax
400351ef:	e8 0d c5 ff ff       	call   40031701 <__floatunsidf>
400351f4:	68 80 57 d4 40       	push   $0x40d45780
400351f9:	6a 00                	push   $0x0
400351fb:	e8 91 af ff ff       	call   40030191 <__adddf3>
40035200:	eb 52                	jmp    40035254 <sx1276_set_rx+0x1bc>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x44);
40035202:	b9 44 00 00 00       	mov    $0x44,%ecx
40035207:	ba 2f 00 00 00       	mov    $0x2f,%edx
4003520c:	89 d8                	mov    %ebx,%eax
4003520e:	e8 18 f5 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 31.25e3);
40035213:	8b 43 24             	mov    0x24(%ebx),%eax
40035216:	8b 40 08             	mov    0x8(%eax),%eax
40035219:	e8 e3 c4 ff ff       	call   40031701 <__floatunsidf>
4003521e:	68 80 84 de 40       	push   $0x40de8480
40035223:	6a 00                	push   $0x0
40035225:	e8 67 af ff ff       	call   40030191 <__adddf3>
4003522a:	eb 28                	jmp    40035254 <sx1276_set_rx+0x1bc>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x44);
4003522c:	b9 44 00 00 00       	mov    $0x44,%ecx
40035231:	ba 2f 00 00 00       	mov    $0x2f,%edx
40035236:	89 d8                	mov    %ebx,%eax
40035238:	e8 ee f4 ff ff       	call   4003472b <sx1276_write_reg>
                        sx1276_set_channel(dev, dev->settings->channel + 41.67e3);
4003523d:	8b 43 24             	mov    0x24(%ebx),%eax
40035240:	8b 40 08             	mov    0x8(%eax),%eax
40035243:	e8 b9 c4 ff ff       	call   40031701 <__floatunsidf>
40035248:	68 c0 58 e4 40       	push   $0x40e458c0
4003524d:	6a 00                	push   $0x0
4003524f:	e8 3d af ff ff       	call   40030191 <__adddf3>
40035254:	59                   	pop    %ecx
40035255:	5e                   	pop    %esi
40035256:	e8 ac c3 ff ff       	call   40031607 <__fixunsdfsi>
4003525b:	89 c2                	mov    %eax,%edx
4003525d:	89 d8                	mov    %ebx,%eax
4003525f:	e8 23 f5 ff ff       	call   40034787 <sx1276_set_channel>
                    break;
40035264:	eb 23                	jmp    40035289 <sx1276_set_rx+0x1f1>
                        sx1276_write_reg(dev, LOR_Reserved2f, 0x40);
40035266:	b9 40 00 00 00       	mov    $0x40,%ecx
4003526b:	ba 2f 00 00 00       	mov    $0x2f,%edx
40035270:	eb 10                	jmp    40035282 <sx1276_set_rx+0x1ea>
                reg = sx1276_read_reg(dev, LOR_RegDetectOptimize);
40035272:	e8 41 f4 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
40035277:	ba 31 00 00 00       	mov    $0x31,%edx
                reg |= 0x80; // set undocumented bit 7
4003527c:	83 c8 80             	or     $0xffffff80,%eax
                sx1276_write_reg(dev, LOR_RegDetectOptimize, reg);
4003527f:	0f b6 c8             	movzbl %al,%ecx
40035282:	89 d8                	mov    %ebx,%eax
40035284:	e8 a2 f4 ff ff       	call   4003472b <sx1276_write_reg>
            rxContinuous = dev->settings->loraSettings->RxContinuous;
40035289:	8b 43 24             	mov    0x24(%ebx),%eax
4003528c:	8b 40 0c             	mov    0xc(%eax),%eax
4003528f:	0f b6 70 16          	movzbl 0x16(%eax),%esi
            if (dev->settings->loraSettings->FreqHopOn == true) {
40035293:	80 78 13 00          	cmpb   $0x0,0x13(%eax)
40035297:	74 24                	je     400352bd <sx1276_set_rx+0x225>
                sx1276_write_reg(dev, LOR_RegIrqFlagsMask, 
40035299:	b9 1d 00 00 00       	mov    $0x1d,%ecx
4003529e:	ba 11 00 00 00       	mov    $0x11,%edx
400352a3:	89 d8                	mov    %ebx,%eax
400352a5:	e8 81 f4 ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, COM_RegDioMapping1);
400352aa:	ba 40 00 00 00       	mov    $0x40,%edx
400352af:	89 d8                	mov    %ebx,%eax
400352b1:	e8 02 f4 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, COM_RegDioMapping1, reg);
400352b6:	89 c1                	mov    %eax,%ecx
400352b8:	83 e1 33             	and    $0x33,%ecx
400352bb:	eb 22                	jmp    400352df <sx1276_set_rx+0x247>
                sx1276_write_reg(dev, LOR_RegIrqFlagsMask, 
400352bd:	b9 1f 00 00 00       	mov    $0x1f,%ecx
400352c2:	ba 11 00 00 00       	mov    $0x11,%edx
400352c7:	89 d8                	mov    %ebx,%eax
400352c9:	e8 5d f4 ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, COM_RegDioMapping1);
400352ce:	ba 40 00 00 00       	mov    $0x40,%edx
400352d3:	89 d8                	mov    %ebx,%eax
400352d5:	e8 de f3 ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, COM_RegDioMapping1, reg);
400352da:	89 c1                	mov    %eax,%ecx
400352dc:	83 e1 3f             	and    $0x3f,%ecx
400352df:	ba 40 00 00 00       	mov    $0x40,%edx
400352e4:	89 d8                	mov    %ebx,%eax
400352e6:	e8 40 f4 ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegFifoRxBaseAddr, 0);
400352eb:	31 c9                	xor    %ecx,%ecx
400352ed:	ba 0f 00 00 00       	mov    $0xf,%edx
400352f2:	89 d8                	mov    %ebx,%eax
400352f4:	e8 32 f4 ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegFifoAddrPtr, 0);
400352f9:	31 c9                	xor    %ecx,%ecx
400352fb:	ba 0d 00 00 00       	mov    $0xd,%edx
40035300:	89 d8                	mov    %ebx,%eax
40035302:	e8 24 f4 ff ff       	call   4003472b <sx1276_write_reg>
    memset(rx_buffer, 0, FIFO_SIZE);
40035307:	31 d2                	xor    %edx,%edx
40035309:	b9 00 01 00 00       	mov    $0x100,%ecx
4003530e:	b8 40 82 00 a8       	mov    $0xa8008240,%eax
40035313:	e8 5d ad ff ff       	call   40030075 <memset>
    dev->settings->state = STATE_RX_RUNNING;
40035318:	8b 43 24             	mov    0x24(%ebx),%eax
4003531b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    if (dev->settings->modem == MODEM_FSK) {
40035322:	83 38 01             	cmpl   $0x1,(%eax)
    r_event = REVENT_EXEC;
40035325:	c7 05 ac 81 00 a8 01 	movl   $0x1,0xa80081ac
4003532c:	00 00 00 
    if (dev->settings->modem == MODEM_FSK) {
4003532f:	74 17                	je     40035348 <sx1276_set_rx+0x2b0>
        if(rxContinuous == true) {
40035331:	89 f0                	mov    %esi,%eax
            sx1276_set_op_mode(dev, MODE_LOR_RxSingle);
40035333:	ba 06 00 00 00       	mov    $0x6,%edx
        if(rxContinuous == true) {
40035338:	84 c0                	test   %al,%al
4003533a:	74 05                	je     40035341 <sx1276_set_rx+0x2a9>
            sx1276_set_op_mode(dev, MODE_LOR_RxContinuous);
4003533c:	ba 05 00 00 00       	mov    $0x5,%edx
40035341:	89 d8                	mov    %ebx,%eax
40035343:	e8 fe f5 ff ff       	call   40034946 <sx1276_set_op_mode>
    bool rxContinuous = false;
40035348:	bb a0 0f 00 00       	mov    $0xfa0,%ebx
    while (counter < 4000 && r_event == REVENT_EXEC) {
4003534d:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
40035352:	48                   	dec    %eax
40035353:	75 0d                	jne    40035362 <sx1276_set_rx+0x2ca>
        k_busy_wait(1000);
40035355:	b8 e8 03 00 00       	mov    $0x3e8,%eax
4003535a:	e8 be 50 00 00       	call   4003a41d <k_busy_wait>
    while (counter < 4000 && r_event == REVENT_EXEC) {
4003535f:	4b                   	dec    %ebx
40035360:	75 eb                	jne    4003534d <sx1276_set_rx+0x2b5>
    if (r_event == REVENT_EXEC) {
40035362:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
40035367:	48                   	dec    %eax
40035368:	75 1c                	jne    40035386 <sx1276_set_rx+0x2ee>
      if((RadioEvents_c != NULL) && (RadioEvents_c->RxTimeout != NULL)) {
4003536a:	a1 28 77 00 a8       	mov    0xa8007728,%eax
      r_event = REVENT_TIMEOUT;
4003536f:	c7 05 ac 81 00 a8 03 	movl   $0x3,0xa80081ac
40035376:	00 00 00 
      if((RadioEvents_c != NULL) && (RadioEvents_c->RxTimeout != NULL)) {
40035379:	85 c0                	test   %eax,%eax
4003537b:	74 09                	je     40035386 <sx1276_set_rx+0x2ee>
4003537d:	8b 40 0c             	mov    0xc(%eax),%eax
40035380:	85 c0                	test   %eax,%eax
40035382:	74 02                	je     40035386 <sx1276_set_rx+0x2ee>
        RadioEvents_c->RxTimeout( );
40035384:	ff d0                	call   *%eax
    return r_event;
40035386:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
}
4003538b:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003538e:	5b                   	pop    %ebx
4003538f:	5e                   	pop    %esi
40035390:	5d                   	pop    %ebp
40035391:	c3                   	ret    

40035392 <sx1276_init>:
{
40035392:	55                   	push   %ebp
40035393:	89 e5                	mov    %esp,%ebp
40035395:	57                   	push   %edi
40035396:	89 d7                	mov    %edx,%edi
40035398:	56                   	push   %esi
40035399:	89 ce                	mov    %ecx,%esi
4003539b:	53                   	push   %ebx
4003539c:	50                   	push   %eax
    if((mraa_rv = mraa_init()) != MRAA_SUCCESS) {
4003539d:	e8 56 e0 ff ff       	call   400333f8 <mraa_init>
400353a2:	85 c0                	test   %eax,%eax
400353a4:	74 10                	je     400353b6 <sx1276_init+0x24>
        printf("%s: mraa_init failed (%d).\n", __FUNCTION__, mraa_rv);
400353a6:	50                   	push   %eax
400353a7:	68 f8 ca 03 40       	push   $0x4003caf8
400353ac:	68 84 c5 03 40       	push   $0x4003c584
400353b1:	e9 f6 02 00 00       	jmp    400356ac <sx1276_init+0x31a>
    RadioEvents_c = events;
400353b6:	8b 45 20             	mov    0x20(%ebp),%eax
400353b9:	a3 28 77 00 a8       	mov    %eax,0xa8007728
    sx1276_context dev = (sx1276_context) malloc(sizeof(struct _sx1276_context));
400353be:	b8 28 00 00 00       	mov    $0x28,%eax
400353c3:	e8 04 57 00 00       	call   4003aacc <malloc>
400353c8:	89 c3                	mov    %eax,%ebx
    if(!dev)
400353ca:	85 c0                	test   %eax,%eax
400353cc:	0f 84 2c 03 00 00    	je     400356fe <sx1276_init+0x36c>
    dev->settings = (m_settings) malloc(sizeof(struct _m_settings));
400353d2:	b8 14 00 00 00       	mov    $0x14,%eax
400353d7:	e8 f0 56 00 00       	call   4003aacc <malloc>
400353dc:	89 43 24             	mov    %eax,0x24(%ebx)
    if(!dev->settings) {
400353df:	85 c0                	test   %eax,%eax
400353e1:	75 0a                	jne    400353ed <sx1276_init+0x5b>
        printf("settings is nullllllllllll\n");
400353e3:	68 a0 c5 03 40       	push   $0x4003c5a0
400353e8:	e9 0b 03 00 00       	jmp    400356f8 <sx1276_init+0x366>
    radioLoRaSettings_t lora_settings = (radioLoRaSettings_t) malloc(sizeof(struct _radioLoRaSettings_t));
400353ed:	b8 1c 00 00 00       	mov    $0x1c,%eax
400353f2:	e8 d5 56 00 00       	call   4003aacc <malloc>
    if(!lora_settings) {
400353f7:	85 c0                	test   %eax,%eax
400353f9:	75 0a                	jne    40035405 <sx1276_init+0x73>
        printf("Null lora settings\n");
400353fb:	68 bc c5 03 40       	push   $0x4003c5bc
40035400:	e9 f3 02 00 00       	jmp    400356f8 <sx1276_init+0x366>
    dev->settings->loraSettings = lora_settings;
40035405:	8b 53 24             	mov    0x24(%ebx),%edx
40035408:	89 42 0c             	mov    %eax,0xc(%edx)
    if (!(dev->spi = mraa_spi_init(0))) {
4003540b:	31 c0                	xor    %eax,%eax
4003540d:	e8 31 e5 ff ff       	call   40033943 <mraa_spi_init>
40035412:	89 43 20             	mov    %eax,0x20(%ebx)
40035415:	85 c0                	test   %eax,%eax
40035417:	75 0a                	jne    40035423 <sx1276_init+0x91>
        printf("sx1276: init failed\n");
40035419:	68 d0 c5 03 40       	push   $0x4003c5d0
4003541e:	e9 19 02 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_spi_mode(dev->spi, MRAA_SPI_MODE1) != MRAA_SUCCESS) {
40035423:	ba 01 00 00 00       	mov    $0x1,%edx
40035428:	e8 9e e5 ff ff       	call   400339cb <mraa_spi_mode>
4003542d:	85 c0                	test   %eax,%eax
4003542f:	74 0a                	je     4003543b <sx1276_init+0xa9>
        printf("sx1276: Unable to set SPI mode\n");
40035431:	68 e5 c5 03 40       	push   $0x4003c5e5
40035436:	e9 01 02 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_spi_frequency(dev->spi, 4000000) != MRAA_SUCCESS) {
4003543b:	8b 43 20             	mov    0x20(%ebx),%eax
4003543e:	ba 00 09 3d 00       	mov    $0x3d0900,%edx
40035443:	e8 bf e5 ff ff       	call   40033a07 <mraa_spi_frequency>
40035448:	85 c0                	test   %eax,%eax
4003544a:	74 0a                	je     40035456 <sx1276_init+0xc4>
        printf("sx1276: Unable to set higher frequency\n");
4003544c:	68 05 c6 03 40       	push   $0x4003c605
40035451:	e9 e6 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(!(dev->gpio_cs = mraa_gpio_init(cs))) {
40035456:	89 f8                	mov    %edi,%eax
40035458:	e8 7c e2 ff ff       	call   400336d9 <mraa_gpio_init>
4003545d:	89 03                	mov    %eax,(%ebx)
4003545f:	85 c0                	test   %eax,%eax
40035461:	75 0a                	jne    4003546d <sx1276_init+0xdb>
        printf("sx1276: unable to init SPI CS\n");
40035463:	68 2d c6 03 40       	push   $0x4003c62d
40035468:	e9 cf 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_dir(dev->gpio_cs, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
4003546d:	31 d2                	xor    %edx,%edx
4003546f:	e8 17 e3 ff ff       	call   4003378b <mraa_gpio_dir>
40035474:	85 c0                	test   %eax,%eax
40035476:	74 0a                	je     40035482 <sx1276_init+0xf0>
        printf("sx1276: unable to set direction on SPI CS\n");
40035478:	68 4c c6 03 40       	push   $0x4003c64c
4003547d:	e9 ba 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    sx1276_cs_off(dev);
40035482:	89 d8                	mov    %ebx,%eax
40035484:	e8 0d f2 ff ff       	call   40034696 <sx1276_cs_off>
    if(!(dev->gpio_reset = mraa_gpio_init(reset_pin))) {
40035489:	89 f0                	mov    %esi,%eax
4003548b:	e8 49 e2 ff ff       	call   400336d9 <mraa_gpio_init>
40035490:	89 43 04             	mov    %eax,0x4(%ebx)
40035493:	85 c0                	test   %eax,%eax
40035495:	75 0a                	jne    400354a1 <sx1276_init+0x10f>
        printf("sx1276: unable to init chip reset\n");
40035497:	68 77 c6 03 40       	push   $0x4003c677
4003549c:	e9 9b 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_dir(dev->gpio_reset, MRAA_GPIO_IN) != MRAA_SUCCESS) {
400354a1:	ba 01 00 00 00       	mov    $0x1,%edx
400354a6:	e8 e0 e2 ff ff       	call   4003378b <mraa_gpio_dir>
400354ab:	85 c0                	test   %eax,%eax
400354ad:	74 0a                	je     400354b9 <sx1276_init+0x127>
        printf("sx1276: unable to set direction on reset pin\n");
400354af:	68 9a c6 03 40       	push   $0x4003c69a
400354b4:	e9 83 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    upm_delay_ms(10);
400354b9:	b8 0a 00 00 00       	mov    $0xa,%eax
400354be:	e8 5d f0 ff ff       	call   40034520 <upm_delay_ms>
    if(!(dev->gpio_dio0 = mraa_gpio_init(dio0)) || !(dev->gpio_dio1 = mraa_gpio_init(dio1))
400354c3:	8b 45 08             	mov    0x8(%ebp),%eax
    int_flag=0;
400354c6:	c6 05 94 81 00 a8 00 	movb   $0x0,0xa8008194
    if(!(dev->gpio_dio0 = mraa_gpio_init(dio0)) || !(dev->gpio_dio1 = mraa_gpio_init(dio1))
400354cd:	e8 07 e2 ff ff       	call   400336d9 <mraa_gpio_init>
400354d2:	89 43 08             	mov    %eax,0x8(%ebx)
400354d5:	85 c0                	test   %eax,%eax
400354d7:	75 0a                	jne    400354e3 <sx1276_init+0x151>
        printf("sx1276: unable to init an interrupt pin on the LORA\n");
400354d9:	68 c8 c6 03 40       	push   $0x4003c6c8
400354de:	e9 59 01 00 00       	jmp    4003563c <sx1276_init+0x2aa>
    if(!(dev->gpio_dio0 = mraa_gpio_init(dio0)) || !(dev->gpio_dio1 = mraa_gpio_init(dio1))
400354e3:	8b 45 0c             	mov    0xc(%ebp),%eax
400354e6:	e8 ee e1 ff ff       	call   400336d9 <mraa_gpio_init>
400354eb:	89 43 0c             	mov    %eax,0xc(%ebx)
400354ee:	85 c0                	test   %eax,%eax
400354f0:	74 e7                	je     400354d9 <sx1276_init+0x147>
       || !(dev->gpio_dio2 = mraa_gpio_init(dio2)) || !(dev->gpio_dio3 = mraa_gpio_init(dio3))
400354f2:	8b 45 10             	mov    0x10(%ebp),%eax
400354f5:	e8 df e1 ff ff       	call   400336d9 <mraa_gpio_init>
400354fa:	89 43 10             	mov    %eax,0x10(%ebx)
400354fd:	85 c0                	test   %eax,%eax
400354ff:	74 d8                	je     400354d9 <sx1276_init+0x147>
40035501:	8b 45 14             	mov    0x14(%ebp),%eax
40035504:	e8 d0 e1 ff ff       	call   400336d9 <mraa_gpio_init>
40035509:	89 43 14             	mov    %eax,0x14(%ebx)
4003550c:	85 c0                	test   %eax,%eax
4003550e:	74 c9                	je     400354d9 <sx1276_init+0x147>
       || !(dev->gpio_dio4 = mraa_gpio_init(dio4)) || !(dev->gpio_dio5 = mraa_gpio_init(dio5))) {
40035510:	8b 45 18             	mov    0x18(%ebp),%eax
40035513:	e8 c1 e1 ff ff       	call   400336d9 <mraa_gpio_init>
40035518:	89 43 18             	mov    %eax,0x18(%ebx)
4003551b:	85 c0                	test   %eax,%eax
4003551d:	74 ba                	je     400354d9 <sx1276_init+0x147>
4003551f:	8b 45 1c             	mov    0x1c(%ebp),%eax
40035522:	e8 b2 e1 ff ff       	call   400336d9 <mraa_gpio_init>
40035527:	89 43 1c             	mov    %eax,0x1c(%ebx)
4003552a:	85 c0                	test   %eax,%eax
4003552c:	74 ab                	je     400354d9 <sx1276_init+0x147>
    if(mraa_gpio_dir(dev->gpio_dio0, MRAA_GPIO_IN) != MRAA_SUCCESS ||
4003552e:	8b 43 08             	mov    0x8(%ebx),%eax
40035531:	ba 01 00 00 00       	mov    $0x1,%edx
40035536:	e8 50 e2 ff ff       	call   4003378b <mraa_gpio_dir>
4003553b:	85 c0                	test   %eax,%eax
4003553d:	74 0a                	je     40035549 <sx1276_init+0x1b7>
        printf("sx1276: unable to set direction on one of the interrupt pins\n");
4003553f:	68 fd c6 03 40       	push   $0x4003c6fd
40035544:	e9 f3 00 00 00       	jmp    4003563c <sx1276_init+0x2aa>
       mraa_gpio_dir(dev->gpio_dio1, MRAA_GPIO_IN) != MRAA_SUCCESS ||
40035549:	8b 43 0c             	mov    0xc(%ebx),%eax
4003554c:	ba 01 00 00 00       	mov    $0x1,%edx
40035551:	e8 35 e2 ff ff       	call   4003378b <mraa_gpio_dir>
    if(mraa_gpio_dir(dev->gpio_dio0, MRAA_GPIO_IN) != MRAA_SUCCESS ||
40035556:	85 c0                	test   %eax,%eax
40035558:	75 e5                	jne    4003553f <sx1276_init+0x1ad>
       mraa_gpio_dir(dev->gpio_dio2, MRAA_GPIO_IN) != MRAA_SUCCESS ||
4003555a:	8b 43 10             	mov    0x10(%ebx),%eax
4003555d:	ba 01 00 00 00       	mov    $0x1,%edx
40035562:	e8 24 e2 ff ff       	call   4003378b <mraa_gpio_dir>
       mraa_gpio_dir(dev->gpio_dio1, MRAA_GPIO_IN) != MRAA_SUCCESS ||
40035567:	85 c0                	test   %eax,%eax
40035569:	75 d4                	jne    4003553f <sx1276_init+0x1ad>
       mraa_gpio_dir(dev->gpio_dio3, MRAA_GPIO_IN) != MRAA_SUCCESS ||
4003556b:	8b 43 14             	mov    0x14(%ebx),%eax
4003556e:	ba 01 00 00 00       	mov    $0x1,%edx
40035573:	e8 13 e2 ff ff       	call   4003378b <mraa_gpio_dir>
       mraa_gpio_dir(dev->gpio_dio2, MRAA_GPIO_IN) != MRAA_SUCCESS ||
40035578:	85 c0                	test   %eax,%eax
4003557a:	75 c3                	jne    4003553f <sx1276_init+0x1ad>
       mraa_gpio_dir(dev->gpio_dio4, MRAA_GPIO_IN) != MRAA_SUCCESS ||
4003557c:	8b 43 18             	mov    0x18(%ebx),%eax
4003557f:	ba 01 00 00 00       	mov    $0x1,%edx
40035584:	e8 02 e2 ff ff       	call   4003378b <mraa_gpio_dir>
       mraa_gpio_dir(dev->gpio_dio3, MRAA_GPIO_IN) != MRAA_SUCCESS ||
40035589:	85 c0                	test   %eax,%eax
4003558b:	75 b2                	jne    4003553f <sx1276_init+0x1ad>
       mraa_gpio_dir(dev->gpio_dio5, MRAA_GPIO_IN) != MRAA_SUCCESS) {
4003558d:	8b 43 1c             	mov    0x1c(%ebx),%eax
40035590:	ba 01 00 00 00       	mov    $0x1,%edx
40035595:	e8 f1 e1 ff ff       	call   4003378b <mraa_gpio_dir>
       mraa_gpio_dir(dev->gpio_dio4, MRAA_GPIO_IN) != MRAA_SUCCESS ||
4003559a:	85 c0                	test   %eax,%eax
4003559c:	75 a1                	jne    4003553f <sx1276_init+0x1ad>
    if(mraa_gpio_isr(dev->gpio_dio0, MRAA_GPIO_EDGE_RISING, sx1276_on_dio0_irq, NULL) != MRAA_SUCCESS) {
4003559e:	8b 43 08             	mov    0x8(%ebx),%eax
400355a1:	b9 79 45 03 40       	mov    $0x40034579,%ecx
400355a6:	ba 02 00 00 00       	mov    $0x2,%edx
400355ab:	6a 00                	push   $0x0
400355ad:	e8 c5 e2 ff ff       	call   40033877 <mraa_gpio_isr>
400355b2:	5f                   	pop    %edi
400355b3:	85 c0                	test   %eax,%eax
400355b5:	74 07                	je     400355be <sx1276_init+0x22c>
        printf("sx1276: Unable to set up the dio0 ISR\n");
400355b7:	68 3b c7 03 40       	push   $0x4003c73b
400355bc:	eb 7e                	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_isr(dev->gpio_dio1, MRAA_GPIO_EDGE_RISING, sx1276_on_dio1_irq, NULL) != MRAA_SUCCESS) {
400355be:	8b 43 0c             	mov    0xc(%ebx),%eax
400355c1:	b9 96 45 03 40       	mov    $0x40034596,%ecx
400355c6:	ba 02 00 00 00       	mov    $0x2,%edx
400355cb:	6a 00                	push   $0x0
400355cd:	e8 a5 e2 ff ff       	call   40033877 <mraa_gpio_isr>
400355d2:	5e                   	pop    %esi
400355d3:	85 c0                	test   %eax,%eax
400355d5:	74 07                	je     400355de <sx1276_init+0x24c>
        printf("sx1276: Unable to set up the dio1 ISR\n");
400355d7:	68 62 c7 03 40       	push   $0x4003c762
400355dc:	eb 5e                	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_isr(dev->gpio_dio2, MRAA_GPIO_EDGE_RISING, sx1276_on_dio2_irq, NULL) != MRAA_SUCCESS) {
400355de:	8b 43 10             	mov    0x10(%ebx),%eax
400355e1:	b9 b3 45 03 40       	mov    $0x400345b3,%ecx
400355e6:	ba 02 00 00 00       	mov    $0x2,%edx
400355eb:	6a 00                	push   $0x0
400355ed:	e8 85 e2 ff ff       	call   40033877 <mraa_gpio_isr>
400355f2:	59                   	pop    %ecx
400355f3:	85 c0                	test   %eax,%eax
400355f5:	74 07                	je     400355fe <sx1276_init+0x26c>
        printf("sx1276: Unable to set up the dio2 ISR\n");
400355f7:	68 89 c7 03 40       	push   $0x4003c789
400355fc:	eb 3e                	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_isr(dev->gpio_dio3, MRAA_GPIO_EDGE_RISING, sx1276_on_dio3_irq, NULL) != MRAA_SUCCESS) {
400355fe:	8b 43 14             	mov    0x14(%ebx),%eax
40035601:	ba 02 00 00 00       	mov    $0x2,%edx
40035606:	b9 d0 45 03 40       	mov    $0x400345d0,%ecx
4003560b:	6a 00                	push   $0x0
4003560d:	e8 65 e2 ff ff       	call   40033877 <mraa_gpio_isr>
40035612:	5a                   	pop    %edx
40035613:	85 c0                	test   %eax,%eax
40035615:	74 07                	je     4003561e <sx1276_init+0x28c>
        printf("sx1276: Unable to set up the dio3 ISR\n");
40035617:	68 b0 c7 03 40       	push   $0x4003c7b0
4003561c:	eb 1e                	jmp    4003563c <sx1276_init+0x2aa>
    if(mraa_gpio_isr(dev->gpio_dio4, MRAA_GPIO_EDGE_RISING, sx1276_on_dio4_irq, NULL) != MRAA_SUCCESS) {
4003561e:	8b 43 18             	mov    0x18(%ebx),%eax
40035621:	b9 ed 45 03 40       	mov    $0x400345ed,%ecx
40035626:	ba 02 00 00 00       	mov    $0x2,%edx
4003562b:	6a 00                	push   $0x0
4003562d:	e8 45 e2 ff ff       	call   40033877 <mraa_gpio_isr>
40035632:	5f                   	pop    %edi
40035633:	85 c0                	test   %eax,%eax
40035635:	74 17                	je     4003564e <sx1276_init+0x2bc>
        printf("sx1276: Unable to set up the dio4 ISR\n");
40035637:	68 d7 c7 03 40       	push   $0x4003c7d7
4003563c:	e8 37 56 00 00       	call   4003ac78 <iprintf>
        free(dev);
40035641:	89 d8                	mov    %ebx,%eax
        printf("sx1276: Unable to set up the dio4 ISR\n");
40035643:	5e                   	pop    %esi
        free(dev);
40035644:	e8 93 54 00 00       	call   4003aadc <free>
40035649:	e9 b0 00 00 00       	jmp    400356fe <sx1276_init+0x36c>
    dev->settings->state = STATE_IDLE;
4003564e:	8b 43 24             	mov    0x24(%ebx),%eax
    memset(rx_buffer, 0, FIFO_SIZE);
40035651:	31 d2                	xor    %edx,%edx
    r_event = REVENT_DONE;
40035653:	c7 05 ac 81 00 a8 00 	movl   $0x0,0xa80081ac
4003565a:	00 00 00 
    memset(rx_buffer, 0, FIFO_SIZE);
4003565d:	b9 00 01 00 00       	mov    $0x100,%ecx
    dev->settings->state = STATE_IDLE;
40035662:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    memset(rx_buffer, 0, FIFO_SIZE);
40035669:	b8 40 82 00 a8       	mov    $0xa8008240,%eax
4003566e:	e8 02 aa ff ff       	call   40030075 <memset>
    if(sx1276_get_chip_version(dev, &chip_id) != UPM_SUCCESS) {
40035673:	8d 55 f3             	lea    -0xd(%ebp),%edx
40035676:	89 d8                	mov    %ebx,%eax
    rx_SNR = 0;
40035678:	c7 05 18 84 00 a8 00 	movl   $0x0,0xa8008418
4003567f:	00 00 00 
    rx_RSSI = 0;
40035682:	c7 05 c0 83 00 a8 00 	movl   $0x0,0xa80083c0
40035689:	00 00 00 
    if(sx1276_get_chip_version(dev, &chip_id) != UPM_SUCCESS) {
4003568c:	e8 83 f0 ff ff       	call   40034714 <sx1276_get_chip_version>
40035691:	85 c0                	test   %eax,%eax
40035693:	74 07                	je     4003569c <sx1276_init+0x30a>
        printf("sx1276: Unable to read the chip ID\n");
40035695:	68 fe c7 03 40       	push   $0x4003c7fe
4003569a:	eb 5c                	jmp    400356f8 <sx1276_init+0x366>
    if (chip_id != chipRevision) { 
4003569c:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
400356a0:	3c 12                	cmp    $0x12,%al
400356a2:	74 12                	je     400356b6 <sx1276_init+0x324>
        printf("sx1276: Incorrect chip version, expected: %x, got: %x\n", chipRevision, chip_id);
400356a4:	50                   	push   %eax
400356a5:	6a 12                	push   $0x12
400356a7:	68 22 c8 03 40       	push   $0x4003c822
400356ac:	e8 c7 55 00 00       	call   4003ac78 <iprintf>
400356b1:	83 c4 0c             	add    $0xc,%esp
400356b4:	eb 48                	jmp    400356fe <sx1276_init+0x36c>
    if(sx1276_reset(dev) != UPM_SUCCESS) {
400356b6:	89 d8                	mov    %ebx,%eax
400356b8:	e8 40 ef ff ff       	call   400345fd <sx1276_reset>
400356bd:	85 c0                	test   %eax,%eax
400356bf:	75 3d                	jne    400356fe <sx1276_init+0x36c>
    printf("chip id was returned: %x\n", chip_id);
400356c1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
400356c5:	50                   	push   %eax
400356c6:	68 59 c8 03 40       	push   $0x4003c859
400356cb:	e8 a8 55 00 00       	call   4003ac78 <iprintf>
    if(sx1276_rx_chain_calibration(dev) != UPM_SUCCESS) {
400356d0:	89 d8                	mov    %ebx,%eax
    printf("chip id was returned: %x\n", chip_id);
400356d2:	5a                   	pop    %edx
400356d3:	59                   	pop    %ecx
    if(sx1276_rx_chain_calibration(dev) != UPM_SUCCESS) {
400356d4:	e8 23 f1 ff ff       	call   400347fc <sx1276_rx_chain_calibration>
400356d9:	85 c0                	test   %eax,%eax
400356db:	74 07                	je     400356e4 <sx1276_init+0x352>
        printf("Unable to do rx chain calibration\n");
400356dd:	68 73 c8 03 40       	push   $0x4003c873
400356e2:	eb 14                	jmp    400356f8 <sx1276_init+0x366>
    if(sx1276_set_op_mode(dev, MODE_Sleep) != UPM_SUCCESS) {
400356e4:	31 d2                	xor    %edx,%edx
400356e6:	89 d8                	mov    %ebx,%eax
400356e8:	e8 59 f2 ff ff       	call   40034946 <sx1276_set_op_mode>
400356ed:	31 f6                	xor    %esi,%esi
400356ef:	85 c0                	test   %eax,%eax
400356f1:	74 0f                	je     40035702 <sx1276_init+0x370>
        printf("sx1276: Unable to set mode to sleep\n");
400356f3:	68 96 c8 03 40       	push   $0x4003c896
400356f8:	e8 7b 55 00 00       	call   4003ac78 <iprintf>
400356fd:	58                   	pop    %eax
        return NULL;
400356fe:	31 db                	xor    %ebx,%ebx
40035700:	eb 40                	jmp    40035742 <sx1276_init+0x3b0>
        sx1276_set_modem(dev, radioRegsInit[i].Modem);
40035702:	8b 96 80 ca 03 40    	mov    0x4003ca80(%esi),%edx
40035708:	89 d8                	mov    %ebx,%eax
4003570a:	e8 99 f2 ff ff       	call   400349a8 <sx1276_set_modem>
4003570f:	83 c6 08             	add    $0x8,%esi
        sx1276_write_reg(dev, radioRegsInit[i].Addr, radioRegsInit[i].Value);
40035712:	0f b6 8e 7d ca 03 40 	movzbl 0x4003ca7d(%esi),%ecx
40035719:	0f b6 96 7c ca 03 40 	movzbl 0x4003ca7c(%esi),%edx
40035720:	89 d8                	mov    %ebx,%eax
40035722:	e8 04 f0 ff ff       	call   4003472b <sx1276_write_reg>
    for (size_t i = 0; i < sizeof(radioRegsInit) / sizeof(radioRegisters_t); i++ ) {
40035727:	83 fe 78             	cmp    $0x78,%esi
4003572a:	75 d6                	jne    40035702 <sx1276_init+0x370>
    sx1276_set_modem(dev, MODEM_FSK);
4003572c:	ba 01 00 00 00       	mov    $0x1,%edx
40035731:	89 d8                	mov    %ebx,%eax
40035733:	e8 70 f2 ff ff       	call   400349a8 <sx1276_set_modem>
    dev->settings->state = STATE_IDLE;
40035738:	8b 43 24             	mov    0x24(%ebx),%eax
4003573b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
40035742:	8d 65 f4             	lea    -0xc(%ebp),%esp
40035745:	89 d8                	mov    %ebx,%eax
40035747:	5b                   	pop    %ebx
40035748:	5e                   	pop    %esi
40035749:	5f                   	pop    %edi
4003574a:	5d                   	pop    %ebp
4003574b:	c3                   	ret    

4003574c <sx1276_write_fifo>:
upm_result_t sx1276_write_fifo(sx1276_context dev, uint8_t* buffer, int len) {
4003574c:	55                   	push   %ebp
    if (len > FIFO_SIZE) {
4003574d:	81 f9 00 01 00 00    	cmp    $0x100,%ecx
upm_result_t sx1276_write_fifo(sx1276_context dev, uint8_t* buffer, int len) {
40035753:	89 e5                	mov    %esp,%ebp
40035755:	57                   	push   %edi
40035756:	56                   	push   %esi
40035757:	53                   	push   %ebx
40035758:	56                   	push   %esi
    if (len > FIFO_SIZE) {
40035759:	7e 0d                	jle    40035768 <sx1276_write_fifo+0x1c>
        printf("sx1276: cannot write more than 256 bytes to FIFO\n");
4003575b:	68 bb c8 03 40       	push   $0x4003c8bb
40035760:	e8 13 55 00 00       	call   4003ac78 <iprintf>
40035765:	5b                   	pop    %ebx
40035766:	eb 4e                	jmp    400357b6 <sx1276_write_fifo+0x6a>
40035768:	89 c3                	mov    %eax,%ebx
4003576a:	89 d7                	mov    %edx,%edi
4003576c:	89 ce                	mov    %ecx,%esi
    uint8_t pkt = (0 | m_writeMode);
4003576e:	c6 45 f3 80          	movb   $0x80,-0xd(%ebp)
    sx1276_cs_on(dev);
40035772:	e8 00 ef ff ff       	call   40034677 <sx1276_cs_on>
    if (mraa_spi_transfer_buf(dev->spi, &pkt, NULL, 1) != MRAA_SUCCESS) {
40035777:	31 c9                	xor    %ecx,%ecx
40035779:	8b 43 20             	mov    0x20(%ebx),%eax
4003577c:	8d 55 f3             	lea    -0xd(%ebp),%edx
4003577f:	6a 01                	push   $0x1
40035781:	e8 ba e2 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
40035786:	59                   	pop    %ecx
40035787:	85 c0                	test   %eax,%eax
40035789:	74 07                	je     40035792 <sx1276_write_fifo+0x46>
        printf("sx1276: Spi.transfer(NULL) failed\n");
4003578b:	68 ed c8 03 40       	push   $0x4003c8ed
40035790:	eb 17                	jmp    400357a9 <sx1276_write_fifo+0x5d>
    if (mraa_spi_transfer_buf(dev->spi, buffer, NULL, len) != MRAA_SUCCESS){
40035792:	8b 43 20             	mov    0x20(%ebx),%eax
40035795:	31 c9                	xor    %ecx,%ecx
40035797:	89 fa                	mov    %edi,%edx
40035799:	56                   	push   %esi
4003579a:	e8 a1 e2 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
4003579f:	5a                   	pop    %edx
400357a0:	85 c0                	test   %eax,%eax
400357a2:	74 19                	je     400357bd <sx1276_write_fifo+0x71>
        printf("sx1276: Spi.transfer(buf) failed");
400357a4:	68 10 c9 03 40       	push   $0x4003c910
400357a9:	e8 ca 54 00 00       	call   4003ac78 <iprintf>
400357ae:	58                   	pop    %eax
        sx1276_cs_off(dev);
400357af:	89 d8                	mov    %ebx,%eax
400357b1:	e8 e0 ee ff ff       	call   40034696 <sx1276_cs_off>
400357b6:	b8 08 00 00 00       	mov    $0x8,%eax
400357bb:	eb 09                	jmp    400357c6 <sx1276_write_fifo+0x7a>
    sx1276_cs_off(dev);
400357bd:	89 d8                	mov    %ebx,%eax
400357bf:	e8 d2 ee ff ff       	call   40034696 <sx1276_cs_off>
    return UPM_SUCCESS;
400357c4:	31 c0                	xor    %eax,%eax
}
400357c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
400357c9:	5b                   	pop    %ebx
400357ca:	5e                   	pop    %esi
400357cb:	5f                   	pop    %edi
400357cc:	5d                   	pop    %ebp
400357cd:	c3                   	ret    

400357ce <sx1276_read_fifo>:
upm_result_t sx1276_read_fifo(sx1276_context dev, uint8_t* buffer, int len){
400357ce:	55                   	push   %ebp
    if (len > FIFO_SIZE)
400357cf:	81 f9 00 01 00 00    	cmp    $0x100,%ecx
upm_result_t sx1276_read_fifo(sx1276_context dev, uint8_t* buffer, int len){
400357d5:	89 e5                	mov    %esp,%ebp
400357d7:	57                   	push   %edi
400357d8:	56                   	push   %esi
400357d9:	53                   	push   %ebx
400357da:	56                   	push   %esi
    if (len > FIFO_SIZE)
400357db:	7e 0d                	jle    400357ea <sx1276_read_fifo+0x1c>
        printf("sx1276: cannot read more than 256 bytes from FIFO\n");
400357dd:	68 31 c9 03 40       	push   $0x4003c931
400357e2:	e8 91 54 00 00       	call   4003ac78 <iprintf>
400357e7:	5b                   	pop    %ebx
400357e8:	eb 4e                	jmp    40035838 <sx1276_read_fifo+0x6a>
400357ea:	89 c3                	mov    %eax,%ebx
400357ec:	89 d7                	mov    %edx,%edi
400357ee:	89 ce                	mov    %ecx,%esi
    uint8_t pkt = 0;
400357f0:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    sx1276_cs_on(dev);
400357f4:	e8 7e ee ff ff       	call   40034677 <sx1276_cs_on>
    if (mraa_spi_transfer_buf(dev->spi, &pkt, NULL, 1) != MRAA_SUCCESS) {
400357f9:	31 c9                	xor    %ecx,%ecx
400357fb:	8b 43 20             	mov    0x20(%ebx),%eax
400357fe:	8d 55 f3             	lea    -0xd(%ebp),%edx
40035801:	6a 01                	push   $0x1
40035803:	e8 38 e2 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
40035808:	59                   	pop    %ecx
40035809:	85 c0                	test   %eax,%eax
4003580b:	74 07                	je     40035814 <sx1276_read_fifo+0x46>
        printf("sx1276: Spi.transfer(0) failed\n");
4003580d:	68 64 c9 03 40       	push   $0x4003c964
40035812:	eb 17                	jmp    4003582b <sx1276_read_fifo+0x5d>
    if (mraa_spi_transfer_buf(dev->spi, NULL, buffer, len)) {
40035814:	31 d2                	xor    %edx,%edx
40035816:	8b 43 20             	mov    0x20(%ebx),%eax
40035819:	89 f9                	mov    %edi,%ecx
4003581b:	56                   	push   %esi
4003581c:	e8 1f e2 ff ff       	call   40033a40 <mraa_spi_transfer_buf>
40035821:	5a                   	pop    %edx
40035822:	85 c0                	test   %eax,%eax
40035824:	74 19                	je     4003583f <sx1276_read_fifo+0x71>
        printf("sx1276: Spi.transfer(buf) failed\n");
40035826:	68 84 c9 03 40       	push   $0x4003c984
4003582b:	e8 48 54 00 00       	call   4003ac78 <iprintf>
40035830:	58                   	pop    %eax
        sx1276_cs_off(dev);
40035831:	89 d8                	mov    %ebx,%eax
40035833:	e8 5e ee ff ff       	call   40034696 <sx1276_cs_off>
40035838:	b8 08 00 00 00       	mov    $0x8,%eax
4003583d:	eb 09                	jmp    40035848 <sx1276_read_fifo+0x7a>
    sx1276_cs_off(dev);
4003583f:	89 d8                	mov    %ebx,%eax
40035841:	e8 50 ee ff ff       	call   40034696 <sx1276_cs_off>
    return UPM_SUCCESS;
40035846:	31 c0                	xor    %eax,%eax
}
40035848:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003584b:	5b                   	pop    %ebx
4003584c:	5e                   	pop    %esi
4003584d:	5f                   	pop    %edi
4003584e:	5d                   	pop    %ebp
4003584f:	c3                   	ret    

40035850 <sx1276_dio0_qos>:
upm_result_t sx1276_dio0_qos(sx1276_context dev) {
40035850:	55                   	push   %ebp
40035851:	89 e5                	mov    %esp,%ebp
40035853:	57                   	push   %edi
40035854:	56                   	push   %esi
40035855:	53                   	push   %ebx
40035856:	83 ec 08             	sub    $0x8,%esp
40035859:	89 c6                	mov    %eax,%esi
    switch (dev->settings->state) {
4003585b:	8b 40 24             	mov    0x24(%eax),%eax
    volatile uint8_t irqFlags = 0;
4003585e:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
    switch (dev->settings->state) {
40035862:	8b 50 04             	mov    0x4(%eax),%edx
40035865:	83 fa 01             	cmp    $0x1,%edx
40035868:	74 0e                	je     40035878 <sx1276_dio0_qos+0x28>
4003586a:	83 fa 02             	cmp    $0x2,%edx
4003586d:	0f 84 b0 01 00 00    	je     40035a23 <sx1276_dio0_qos+0x1d3>
40035873:	e9 e6 01 00 00       	jmp    40035a5e <sx1276_dio0_qos+0x20e>
            switch (dev->settings->modem) {
40035878:	83 38 00             	cmpl   $0x0,(%eax)
4003587b:	0f 85 dd 01 00 00    	jne    40035a5e <sx1276_dio0_qos+0x20e>
                    sx1276_write_reg(dev, LOR_RegIrqFlags, LOR_IRQFLAG_RxDone);
40035881:	b9 40 00 00 00       	mov    $0x40,%ecx
40035886:	ba 12 00 00 00       	mov    $0x12,%edx
4003588b:	89 f0                	mov    %esi,%eax
4003588d:	e8 99 ee ff ff       	call   4003472b <sx1276_write_reg>
                    irqFlags = sx1276_read_reg(dev, LOR_RegIrqFlags);
40035892:	ba 12 00 00 00       	mov    $0x12,%edx
40035897:	89 f0                	mov    %esi,%eax
40035899:	e8 1a ee ff ff       	call   400346b8 <sx1276_read_reg>
4003589e:	88 45 f3             	mov    %al,-0xd(%ebp)
                    if (irqFlags & LOR_IRQFLAG_PayloadCrcError) {
400358a1:	8a 45 f3             	mov    -0xd(%ebp),%al
400358a4:	a8 20                	test   $0x20,%al
400358a6:	74 45                	je     400358ed <sx1276_dio0_qos+0x9d>
                        sx1276_write_reg(dev, LOR_RegIrqFlags, LOR_IRQFLAG_PayloadCrcError);
400358a8:	ba 12 00 00 00       	mov    $0x12,%edx
400358ad:	b9 20 00 00 00       	mov    $0x20,%ecx
400358b2:	89 f0                	mov    %esi,%eax
400358b4:	e8 72 ee ff ff       	call   4003472b <sx1276_write_reg>
                        if (dev->settings->loraSettings->RxContinuous == false) {
400358b9:	8b 46 24             	mov    0x24(%esi),%eax
400358bc:	8b 50 0c             	mov    0xc(%eax),%edx
400358bf:	80 7a 16 00          	cmpb   $0x0,0x16(%edx)
400358c3:	75 07                	jne    400358cc <sx1276_dio0_qos+0x7c>
                            dev->settings->state = STATE_IDLE;
400358c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
                        if((RadioEvents_c != NULL) && (RadioEvents_c->RxError != NULL)) {
400358cc:	a1 28 77 00 a8       	mov    0xa8007728,%eax
400358d1:	85 c0                	test   %eax,%eax
400358d3:	74 09                	je     400358de <sx1276_dio0_qos+0x8e>
400358d5:	8b 40 10             	mov    0x10(%eax),%eax
400358d8:	85 c0                	test   %eax,%eax
400358da:	74 02                	je     400358de <sx1276_dio0_qos+0x8e>
                            RadioEvents_c->RxError();
400358dc:	ff d0                	call   *%eax
                        r_event = REVENT_ERROR;
400358de:	c7 05 ac 81 00 a8 02 	movl   $0x2,0xa80081ac
400358e5:	00 00 00 
                        break;
400358e8:	e9 71 01 00 00       	jmp    40035a5e <sx1276_dio0_qos+0x20e>
                    dev->settings->loraPacketHandler->SnrValue = sx1276_read_reg(dev, LOR_RegPktSnrValue);
400358ed:	8b 46 24             	mov    0x24(%esi),%eax
400358f0:	ba 19 00 00 00       	mov    $0x19,%edx
400358f5:	8b 58 10             	mov    0x10(%eax),%ebx
400358f8:	89 f0                	mov    %esi,%eax
400358fa:	e8 b9 ed ff ff       	call   400346b8 <sx1276_read_reg>
400358ff:	88 03                	mov    %al,(%ebx)
                    if (dev->settings->loraPacketHandler->SnrValue & 0x80) {
40035901:	8b 46 24             	mov    0x24(%esi),%eax
40035904:	8b 50 10             	mov    0x10(%eax),%edx
                        snr = ( (~(dev->settings->loraPacketHandler->SnrValue) + 1 ) & 0xff) >> 2;
40035907:	8b 40 10             	mov    0x10(%eax),%eax
                    if (dev->settings->loraPacketHandler->SnrValue & 0x80) {
4003590a:	80 3a 00             	cmpb   $0x0,(%edx)
                        snr = ( (~(dev->settings->loraPacketHandler->SnrValue) + 1 ) & 0xff) >> 2;
4003590d:	0f be 18             	movsbl (%eax),%ebx
                    if (dev->settings->loraPacketHandler->SnrValue & 0x80) {
40035910:	79 0c                	jns    4003591e <sx1276_dio0_qos+0xce>
                        snr = ( (~(dev->settings->loraPacketHandler->SnrValue) + 1 ) & 0xff) >> 2;
40035912:	f7 db                	neg    %ebx
40035914:	c1 fb 02             	sar    $0x2,%ebx
40035917:	83 e3 3f             	and    $0x3f,%ebx
                        snr = -snr;
4003591a:	f7 db                	neg    %ebx
4003591c:	eb 06                	jmp    40035924 <sx1276_dio0_qos+0xd4>
                        snr = (dev->settings->loraPacketHandler->SnrValue & 0xff) >> 2;
4003591e:	c1 fb 02             	sar    $0x2,%ebx
40035921:	83 e3 3f             	and    $0x3f,%ebx
                    int16_t rssi = sx1276_read_reg(dev, LOR_RegPktRssiValue);
40035924:	ba 1a 00 00 00       	mov    $0x1a,%edx
40035929:	89 f0                	mov    %esi,%eax
4003592b:	e8 88 ed ff ff       	call   400346b8 <sx1276_read_reg>
                    if (snr < 0) {
40035930:	84 db                	test   %bl,%bl
                    int16_t rssi = sx1276_read_reg(dev, LOR_RegPktRssiValue);
40035932:	88 45 ef             	mov    %al,-0x11(%ebp)
40035935:	8b 4e 24             	mov    0x24(%esi),%ecx
40035938:	0f b6 c0             	movzbl %al,%eax
                    if (snr < 0) {
4003593b:	79 2c                	jns    40035969 <sx1276_dio0_qos+0x119>
                        if (dev->settings->channel > RF_MID_BAND_THRESH) {
4003593d:	81 79 08 40 dd 4a 1f 	cmpl   $0x1f4add40,0x8(%ecx)
40035944:	66 0f be d3          	movsbw %bl,%dx
                            dev->settings->loraPacketHandler->RssiValue =
40035948:	8b 79 10             	mov    0x10(%ecx),%edi
                        if (dev->settings->channel > RF_MID_BAND_THRESH) {
4003594b:	76 09                	jbe    40035956 <sx1276_dio0_qos+0x106>
                            LOR_RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) + snr;
4003594d:	8d 94 10 63 ff ff ff 	lea    -0x9d(%eax,%edx,1),%edx
40035954:	eb 07                	jmp    4003595d <sx1276_dio0_qos+0x10d>
                            LOR_RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) + snr;
40035956:	8d 94 10 5c ff ff ff 	lea    -0xa4(%eax,%edx,1),%edx
4003595d:	66 c1 f8 04          	sar    $0x4,%ax
40035961:	01 c2                	add    %eax,%edx
40035963:	66 89 57 02          	mov    %dx,0x2(%edi)
40035967:	eb 33                	jmp    4003599c <sx1276_dio0_qos+0x14c>
                        if (dev->settings->channel > RF_MID_BAND_THRESH) {
40035969:	81 79 08 40 dd 4a 1f 	cmpl   $0x1f4add40,0x8(%ecx)
40035970:	76 16                	jbe    40035988 <sx1276_dio0_qos+0x138>
                            LOR_RSSI_OFFSET_HF + rssi + (rssi >> 4);
40035972:	89 c2                	mov    %eax,%edx
                            dev->settings->loraPacketHandler->RssiValue =
40035974:	8b 79 10             	mov    0x10(%ecx),%edi
                            LOR_RSSI_OFFSET_HF + rssi + (rssi >> 4);
40035977:	66 c1 fa 04          	sar    $0x4,%dx
4003597b:	8d 84 10 63 ff ff ff 	lea    -0x9d(%eax,%edx,1),%eax
40035982:	66 89 47 02          	mov    %ax,0x2(%edi)
40035986:	eb 14                	jmp    4003599c <sx1276_dio0_qos+0x14c>
                            LOR_RSSI_OFFSET_LF + rssi + (rssi >> 4);
40035988:	89 c7                	mov    %eax,%edi
                            dev->settings->loraPacketHandler->RssiValue =
4003598a:	8b 51 10             	mov    0x10(%ecx),%edx
                            LOR_RSSI_OFFSET_LF + rssi + (rssi >> 4);
4003598d:	66 c1 ff 04          	sar    $0x4,%di
40035991:	8d 84 38 5c ff ff ff 	lea    -0xa4(%eax,%edi,1),%eax
40035998:	66 89 42 02          	mov    %ax,0x2(%edx)
                    sx1276_read_reg(dev, LOR_RegRxNbBytes);
4003599c:	ba 13 00 00 00       	mov    $0x13,%edx
400359a1:	89 f0                	mov    %esi,%eax
                    dev->settings->loraPacketHandler->Size = 
400359a3:	8b 79 10             	mov    0x10(%ecx),%edi
                    sx1276_read_reg(dev, LOR_RegRxNbBytes);
400359a6:	e8 0d ed ff ff       	call   400346b8 <sx1276_read_reg>
                    dev->settings->loraPacketHandler->Size = 
400359ab:	88 47 04             	mov    %al,0x4(%edi)
                    sx1276_read_fifo(dev, rx_buffer, dev->settings->loraPacketHandler->Size);
400359ae:	ba 40 82 00 a8       	mov    $0xa8008240,%edx
400359b3:	8b 46 24             	mov    0x24(%esi),%eax
400359b6:	8b 40 10             	mov    0x10(%eax),%eax
400359b9:	0f b6 48 04          	movzbl 0x4(%eax),%ecx
400359bd:	89 f0                	mov    %esi,%eax
400359bf:	e8 0a fe ff ff       	call   400357ce <sx1276_read_fifo>
                    if (dev->settings->loraSettings->RxContinuous == false) {
400359c4:	8b 46 24             	mov    0x24(%esi),%eax
400359c7:	8b 50 0c             	mov    0xc(%eax),%edx
400359ca:	80 7a 16 00          	cmpb   $0x0,0x16(%edx)
400359ce:	75 07                	jne    400359d7 <sx1276_dio0_qos+0x187>
                        dev->settings->state = STATE_IDLE;
400359d0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
                    rx_RSSI = (int)rssi;
400359d7:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
                    rx_SNR = (int)snr;
400359db:	0f be db             	movsbl %bl,%ebx
                    rx_RSSI = (int)rssi;
400359de:	89 15 c0 83 00 a8    	mov    %edx,0xa80083c0
                    rx_SNR = (int)snr;
400359e4:	89 1d 18 84 00 a8    	mov    %ebx,0xa8008418
                    rx_Len = dev->settings->loraPacketHandler->Size;
400359ea:	8b 50 10             	mov    0x10(%eax),%edx
400359ed:	0f b6 52 04          	movzbl 0x4(%edx),%edx
400359f1:	89 15 34 82 00 a8    	mov    %edx,0xa8008234
                    if (RadioEvents_c->RxDone != NULL)
400359f7:	8b 15 28 77 00 a8    	mov    0xa8007728,%edx
400359fd:	8b 5a 08             	mov    0x8(%edx),%ebx
40035a00:	85 db                	test   %ebx,%ebx
40035a02:	74 50                	je     40035a54 <sx1276_dio0_qos+0x204>
                       RadioEvents_c->RxDone(rx_buffer, dev->settings->loraPacketHandler->Size, dev->settings->loraPacketHandler->RssiValue, dev->settings->loraPacketHandler->SnrValue);
40035a04:	8b 70 10             	mov    0x10(%eax),%esi
40035a07:	8b 50 10             	mov    0x10(%eax),%edx
40035a0a:	8b 40 10             	mov    0x10(%eax),%eax
40035a0d:	0f bf 4a 02          	movswl 0x2(%edx),%ecx
40035a11:	0f b6 50 04          	movzbl 0x4(%eax),%edx
40035a15:	0f be 06             	movsbl (%esi),%eax
40035a18:	50                   	push   %eax
40035a19:	b8 40 82 00 a8       	mov    $0xa8008240,%eax
40035a1e:	ff d3                	call   *%ebx
40035a20:	58                   	pop    %eax
40035a21:	eb 31                	jmp    40035a54 <sx1276_dio0_qos+0x204>
            switch (dev->settings->modem) {
40035a23:	83 38 00             	cmpl   $0x0,(%eax)
40035a26:	75 11                	jne    40035a39 <sx1276_dio0_qos+0x1e9>
                    sx1276_write_reg(dev, LOR_RegIrqFlags, LOR_IRQFLAG_TxDone);
40035a28:	b9 08 00 00 00       	mov    $0x8,%ecx
40035a2d:	ba 12 00 00 00       	mov    $0x12,%edx
40035a32:	89 f0                	mov    %esi,%eax
40035a34:	e8 f2 ec ff ff       	call   4003472b <sx1276_write_reg>
                    dev->settings->state = STATE_IDLE;
40035a39:	8b 46 24             	mov    0x24(%esi),%eax
40035a3c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
                    if((RadioEvents_c != NULL) && (RadioEvents_c->TxDone != NULL)) {
40035a43:	a1 28 77 00 a8       	mov    0xa8007728,%eax
40035a48:	85 c0                	test   %eax,%eax
40035a4a:	74 08                	je     40035a54 <sx1276_dio0_qos+0x204>
40035a4c:	8b 00                	mov    (%eax),%eax
40035a4e:	85 c0                	test   %eax,%eax
40035a50:	74 02                	je     40035a54 <sx1276_dio0_qos+0x204>
                        RadioEvents_c->TxDone();
40035a52:	ff d0                	call   *%eax
                    r_event = REVENT_DONE;
40035a54:	c7 05 ac 81 00 a8 00 	movl   $0x0,0xa80081ac
40035a5b:	00 00 00 
}
40035a5e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40035a61:	31 c0                	xor    %eax,%eax
40035a63:	5b                   	pop    %ebx
40035a64:	5e                   	pop    %esi
40035a65:	5f                   	pop    %edi
40035a66:	5d                   	pop    %ebp
40035a67:	c3                   	ret    

40035a68 <sx1276_set_tx>:
RADIO_EVENT_T sx1276_set_tx(sx1276_context dev, int timeout){
40035a68:	55                   	push   %ebp
40035a69:	89 e5                	mov    %esp,%ebp
40035a6b:	56                   	push   %esi
40035a6c:	53                   	push   %ebx
40035a6d:	89 c3                	mov    %eax,%ebx
printf("coming into set tx\n");
40035a6f:	68 a6 c9 03 40       	push   $0x4003c9a6
40035a74:	e8 ff 51 00 00       	call   4003ac78 <iprintf>
40035a79:	58                   	pop    %eax
    switch (dev->settings->modem) {
40035a7a:	8b 43 24             	mov    0x24(%ebx),%eax
40035a7d:	83 38 00             	cmpl   $0x0,(%eax)
40035a80:	75 5e                	jne    40035ae0 <sx1276_set_tx+0x78>
            if (dev->settings->loraSettings->FreqHopOn == true ) {
40035a82:	8b 40 0c             	mov    0xc(%eax),%eax
40035a85:	80 78 13 00          	cmpb   $0x0,0x13(%eax)
40035a89:	74 24                	je     40035aaf <sx1276_set_tx+0x47>
                sx1276_write_reg(dev, LOR_RegIrqFlagsMask, 
40035a8b:	b9 f5 00 00 00       	mov    $0xf5,%ecx
40035a90:	ba 11 00 00 00       	mov    $0x11,%edx
40035a95:	89 d8                	mov    %ebx,%eax
40035a97:	e8 8f ec ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, COM_RegDioMapping1);
40035a9c:	ba 40 00 00 00       	mov    $0x40,%edx
40035aa1:	89 d8                	mov    %ebx,%eax
40035aa3:	e8 10 ec ff ff       	call   400346b8 <sx1276_read_reg>
                reg |= ( (DIOMAPPING_01 << DOIMAPPING1_Dio0Mapping_SHIFT) |
40035aa8:	89 c1                	mov    %eax,%ecx
40035aaa:	83 e1 33             	and    $0x33,%ecx
40035aad:	eb 22                	jmp    40035ad1 <sx1276_set_tx+0x69>
                sx1276_write_reg(dev, LOR_RegIrqFlagsMask, 
40035aaf:	b9 f7 00 00 00       	mov    $0xf7,%ecx
40035ab4:	ba 11 00 00 00       	mov    $0x11,%edx
40035ab9:	89 d8                	mov    %ebx,%eax
40035abb:	e8 6b ec ff ff       	call   4003472b <sx1276_write_reg>
                reg = sx1276_read_reg(dev, COM_RegDioMapping1);
40035ac0:	ba 40 00 00 00       	mov    $0x40,%edx
40035ac5:	89 d8                	mov    %ebx,%eax
40035ac7:	e8 ec eb ff ff       	call   400346b8 <sx1276_read_reg>
                reg |= (DIOMAPPING_01 << DOIMAPPING1_Dio0Mapping_SHIFT);
40035acc:	89 c1                	mov    %eax,%ecx
40035ace:	83 e1 3f             	and    $0x3f,%ecx
                sx1276_write_reg(dev, COM_RegDioMapping1, reg);
40035ad1:	83 c9 40             	or     $0x40,%ecx
40035ad4:	ba 40 00 00 00       	mov    $0x40,%edx
40035ad9:	89 d8                	mov    %ebx,%eax
40035adb:	e8 4b ec ff ff       	call   4003472b <sx1276_write_reg>
    dev->settings->state = STATE_TX_RUNNING;
40035ae0:	8b 43 24             	mov    0x24(%ebx),%eax
    sx1276_set_op_mode(dev, MODE_TxMode);
40035ae3:	ba 03 00 00 00       	mov    $0x3,%edx
    dev->settings->state = STATE_TX_RUNNING;
40035ae8:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    sx1276_set_op_mode(dev, MODE_TxMode);
40035aef:	89 d8                	mov    %ebx,%eax
    r_event = REVENT_EXEC;
40035af1:	c7 05 ac 81 00 a8 01 	movl   $0x1,0xa80081ac
40035af8:	00 00 00 
    sx1276_set_op_mode(dev, MODE_TxMode);
40035afb:	e8 46 ee ff ff       	call   40034946 <sx1276_set_op_mode>
printf("current state : %d\n", dev->settings->state);
40035b00:	8b 43 24             	mov    0x24(%ebx),%eax
40035b03:	8b 40 04             	mov    0x4(%eax),%eax
40035b06:	50                   	push   %eax
40035b07:	68 ba c9 03 40       	push   $0x4003c9ba
40035b0c:	e8 67 51 00 00       	call   4003ac78 <iprintf>
40035b11:	59                   	pop    %ecx
40035b12:	5e                   	pop    %esi
40035b13:	be a0 0f 00 00       	mov    $0xfa0,%esi
    while (counter < 4000 && r_event != REVENT_DONE) {
40035b18:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
40035b1d:	85 c0                	test   %eax,%eax
40035b1f:	0f 84 85 00 00 00    	je     40035baa <sx1276_set_tx+0x142>
        if(int_flag == 1) {
40035b25:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b2a:	fe c8                	dec    %al
40035b2c:	75 14                	jne    40035b42 <sx1276_set_tx+0xda>
            sx1276_dio0_qos(dev);
40035b2e:	89 d8                	mov    %ebx,%eax
40035b30:	e8 1b fd ff ff       	call   40035850 <sx1276_dio0_qos>
            int_flag = int_flag & 0xfe;
40035b35:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b3a:	83 e0 fe             	and    $0xfffffffe,%eax
40035b3d:	a2 94 81 00 a8       	mov    %al,0xa8008194
        if(int_flag == 2) {
40035b42:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b47:	3c 02                	cmp    $0x2,%al
40035b49:	75 14                	jne    40035b5f <sx1276_set_tx+0xf7>
            sx1276_dio1_qos(dev);
40035b4b:	89 d8                	mov    %ebx,%eax
40035b4d:	e8 ed ea ff ff       	call   4003463f <sx1276_dio1_qos>
            int_flag = int_flag & 0xfd;
40035b52:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b57:	83 e0 fd             	and    $0xfffffffd,%eax
40035b5a:	a2 94 81 00 a8       	mov    %al,0xa8008194
        if(int_flag == 4) {
40035b5f:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b64:	3c 04                	cmp    $0x4,%al
40035b66:	75 14                	jne    40035b7c <sx1276_set_tx+0x114>
            sx1276_on_dio2_irq(dev);
40035b68:	89 d8                	mov    %ebx,%eax
40035b6a:	e8 44 ea ff ff       	call   400345b3 <sx1276_on_dio2_irq>
            int_flag = int_flag & 0xfd;
40035b6f:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b74:	83 e0 fd             	and    $0xfffffffd,%eax
40035b77:	a2 94 81 00 a8       	mov    %al,0xa8008194
        if(int_flag == 8) {
40035b7c:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b81:	3c 08                	cmp    $0x8,%al
40035b83:	75 14                	jne    40035b99 <sx1276_set_tx+0x131>
            sx1276_on_dio3_irq(dev);
40035b85:	89 d8                	mov    %ebx,%eax
40035b87:	e8 44 ea ff ff       	call   400345d0 <sx1276_on_dio3_irq>
            int_flag = int_flag & 0xf7;
40035b8c:	a0 94 81 00 a8       	mov    0xa8008194,%al
40035b91:	83 e0 f7             	and    $0xfffffff7,%eax
40035b94:	a2 94 81 00 a8       	mov    %al,0xa8008194
        upm_delay_ms(1);
40035b99:	b8 01 00 00 00       	mov    $0x1,%eax
40035b9e:	e8 7d e9 ff ff       	call   40034520 <upm_delay_ms>
    while (counter < 4000 && r_event != REVENT_DONE) {
40035ba3:	4e                   	dec    %esi
40035ba4:	0f 85 6e ff ff ff    	jne    40035b18 <sx1276_set_tx+0xb0>
uint8_t reg1 = sx1276_read_reg(dev, LOR_RegIrqFlags);
40035baa:	ba 12 00 00 00       	mov    $0x12,%edx
40035baf:	89 d8                	mov    %ebx,%eax
40035bb1:	e8 02 eb ff ff       	call   400346b8 <sx1276_read_reg>
                    printf("IRQ flag values: %x\n", reg1);
40035bb6:	0f b6 c0             	movzbl %al,%eax
40035bb9:	50                   	push   %eax
40035bba:	68 ce c9 03 40       	push   $0x4003c9ce
40035bbf:	e8 b4 50 00 00       	call   4003ac78 <iprintf>
       printf("r_event value after blah: %d\n", r_event);
40035bc4:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
                    printf("IRQ flag values: %x\n", reg1);
40035bc9:	59                   	pop    %ecx
40035bca:	5e                   	pop    %esi
       printf("r_event value after blah: %d\n", r_event);
40035bcb:	50                   	push   %eax
40035bcc:	68 e3 c9 03 40       	push   $0x4003c9e3
40035bd1:	e8 a2 50 00 00       	call   4003ac78 <iprintf>
    int_flag = 0;
40035bd6:	c6 05 94 81 00 a8 00 	movb   $0x0,0xa8008194
       printf("r_event value after blah: %d\n", r_event);
40035bdd:	58                   	pop    %eax
    if (r_event == REVENT_EXEC) {
40035bde:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
       printf("r_event value after blah: %d\n", r_event);
40035be3:	5a                   	pop    %edx
    if (r_event == REVENT_EXEC) {
40035be4:	48                   	dec    %eax
40035be5:	75 31                	jne    40035c18 <sx1276_set_tx+0x1b0>
        printf("sx1276: setTx: Timeout occured\n");
40035be7:	68 01 ca 03 40       	push   $0x4003ca01
40035bec:	e8 87 50 00 00       	call   4003ac78 <iprintf>
        dev->settings->state = STATE_IDLE;
40035bf1:	8b 43 24             	mov    0x24(%ebx),%eax
        printf("sx1276: setTx: Timeout occured\n");
40035bf4:	5a                   	pop    %edx
        r_event = REVENT_TIMEOUT;
40035bf5:	c7 05 ac 81 00 a8 03 	movl   $0x3,0xa80081ac
40035bfc:	00 00 00 
        dev->settings->state = STATE_IDLE;
40035bff:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        if((RadioEvents_c != NULL) && (RadioEvents_c->TxTimeout != NULL)) {
40035c06:	a1 28 77 00 a8       	mov    0xa8007728,%eax
40035c0b:	85 c0                	test   %eax,%eax
40035c0d:	74 09                	je     40035c18 <sx1276_set_tx+0x1b0>
40035c0f:	8b 40 04             	mov    0x4(%eax),%eax
40035c12:	85 c0                	test   %eax,%eax
40035c14:	74 02                	je     40035c18 <sx1276_set_tx+0x1b0>
            RadioEvents_c->TxTimeout();
40035c16:	ff d0                	call   *%eax
printf("exiting set tx function\n");
40035c18:	68 21 ca 03 40       	push   $0x4003ca21
40035c1d:	e8 56 50 00 00       	call   4003ac78 <iprintf>
40035c22:	58                   	pop    %eax
    return r_event;
40035c23:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
}
40035c28:	8d 65 f8             	lea    -0x8(%ebp),%esp
40035c2b:	5b                   	pop    %ebx
40035c2c:	5e                   	pop    %esi
40035c2d:	5d                   	pop    %ebp
40035c2e:	c3                   	ret    

40035c2f <sx1276_send>:
RADIO_EVENT_T sx1276_send(sx1276_context dev, uint8_t* buffer, uint8_t size, int timeout) {
40035c2f:	55                   	push   %ebp
40035c30:	89 e5                	mov    %esp,%ebp
40035c32:	57                   	push   %edi
40035c33:	56                   	push   %esi
40035c34:	53                   	push   %ebx
40035c35:	53                   	push   %ebx
40035c36:	89 c3                	mov    %eax,%ebx
40035c38:	8b 45 08             	mov    0x8(%ebp),%eax
40035c3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    switch (dev->settings->modem) {
40035c3e:	8b 43 24             	mov    0x24(%ebx),%eax
40035c41:	83 38 00             	cmpl   $0x0,(%eax)
40035c44:	0f 85 df 00 00 00    	jne    40035d29 <sx1276_send+0xfa>
            if (dev->settings->loraSettings->IqInverted == true) {
40035c4a:	8b 40 0c             	mov    0xc(%eax),%eax
40035c4d:	89 d7                	mov    %edx,%edi
40035c4f:	89 ce                	mov    %ecx,%esi
                uint8_t reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
40035c51:	ba 33 00 00 00       	mov    $0x33,%edx
            if (dev->settings->loraSettings->IqInverted == true) {
40035c56:	80 78 15 00          	cmpb   $0x0,0x15(%eax)
                uint8_t reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
40035c5a:	89 d8                	mov    %ebx,%eax
            if (dev->settings->loraSettings->IqInverted == true) {
40035c5c:	74 20                	je     40035c7e <sx1276_send+0x4f>
                uint8_t reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
40035c5e:	e8 55 ea ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
40035c63:	ba 33 00 00 00       	mov    $0x33,%edx
40035c68:	89 c1                	mov    %eax,%ecx
40035c6a:	89 d8                	mov    %ebx,%eax
40035c6c:	81 e1 be 00 00 00    	and    $0xbe,%ecx
40035c72:	e8 b4 ea ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ2, 0x19);
40035c77:	b9 19 00 00 00       	mov    $0x19,%ecx
40035c7c:	eb 21                	jmp    40035c9f <sx1276_send+0x70>
                uint8_t reg = sx1276_read_reg(dev, LOR_RegInvertIQ);
40035c7e:	e8 35 ea ff ff       	call   400346b8 <sx1276_read_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
40035c83:	ba 33 00 00 00       	mov    $0x33,%edx
                reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
40035c88:	89 c1                	mov    %eax,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
40035c8a:	89 d8                	mov    %ebx,%eax
                reg |= INVERTIQ_InvertIQTxOff; // 'active' off.
40035c8c:	81 e1 be 00 00 00    	and    $0xbe,%ecx
                sx1276_write_reg(dev, LOR_RegInvertIQ, reg);
40035c92:	83 c9 01             	or     $0x1,%ecx
40035c95:	e8 91 ea ff ff       	call   4003472b <sx1276_write_reg>
                sx1276_write_reg(dev, LOR_RegInvertIQ2, 0x1d);
40035c9a:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40035c9f:	ba 3b 00 00 00       	mov    $0x3b,%edx
40035ca4:	89 d8                	mov    %ebx,%eax
40035ca6:	e8 80 ea ff ff       	call   4003472b <sx1276_write_reg>
            dev->settings->loraPacketHandler->Size = size;
40035cab:	8b 43 24             	mov    0x24(%ebx),%eax
40035cae:	89 f2                	mov    %esi,%edx
40035cb0:	8b 40 10             	mov    0x10(%eax),%eax
            sx1276_write_reg(dev, LOR_RegPayloadLength, size);
40035cb3:	0f b6 f2             	movzbl %dl,%esi
            dev->settings->loraPacketHandler->Size = size;
40035cb6:	88 50 04             	mov    %dl,0x4(%eax)
            sx1276_write_reg(dev, LOR_RegPayloadLength, size);
40035cb9:	89 f1                	mov    %esi,%ecx
40035cbb:	ba 22 00 00 00       	mov    $0x22,%edx
40035cc0:	89 d8                	mov    %ebx,%eax
40035cc2:	e8 64 ea ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegFifoTxBaseAddr, 0);
40035cc7:	31 c9                	xor    %ecx,%ecx
40035cc9:	ba 0e 00 00 00       	mov    $0xe,%edx
40035cce:	89 d8                	mov    %ebx,%eax
40035cd0:	e8 56 ea ff ff       	call   4003472b <sx1276_write_reg>
            sx1276_write_reg(dev, LOR_RegFifoAddrPtr, 0 );
40035cd5:	31 c9                	xor    %ecx,%ecx
40035cd7:	ba 0d 00 00 00       	mov    $0xd,%edx
40035cdc:	89 d8                	mov    %ebx,%eax
40035cde:	e8 48 ea ff ff       	call   4003472b <sx1276_write_reg>
            if ((sx1276_read_reg(dev, COM_RegOpMode) & _OPMODE_Mode_MASK) == MODE_Sleep) {
40035ce3:	ba 01 00 00 00       	mov    $0x1,%edx
40035ce8:	89 d8                	mov    %ebx,%eax
40035cea:	e8 c9 e9 ff ff       	call   400346b8 <sx1276_read_reg>
40035cef:	a8 07                	test   $0x7,%al
40035cf1:	75 1c                	jne    40035d0f <sx1276_send+0xe0>
                sx1276_set_stand_by(dev);
40035cf3:	89 d8                	mov    %ebx,%eax
40035cf5:	e8 8f ec ff ff       	call   40034989 <sx1276_set_stand_by>
printf("coming here\n");
40035cfa:	68 3a ca 03 40       	push   $0x4003ca3a
40035cff:	e8 74 4f 00 00       	call   4003ac78 <iprintf>
                upm_delay_ms(1);
40035d04:	b8 01 00 00 00       	mov    $0x1,%eax
printf("coming here\n");
40035d09:	5a                   	pop    %edx
                upm_delay_ms(1);
40035d0a:	e8 11 e8 ff ff       	call   40034520 <upm_delay_ms>
            if(sx1276_write_fifo(dev, buffer, size) != UPM_SUCCESS) {
40035d0f:	89 f1                	mov    %esi,%ecx
40035d11:	89 fa                	mov    %edi,%edx
40035d13:	89 d8                	mov    %ebx,%eax
40035d15:	e8 32 fa ff ff       	call   4003574c <sx1276_write_fifo>
40035d1a:	85 c0                	test   %eax,%eax
40035d1c:	74 0b                	je     40035d29 <sx1276_send+0xfa>
                printf("unable to write payload buffer\n");
40035d1e:	68 47 ca 03 40       	push   $0x4003ca47
40035d23:	e8 50 4f 00 00       	call   4003ac78 <iprintf>
40035d28:	58                   	pop    %eax
    return sx1276_set_tx(dev, timeout);
40035d29:	8b 55 f0             	mov    -0x10(%ebp),%edx
}
40035d2c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    return sx1276_set_tx(dev, timeout);
40035d2f:	89 d8                	mov    %ebx,%eax
}
40035d31:	5b                   	pop    %ebx
40035d32:	5e                   	pop    %esi
40035d33:	5f                   	pop    %edi
40035d34:	5d                   	pop    %ebp
    return sx1276_set_tx(dev, timeout);
40035d35:	e9 2e fd ff ff       	jmp    40035a68 <sx1276_set_tx>

40035d3a <sx1276_set_sleep>:

upm_result_t sx1276_set_sleep(sx1276_context dev) {
40035d3a:	55                   	push   %ebp
    sx1276_set_op_mode(dev, MODE_Sleep);
40035d3b:	31 d2                	xor    %edx,%edx
upm_result_t sx1276_set_sleep(sx1276_context dev) {
40035d3d:	89 e5                	mov    %esp,%ebp
40035d3f:	53                   	push   %ebx
40035d40:	89 c3                	mov    %eax,%ebx
    sx1276_set_op_mode(dev, MODE_Sleep);
40035d42:	e8 ff eb ff ff       	call   40034946 <sx1276_set_op_mode>
    dev->settings->state = STATE_IDLE;
40035d47:	8b 43 24             	mov    0x24(%ebx),%eax
40035d4a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    return UPM_SUCCESS;
}
40035d51:	31 c0                	xor    %eax,%eax
40035d53:	5b                   	pop    %ebx
40035d54:	5d                   	pop    %ebp
40035d55:	c3                   	ret    

40035d56 <sx1276_set_max_payload_length>:

void sx1276_set_max_payload_length(sx1276_context dev, RADIO_MODEM_T modem, uint8_t max){
40035d56:	55                   	push   %ebp
40035d57:	89 e5                	mov    %esp,%ebp
40035d59:	57                   	push   %edi
40035d5a:	89 d7                	mov    %edx,%edi
40035d5c:	56                   	push   %esi
40035d5d:	89 c6                	mov    %eax,%esi
40035d5f:	53                   	push   %ebx
40035d60:	89 cb                	mov    %ecx,%ebx
    sx1276_set_modem(dev, modem);
40035d62:	e8 41 ec ff ff       	call   400349a8 <sx1276_set_modem>

    switch(modem) {
40035d67:	85 ff                	test   %edi,%edi
40035d69:	75 13                	jne    40035d7e <sx1276_set_max_payload_length+0x28>
        case MODEM_FSK:
        break;
        case MODEM_LORA:
            sx1276_write_reg(dev, LOR_RegMaxPayloadLength, max);
40035d6b:	0f b6 cb             	movzbl %bl,%ecx
40035d6e:	89 f0                	mov    %esi,%eax
40035d70:	ba 23 00 00 00       	mov    $0x23,%edx
        break;
    }
}
40035d75:	5b                   	pop    %ebx
40035d76:	5e                   	pop    %esi
40035d77:	5f                   	pop    %edi
40035d78:	5d                   	pop    %ebp
            sx1276_write_reg(dev, LOR_RegMaxPayloadLength, max);
40035d79:	e9 ad e9 ff ff       	jmp    4003472b <sx1276_write_reg>
}
40035d7e:	5b                   	pop    %ebx
40035d7f:	5e                   	pop    %esi
40035d80:	5f                   	pop    %edi
40035d81:	5d                   	pop    %ebp
40035d82:	c3                   	ret    

40035d83 <sx1276_set_public_network>:

void sx1276_set_public_network(sx1276_context dev, bool enable) {
40035d83:	55                   	push   %ebp
40035d84:	89 e5                	mov    %esp,%ebp
40035d86:	56                   	push   %esi
40035d87:	89 d6                	mov    %edx,%esi
    sx1276_set_modem(dev, MODEM_LORA);
40035d89:	31 d2                	xor    %edx,%edx
void sx1276_set_public_network(sx1276_context dev, bool enable) {
40035d8b:	53                   	push   %ebx
40035d8c:	89 c3                	mov    %eax,%ebx
    sx1276_set_modem(dev, MODEM_LORA);
40035d8e:	e8 15 ec ff ff       	call   400349a8 <sx1276_set_modem>
    if( enable == true )
40035d93:	89 f0                	mov    %esi,%eax
    {
        // Change LoRa modem SyncWord
        sx1276_write_reg(dev, LOR_RegSyncWord, LORA_MAC_PUBLIC_SYNCWORD);
40035d95:	b9 34 00 00 00       	mov    $0x34,%ecx
    if( enable == true )
40035d9a:	84 c0                	test   %al,%al
40035d9c:	75 05                	jne    40035da3 <sx1276_set_public_network+0x20>
    }
    else
    {
        // Change LoRa modem SyncWord
        sx1276_write_reg(dev, LOR_RegSyncWord, LORA_MAC_PRIVATE_SYNCWORD);
40035d9e:	b9 12 00 00 00       	mov    $0x12,%ecx
40035da3:	89 d8                	mov    %ebx,%eax
40035da5:	ba 39 00 00 00       	mov    $0x39,%edx
    }
}
40035daa:	5b                   	pop    %ebx
40035dab:	5e                   	pop    %esi
40035dac:	5d                   	pop    %ebp
        sx1276_write_reg(dev, LOR_RegSyncWord, LORA_MAC_PRIVATE_SYNCWORD);
40035dad:	e9 79 e9 ff ff       	jmp    4003472b <sx1276_write_reg>

40035db2 <sx1276_get_status>:

RADIO_STATES_T sx1276_get_status(sx1276_context dev) {
40035db2:	55                   	push   %ebp
    return dev->settings->state;
40035db3:	8b 40 24             	mov    0x24(%eax),%eax
RADIO_STATES_T sx1276_get_status(sx1276_context dev) {
40035db6:	89 e5                	mov    %esp,%ebp
}
40035db8:	5d                   	pop    %ebp
    return dev->settings->state;
40035db9:	8b 40 04             	mov    0x4(%eax),%eax
}
40035dbc:	c3                   	ret    

40035dbd <sx1276_check_rf_frequency>:

bool sx1276_check_rf_frequency(sx1276_context dev, uint32_t freq) {
40035dbd:	55                   	push   %ebp
    // currently all frequencies are supported as per semtech sx1276 driver
    return true;
}
40035dbe:	b0 01                	mov    $0x1,%al
bool sx1276_check_rf_frequency(sx1276_context dev, uint32_t freq) {
40035dc0:	89 e5                	mov    %esp,%ebp
}
40035dc2:	5d                   	pop    %ebp
40035dc3:	c3                   	ret    

40035dc4 <sx1276_random>:

uint32_t sx1276_random(sx1276_context dev) {
40035dc4:	55                   	push   %ebp

    /*
     * Radio setup for random number generation
     */
    // Set LoRa modem ON
    sx1276_set_modem(dev, MODEM_LORA);
40035dc5:	31 d2                	xor    %edx,%edx
uint32_t sx1276_random(sx1276_context dev) {
40035dc7:	89 e5                	mov    %esp,%ebp
40035dc9:	57                   	push   %edi
40035dca:	56                   	push   %esi
40035dcb:	53                   	push   %ebx
40035dcc:	89 c3                	mov    %eax,%ebx
    sx1276_set_modem(dev, MODEM_LORA);
40035dce:	e8 d5 eb ff ff       	call   400349a8 <sx1276_set_modem>

    // Disable LoRa modem interrupts
    sx1276_write_reg(dev, LOR_RegIrqFlagsMask, LOR_IRQFLAG_RxTimeout |
40035dd3:	b9 ff 00 00 00       	mov    $0xff,%ecx
40035dd8:	ba 11 00 00 00       	mov    $0x11,%edx
40035ddd:	89 d8                	mov    %ebx,%eax
                LOR_IRQFLAG_CadDone |
                LOR_IRQFLAG_FhssChangeChannel |
                LOR_IRQFLAG_CadDetected );

    // Set radio in continuous reception
    sx1276_set_op_mode(dev, MODE_LOR_RxContinuous);
40035ddf:	31 ff                	xor    %edi,%edi
    sx1276_write_reg(dev, LOR_RegIrqFlagsMask, LOR_IRQFLAG_RxTimeout |
40035de1:	e8 45 e9 ff ff       	call   4003472b <sx1276_write_reg>
    sx1276_set_op_mode(dev, MODE_LOR_RxContinuous);
40035de6:	ba 05 00 00 00       	mov    $0x5,%edx
40035deb:	89 d8                	mov    %ebx,%eax
    uint32_t rnd = 0;
40035ded:	31 f6                	xor    %esi,%esi
    sx1276_set_op_mode(dev, MODE_LOR_RxContinuous);
40035def:	e8 52 eb ff ff       	call   40034946 <sx1276_set_op_mode>

    for(i=0;i<32;i++) {
        //DelayMs( 1 );
        upm_delay_ms(1);
40035df4:	b8 01 00 00 00       	mov    $0x1,%eax
40035df9:	e8 22 e7 ff ff       	call   40034520 <upm_delay_ms>
        // Unfiltered RSSI value reading. Only takes the LSB value
        rnd |= ((uint32_t)sx1276_read_reg(dev, LOR_RegRssiWideband)&0x01) << i;
40035dfe:	ba 2c 00 00 00       	mov    $0x2c,%edx
40035e03:	89 d8                	mov    %ebx,%eax
40035e05:	e8 ae e8 ff ff       	call   400346b8 <sx1276_read_reg>
40035e0a:	89 f9                	mov    %edi,%ecx
40035e0c:	83 e0 01             	and    $0x1,%eax
40035e0f:	47                   	inc    %edi
40035e10:	d3 e0                	shl    %cl,%eax
40035e12:	09 c6                	or     %eax,%esi
    for(i=0;i<32;i++) {
40035e14:	83 ff 20             	cmp    $0x20,%edi
40035e17:	75 db                	jne    40035df4 <sx1276_random+0x30>
    }

    sx1276_set_sleep(dev);
40035e19:	89 d8                	mov    %ebx,%eax
40035e1b:	e8 1a ff ff ff       	call   40035d3a <sx1276_set_sleep>

    return rnd;
}
40035e20:	5b                   	pop    %ebx
40035e21:	89 f0                	mov    %esi,%eax
40035e23:	5e                   	pop    %esi
40035e24:	5f                   	pop    %edi
40035e25:	5d                   	pop    %ebp
40035e26:	c3                   	ret    

40035e27 <sx1276_get_time_on_air>:

uint32_t sx1276_get_time_on_air(sx1276_context dev, RADIO_MODEM_T modem, uint8_t pktLen) {
    uint32_t airTime = 0;

    switch(modem) {
40035e27:	85 d2                	test   %edx,%edx
40035e29:	0f 85 a7 01 00 00    	jne    40035fd6 <sx1276_get_time_on_air+0x1af>
uint32_t sx1276_get_time_on_air(sx1276_context dev, RADIO_MODEM_T modem, uint8_t pktLen) {
40035e2f:	55                   	push   %ebp
40035e30:	89 e5                	mov    %esp,%ebp
40035e32:	57                   	push   %edi
40035e33:	56                   	push   %esi
40035e34:	53                   	push   %ebx
40035e35:	83 ec 20             	sub    $0x20,%esp
        case MODEM_FSK:{}
        break;
        case MODEM_LORA: {
            double bw = 0.0;
            // REMARK: When using LoRa modem only bandwidths 125, 250 and 500 kHz are supported
            switch(dev->settings->loraSettings->Bandwidth) {
40035e38:	31 f6                	xor    %esi,%esi
40035e3a:	8b 50 24             	mov    0x24(%eax),%edx
40035e3d:	8b 5a 0c             	mov    0xc(%edx),%ebx
40035e40:	8b 7b 04             	mov    0x4(%ebx),%edi
40035e43:	8d 57 f9             	lea    -0x7(%edi),%edx
40035e46:	31 ff                	xor    %edi,%edi
40035e48:	83 fa 02             	cmp    $0x2,%edx
40035e4b:	77 0e                	ja     40035e5b <sx1276_get_time_on_air+0x34>
40035e4d:	8b 34 d5 68 ca 03 40 	mov    0x4003ca68(,%edx,8),%esi
40035e54:	8b 3c d5 6c ca 03 40 	mov    0x4003ca6c(,%edx,8),%edi
40035e5b:	89 45 d8             	mov    %eax,-0x28(%ebp)
                case 9: // 500 kHz
                    bw = 500e3;
                break;
            }
            // Symbol rate : time for one symbol (secs)
            double rs = bw / (1 << dev->settings->loraSettings->Datarate);
40035e5e:	8b 43 08             	mov    0x8(%ebx),%eax
40035e61:	89 45 ec             	mov    %eax,-0x14(%ebp)
40035e64:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
40035e67:	b8 01 00 00 00       	mov    $0x1,%eax
40035e6c:	8a 4d ec             	mov    -0x14(%ebp),%cl
40035e6f:	d3 e0                	shl    %cl,%eax
40035e71:	e8 fe b7 ff ff       	call   40031674 <__floatsidf>
40035e76:	52                   	push   %edx
40035e77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40035e7a:	50                   	push   %eax
40035e7b:	89 55 e8             	mov    %edx,-0x18(%ebp)
40035e7e:	89 f0                	mov    %esi,%eax
40035e80:	89 fa                	mov    %edi,%edx
40035e82:	e8 77 ab ff ff       	call   400309fe <__divdf3>
40035e87:	5e                   	pop    %esi
40035e88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40035e8b:	5f                   	pop    %edi
40035e8c:	89 55 e8             	mov    %edx,-0x18(%ebp)
            double ts = 1 / rs;
40035e8f:	52                   	push   %edx
40035e90:	ba 00 00 f0 3f       	mov    $0x3ff00000,%edx
40035e95:	50                   	push   %eax
40035e96:	31 c0                	xor    %eax,%eax
40035e98:	e8 61 ab ff ff       	call   400309fe <__divdf3>
40035e9d:	59                   	pop    %ecx
40035e9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40035ea1:	5e                   	pop    %esi
            // time of preamble
            double tPreamble = ( dev->settings->loraSettings->PreambleLen + 4.25 ) * ts;
40035ea2:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
            double ts = 1 / rs;
40035ea6:	89 55 e8             	mov    %edx,-0x18(%ebp)
            double tPreamble = ( dev->settings->loraSettings->PreambleLen + 4.25 ) * ts;
40035ea9:	e8 c6 b7 ff ff       	call   40031674 <__floatsidf>
40035eae:	68 00 00 11 40       	push   $0x40110000
40035eb3:	6a 00                	push   $0x0
40035eb5:	e8 d7 a2 ff ff       	call   40030191 <__adddf3>
40035eba:	5f                   	pop    %edi
40035ebb:	59                   	pop    %ecx
40035ebc:	ff 75 e8             	pushl  -0x18(%ebp)
40035ebf:	ff 75 e4             	pushl  -0x1c(%ebp)
40035ec2:	e8 89 b2 ff ff       	call   40031150 <__muldf3>
40035ec7:	5e                   	pop    %esi
            // Symbol length of payload and time
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035ec8:	0f b6 4d d4          	movzbl -0x2c(%ebp),%ecx
            double tPreamble = ( dev->settings->loraSettings->PreambleLen + 4.25 ) * ts;
40035ecc:	89 45 dc             	mov    %eax,-0x24(%ebp)
40035ecf:	5f                   	pop    %edi
                              28 + 16 * dev->settings->loraSettings->CrcOn -
40035ed0:	0f b6 43 12          	movzbl 0x12(%ebx),%eax
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035ed4:	8b 7d ec             	mov    -0x14(%ebp),%edi
            double tPreamble = ( dev->settings->loraSettings->PreambleLen + 4.25 ) * ts;
40035ed7:	89 55 e0             	mov    %edx,-0x20(%ebp)
                              28 + 16 * dev->settings->loraSettings->CrcOn -
40035eda:	c1 e0 04             	shl    $0x4,%eax
40035edd:	89 c2                	mov    %eax,%edx
40035edf:	8d 04 cd 1c 00 00 00 	lea    0x1c(,%ecx,8),%eax
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035ee6:	8d 0c bd 00 00 00 00 	lea    0x0(,%edi,4),%ecx
40035eed:	29 c8                	sub    %ecx,%eax
                              (dev->settings->loraSettings->FixLen ? 20 : 0))/
40035eef:	80 7b 10 01          	cmpb   $0x1,0x10(%ebx)
40035ef3:	19 c9                	sbb    %ecx,%ecx
                              28 + 16 * dev->settings->loraSettings->CrcOn -
40035ef5:	01 d0                	add    %edx,%eax
                              (dev->settings->loraSettings->FixLen ? 20 : 0))/
40035ef7:	f7 d1                	not    %ecx
40035ef9:	83 e1 14             	and    $0x14,%ecx
                              28 + 16 * dev->settings->loraSettings->CrcOn -
40035efc:	29 c8                	sub    %ecx,%eax
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035efe:	e8 fe b7 ff ff       	call   40031701 <__floatunsidf>
40035f03:	89 c6                	mov    %eax,%esi
                              (double)(4 * (dev->settings->loraSettings->Datarate -
                              ((dev->settings->loraSettings->LowDatarateOptimize > 0) ? 2:0))))*
40035f05:	31 c0                	xor    %eax,%eax
40035f07:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
40035f0b:	0f 95 c0             	setne  %al
40035f0e:	01 c0                	add    %eax,%eax
                              (double)(4 * (dev->settings->loraSettings->Datarate -
40035f10:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40035f13:	29 c3                	sub    %eax,%ebx
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035f15:	89 d7                	mov    %edx,%edi
                              (double)(4 * (dev->settings->loraSettings->Datarate -
40035f17:	89 d8                	mov    %ebx,%eax
40035f19:	c1 e0 02             	shl    $0x2,%eax
40035f1c:	e8 e0 b7 ff ff       	call   40031701 <__floatunsidf>
40035f21:	89 45 ec             	mov    %eax,-0x14(%ebp)
40035f24:	89 55 f0             	mov    %edx,-0x10(%ebp)
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035f27:	52                   	push   %edx
40035f28:	89 fa                	mov    %edi,%edx
40035f2a:	50                   	push   %eax
40035f2b:	89 f0                	mov    %esi,%eax
40035f2d:	e8 cc aa ff ff       	call   400309fe <__divdf3>
40035f32:	59                   	pop    %ecx
40035f33:	5b                   	pop    %ebx
40035f34:	e8 fb 48 00 00       	call   4003a834 <ceil>
40035f39:	89 45 ec             	mov    %eax,-0x14(%ebp)
                              (dev->settings->loraSettings->Coderate + 4);
40035f3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035f3f:	89 55 f0             	mov    %edx,-0x10(%ebp)
                              (dev->settings->loraSettings->Coderate + 4);
40035f42:	8b 40 24             	mov    0x24(%eax),%eax
40035f45:	8b 40 0c             	mov    0xc(%eax),%eax
40035f48:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
40035f4c:	83 c0 04             	add    $0x4,%eax
                              ((dev->settings->loraSettings->LowDatarateOptimize > 0) ? 2:0))))*
40035f4f:	e8 20 b7 ff ff       	call   40031674 <__floatsidf>
            double tmp = ceil((8 * pktLen - 4 * dev->settings->loraSettings->Datarate +
40035f54:	ff 75 f0             	pushl  -0x10(%ebp)
40035f57:	ff 75 ec             	pushl  -0x14(%ebp)
40035f5a:	e8 f1 b1 ff ff       	call   40031150 <__muldf3>
40035f5f:	5e                   	pop    %esi
40035f60:	89 c6                	mov    %eax,%esi
40035f62:	5f                   	pop    %edi
40035f63:	89 d7                	mov    %edx,%edi
            double nPayload = 8 + ((tmp > 0) ? tmp:0);
40035f65:	6a 00                	push   $0x0
40035f67:	6a 00                	push   $0x0
40035f69:	e8 c0 af ff ff       	call   40030f2e <__gedf2>
40035f6e:	5a                   	pop    %edx
40035f6f:	85 c0                	test   %eax,%eax
40035f71:	59                   	pop    %ecx
40035f72:	b8 00 00 00 00       	mov    $0x0,%eax
40035f77:	ba 00 00 20 40       	mov    $0x40200000,%edx
40035f7c:	7e 0d                	jle    40035f8b <sx1276_get_time_on_air+0x164>
40035f7e:	52                   	push   %edx
40035f7f:	89 fa                	mov    %edi,%edx
40035f81:	50                   	push   %eax
40035f82:	89 f0                	mov    %esi,%eax
40035f84:	e8 08 a2 ff ff       	call   40030191 <__adddf3>
40035f89:	59                   	pop    %ecx
40035f8a:	5b                   	pop    %ebx
            double tPayload = nPayload*ts;
40035f8b:	ff 75 e8             	pushl  -0x18(%ebp)
40035f8e:	ff 75 e4             	pushl  -0x1c(%ebp)
40035f91:	e8 ba b1 ff ff       	call   40031150 <__muldf3>
40035f96:	59                   	pop    %ecx
40035f97:	5b                   	pop    %ebx
            // Time on air
            double tOnAir = tPreamble + tPayload;
40035f98:	ff 75 e0             	pushl  -0x20(%ebp)
40035f9b:	ff 75 dc             	pushl  -0x24(%ebp)
40035f9e:	e8 ee a1 ff ff       	call   40030191 <__adddf3>
40035fa3:	5e                   	pop    %esi
40035fa4:	5f                   	pop    %edi
            // return ms secs
            airTime = floor(tOnAir*1e3 + 0.999);
40035fa5:	68 00 40 8f 40       	push   $0x408f4000
40035faa:	6a 00                	push   $0x0
40035fac:	e8 9f b1 ff ff       	call   40031150 <__muldf3>
40035fb1:	59                   	pop    %ecx
40035fb2:	5b                   	pop    %ebx
40035fb3:	68 ce f7 ef 3f       	push   $0x3feff7ce
40035fb8:	68 2b 87 16 d9       	push   $0xd916872b
40035fbd:	e8 cf a1 ff ff       	call   40030191 <__adddf3>
40035fc2:	5e                   	pop    %esi
40035fc3:	5f                   	pop    %edi
40035fc4:	e8 b6 49 00 00       	call   4003a97f <floor>
40035fc9:	e8 39 b6 ff ff       	call   40031607 <__fixunsdfsi>
        }
        break;
    }

    return airTime;
}
40035fce:	8d 65 f4             	lea    -0xc(%ebp),%esp
40035fd1:	5b                   	pop    %ebx
40035fd2:	5e                   	pop    %esi
40035fd3:	5f                   	pop    %edi
40035fd4:	5d                   	pop    %ebp
40035fd5:	c3                   	ret    
    uint32_t airTime = 0;
40035fd6:	31 c0                	xor    %eax,%eax
    return airTime;
40035fd8:	c3                   	ret    

40035fd9 <sx1276_set_tx_continuous_wave>:

void sx1276_set_tx_continuous_wave(sx1276_context dev, uint32_t freq, int8_t power, uint16_t time) {
40035fd9:	55                   	push   %ebp
40035fda:	89 e5                	mov    %esp,%ebp
40035fdc:	57                   	push   %edi
40035fdd:	56                   	push   %esi
40035fde:	53                   	push   %ebx
40035fdf:	53                   	push   %ebx
40035fe0:	89 c3                	mov    %eax,%ebx
40035fe2:	8b 75 08             	mov    0x8(%ebp),%esi
40035fe5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    uint32_t timeout = ( uint32_t )( time * 1e3 );

    sx1276_set_channel(dev, freq);
40035fe8:	e8 9a e7 ff ff       	call   40034787 <sx1276_set_channel>
    //SX1276SetChannel( freq );

    // check what has to be done with the timeout
    sx1276_set_tx_config(dev, MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0);
40035fed:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40035ff0:	6a 00                	push   $0x0
40035ff2:	ba 01 00 00 00       	mov    $0x1,%edx
40035ff7:	6a 00                	push   $0x0
40035ff9:	89 d8                	mov    %ebx,%eax
40035ffb:	6a 00                	push   $0x0
40035ffd:	6a 00                	push   $0x0
40035fff:	0f be c9             	movsbl %cl,%ecx
40036002:	6a 00                	push   $0x0
40036004:	6a 05                	push   $0x5
40036006:	6a 00                	push   $0x0
40036008:	68 c0 12 00 00       	push   $0x12c0
4003600d:	6a 00                	push   $0x0
4003600f:	6a 00                	push   $0x0
40036011:	e8 09 ea ff ff       	call   40034a1f <sx1276_set_tx_config>
40036016:	83 c4 28             	add    $0x28,%esp
    //SX1276SetTxConfig( MODEM_FSK, power, 0, 0, 4800, 0, 5, false, false, 0, 0, 0, timeout );

    sx1276_write_reg(dev, FSK_RegPacketConfig2, (sx1276_read_reg(dev, FSK_RegPacketConfig2) & COM_PacketConfig2_DataMode_Mask));
40036019:	ba 31 00 00 00       	mov    $0x31,%edx
4003601e:	89 d8                	mov    %ebx,%eax
40036020:	e8 93 e6 ff ff       	call   400346b8 <sx1276_read_reg>
40036025:	ba 31 00 00 00       	mov    $0x31,%edx
4003602a:	89 c1                	mov    %eax,%ecx
4003602c:	89 d8                	mov    %ebx,%eax
4003602e:	81 e1 bf 00 00 00    	and    $0xbf,%ecx
40036034:	e8 f2 e6 ff ff       	call   4003472b <sx1276_write_reg>
    //SX1276Write( FSK_RegPacketConfig2, ( SX1276Read( FSK_RegPacketConfig2 ) & COM_PacketConfig2_DataMode_Mask ) );
    // Disable radio interrupts
    sx1276_write_reg(dev, COM_RegDioMapping1, RF_DIOMAPPING1_DIO0_11 | RF_DIOMAPPING1_DIO1_11);
40036039:	b9 f0 00 00 00       	mov    $0xf0,%ecx
4003603e:	ba 40 00 00 00       	mov    $0x40,%edx
40036043:	89 d8                	mov    %ebx,%eax
40036045:	e8 e1 e6 ff ff       	call   4003472b <sx1276_write_reg>
    sx1276_write_reg(dev, COM_RegDioMapping2, RF_DIOMAPPING2_DIO4_10 | RF_DIOMAPPING2_DIO5_10);
4003604a:	b9 a0 00 00 00       	mov    $0xa0,%ecx
4003604f:	ba 41 00 00 00       	mov    $0x41,%edx
40036054:	89 d8                	mov    %ebx,%eax
40036056:	e8 d0 e6 ff ff       	call   4003472b <sx1276_write_reg>
    //TimerSetValue( &TxTimeoutTimer, timeout );

    //SX1276.Settings.State = RF_TX_RUNNING;
    //TimerStart( &TxTimeoutTimer );
    int counter = 0;
    dev->settings->state = STATE_TX_RUNNING;
4003605b:	8b 43 24             	mov    0x24(%ebx),%eax
    r_event = REVENT_EXEC;
    //k_timer_start(&TxTimeoutTimer, timeout, 0);
    //SX1276SetOpMode( RF_OPMODE_TRANSMITTER );
    sx1276_set_op_mode(dev, MODE_TxMode);
4003605e:	ba 03 00 00 00       	mov    $0x3,%edx
    dev->settings->state = STATE_TX_RUNNING;
40036063:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    sx1276_set_op_mode(dev, MODE_TxMode);
4003606a:	89 d8                	mov    %ebx,%eax
    r_event = REVENT_EXEC;
4003606c:	c7 05 ac 81 00 a8 01 	movl   $0x1,0xa80081ac
40036073:	00 00 00 
    sx1276_set_op_mode(dev, MODE_TxMode);
40036076:	e8 cb e8 ff ff       	call   40034946 <sx1276_set_op_mode>
    uint32_t timeout = ( uint32_t )( time * 1e3 );
4003607b:	0f b7 c6             	movzwl %si,%eax
4003607e:	e8 f1 b5 ff ff       	call   40031674 <__floatsidf>
40036083:	68 00 40 8f 40       	push   $0x408f4000
40036088:	6a 00                	push   $0x0
4003608a:	e8 c1 b0 ff ff       	call   40031150 <__muldf3>
4003608f:	5e                   	pop    %esi
40036090:	5f                   	pop    %edi
40036091:	e8 71 b5 ff ff       	call   40031607 <__fixunsdfsi>
    int counter = 0;
40036096:	31 f6                	xor    %esi,%esi
    uint32_t timeout = ( uint32_t )( time * 1e3 );
40036098:	89 c7                	mov    %eax,%edi

    while (counter < timeout && r_event != REVENT_DONE) {
4003609a:	39 fe                	cmp    %edi,%esi
4003609c:	0f 84 91 00 00 00    	je     40036133 <sx1276_set_tx_continuous_wave+0x15a>
400360a2:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
400360a7:	85 c0                	test   %eax,%eax
400360a9:	0f 84 84 00 00 00    	je     40036133 <sx1276_set_tx_continuous_wave+0x15a>
        if(int_flag == 1) {
400360af:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360b4:	fe c8                	dec    %al
400360b6:	75 14                	jne    400360cc <sx1276_set_tx_continuous_wave+0xf3>
            sx1276_dio0_qos(dev);
400360b8:	89 d8                	mov    %ebx,%eax
400360ba:	e8 91 f7 ff ff       	call   40035850 <sx1276_dio0_qos>
            int_flag = int_flag & 0xfe;
400360bf:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360c4:	83 e0 fe             	and    $0xfffffffe,%eax
400360c7:	a2 94 81 00 a8       	mov    %al,0xa8008194
        }
        if(int_flag == 2) {
400360cc:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360d1:	3c 02                	cmp    $0x2,%al
400360d3:	75 14                	jne    400360e9 <sx1276_set_tx_continuous_wave+0x110>
            sx1276_dio1_qos(dev);
400360d5:	89 d8                	mov    %ebx,%eax
400360d7:	e8 63 e5 ff ff       	call   4003463f <sx1276_dio1_qos>
            int_flag = int_flag & 0xfd;
400360dc:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360e1:	83 e0 fd             	and    $0xfffffffd,%eax
400360e4:	a2 94 81 00 a8       	mov    %al,0xa8008194
        }
        if(int_flag == 4) {
400360e9:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360ee:	3c 04                	cmp    $0x4,%al
400360f0:	75 14                	jne    40036106 <sx1276_set_tx_continuous_wave+0x12d>
            sx1276_on_dio2_irq(dev);
400360f2:	89 d8                	mov    %ebx,%eax
400360f4:	e8 ba e4 ff ff       	call   400345b3 <sx1276_on_dio2_irq>
            int_flag = int_flag & 0xfd;
400360f9:	a0 94 81 00 a8       	mov    0xa8008194,%al
400360fe:	83 e0 fd             	and    $0xfffffffd,%eax
40036101:	a2 94 81 00 a8       	mov    %al,0xa8008194
        }
        if(int_flag == 8) {
40036106:	a0 94 81 00 a8       	mov    0xa8008194,%al
4003610b:	3c 08                	cmp    $0x8,%al
4003610d:	75 14                	jne    40036123 <sx1276_set_tx_continuous_wave+0x14a>
            sx1276_on_dio3_irq(dev);
4003610f:	89 d8                	mov    %ebx,%eax
40036111:	e8 ba e4 ff ff       	call   400345d0 <sx1276_on_dio3_irq>
            int_flag = int_flag & 0xf7;
40036116:	a0 94 81 00 a8       	mov    0xa8008194,%al
4003611b:	83 e0 f7             	and    $0xfffffff7,%eax
4003611e:	a2 94 81 00 a8       	mov    %al,0xa8008194
        }
        counter = counter + 1;
        //k_busy_wait(1000);
        upm_delay_ms(1);
40036123:	b8 01 00 00 00       	mov    $0x1,%eax
        counter = counter + 1;
40036128:	46                   	inc    %esi
        upm_delay_ms(1);
40036129:	e8 f2 e3 ff ff       	call   40034520 <upm_delay_ms>
4003612e:	e9 67 ff ff ff       	jmp    4003609a <sx1276_set_tx_continuous_wave+0xc1>
        //k_sleep(1);
    }

    // if the state hasnt changed so far we are in for a timeout
    if(r_event == REVENT_EXEC) {
40036133:	a1 ac 81 00 a8       	mov    0xa80081ac,%eax
40036138:	48                   	dec    %eax
40036139:	75 23                	jne    4003615e <sx1276_set_tx_continuous_wave+0x185>
        dev->settings->state = STATE_IDLE;
4003613b:	8b 43 24             	mov    0x24(%ebx),%eax
4003613e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
        if((RadioEvents_c != NULL) && (RadioEvents_c->TxTimeout != NULL)) {
40036145:	a1 28 77 00 a8       	mov    0xa8007728,%eax
4003614a:	85 c0                	test   %eax,%eax
4003614c:	74 10                	je     4003615e <sx1276_set_tx_continuous_wave+0x185>
4003614e:	8b 40 04             	mov    0x4(%eax),%eax
40036151:	85 c0                	test   %eax,%eax
40036153:	74 09                	je     4003615e <sx1276_set_tx_continuous_wave+0x185>
            RadioEvents_c->TxTimeout();
        }
    }
}
40036155:	8d 65 f4             	lea    -0xc(%ebp),%esp
40036158:	5b                   	pop    %ebx
40036159:	5e                   	pop    %esi
4003615a:	5f                   	pop    %edi
4003615b:	5d                   	pop    %ebp
            RadioEvents_c->TxTimeout();
4003615c:	ff e0                	jmp    *%eax
}
4003615e:	8d 65 f4             	lea    -0xc(%ebp),%esp
40036161:	5b                   	pop    %ebx
40036162:	5e                   	pop    %esi
40036163:	5f                   	pop    %edi
40036164:	5d                   	pop    %ebp
40036165:	c3                   	ret    

40036166 <sx1276_set_standby>:

void sx1276_set_standby(sx1276_context dev) {
40036166:	55                   	push   %ebp
    sx1276_set_op_mode(dev, MODE_Standby );
40036167:	ba 01 00 00 00       	mov    $0x1,%edx
void sx1276_set_standby(sx1276_context dev) {
4003616c:	89 e5                	mov    %esp,%ebp
4003616e:	53                   	push   %ebx
4003616f:	89 c3                	mov    %eax,%ebx
    sx1276_set_op_mode(dev, MODE_Standby );
40036171:	e8 d0 e7 ff ff       	call   40034946 <sx1276_set_op_mode>
    dev->settings->state = STATE_IDLE;
40036176:	8b 43 24             	mov    0x24(%ebx),%eax
40036179:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
40036180:	5b                   	pop    %ebx
40036181:	5d                   	pop    %ebp
40036182:	c3                   	ret    

40036183 <ValidatePayloadLength>:
    }
    return false;
}

static bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )
{
40036183:	55                   	push   %ebp
40036184:	89 e5                	mov    %esp,%ebp
    uint16_t maxN = 0;
    uint16_t payloadSize = 0;

    // Get the maximum payload length
    if( RepeaterSupport == true )
40036186:	80 3d 7f 7d 00 a8 00 	cmpb   $0x0,0xa8007d7f
4003618d:	0f be d2             	movsbl %dl,%edx
40036190:	74 09                	je     4003619b <ValidatePayloadLength+0x18>
    {
        maxN = MaxPayloadOfDatarateRepeater[datarate];
40036192:	0f b6 92 80 cc 03 40 	movzbl 0x4003cc80(%edx),%edx
40036199:	eb 07                	jmp    400361a2 <ValidatePayloadLength+0x1f>
    }
    else
    {
        maxN = MaxPayloadOfDatarate[datarate];
4003619b:	0f b6 92 90 cc 03 40 	movzbl 0x4003cc90(%edx),%edx
    }

    // Calculate the resulting payload size
    payloadSize = ( lenN + fOptsLen );
400361a2:	0f b6 c0             	movzbl %al,%eax
400361a5:	0f b6 c9             	movzbl %cl,%ecx
400361a8:	01 c1                	add    %eax,%ecx
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
    {
        return true;
    }
    return false;
}
400361aa:	5d                   	pop    %ebp
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
400361ab:	66 39 ca             	cmp    %cx,%dx
400361ae:	0f 93 c0             	setae  %al
400361b1:	66 81 f9 ff 00       	cmp    $0xff,%cx
400361b6:	0f 96 c2             	setbe  %dl
400361b9:	21 d0                	and    %edx,%eax
}
400361bb:	c3                   	ret    

400361bc <AddMacCommand>:

    return adrAckReq;
}

static LoRaMacStatus_t AddMacCommand( uint8_t cmd, uint8_t p1, uint8_t p2 )
{
400361bc:	55                   	push   %ebp
    LoRaMacStatus_t status = LORAMAC_STATUS_BUSY;
    // The maximum buffer length must take MAC commands to re-send into account.
    uint8_t bufLen = LORA_MAC_COMMAND_MAX_LENGTH - MacCommandsBufferToRepeatIndex;

    switch( cmd )
400361bd:	83 e8 02             	sub    $0x2,%eax
{
400361c0:	89 e5                	mov    %esp,%ebp
400361c2:	57                   	push   %edi
400361c3:	56                   	push   %esi
400361c4:	89 d6                	mov    %edx,%esi
    uint8_t bufLen = LORA_MAC_COMMAND_MAX_LENGTH - MacCommandsBufferToRepeatIndex;
400361c6:	b2 0f                	mov    $0xf,%dl
{
400361c8:	53                   	push   %ebx
    uint8_t bufLen = LORA_MAC_COMMAND_MAX_LENGTH - MacCommandsBufferToRepeatIndex;
400361c9:	2a 15 3f 7a 00 a8    	sub    0xa8007a3f,%dl
    switch( cmd )
400361cf:	3c 06                	cmp    $0x6,%al
400361d1:	0f 87 18 01 00 00    	ja     400362ef <AddMacCommand+0x133>
400361d7:	0f b6 c0             	movzbl %al,%eax
400361da:	0f b6 1d 40 7a 00 a8 	movzbl 0xa8007a40,%ebx
400361e1:	ff 24 85 04 cb 03 40 	jmp    *0x4003cb04(,%eax,4)
400361e8:	b8 01 00 00 00       	mov    $0x1,%eax
    {
        case MOTE_MAC_LINK_CHECK_REQ:
            if( MacCommandsBufferIndex < bufLen )
400361ed:	38 da                	cmp    %bl,%dl
400361ef:	0f 86 0a 01 00 00    	jbe    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
400361f5:	8d 43 01             	lea    0x1(%ebx),%eax
400361f8:	c6 83 30 7a 00 a8 02 	movb   $0x2,-0x57ff85d0(%ebx)
400361ff:	a2 40 7a 00 a8       	mov    %al,0xa8007a40
40036204:	e9 ed 00 00 00       	jmp    400362f6 <AddMacCommand+0x13a>
                // No payload for this command
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_LINK_ADR_ANS:
            if( MacCommandsBufferIndex < ( bufLen - 1 ) )
40036209:	0f b6 d2             	movzbl %dl,%edx
4003620c:	0f b6 cb             	movzbl %bl,%ecx
4003620f:	4a                   	dec    %edx
40036210:	b8 01 00 00 00       	mov    $0x1,%eax
40036215:	39 d1                	cmp    %edx,%ecx
40036217:	0f 8d e2 00 00 00    	jge    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
4003621d:	c6 81 30 7a 00 a8 03 	movb   $0x3,-0x57ff85d0(%ecx)
40036224:	e9 96 00 00 00       	jmp    400362bf <AddMacCommand+0x103>
40036229:	b8 01 00 00 00       	mov    $0x1,%eax
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_DUTY_CYCLE_ANS:
            if( MacCommandsBufferIndex < bufLen )
4003622e:	38 da                	cmp    %bl,%dl
40036230:	0f 86 c9 00 00 00    	jbe    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
40036236:	8d 43 01             	lea    0x1(%ebx),%eax
40036239:	c6 83 30 7a 00 a8 04 	movb   $0x4,-0x57ff85d0(%ebx)
40036240:	a2 40 7a 00 a8       	mov    %al,0xa8007a40
40036245:	e9 ac 00 00 00       	jmp    400362f6 <AddMacCommand+0x13a>
                // No payload for this answer
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_RX_PARAM_SETUP_ANS:
            if( MacCommandsBufferIndex < ( bufLen - 1 ) )
4003624a:	0f b6 d2             	movzbl %dl,%edx
4003624d:	0f b6 cb             	movzbl %bl,%ecx
40036250:	4a                   	dec    %edx
40036251:	b8 01 00 00 00       	mov    $0x1,%eax
40036256:	39 d1                	cmp    %edx,%ecx
40036258:	0f 8d a1 00 00 00    	jge    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
4003625e:	c6 81 30 7a 00 a8 05 	movb   $0x5,-0x57ff85d0(%ecx)
40036265:	eb 58                	jmp    400362bf <AddMacCommand+0x103>
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_DEV_STATUS_ANS:
            if( MacCommandsBufferIndex < ( bufLen - 2 ) )
40036267:	0f b6 d2             	movzbl %dl,%edx
4003626a:	0f b6 fb             	movzbl %bl,%edi
4003626d:	83 ea 02             	sub    $0x2,%edx
40036270:	b8 01 00 00 00       	mov    $0x1,%eax
40036275:	39 d7                	cmp    %edx,%edi
40036277:	0f 8d 82 00 00 00    	jge    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
4003627d:	8d 43 01             	lea    0x1(%ebx),%eax
                // 1st byte Battery
                // 2nd byte Margin
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
40036280:	89 f2                	mov    %esi,%edx
40036282:	0f b6 c0             	movzbl %al,%eax
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
40036285:	c6 87 30 7a 00 a8 06 	movb   $0x6,-0x57ff85d0(%edi)
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
4003628c:	88 90 30 7a 00 a8    	mov    %dl,-0x57ff85d0(%eax)
                MacCommandsBuffer[MacCommandsBufferIndex++] = p2;
40036292:	8d 43 03             	lea    0x3(%ebx),%eax
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
40036295:	83 c3 02             	add    $0x2,%ebx
                MacCommandsBuffer[MacCommandsBufferIndex++] = p2;
40036298:	a2 40 7a 00 a8       	mov    %al,0xa8007a40
4003629d:	0f b6 db             	movzbl %bl,%ebx
400362a0:	88 8b 30 7a 00 a8    	mov    %cl,-0x57ff85d0(%ebx)
400362a6:	eb 4e                	jmp    400362f6 <AddMacCommand+0x13a>
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_NEW_CHANNEL_ANS:
            if( MacCommandsBufferIndex < ( bufLen - 1 ) )
400362a8:	0f b6 d2             	movzbl %dl,%edx
400362ab:	0f b6 cb             	movzbl %bl,%ecx
400362ae:	4a                   	dec    %edx
400362af:	b8 01 00 00 00       	mov    $0x1,%eax
400362b4:	39 d1                	cmp    %edx,%ecx
400362b6:	7d 47                	jge    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
400362b8:	c6 81 30 7a 00 a8 07 	movb   $0x7,-0x57ff85d0(%ecx)
                // Status: Datarate range OK, Channel frequency OK
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
400362bf:	8d 43 02             	lea    0x2(%ebx),%eax
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
400362c2:	43                   	inc    %ebx
                MacCommandsBuffer[MacCommandsBufferIndex++] = p1;
400362c3:	0f b6 db             	movzbl %bl,%ebx
400362c6:	a2 40 7a 00 a8       	mov    %al,0xa8007a40
400362cb:	89 f0                	mov    %esi,%eax
400362cd:	88 83 30 7a 00 a8    	mov    %al,-0x57ff85d0(%ebx)
400362d3:	eb 21                	jmp    400362f6 <AddMacCommand+0x13a>
400362d5:	b8 01 00 00 00       	mov    $0x1,%eax
                status = LORAMAC_STATUS_OK;
            }
            break;
        case MOTE_MAC_RX_TIMING_SETUP_ANS:
            if( MacCommandsBufferIndex < bufLen )
400362da:	38 da                	cmp    %bl,%dl
400362dc:	76 21                	jbe    400362ff <AddMacCommand+0x143>
            {
                MacCommandsBuffer[MacCommandsBufferIndex++] = cmd;
400362de:	8d 43 01             	lea    0x1(%ebx),%eax
400362e1:	c6 83 30 7a 00 a8 08 	movb   $0x8,-0x57ff85d0(%ebx)
400362e8:	a2 40 7a 00 a8       	mov    %al,0xa8007a40
400362ed:	eb 07                	jmp    400362f6 <AddMacCommand+0x13a>
                // No payload for this answer
                status = LORAMAC_STATUS_OK;
            }
            break;
        default:
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
400362ef:	b8 02 00 00 00       	mov    $0x2,%eax
400362f4:	eb 09                	jmp    400362ff <AddMacCommand+0x143>
    }
    if( status == LORAMAC_STATUS_OK )
    {
        MacCommandsInNextTx = true;
400362f6:	c6 05 41 7a 00 a8 01 	movb   $0x1,0xa8007a41
400362fd:	31 c0                	xor    %eax,%eax
    }
    return status;
}
400362ff:	5b                   	pop    %ebx
40036300:	5e                   	pop    %esi
40036301:	5f                   	pop    %edi
40036302:	5d                   	pop    %ebp
40036303:	c3                   	ret    

40036304 <AdrNextDr>:
{
40036304:	55                   	push   %ebp
    if( adrEnabled == true )
40036305:	84 c0                	test   %al,%al
{
40036307:	89 e5                	mov    %esp,%ebp
40036309:	57                   	push   %edi
4003630a:	89 cf                	mov    %ecx,%edi
4003630c:	56                   	push   %esi
4003630d:	89 d6                	mov    %edx,%esi
4003630f:	53                   	push   %ebx
40036310:	88 c2                	mov    %al,%dl
    int8_t datarate = LoRaMacParams.ChannelsDatarate;
40036312:	8a 1d a1 84 00 a8    	mov    0xa80084a1,%bl
    if( adrEnabled == true )
40036318:	74 5b                	je     40036375 <AdrNextDr+0x71>
        if( datarate == LORAMAC_TX_MIN_DATARATE )
4003631a:	84 db                	test   %bl,%bl
4003631c:	75 0c                	jne    4003632a <AdrNextDr+0x26>
            AdrAckCounter = 0;
4003631e:	c7 05 44 7a 00 a8 00 	movl   $0x0,0xa8007a44
40036325:	00 00 00 
40036328:	eb 45                	jmp    4003636f <AdrNextDr+0x6b>
            if( AdrAckCounter >= ADR_ACK_LIMIT )
4003632a:	a1 44 7a 00 a8       	mov    0xa8007a44,%eax
4003632f:	83 f8 3f             	cmp    $0x3f,%eax
40036332:	76 3b                	jbe    4003636f <AdrNextDr+0x6b>
                LoRaMacParams.ChannelsTxPower = LORAMAC_MAX_TX_POWER;
40036334:	c6 05 a0 84 00 a8 00 	movb   $0x0,0xa80084a0
            if( AdrAckCounter >= ( ADR_ACK_LIMIT + ADR_ACK_DELAY ) )
4003633b:	83 f8 5f             	cmp    $0x5f,%eax
4003633e:	76 35                	jbe    40036375 <AdrNextDr+0x71>
                if( ( AdrAckCounter % ADR_ACK_DELAY ) == 0 )
40036340:	a8 1f                	test   $0x1f,%al
40036342:	75 31                	jne    40036375 <AdrNextDr+0x71>
                    if( ( datarate > LORAMAC_TX_MIN_DATARATE ) && ( datarate == DR_8 ) )
40036344:	80 fb 08             	cmp    $0x8,%bl
40036347:	74 2a                	je     40036373 <AdrNextDr+0x6f>
                    else if( datarate > LORAMAC_TX_MIN_DATARATE )
40036349:	84 db                	test   %bl,%bl
4003634b:	7e 28                	jle    40036375 <AdrNextDr+0x71>
                    if( datarate == LORAMAC_TX_MIN_DATARATE )
4003634d:	fe cb                	dec    %bl
4003634f:	75 24                	jne    40036375 <AdrNextDr+0x71>
                        if( updateChannelMask == true )
40036351:	89 f0                	mov    %esi,%eax
40036353:	84 c0                	test   %al,%al
40036355:	74 1e                	je     40036375 <AdrNextDr+0x71>
                            memcpy( ( uint8_t* )LoRaMacParams.ChannelsMask, ( uint8_t* )LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
40036357:	ba 44 84 00 a8       	mov    $0xa8008444,%edx
4003635c:	b9 0c 00 00 00       	mov    $0xc,%ecx
40036361:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
40036366:	e8 ff 9c ff ff       	call   4003006a <memcpy>
                adrAckReq = true;
4003636b:	89 f2                	mov    %esi,%edx
4003636d:	eb 06                	jmp    40036375 <AdrNextDr+0x71>
                adrAckReq = false;
4003636f:	31 d2                	xor    %edx,%edx
40036371:	eb 02                	jmp    40036375 <AdrNextDr+0x71>
                        datarate = DR_4;
40036373:	b3 04                	mov    $0x4,%bl
    *datarateOut = datarate;
40036375:	88 1f                	mov    %bl,(%edi)
}
40036377:	88 d0                	mov    %dl,%al
40036379:	5b                   	pop    %ebx
4003637a:	5e                   	pop    %esi
4003637b:	5f                   	pop    %edi
4003637c:	5d                   	pop    %ebp
4003637d:	c3                   	ret    

4003637e <OnAckTimeoutTimerEvent>:
{
4003637e:	55                   	push   %ebp
    k_timer_stop(&AckTimeoutTimer);
4003637f:	b8 e0 84 00 a8       	mov    $0xa80084e0,%eax
{
40036384:	89 e5                	mov    %esp,%ebp
    k_timer_stop(&AckTimeoutTimer);
40036386:	e8 ee 43 00 00       	call   4003a779 <k_timer_stop>
    if( NodeAckRequested == true )
4003638b:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
40036392:	74 0e                	je     400363a2 <OnAckTimeoutTimerEvent+0x24>
        LoRaMacState &= ~LORAMAC_ACK_REQ;
40036394:	83 25 ac 77 00 a8 fb 	andl   $0xfffffffb,0xa80077ac
        AckTimeoutRetry = true;
4003639b:	c6 05 7c 77 00 a8 01 	movb   $0x1,0xa800777c
    if( LoRaMacDeviceClass == CLASS_C )
400363a2:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
400363a9:	75 07                	jne    400363b2 <OnAckTimeoutTimerEvent+0x34>
        LoRaMacFlags.Bits.MacDone = 1;
400363ab:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
}
400363b2:	5d                   	pop    %ebp
400363b3:	c3                   	ret    

400363b4 <RxWindowSetup>:
{
400363b4:	55                   	push   %ebp
400363b5:	89 e5                	mov    %esp,%ebp
400363b7:	57                   	push   %edi
400363b8:	56                   	push   %esi
400363b9:	53                   	push   %ebx
400363ba:	83 ec 14             	sub    $0x14,%esp
400363bd:	89 55 ec             	mov    %edx,-0x14(%ebp)
    uint8_t downlinkDatarate = Datarates[datarate];
400363c0:	0f be 7d ec          	movsbl -0x14(%ebp),%edi
{
400363c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400363c7:	8b 45 0c             	mov    0xc(%ebp),%eax
400363ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t downlinkDatarate = Datarates[datarate];
400363cd:	8a 87 b4 cc 03 40    	mov    0x4003ccb4(%edi),%al
400363d3:	88 45 eb             	mov    %al,-0x15(%ebp)
    if(sx1276_get_status(dev) == STATE_IDLE) {
400363d6:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
{
400363db:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400363de:	8b 75 08             	mov    0x8(%ebp),%esi
400363e1:	8a 5d f0             	mov    -0x10(%ebp),%bl
    if(sx1276_get_status(dev) == STATE_IDLE) {
400363e4:	e8 c9 f9 ff ff       	call   40035db2 <sx1276_get_status>
400363e9:	85 c0                	test   %eax,%eax
400363eb:	0f 85 98 00 00 00    	jne    40036489 <RxWindowSetup+0xd5>
        sx1276_set_channel(dev, freq);
400363f1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400363f4:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
400363f9:	e8 89 e3 ff ff       	call   40034787 <sx1276_set_channel>
        McpsIndication.RxDatarate = ( uint8_t ) datarate;
400363fe:	8a 45 ec             	mov    -0x14(%ebp),%al
40036401:	a2 62 77 00 a8       	mov    %al,0xa8007762
        sx1276_set_rx_config(dev, modem, bandwidth, downlinkDatarate, 1, 0, 8, timeout, false, 0, false, 0, 0, true, rxContinuous);
40036406:	31 d2                	xor    %edx,%edx
40036408:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
4003640c:	50                   	push   %eax
4003640d:	6a 01                	push   $0x1
4003640f:	0f b7 c6             	movzwl %si,%eax
40036412:	6a 00                	push   $0x0
40036414:	6a 00                	push   $0x0
40036416:	6a 00                	push   $0x0
40036418:	6a 00                	push   $0x0
4003641a:	6a 00                	push   $0x0
4003641c:	50                   	push   %eax
4003641d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
40036421:	6a 08                	push   $0x8
40036423:	8b 4d e0             	mov    -0x20(%ebp),%ecx
40036426:	6a 00                	push   $0x0
40036428:	6a 01                	push   $0x1
4003642a:	50                   	push   %eax
4003642b:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036430:	e8 49 e9 ff ff       	call   40034d7e <sx1276_set_rx_config>
40036435:	83 c4 30             	add    $0x30,%esp
        if( RepeaterSupport == true )
40036438:	80 3d 7f 7d 00 a8 00 	cmpb   $0x0,0xa8007d7f
4003643f:	74 08                	je     40036449 <RxWindowSetup+0x95>
            sx1276_set_max_payload_length(dev, modem, MaxPayloadOfDatarateRepeater[datarate] + LORA_MAC_FRMPAYLOAD_OVERHEAD);
40036441:	8a 8f 80 cc 03 40    	mov    0x4003cc80(%edi),%cl
40036447:	eb 06                	jmp    4003644f <RxWindowSetup+0x9b>
            sx1276_set_max_payload_length(dev, modem, MaxPayloadOfDatarate[datarate] + LORA_MAC_FRMPAYLOAD_OVERHEAD);
40036449:	8a 8f 90 cc 03 40    	mov    0x4003cc90(%edi),%cl
4003644f:	83 c1 0d             	add    $0xd,%ecx
40036452:	31 d2                	xor    %edx,%edx
40036454:	0f b6 c9             	movzbl %cl,%ecx
40036457:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
4003645c:	e8 f5 f8 ff ff       	call   40035d56 <sx1276_set_max_payload_length>
        if( rxContinuous == false )
40036461:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
40036465:	75 14                	jne    4003647b <RxWindowSetup+0xc7>
            sx1276_set_rx(dev, LoRaMacParams.MaxRxWindow);
40036467:	8b 15 a4 84 00 a8    	mov    0xa80084a4,%edx
4003646d:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036472:	e8 21 ec ff ff       	call   40035098 <sx1276_set_rx>
        return true;
40036477:	b3 01                	mov    $0x1,%bl
40036479:	eb 10                	jmp    4003648b <RxWindowSetup+0xd7>
            sx1276_set_rx(dev, 0);
4003647b:	31 d2                	xor    %edx,%edx
4003647d:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036482:	e8 11 ec ff ff       	call   40035098 <sx1276_set_rx>
40036487:	eb 02                	jmp    4003648b <RxWindowSetup+0xd7>
    return false;
40036489:	31 db                	xor    %ebx,%ebx
}
4003648b:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003648e:	88 d8                	mov    %bl,%al
40036490:	5b                   	pop    %ebx
40036491:	5e                   	pop    %esi
40036492:	5f                   	pop    %edi
40036493:	5d                   	pop    %ebp
40036494:	c3                   	ret    

40036495 <OnRxWindow2TimerEvent>:
{
40036495:	55                   	push   %ebp
    k_timer_stop(&RxWindowTimer2);
40036496:	b8 00 82 00 a8       	mov    $0xa8008200,%eax
{
4003649b:	89 e5                	mov    %esp,%ebp
4003649d:	53                   	push   %ebx
    k_timer_stop(&RxWindowTimer2);
4003649e:	e8 d6 42 00 00       	call   4003a779 <k_timer_stop>
400364a3:	b8 05 00 00 00       	mov    $0x5,%eax
    switch( LoRaMacParams.Rx2Channel.Datarate )
400364a8:	0f be 15 c0 84 00 a8 	movsbl 0xa80084c0,%edx
400364af:	8d 4a ff             	lea    -0x1(%edx),%ecx
400364b2:	80 f9 0c             	cmp    $0xc,%cl
400364b5:	77 0a                	ja     400364c1 <OnRxWindow2TimerEvent+0x2c>
400364b7:	0f b6 c9             	movzbl %cl,%ecx
400364ba:	0f b6 81 64 cc 03 40 	movzbl 0x4003cc64(%ecx),%eax
        bandwidth  = 2;
400364c1:	31 c9                	xor    %ecx,%ecx
400364c3:	80 fa 04             	cmp    $0x4,%dl
400364c6:	0f 93 c1             	setae  %cl
    if( LoRaMacDeviceClass == CLASS_C )
400364c9:	31 db                	xor    %ebx,%ebx
        bandwidth  = 2;
400364cb:	01 c9                	add    %ecx,%ecx
    if( LoRaMacDeviceClass == CLASS_C )
400364cd:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
400364d4:	0f 94 c3             	sete   %bl
    if( RxWindowSetup( LoRaMacParams.Rx2Channel.Frequency, LoRaMacParams.Rx2Channel.Datarate, bandwidth, symbTimeout, rxContinuousMode ) == true )
400364d7:	53                   	push   %ebx
400364d8:	50                   	push   %eax
400364d9:	a1 bc 84 00 a8       	mov    0xa80084bc,%eax
400364de:	e8 d1 fe ff ff       	call   400363b4 <RxWindowSetup>
400364e3:	5a                   	pop    %edx
400364e4:	84 c0                	test   %al,%al
400364e6:	59                   	pop    %ecx
400364e7:	74 07                	je     400364f0 <OnRxWindow2TimerEvent+0x5b>
        RxSlot = 1;
400364e9:	c6 05 2c 77 00 a8 01 	movb   $0x1,0xa800772c
}
400364f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400364f3:	c9                   	leave  
400364f4:	c3                   	ret    

400364f5 <OnRadioTxTimeout>:
{
400364f5:	55                   	push   %ebp
400364f6:	89 e5                	mov    %esp,%ebp
    if(LoRaMacDeviceClass != CLASS_C) {
400364f8:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
400364ff:	74 0c                	je     4003650d <OnRadioTxTimeout+0x18>
        sx1276_set_sleep(dev);
40036501:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036506:	e8 2f f8 ff ff       	call   40035d3a <sx1276_set_sleep>
4003650b:	eb 05                	jmp    40036512 <OnRadioTxTimeout+0x1d>
        OnRxWindow2TimerEvent( );
4003650d:	e8 83 ff ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
40036512:	c7 05 44 77 00 a8 02 	movl   $0x2,0xa8007744
40036519:	00 00 00 
    MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
4003651c:	c7 05 34 77 00 a8 02 	movl   $0x2,0xa8007734
40036523:	00 00 00 
    LoRaMacFlags.Bits.MacDone = 1;
40036526:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
}
4003652d:	5d                   	pop    %ebp
4003652e:	c3                   	ret    

4003652f <PrepareRxDoneAbort>:
{
4003652f:	55                   	push   %ebp
    LoRaMacState |= LORAMAC_RX_ABORT;
40036530:	83 0d ac 77 00 a8 40 	orl    $0x40,0xa80077ac
{
40036537:	89 e5                	mov    %esp,%ebp
    if(NodeAckRequested)
40036539:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
40036540:	74 05                	je     40036547 <PrepareRxDoneAbort+0x18>
        OnAckTimeoutTimerEvent();
40036542:	e8 37 fe ff ff       	call   4003637e <OnAckTimeoutTimerEvent>
    if((RxSlot == 0) && (LoRaMacDeviceClass == CLASS_C))
40036547:	80 3d 2c 77 00 a8 00 	cmpb   $0x0,0xa800772c
4003654e:	75 0e                	jne    4003655e <PrepareRxDoneAbort+0x2f>
40036550:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
40036557:	75 05                	jne    4003655e <PrepareRxDoneAbort+0x2f>
        OnRxWindow2TimerEvent();
40036559:	e8 37 ff ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    LoRaMacFlags.Bits.MacDone = 1;
4003655e:	80 0d 14 84 00 a8 0a 	orb    $0xa,0xa8008414
    k_timer_start(&MacStateCheckTimer, 1, 0);
40036565:	31 c9                	xor    %ecx,%ecx
40036567:	ba 01 00 00 00       	mov    $0x1,%edx
4003656c:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
}
40036571:	5d                   	pop    %ebp
    k_timer_start(&MacStateCheckTimer, 1, 0);
40036572:	e9 a3 41 00 00       	jmp    4003a71a <k_timer_start>

40036577 <OnRxWindow1TimerEvent>:
{
40036577:	55                   	push   %ebp
    k_timer_stop(&RxWindowTimer1);
40036578:	b8 e0 83 00 a8       	mov    $0xa80083e0,%eax
{
4003657d:	89 e5                	mov    %esp,%ebp
4003657f:	53                   	push   %ebx
    k_timer_stop(&RxWindowTimer1);
40036580:	e8 f4 41 00 00       	call   4003a779 <k_timer_stop>
    RxSlot = 0;
40036585:	c6 05 2c 77 00 a8 00 	movb   $0x0,0xa800772c
    if( LoRaMacDeviceClass == CLASS_C )
4003658c:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
40036593:	75 0a                	jne    4003659f <OnRxWindow1TimerEvent+0x28>
        sx1276_set_standby(dev);
40036595:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
4003659a:	e8 c7 fb ff ff       	call   40036166 <sx1276_set_standby>
    datarate = datarateOffsets[LoRaMacParams.ChannelsDatarate][LoRaMacParams.Rx1DrOffset];
4003659f:	0f be 15 a1 84 00 a8 	movsbl 0xa80084a1,%edx
400365a6:	0f b6 05 b9 84 00 a8 	movzbl 0xa80084b9,%eax
400365ad:	8a 84 90 a0 cc 03 40 	mov    0x4003cca0(%eax,%edx,4),%al
400365b4:	84 c0                	test   %al,%al
400365b6:	79 02                	jns    400365ba <OnRxWindow1TimerEvent+0x43>
400365b8:	31 c0                	xor    %eax,%eax
400365ba:	8d 48 ff             	lea    -0x1(%eax),%ecx
    switch( datarate )
400365bd:	bb 05 00 00 00       	mov    $0x5,%ebx
400365c2:	0f be d0             	movsbl %al,%edx
400365c5:	80 f9 0c             	cmp    $0xc,%cl
400365c8:	77 0a                	ja     400365d4 <OnRxWindow1TimerEvent+0x5d>
400365ca:	0f b6 c9             	movzbl %cl,%ecx
400365cd:	0f b6 99 64 cc 03 40 	movzbl 0x4003cc64(%ecx),%ebx
        bandwidth  = 2;
400365d4:	31 c9                	xor    %ecx,%ecx
400365d6:	3c 04                	cmp    $0x4,%al
    RxWindowSetup( LORAMAC_FIRST_RX1_CHANNEL + ( Channel % 8 ) * LORAMAC_STEPWIDTH_RX1_CHANNEL, datarate, bandwidth, symbTimeout, false );
400365d8:	a0 b8 77 00 a8       	mov    0xa80077b8,%al
400365dd:	6a 00                	push   $0x0
        bandwidth  = 2;
400365df:	0f 9d c1             	setge  %cl
    RxWindowSetup( LORAMAC_FIRST_RX1_CHANNEL + ( Channel % 8 ) * LORAMAC_STEPWIDTH_RX1_CHANNEL, datarate, bandwidth, symbTimeout, false );
400365e2:	83 e0 07             	and    $0x7,%eax
        bandwidth  = 2;
400365e5:	01 c9                	add    %ecx,%ecx
    RxWindowSetup( LORAMAC_FIRST_RX1_CHANNEL + ( Channel % 8 ) * LORAMAC_STEPWIDTH_RX1_CHANNEL, datarate, bandwidth, symbTimeout, false );
400365e7:	69 c0 c0 27 09 00    	imul   $0x927c0,%eax,%eax
400365ed:	05 a0 70 08 37       	add    $0x370870a0,%eax
400365f2:	53                   	push   %ebx
400365f3:	e8 bc fd ff ff       	call   400363b4 <RxWindowSetup>
400365f8:	58                   	pop    %eax
}
400365f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    RxWindowSetup( LORAMAC_FIRST_RX1_CHANNEL + ( Channel % 8 ) * LORAMAC_STEPWIDTH_RX1_CHANNEL, datarate, bandwidth, symbTimeout, false );
400365fc:	5a                   	pop    %edx
}
400365fd:	c9                   	leave  
400365fe:	c3                   	ret    

400365ff <ResetMacParameters>:
    MacCommandsBufferIndex = 0;
    MacCommandsBufferToRepeatIndex = 0;

    IsRxWindowsEnabled = true;

    LoRaMacParams.ChannelsTxPower = LoRaMacParamsDefaults.ChannelsTxPower;
400365ff:	a0 20 84 00 a8       	mov    0xa8008420,%al
{
40036604:	55                   	push   %ebp
    LoRaMacParams.ChannelsTxPower = LoRaMacParamsDefaults.ChannelsTxPower;
40036605:	a2 a0 84 00 a8       	mov    %al,0xa80084a0
    LoRaMacParams.ChannelsDatarate = LoRaMacParamsDefaults.ChannelsDatarate;
4003660a:	a0 21 84 00 a8       	mov    0xa8008421,%al
4003660f:	a2 a1 84 00 a8       	mov    %al,0xa80084a1

    LoRaMacParams.MaxRxWindow = LoRaMacParamsDefaults.MaxRxWindow;
40036614:	a1 24 84 00 a8       	mov    0xa8008424,%eax
40036619:	a3 a4 84 00 a8       	mov    %eax,0xa80084a4
    LoRaMacParams.ReceiveDelay1 = LoRaMacParamsDefaults.ReceiveDelay1;
4003661e:	a1 28 84 00 a8       	mov    0xa8008428,%eax
40036623:	a3 a8 84 00 a8       	mov    %eax,0xa80084a8
    LoRaMacParams.ReceiveDelay2 = LoRaMacParamsDefaults.ReceiveDelay2;
40036628:	a1 2c 84 00 a8       	mov    0xa800842c,%eax
4003662d:	a3 ac 84 00 a8       	mov    %eax,0xa80084ac
    LoRaMacParams.JoinAcceptDelay1 = LoRaMacParamsDefaults.JoinAcceptDelay1;
40036632:	a1 30 84 00 a8       	mov    0xa8008430,%eax
40036637:	a3 b0 84 00 a8       	mov    %eax,0xa80084b0
    LoRaMacParams.JoinAcceptDelay2 = LoRaMacParamsDefaults.JoinAcceptDelay2;
4003663c:	a1 34 84 00 a8       	mov    0xa8008434,%eax
40036641:	a3 b4 84 00 a8       	mov    %eax,0xa80084b4

    LoRaMacParams.Rx1DrOffset = LoRaMacParamsDefaults.Rx1DrOffset;
40036646:	a0 39 84 00 a8       	mov    0xa8008439,%al
4003664b:	a2 b9 84 00 a8       	mov    %al,0xa80084b9
    LoRaMacParams.ChannelsNbRep = LoRaMacParamsDefaults.ChannelsNbRep;
40036650:	a0 38 84 00 a8       	mov    0xa8008438,%al
    IsLoRaMacNetworkJoined = false;
40036655:	c6 05 49 7a 00 a8 00 	movb   $0x0,0xa8007a49
    UpLinkCounter = 0;
4003665c:	c7 05 50 7a 00 a8 00 	movl   $0x0,0xa8007a50
40036663:	00 00 00 
    DownLinkCounter = 0;
40036666:	c7 05 4c 7a 00 a8 00 	movl   $0x0,0xa8007a4c
4003666d:	00 00 00 
    AdrAckCounter = 0;
40036670:	c7 05 44 7a 00 a8 00 	movl   $0x0,0xa8007a44
40036677:	00 00 00 
    ChannelsNbRepCounter = 0;
4003667a:	c6 05 c7 77 00 a8 00 	movb   $0x0,0xa80077c7
    AckTimeoutRetries = 1;
40036681:	c6 05 1e 67 00 a8 01 	movb   $0x1,0xa800671e
    AckTimeoutRetriesCounter = 1;
40036688:	c6 05 1d 67 00 a8 01 	movb   $0x1,0xa800671d
    AckTimeoutRetry = false;
4003668f:	c6 05 7c 77 00 a8 00 	movb   $0x0,0xa800777c
    MaxDCycle = 0;
40036696:	c6 05 c6 77 00 a8 00 	movb   $0x0,0xa80077c6
    AggregatedDCycle = 1;
4003669d:	66 c7 05 c4 77 00 a8 	movw   $0x1,0xa80077c4
400366a4:	01 00 
    MacCommandsBufferIndex = 0;
400366a6:	c6 05 40 7a 00 a8 00 	movb   $0x0,0xa8007a40
    MacCommandsBufferToRepeatIndex = 0;
400366ad:	c6 05 3f 7a 00 a8 00 	movb   $0x0,0xa8007a3f
    IsRxWindowsEnabled = true;
400366b4:	c6 05 2c 67 00 a8 01 	movb   $0x1,0xa800672c
    LoRaMacParams.ChannelsNbRep = LoRaMacParamsDefaults.ChannelsNbRep;
400366bb:	a2 b8 84 00 a8       	mov    %al,0xa80084b8

    LoRaMacParams.Rx2Channel = LoRaMacParamsDefaults.Rx2Channel;
400366c0:	a1 3c 84 00 a8       	mov    0xa800843c,%eax
400366c5:	8b 15 40 84 00 a8    	mov    0xa8008440,%edx
{
400366cb:	89 e5                	mov    %esp,%ebp
    LoRaMacParams.Rx2Channel = LoRaMacParamsDefaults.Rx2Channel;
400366cd:	a3 bc 84 00 a8       	mov    %eax,0xa80084bc
400366d2:	89 15 c0 84 00 a8    	mov    %edx,0xa80084c0

    memcpy( ( uint8_t* ) LoRaMacParams.ChannelsMask, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
400366d8:	b9 0c 00 00 00       	mov    $0xc,%ecx
400366dd:	ba 44 84 00 a8       	mov    $0xa8008444,%edx
400366e2:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
400366e7:	e8 7e 99 ff ff       	call   4003006a <memcpy>

#if defined( USE_BAND_915 ) || defined( USE_BAND_915_HYBRID )
    memcpy( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
400366ec:	b9 0c 00 00 00       	mov    $0xc,%ecx
400366f1:	ba 44 84 00 a8       	mov    $0xa8008444,%edx
400366f6:	b8 c8 77 00 a8       	mov    $0xa80077c8,%eax
400366fb:	e8 6a 99 ff ff       	call   4003006a <memcpy>
#endif


    NodeAckRequested = false;
40036700:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
    SrvAckRequested = false;
40036707:	c6 05 42 7a 00 a8 00 	movb   $0x0,0xa8007a42
    MacCommandsInNextTx = false;
4003670e:	c6 05 41 7a 00 a8 00 	movb   $0x0,0xa8007a41

    // Reset Multicast downlink counters
    MulticastParams_t *cur = MulticastChannels;
40036715:	a1 88 7d 00 a8       	mov    0xa8007d88,%eax
    while( cur != NULL )
4003671a:	85 c0                	test   %eax,%eax
4003671c:	74 0c                	je     4003672a <ResetMacParameters+0x12b>
    {
        cur->DownLinkCounter = 0;
4003671e:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
        cur = cur->Next;
40036725:	8b 40 28             	mov    0x28(%eax),%eax
40036728:	eb f0                	jmp    4003671a <ResetMacParameters+0x11b>
    }

    // Initialize channel index.
    Channel = LORA_MAX_NB_CHANNELS;
4003672a:	c6 05 b8 77 00 a8 48 	movb   $0x48,0xa80077b8
        *dst-- = *src++;
    }
}

uint32_t TimerGetCurrentTime(void) {
    return k_uptime_get_32();
40036731:	e8 75 39 00 00       	call   4003a0ab <k_uptime_get_32>
}
40036736:	5d                   	pop    %ebp
    LoRaMacInitializationTime = TimerGetCurrentTime( );
40036737:	a3 b4 77 00 a8       	mov    %eax,0xa80077b4
}
4003673c:	c3                   	ret    

4003673d <OnRadioTxDone>:
{
4003673d:	55                   	push   %ebp
4003673e:	89 e5                	mov    %esp,%ebp
40036740:	57                   	push   %edi
40036741:	56                   	push   %esi
40036742:	53                   	push   %ebx
40036743:	83 ec 08             	sub    $0x8,%esp
    return k_uptime_get_32();
40036746:	e8 60 39 00 00       	call   4003a0ab <k_uptime_get_32>
    if( LoRaMacDeviceClass != CLASS_C )
4003674b:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
    return k_uptime_get_32();
40036752:	89 c6                	mov    %eax,%esi
    if( LoRaMacDeviceClass != CLASS_C )
40036754:	74 0c                	je     40036762 <OnRadioTxDone+0x25>
        sx1276_set_sleep(dev);
40036756:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
4003675b:	e8 da f5 ff ff       	call   40035d3a <sx1276_set_sleep>
40036760:	eb 05                	jmp    40036767 <OnRadioTxDone+0x2a>
        OnRxWindow2TimerEvent();
40036762:	e8 2e fd ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    if( IsRxWindowsEnabled == true )
40036767:	80 3d 2c 67 00 a8 00 	cmpb   $0x0,0xa800672c
4003676e:	74 69                	je     400367d9 <OnRadioTxDone+0x9c>
        k_timer_start(&RxWindowTimer1, RxWindow1Delay, 0);
40036770:	31 c9                	xor    %ecx,%ecx
40036772:	8b 15 84 77 00 a8    	mov    0xa8007784,%edx
40036778:	b8 e0 83 00 a8       	mov    $0xa80083e0,%eax
4003677d:	e8 98 3f 00 00       	call   4003a71a <k_timer_start>
        if(LoRaMacDeviceClass != CLASS_C)
40036782:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
40036789:	74 12                	je     4003679d <OnRadioTxDone+0x60>
            k_timer_start(&RxWindowTimer2, RxWindow2Delay, 0);
4003678b:	31 c9                	xor    %ecx,%ecx
4003678d:	8b 15 80 77 00 a8    	mov    0xa8007780,%edx
40036793:	b8 00 82 00 a8       	mov    $0xa8008200,%eax
40036798:	e8 7d 3f 00 00       	call   4003a71a <k_timer_start>
        if((LoRaMacDeviceClass == CLASS_C) || (NodeAckRequested == true))
4003679d:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
400367a4:	74 09                	je     400367af <OnRadioTxDone+0x72>
400367a6:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
400367ad:	74 55                	je     40036804 <OnRadioTxDone+0xc7>
            k_timer_start(&AckTimeoutTimer, RxWindow2Delay + ACK_TIMEOUT + upm_rand_range(-ACK_TIMEOUT_RND, ACK_TIMEOUT_RND), 0);
400367af:	ba e8 03 00 00       	mov    $0x3e8,%edx
400367b4:	b8 18 fc ff ff       	mov    $0xfffffc18,%eax
400367b9:	e8 9e dd ff ff       	call   4003455c <upm_rand_range>
400367be:	8b 15 80 77 00 a8    	mov    0xa8007780,%edx
400367c4:	31 c9                	xor    %ecx,%ecx
400367c6:	8d 94 10 d0 07 00 00 	lea    0x7d0(%eax,%edx,1),%edx
400367cd:	b8 e0 84 00 a8       	mov    $0xa80084e0,%eax
400367d2:	e8 43 3f 00 00       	call   4003a71a <k_timer_start>
400367d7:	eb 2b                	jmp    40036804 <OnRadioTxDone+0xc7>
        McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
400367d9:	c7 05 44 77 00 a8 00 	movl   $0x0,0xa8007744
400367e0:	00 00 00 
        MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;
400367e3:	c7 05 34 77 00 a8 03 	movl   $0x3,0xa8007734
400367ea:	00 00 00 
        if(LoRaMacFlags.Value == 0) {
400367ed:	80 3d 14 84 00 a8 00 	cmpb   $0x0,0xa8008414
400367f4:	75 07                	jne    400367fd <OnRadioTxDone+0xc0>
            LoRaMacFlags.Bits.McpsReq = 1;
400367f6:	c6 05 14 84 00 a8 01 	movb   $0x1,0xa8008414
        LoRaMacFlags.Bits.MacDone = 1;
400367fd:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
    Bands[Channels[Channel].Band].LastTxDoneTime = curTime;
40036804:	0f b6 1d b8 77 00 a8 	movzbl 0xa80077b8,%ebx
    AggregatedLastTxDoneTime = curTime;
4003680b:	89 35 c0 77 00 a8    	mov    %esi,0xa80077c0
    Bands[Channels[Channel].Band].LastTxDoneTime = curTime;
40036811:	0f b6 04 dd e5 77 00 	movzbl -0x57ff881b(,%ebx,8),%eax
40036818:	a8 
40036819:	6b c0 0c             	imul   $0xc,%eax,%eax
    if( IsLoRaMacNetworkJoined == false )
4003681c:	80 3d 49 7a 00 a8 00 	cmpb   $0x0,0xa8007a49
    Bands[Channels[Channel].Band].LastTxDoneTime = curTime;
40036823:	8d 90 20 67 00 a8    	lea    -0x57ff98e0(%eax),%edx
    uint16_t dutyCycle = Bands[Channels[channel].Band].DCycle;
40036829:	8b 80 20 67 00 a8    	mov    -0x57ff98e0(%eax),%eax
4003682f:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
    Bands[Channels[Channel].Band].LastTxDoneTime = curTime;
40036833:	89 72 04             	mov    %esi,0x4(%edx)
    Bands[Channels[channel].Band].TimeOff = 0;
40036836:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    if( IsLoRaMacNetworkJoined == false )
4003683d:	75 7a                	jne    400368b9 <OnRadioTxDone+0x17c>
4003683f:	a1 b4 77 00 a8       	mov    0xa80077b4,%eax
40036844:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

uint32_t TimerGetElapsedTime(uint32_t ref_time) {
    return k_uptime_delta_32(&ref_time);
40036847:	8d 45 f0             	lea    -0x10(%ebp),%eax
4003684a:	e8 c0 38 00 00       	call   4003a10f <k_uptime_delta_32>
    if( timeElapsed < 3600e3 )
4003684f:	e8 ad ae ff ff       	call   40031701 <__floatunsidf>
40036854:	68 40 77 4b 41       	push   $0x414b7740
40036859:	89 d7                	mov    %edx,%edi
4003685b:	6a 00                	push   $0x0
4003685d:	89 c6                	mov    %eax,%esi
4003685f:	e8 db a7 ff ff       	call   4003103f <__ledf2>
40036864:	5a                   	pop    %edx
40036865:	85 c0                	test   %eax,%eax
40036867:	59                   	pop    %ecx
        dutyCycle = BACKOFF_DC_1_HOUR;
40036868:	ba 64 00 00 00       	mov    $0x64,%edx
    if( timeElapsed < 3600e3 )
4003686d:	78 20                	js     4003688f <OnRadioTxDone+0x152>
    else if( timeElapsed < ( 3600e3 + 36000e3 ) )
4003686f:	89 fa                	mov    %edi,%edx
40036871:	89 f0                	mov    %esi,%eax
40036873:	68 fc e1 82 41       	push   $0x4182e1fc
40036878:	6a 00                	push   $0x0
4003687a:	e8 c0 a7 ff ff       	call   4003103f <__ledf2>
4003687f:	5a                   	pop    %edx
40036880:	85 c0                	test   %eax,%eax
40036882:	59                   	pop    %ecx
        dutyCycle = BACKOFF_DC_10_HOURS;
40036883:	ba e8 03 00 00       	mov    $0x3e8,%edx
    else if( timeElapsed < ( 3600e3 + 36000e3 ) )
40036888:	78 05                	js     4003688f <OnRadioTxDone+0x152>
        dutyCycle = BACKOFF_DC_24_HOURS;
4003688a:	ba 10 27 00 00       	mov    $0x2710,%edx
        Bands[Channels[channel].Band].TimeOff = TxTimeOnAir * dutyCycle - TxTimeOnAir;
4003688f:	0f b6 0c dd e5 77 00 	movzbl -0x57ff881b(,%ebx,8),%ecx
40036896:	a8 
40036897:	6b c9 0c             	imul   $0xc,%ecx,%ecx
        dutyCycle = UPM_MAX( dutyCycle, joinDutyCycle );
4003689a:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
        Bands[Channels[channel].Band].TimeOff = TxTimeOnAir * dutyCycle - TxTimeOnAir;
4003689e:	81 c1 20 67 00 a8    	add    $0xa8006720,%ecx
        dutyCycle = UPM_MAX( dutyCycle, joinDutyCycle );
400368a4:	66 39 d0             	cmp    %dx,%ax
400368a7:	73 03                	jae    400368ac <OnRadioTxDone+0x16f>
400368a9:	0f b7 c2             	movzwl %dx,%eax
        Bands[Channels[channel].Band].TimeOff = TxTimeOnAir * dutyCycle - TxTimeOnAir;
400368ac:	48                   	dec    %eax
400368ad:	0f af 05 78 77 00 a8 	imul   0xa8007778,%eax
400368b4:	89 41 08             	mov    %eax,0x8(%ecx)
400368b7:	eb 18                	jmp    400368d1 <OnRadioTxDone+0x194>
        if( DutyCycleOn == true )
400368b9:	80 3d b9 77 00 a8 00 	cmpb   $0x0,0xa80077b9
400368c0:	74 0f                	je     400368d1 <OnRadioTxDone+0x194>
            Bands[Channels[channel].Band].TimeOff = TxTimeOnAir * dutyCycle - TxTimeOnAir;
400368c2:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
400368c6:	48                   	dec    %eax
400368c7:	0f af 05 78 77 00 a8 	imul   0xa8007778,%eax
400368ce:	89 42 08             	mov    %eax,0x8(%edx)
    AggregatedTimeOff = AggregatedTimeOff + ( TxTimeOnAir * AggregatedDCycle - TxTimeOnAir );
400368d1:	0f b7 05 c4 77 00 a8 	movzwl 0xa80077c4,%eax
400368d8:	48                   	dec    %eax
400368d9:	0f af 05 78 77 00 a8 	imul   0xa8007778,%eax
400368e0:	01 05 bc 77 00 a8    	add    %eax,0xa80077bc
    if(NodeAckRequested == false) {
400368e6:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
400368ed:	75 10                	jne    400368ff <OnRadioTxDone+0x1c2>
        ChannelsNbRepCounter++;
400368ef:	fe 05 c7 77 00 a8    	incb   0xa80077c7
        McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
400368f5:	c7 05 44 77 00 a8 00 	movl   $0x0,0xa8007744
400368fc:	00 00 00 
}
400368ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
40036902:	5b                   	pop    %ebx
40036903:	5e                   	pop    %esi
40036904:	5f                   	pop    %edi
40036905:	5d                   	pop    %ebp
40036906:	c3                   	ret    

40036907 <OnRadioRxTimeout>:
{
40036907:	55                   	push   %ebp
40036908:	89 e5                	mov    %esp,%ebp
    if( LoRaMacDeviceClass != CLASS_C )
4003690a:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
40036911:	74 0c                	je     4003691f <OnRadioRxTimeout+0x18>
        sx1276_set_sleep(dev);
40036913:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036918:	e8 1d f4 ff ff       	call   40035d3a <sx1276_set_sleep>
4003691d:	eb 05                	jmp    40036924 <OnRadioRxTimeout+0x1d>
        OnRxWindow2TimerEvent( );
4003691f:	e8 71 fb ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    if( RxSlot == 1 )
40036924:	80 3d 2c 77 00 a8 01 	cmpb   $0x1,0xa800772c
4003692b:	75 24                	jne    40036951 <OnRadioRxTimeout+0x4a>
        if( NodeAckRequested == true )
4003692d:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
40036934:	74 0a                	je     40036940 <OnRadioRxTimeout+0x39>
            McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;
40036936:	c7 05 44 77 00 a8 03 	movl   $0x3,0xa8007744
4003693d:	00 00 00 
        LoRaMacFlags.Bits.MacDone = 1;
40036940:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
        MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT;
40036947:	c7 05 34 77 00 a8 03 	movl   $0x3,0xa8007734
4003694e:	00 00 00 
}
40036951:	5d                   	pop    %ebp
40036952:	c3                   	ret    

40036953 <OnRadioRxError>:
{
40036953:	55                   	push   %ebp
40036954:	89 e5                	mov    %esp,%ebp
    if( LoRaMacDeviceClass != CLASS_C )
40036956:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
4003695d:	74 0c                	je     4003696b <OnRadioRxError+0x18>
        sx1276_set_sleep(dev);
4003695f:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036964:	e8 d1 f3 ff ff       	call   40035d3a <sx1276_set_sleep>
40036969:	eb 05                	jmp    40036970 <OnRadioRxError+0x1d>
        OnRxWindow2TimerEvent( );
4003696b:	e8 25 fb ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    if( RxSlot == 1 )
40036970:	80 3d 2c 77 00 a8 01 	cmpb   $0x1,0xa800772c
40036977:	75 24                	jne    4003699d <OnRadioRxError+0x4a>
        if( NodeAckRequested == true )
40036979:	80 3d 43 7a 00 a8 00 	cmpb   $0x0,0xa8007a43
40036980:	74 0a                	je     4003698c <OnRadioRxError+0x39>
            McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;
40036982:	c7 05 44 77 00 a8 04 	movl   $0x4,0xa8007744
40036989:	00 00 00 
        LoRaMacFlags.Bits.MacDone = 1;
4003698c:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
        MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_RX2_ERROR;
40036993:	c7 05 34 77 00 a8 04 	movl   $0x4,0xa8007734
4003699a:	00 00 00 
}
4003699d:	5d                   	pop    %ebp
4003699e:	c3                   	ret    

4003699f <CountNbEnabled125kHzChannels>:
{
4003699f:	55                   	push   %ebp
400369a0:	31 d2                	xor    %edx,%edx
400369a2:	89 e5                	mov    %esp,%ebp
400369a4:	57                   	push   %edi
400369a5:	56                   	push   %esi
400369a6:	53                   	push   %ebx
400369a7:	83 ec 08             	sub    $0x8,%esp
    uint8_t nb125kHzChannels = 0;
400369aa:	31 db                	xor    %ebx,%ebx
{
400369ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
        nb125kHzChannels += CountBits( channelsMask[k], 16 );
400369af:	8b 45 ec             	mov    -0x14(%ebp),%eax
400369b2:	31 c9                	xor    %ecx,%ecx
    uint8_t nbActiveBits = 0;
400369b4:	31 ff                	xor    %edi,%edi
        nb125kHzChannels += CountBits( channelsMask[k], 16 );
400369b6:	0f b7 04 10          	movzwl (%eax,%edx,1),%eax
400369ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
400369bd:	be 01 00 00 00       	mov    $0x1,%esi
400369c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
400369c5:	d3 e6                	shl    %cl,%esi
400369c7:	21 f0                	and    %esi,%eax
            nbActiveBits++;
400369c9:	39 c6                	cmp    %eax,%esi
400369cb:	0f 94 c0             	sete   %al
400369ce:	89 c6                	mov    %eax,%esi
400369d0:	41                   	inc    %ecx
400369d1:	01 f7                	add    %esi,%edi
    for( uint8_t j = 0; j < nbBits; j++ )
400369d3:	83 f9 10             	cmp    $0x10,%ecx
400369d6:	75 e5                	jne    400369bd <CountNbEnabled125kHzChannels+0x1e>
400369d8:	83 c2 02             	add    $0x2,%edx
        nb125kHzChannels += CountBits( channelsMask[k], 16 );
400369db:	01 fb                	add    %edi,%ebx
    for( uint8_t i = 0, k = 0; i < LORA_MAX_NB_CHANNELS - 8; i += 16, k++ )
400369dd:	83 fa 08             	cmp    $0x8,%edx
400369e0:	75 cd                	jne    400369af <CountNbEnabled125kHzChannels+0x10>
}
400369e2:	5a                   	pop    %edx
400369e3:	88 d8                	mov    %bl,%al
400369e5:	59                   	pop    %ecx
400369e6:	5b                   	pop    %ebx
400369e7:	5e                   	pop    %esi
400369e8:	5f                   	pop    %edi
400369e9:	5d                   	pop    %ebp
400369ea:	c3                   	ret    

400369eb <LimitTxPower>:
{
400369eb:	55                   	push   %ebp
400369ec:	89 e5                	mov    %esp,%ebp
400369ee:	56                   	push   %esi
400369ef:	53                   	push   %ebx
400369f0:	89 c3                	mov    %eax,%ebx
    if( ( LoRaMacParams.ChannelsDatarate == DR_4 ) ||
400369f2:	a0 a1 84 00 a8       	mov    0xa80084a1,%al
400369f7:	8d 48 f8             	lea    -0x8(%eax),%ecx
400369fa:	80 f9 05             	cmp    $0x5,%cl
400369fd:	76 04                	jbe    40036a03 <LimitTxPower+0x18>
400369ff:	3c 04                	cmp    $0x4,%al
40036a01:	75 0b                	jne    40036a0e <LimitTxPower+0x23>
        resultTxPower =  UPM_MAX( txPower, TX_POWER_26_DBM );
40036a03:	88 d8                	mov    %bl,%al
40036a05:	80 fb 02             	cmp    $0x2,%bl
40036a08:	7d 27                	jge    40036a31 <LimitTxPower+0x46>
40036a0a:	b0 02                	mov    $0x2,%al
40036a0c:	eb 23                	jmp    40036a31 <LimitTxPower+0x46>
        if( CountNbEnabled125kHzChannels( LoRaMacParams.ChannelsMask ) < 50 )
40036a0e:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
40036a13:	89 d6                	mov    %edx,%esi
40036a15:	e8 85 ff ff ff       	call   4003699f <CountNbEnabled125kHzChannels>
40036a1a:	3c 31                	cmp    $0x31,%al
            resultTxPower = UPM_MAX( txPower, TX_POWER_20_DBM );
40036a1c:	88 d8                	mov    %bl,%al
        if( CountNbEnabled125kHzChannels( LoRaMacParams.ChannelsMask ) < 50 )
40036a1e:	76 0a                	jbe    40036a2a <LimitTxPower+0x3f>
    resultTxPower =  UPM_MAX( txPower, maxBandTxPower );
40036a20:	89 f1                	mov    %esi,%ecx
40036a22:	38 cb                	cmp    %cl,%bl
40036a24:	7d 0b                	jge    40036a31 <LimitTxPower+0x46>
40036a26:	89 f0                	mov    %esi,%eax
40036a28:	eb 07                	jmp    40036a31 <LimitTxPower+0x46>
            resultTxPower = UPM_MAX( txPower, TX_POWER_20_DBM );
40036a2a:	80 fb 05             	cmp    $0x5,%bl
40036a2d:	7d 02                	jge    40036a31 <LimitTxPower+0x46>
40036a2f:	b0 05                	mov    $0x5,%al
}
40036a31:	5b                   	pop    %ebx
40036a32:	5e                   	pop    %esi
40036a33:	5d                   	pop    %ebp
40036a34:	c3                   	ret    

40036a35 <ProcessMacCommands>:
{
40036a35:	55                   	push   %ebp
40036a36:	89 e5                	mov    %esp,%ebp
40036a38:	57                   	push   %edi
40036a39:	56                   	push   %esi
40036a3a:	53                   	push   %ebx
40036a3b:	83 ec 1c             	sub    $0x1c,%esp
40036a3e:	89 c6                	mov    %eax,%esi
                    AddMacCommand( MOTE_MAC_DEV_STATUS_ANS, batteryLevel, snr );
40036a40:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
{
40036a44:	88 d3                	mov    %dl,%bl
40036a46:	88 4d e2             	mov    %cl,-0x1e(%ebp)
                    AddMacCommand( MOTE_MAC_DEV_STATUS_ANS, batteryLevel, snr );
40036a49:	89 45 d8             	mov    %eax,-0x28(%ebp)
    while( macIndex < commandsSize )
40036a4c:	3a 5d e2             	cmp    -0x1e(%ebp),%bl
40036a4f:	0f 83 eb 03 00 00    	jae    40036e40 <ProcessMacCommands+0x40b>
        switch( payload[macIndex++] )
40036a55:	8d 43 01             	lea    0x1(%ebx),%eax
40036a58:	88 45 e7             	mov    %al,-0x19(%ebp)
40036a5b:	0f b6 c3             	movzbl %bl,%eax
40036a5e:	8a 04 06             	mov    (%esi,%eax,1),%al
40036a61:	83 e8 02             	sub    $0x2,%eax
40036a64:	3c 06                	cmp    $0x6,%al
40036a66:	0f 87 d4 03 00 00    	ja     40036e40 <ProcessMacCommands+0x40b>
40036a6c:	0f b6 c0             	movzbl %al,%eax
40036a6f:	ff 24 85 20 cb 03 40 	jmp    *0x4003cb20(,%eax,4)
                MlmeConfirm.DemodMargin = payload[macIndex++];
40036a76:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
                MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
40036a7a:	c7 05 34 77 00 a8 00 	movl   $0x0,0xa8007734
40036a81:	00 00 00 
                MlmeConfirm.DemodMargin = payload[macIndex++];
40036a84:	8a 04 06             	mov    (%esi,%eax,1),%al
40036a87:	a2 3c 77 00 a8       	mov    %al,0xa800773c
                MlmeConfirm.NbGateways = payload[macIndex++];
40036a8c:	8d 43 03             	lea    0x3(%ebx),%eax
                MlmeConfirm.DemodMargin = payload[macIndex++];
40036a8f:	83 c3 02             	add    $0x2,%ebx
                MlmeConfirm.NbGateways = payload[macIndex++];
40036a92:	88 45 e7             	mov    %al,-0x19(%ebp)
40036a95:	0f b6 db             	movzbl %bl,%ebx
40036a98:	8a 04 1e             	mov    (%esi,%ebx,1),%al
40036a9b:	a2 3d 77 00 a8       	mov    %al,0xa800773d
                break;
40036aa0:	e9 7b 03 00 00       	jmp    40036e20 <ProcessMacCommands+0x3eb>
                    uint16_t channelsMask[6] = { 0, 0, 0, 0, 0, 0 };
40036aa5:	8d 7d e8             	lea    -0x18(%ebp),%edi
40036aa8:	b9 03 00 00 00       	mov    $0x3,%ecx
40036aad:	31 c0                	xor    %eax,%eax
40036aaf:	f3 ab                	rep stos %eax,%es:(%edi)
                        channelsMask[i] = LoRaMacParams.ChannelsMask[i];
40036ab1:	66 8b 90 c4 84 00 a8 	mov    -0x57ff7b3c(%eax),%dx
40036ab8:	66 89 54 05 e8       	mov    %dx,-0x18(%ebp,%eax,1)
40036abd:	83 c0 02             	add    $0x2,%eax
                    for( i = 0; i < 6; i++ )
40036ac0:	83 f8 0c             	cmp    $0xc,%eax
40036ac3:	75 ec                	jne    40036ab1 <ProcessMacCommands+0x7c>
                    datarate = payload[macIndex++];
40036ac5:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
40036ac9:	8a 04 06             	mov    (%esi,%eax,1),%al
                    txPower = datarate & 0x0F;
40036acc:	88 c2                	mov    %al,%dl
                    datarate = ( datarate >> 4 ) & 0x0F;
40036ace:	c0 e8 04             	shr    $0x4,%al
                    txPower = datarate & 0x0F;
40036ad1:	83 e2 0f             	and    $0xf,%edx
40036ad4:	88 55 e5             	mov    %dl,-0x1b(%ebp)
                    datarate = ( datarate >> 4 ) & 0x0F;
40036ad7:	88 45 e6             	mov    %al,-0x1a(%ebp)
                    if( ( AdrCtrlOn == false ) &&
40036ada:	80 3d 48 7a 00 a8 00 	cmpb   $0x0,0xa8007a48
40036ae1:	75 29                	jne    40036b0c <ProcessMacCommands+0xd7>
40036ae3:	3a 05 a1 84 00 a8    	cmp    0xa80084a1,%al
40036ae9:	75 08                	jne    40036af3 <ProcessMacCommands+0xbe>
                        ( ( LoRaMacParams.ChannelsDatarate != datarate ) || ( LoRaMacParams.ChannelsTxPower != txPower ) ) )
40036aeb:	3a 15 a0 84 00 a8    	cmp    0xa80084a0,%dl
40036af1:	74 19                	je     40036b0c <ProcessMacCommands+0xd7>
                        AddMacCommand( MOTE_MAC_LINK_ADR_ANS, 0, 0 );
40036af3:	31 c9                	xor    %ecx,%ecx
40036af5:	31 d2                	xor    %edx,%edx
40036af7:	b8 03 00 00 00       	mov    $0x3,%eax
40036afc:	e8 bb f6 ff ff       	call   400361bc <AddMacCommand>
                        macIndex += 3;  // Skip over the remaining bytes of the request
40036b01:	8d 43 05             	lea    0x5(%ebx),%eax
40036b04:	88 45 e7             	mov    %al,-0x19(%ebp)
40036b07:	e9 14 03 00 00       	jmp    40036e20 <ProcessMacCommands+0x3eb>
                    chMask = ( uint16_t )payload[macIndex++];
40036b0c:	8d 43 03             	lea    0x3(%ebx),%eax
                    chMask |= ( uint16_t )payload[macIndex++] << 8;
40036b0f:	0f b6 c0             	movzbl %al,%eax
40036b12:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
40036b16:	c1 e1 08             	shl    $0x8,%ecx
                    datarate = payload[macIndex++];
40036b19:	8d 43 02             	lea    0x2(%ebx),%eax
                    chMask = ( uint16_t )payload[macIndex++];
40036b1c:	0f b6 c0             	movzbl %al,%eax
                    chMask |= ( uint16_t )payload[macIndex++] << 8;
40036b1f:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
40036b23:	09 c1                	or     %eax,%ecx
                    nbRep = payload[macIndex++];
40036b25:	8d 43 05             	lea    0x5(%ebx),%eax
                    chMask |= ( uint16_t )payload[macIndex++] << 8;
40036b28:	83 c3 04             	add    $0x4,%ebx
                    nbRep = payload[macIndex++];
40036b2b:	88 45 e7             	mov    %al,-0x19(%ebp)
40036b2e:	0f b6 db             	movzbl %bl,%ebx
40036b31:	8a 04 1e             	mov    (%esi,%ebx,1),%al
                    chMaskCntl = ( nbRep >> 4 ) & 0x07;
40036b34:	88 c3                	mov    %al,%bl
40036b36:	c0 eb 04             	shr    $0x4,%bl
40036b39:	83 e3 07             	and    $0x7,%ebx
                    if( nbRep == 0 )
40036b3c:	24 0f                	and    $0xf,%al
40036b3e:	88 45 e4             	mov    %al,-0x1c(%ebp)
40036b41:	75 04                	jne    40036b47 <ProcessMacCommands+0x112>
                        nbRep = 1;
40036b43:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
                    if( chMaskCntl == 6 )
40036b47:	80 fb 06             	cmp    $0x6,%bl
40036b4a:	75 20                	jne    40036b6c <ProcessMacCommands+0x137>
                        channelsMask[0] = 0xFFFF;
40036b4c:	66 c7 45 e8 ff ff    	movw   $0xffff,-0x18(%ebp)
                        channelsMask[1] = 0xFFFF;
40036b52:	66 c7 45 ea ff ff    	movw   $0xffff,-0x16(%ebp)
                        channelsMask[2] = 0xFFFF;
40036b58:	66 c7 45 ec ff ff    	movw   $0xffff,-0x14(%ebp)
                        channelsMask[3] = 0xFFFF;
40036b5e:	66 c7 45 ee ff ff    	movw   $0xffff,-0x12(%ebp)
                        channelsMask[4] = chMask;
40036b64:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
                    uint8_t status = 0x07;
40036b68:	b3 07                	mov    $0x7,%bl
40036b6a:	eb 46                	jmp    40036bb2 <ProcessMacCommands+0x17d>
                    else if( chMaskCntl == 7 )
40036b6c:	80 fb 07             	cmp    $0x7,%bl
40036b6f:	75 1e                	jne    40036b8f <ProcessMacCommands+0x15a>
                        channelsMask[0] = 0x0000;
40036b71:	66 c7 45 e8 00 00    	movw   $0x0,-0x18(%ebp)
                        channelsMask[1] = 0x0000;
40036b77:	66 c7 45 ea 00 00    	movw   $0x0,-0x16(%ebp)
                        channelsMask[2] = 0x0000;
40036b7d:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
                        channelsMask[3] = 0x0000;
40036b83:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
                        channelsMask[4] = chMask;
40036b89:	66 89 4d f0          	mov    %cx,-0x10(%ebp)
40036b8d:	eb 23                	jmp    40036bb2 <ProcessMacCommands+0x17d>
                    else if( chMaskCntl == 5 )
40036b8f:	80 fb 05             	cmp    $0x5,%bl
40036b92:	74 1c                	je     40036bb0 <ProcessMacCommands+0x17b>
                        channelsMask[chMaskCntl] = chMask;
40036b94:	0f b6 db             	movzbl %bl,%ebx
                        if( ( datarate < DR_4 ) && ( CountNbEnabled125kHzChannels( channelsMask ) < 2 ) )
40036b97:	80 7d e6 03          	cmpb   $0x3,-0x1a(%ebp)
                        channelsMask[chMaskCntl] = chMask;
40036b9b:	66 89 4c 5d e8       	mov    %cx,-0x18(%ebp,%ebx,2)
                    uint8_t status = 0x07;
40036ba0:	b3 07                	mov    $0x7,%bl
                        if( ( datarate < DR_4 ) && ( CountNbEnabled125kHzChannels( channelsMask ) < 2 ) )
40036ba2:	77 0e                	ja     40036bb2 <ProcessMacCommands+0x17d>
40036ba4:	8d 45 e8             	lea    -0x18(%ebp),%eax
40036ba7:	e8 f3 fd ff ff       	call   4003699f <CountNbEnabled125kHzChannels>
40036bac:	3c 01                	cmp    $0x1,%al
40036bae:	77 02                	ja     40036bb2 <ProcessMacCommands+0x17d>
                            status &= 0xFE; // Channel mask KO
40036bb0:	b3 06                	mov    $0x6,%bl
    if( ( value >= min ) && ( value <= max ) )
40036bb2:	80 7d e6 04          	cmpb   $0x4,-0x1a(%ebp)
40036bb6:	77 49                	ja     40036c01 <ProcessMacCommands+0x1cc>
40036bb8:	8d 7d e8             	lea    -0x18(%ebp),%edi
40036bbb:	31 d2                	xor    %edx,%edx
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
40036bbd:	0f b7 07             	movzwl (%edi),%eax
40036bc0:	89 45 dc             	mov    %eax,-0x24(%ebp)
40036bc3:	31 c0                	xor    %eax,%eax
40036bc5:	8b 4d dc             	mov    -0x24(%ebp),%ecx
40036bc8:	0f a3 c1             	bt     %eax,%ecx
40036bcb:	73 23                	jae    40036bf0 <ProcessMacCommands+0x1bb>
40036bcd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
                if( ValueInRange( datarate, Channels[i + j].DrRange.Fields.Min, Channels[i + j].DrRange.Fields.Max ) == true )
40036bd0:	8a 0c cd e4 77 00 a8 	mov    -0x57ff881c(,%ecx,8),%cl
40036bd7:	88 4d e3             	mov    %cl,-0x1d(%ebp)
40036bda:	c1 e1 04             	shl    $0x4,%ecx
40036bdd:	c0 f9 04             	sar    $0x4,%cl
    if( ( value >= min ) && ( value <= max ) )
40036be0:	38 4d e6             	cmp    %cl,-0x1a(%ebp)
40036be3:	7c 0b                	jl     40036bf0 <ProcessMacCommands+0x1bb>
                if( ValueInRange( datarate, Channels[i + j].DrRange.Fields.Min, Channels[i + j].DrRange.Fields.Max ) == true )
40036be5:	8a 4d e3             	mov    -0x1d(%ebp),%cl
40036be8:	c0 f9 04             	sar    $0x4,%cl
    if( ( value >= min ) && ( value <= max ) )
40036beb:	38 4d e6             	cmp    %cl,-0x1a(%ebp)
40036bee:	7e 14                	jle    40036c04 <ProcessMacCommands+0x1cf>
40036bf0:	40                   	inc    %eax
        for( uint8_t j = 0; j < 16; j++ )
40036bf1:	83 f8 10             	cmp    $0x10,%eax
40036bf4:	75 cf                	jne    40036bc5 <ProcessMacCommands+0x190>
40036bf6:	83 c2 10             	add    $0x10,%edx
40036bf9:	83 c7 02             	add    $0x2,%edi
    for( uint8_t i = 0, k = 0; i < LORA_MAX_NB_CHANNELS; i += 16, k++ )
40036bfc:	83 fa 50             	cmp    $0x50,%edx
40036bff:	75 bc                	jne    40036bbd <ProcessMacCommands+0x188>
                        status &= 0xFD; // Datarate KO
40036c01:	83 e3 fd             	and    $0xfffffffd,%ebx
    if( ( value >= min ) && ( value <= max ) )
40036c04:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
40036c08:	0f 8f 1a 02 00 00    	jg     40036e28 <ProcessMacCommands+0x3f3>
                    if( ( status & 0x07 ) == 0x07 )
40036c0e:	0f b6 fb             	movzbl %bl,%edi
40036c11:	80 fb 07             	cmp    $0x7,%bl
40036c14:	75 79                	jne    40036c8f <ProcessMacCommands+0x25a>
                        LoRaMacParams.ChannelsDatarate = datarate;
40036c16:	8a 45 e6             	mov    -0x1a(%ebp),%al
                        memcpy( ( uint8_t* )LoRaMacParams.ChannelsMask, ( uint8_t* )channelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
40036c19:	b9 0c 00 00 00       	mov    $0xc,%ecx
                        LoRaMacParams.ChannelsDatarate = datarate;
40036c1e:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
                        LoRaMacParams.ChannelsTxPower = txPower;
40036c23:	8a 45 e5             	mov    -0x1b(%ebp),%al
40036c26:	a2 a0 84 00 a8       	mov    %al,0xa80084a0
                        memcpy( ( uint8_t* )LoRaMacParams.ChannelsMask, ( uint8_t* )channelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
40036c2b:	8d 55 e8             	lea    -0x18(%ebp),%edx
40036c2e:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
40036c33:	e8 32 94 ff ff       	call   4003006a <memcpy>
                        LoRaMacParams.ChannelsNbRep = nbRep;
40036c38:	8a 45 e4             	mov    -0x1c(%ebp),%al
40036c3b:	a2 b8 84 00 a8       	mov    %al,0xa80084b8
                        ChannelsMaskRemaining[0] &= channelsMask[0];
40036c40:	a1 c8 77 00 a8       	mov    0xa80077c8,%eax
40036c45:	23 45 e8             	and    -0x18(%ebp),%eax
40036c48:	66 a3 c8 77 00 a8    	mov    %ax,0xa80077c8
                        ChannelsMaskRemaining[1] &= channelsMask[1];
40036c4e:	66 a1 ca 77 00 a8    	mov    0xa80077ca,%ax
40036c54:	66 23 45 ea          	and    -0x16(%ebp),%ax
40036c58:	66 a3 ca 77 00 a8    	mov    %ax,0xa80077ca
                        ChannelsMaskRemaining[2] &= channelsMask[2];
40036c5e:	a1 cc 77 00 a8       	mov    0xa80077cc,%eax
40036c63:	23 45 ec             	and    -0x14(%ebp),%eax
40036c66:	66 a3 cc 77 00 a8    	mov    %ax,0xa80077cc
                        ChannelsMaskRemaining[3] &= channelsMask[3];
40036c6c:	66 a1 ce 77 00 a8    	mov    0xa80077ce,%ax
40036c72:	66 23 45 ee          	and    -0x12(%ebp),%ax
40036c76:	66 a3 ce 77 00 a8    	mov    %ax,0xa80077ce
                        ChannelsMaskRemaining[4] = channelsMask[4];
40036c7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
40036c7f:	66 a3 d0 77 00 a8    	mov    %ax,0xa80077d0
                        ChannelsMaskRemaining[5] = channelsMask[5];
40036c85:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
40036c89:	66 a3 d2 77 00 a8    	mov    %ax,0xa80077d2
                    AddMacCommand( MOTE_MAC_LINK_ADR_ANS, status, 0 );
40036c8f:	31 c9                	xor    %ecx,%ecx
40036c91:	89 fa                	mov    %edi,%edx
40036c93:	b8 03 00 00 00       	mov    $0x3,%eax
40036c98:	e9 1e 01 00 00       	jmp    40036dbb <ProcessMacCommands+0x386>
                MaxDCycle = payload[macIndex++];
40036c9d:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
40036ca1:	83 c3 02             	add    $0x2,%ebx
                AddMacCommand( MOTE_MAC_DUTY_CYCLE_ANS, 0, 0 );
40036ca4:	31 d2                	xor    %edx,%edx
                MaxDCycle = payload[macIndex++];
40036ca6:	8a 0c 06             	mov    (%esi,%eax,1),%cl
                AggregatedDCycle = 1 << MaxDCycle;
40036ca9:	b8 01 00 00 00       	mov    $0x1,%eax
40036cae:	d3 e0                	shl    %cl,%eax
                MaxDCycle = payload[macIndex++];
40036cb0:	88 0d c6 77 00 a8    	mov    %cl,0xa80077c6
                AggregatedDCycle = 1 << MaxDCycle;
40036cb6:	66 a3 c4 77 00 a8    	mov    %ax,0xa80077c4
                AddMacCommand( MOTE_MAC_DUTY_CYCLE_ANS, 0, 0 );
40036cbc:	31 c9                	xor    %ecx,%ecx
40036cbe:	b8 04 00 00 00       	mov    $0x4,%eax
40036cc3:	e9 50 01 00 00       	jmp    40036e18 <ProcessMacCommands+0x3e3>
                    drOffset = ( payload[macIndex] >> 4 ) & 0x07;
40036cc8:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
40036ccc:	8a 04 06             	mov    (%esi,%eax,1),%al
40036ccf:	88 c2                	mov    %al,%dl
                    datarate = payload[macIndex] & 0x0F;
40036cd1:	83 e0 0f             	and    $0xf,%eax
                    drOffset = ( payload[macIndex] >> 4 ) & 0x07;
40036cd4:	c0 ea 04             	shr    $0x4,%dl
                    datarate = payload[macIndex] & 0x0F;
40036cd7:	89 c7                	mov    %eax,%edi
                    macIndex++;
40036cd9:	8d 43 02             	lea    0x2(%ebx),%eax
                    drOffset = ( payload[macIndex] >> 4 ) & 0x07;
40036cdc:	83 e2 07             	and    $0x7,%edx
                    freq =  ( uint32_t )payload[macIndex++];
40036cdf:	0f b6 c0             	movzbl %al,%eax
                    drOffset = ( payload[macIndex] >> 4 ) & 0x07;
40036ce2:	88 55 e6             	mov    %dl,-0x1a(%ebp)
                    freq =  ( uint32_t )payload[macIndex++];
40036ce5:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
                    freq |= ( uint32_t )payload[macIndex++] << 16;
40036ce9:	8d 43 05             	lea    0x5(%ebx),%eax
40036cec:	88 45 e7             	mov    %al,-0x19(%ebp)
                    freq =  ( uint32_t )payload[macIndex++];
40036cef:	8d 43 03             	lea    0x3(%ebx),%eax
                    freq |= ( uint32_t )payload[macIndex++] << 8;
40036cf2:	83 c3 04             	add    $0x4,%ebx
40036cf5:	0f b6 c0             	movzbl %al,%eax
                    freq |= ( uint32_t )payload[macIndex++] << 16;
40036cf8:	0f b6 db             	movzbl %bl,%ebx
                    freq |= ( uint32_t )payload[macIndex++] << 8;
40036cfb:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
                    freq |= ( uint32_t )payload[macIndex++] << 16;
40036cff:	0f b6 1c 1e          	movzbl (%esi,%ebx,1),%ebx
                    freq |= ( uint32_t )payload[macIndex++] << 8;
40036d03:	c1 e0 08             	shl    $0x8,%eax
                    freq |= ( uint32_t )payload[macIndex++] << 16;
40036d06:	c1 e3 10             	shl    $0x10,%ebx
40036d09:	09 c3                	or     %eax,%ebx
    if((sx1276_check_rf_frequency(dev, freq) == true) &&
40036d0b:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
                    freq |= ( uint32_t )payload[macIndex++] << 16;
40036d10:	09 d9                	or     %ebx,%ecx
                    freq *= 100;
40036d12:	6b d9 64             	imul   $0x64,%ecx,%ebx
    if((sx1276_check_rf_frequency(dev, freq) == true) &&
40036d15:	89 da                	mov    %ebx,%edx
40036d17:	e8 a1 f0 ff ff       	call   40035dbd <sx1276_check_rf_frequency>
                        status &= 0xFE; // Channel frequency KO
40036d1c:	b1 06                	mov    $0x6,%cl
    if((sx1276_check_rf_frequency(dev, freq) == true) &&
40036d1e:	84 c0                	test   %al,%al
40036d20:	74 1e                	je     40036d40 <ProcessMacCommands+0x30b>
        ( freq >= LORAMAC_FIRST_RX1_CHANNEL ) &&
40036d22:	8d 83 60 8f f7 c8    	lea    -0x370870a0(%ebx),%eax
40036d28:	3d 40 16 40 00       	cmp    $0x401640,%eax
40036d2d:	77 11                	ja     40036d40 <ProcessMacCommands+0x30b>
        ( ( ( freq - ( uint32_t ) LORAMAC_FIRST_RX1_CHANNEL ) % ( uint32_t ) LORAMAC_STEPWIDTH_RX1_CHANNEL ) == 0 ) )
40036d2f:	b9 c0 27 09 00       	mov    $0x927c0,%ecx
40036d34:	31 d2                	xor    %edx,%edx
40036d36:	f7 f1                	div    %ecx
                    uint8_t status = 0x07;
40036d38:	85 d2                	test   %edx,%edx
40036d3a:	0f 94 c1             	sete   %cl
40036d3d:	83 c1 06             	add    $0x6,%ecx
    if( ( value >= min ) && ( value <= max ) )
40036d40:	8d 47 f8             	lea    -0x8(%edi),%eax
40036d43:	3c 05                	cmp    $0x5,%al
40036d45:	0f 87 e5 00 00 00    	ja     40036e30 <ProcessMacCommands+0x3fb>
40036d4b:	8d 47 fb             	lea    -0x5(%edi),%eax
                    if( ( ValueInRange( datarate, DR_5, DR_7 ) == true ) ||
40036d4e:	3c 02                	cmp    $0x2,%al
40036d50:	76 06                	jbe    40036d58 <ProcessMacCommands+0x323>
40036d52:	89 f8                	mov    %edi,%eax
40036d54:	3c 0d                	cmp    $0xd,%al
40036d56:	7e 03                	jle    40036d5b <ProcessMacCommands+0x326>
                        status &= 0xFD; // Datarate KO
40036d58:	83 e1 fd             	and    $0xfffffffd,%ecx
    if( ( value >= min ) && ( value <= max ) )
40036d5b:	80 7d e6 03          	cmpb   $0x3,-0x1a(%ebp)
40036d5f:	0f 8f d3 00 00 00    	jg     40036e38 <ProcessMacCommands+0x403>
                    if( ( status & 0x07 ) == 0x07 )
40036d65:	0f b6 d1             	movzbl %cl,%edx
40036d68:	80 f9 07             	cmp    $0x7,%cl
40036d6b:	75 15                	jne    40036d82 <ProcessMacCommands+0x34d>
                        LoRaMacParams.Rx2Channel.Datarate = datarate;
40036d6d:	89 f8                	mov    %edi,%eax
                        LoRaMacParams.Rx2Channel.Frequency = freq;
40036d6f:	89 1d bc 84 00 a8    	mov    %ebx,0xa80084bc
                        LoRaMacParams.Rx2Channel.Datarate = datarate;
40036d75:	a2 c0 84 00 a8       	mov    %al,0xa80084c0
                        LoRaMacParams.Rx1DrOffset = drOffset;
40036d7a:	8a 45 e6             	mov    -0x1a(%ebp),%al
40036d7d:	a2 b9 84 00 a8       	mov    %al,0xa80084b9
                    AddMacCommand( MOTE_MAC_RX_PARAM_SETUP_ANS, status, 0 );
40036d82:	31 c9                	xor    %ecx,%ecx
40036d84:	b8 05 00 00 00       	mov    $0x5,%eax
40036d89:	eb 30                	jmp    40036dbb <ProcessMacCommands+0x386>
                    if( ( LoRaMacCallbacks != NULL ) && ( LoRaMacCallbacks->GetBatteryLevel != NULL ) )
40036d8b:	8b 15 a4 77 00 a8    	mov    0xa80077a4,%edx
                    uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
40036d91:	b0 ff                	mov    $0xff,%al
                    if( ( LoRaMacCallbacks != NULL ) && ( LoRaMacCallbacks->GetBatteryLevel != NULL ) )
40036d93:	85 d2                	test   %edx,%edx
40036d95:	74 08                	je     40036d9f <ProcessMacCommands+0x36a>
40036d97:	8b 12                	mov    (%edx),%edx
40036d99:	85 d2                	test   %edx,%edx
40036d9b:	74 02                	je     40036d9f <ProcessMacCommands+0x36a>
                        batteryLevel = LoRaMacCallbacks->GetBatteryLevel( );
40036d9d:	ff d2                	call   *%edx
                    AddMacCommand( MOTE_MAC_DEV_STATUS_ANS, batteryLevel, snr );
40036d9f:	0f b6 d0             	movzbl %al,%edx
40036da2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
40036da5:	b8 06 00 00 00       	mov    $0x6,%eax
40036daa:	eb 0f                	jmp    40036dbb <ProcessMacCommands+0x386>
                    macIndex += 5;
40036dac:	8d 43 06             	lea    0x6(%ebx),%eax
                    AddMacCommand( MOTE_MAC_NEW_CHANNEL_ANS, status, 0 );
40036daf:	31 c9                	xor    %ecx,%ecx
                    macIndex += 5;
40036db1:	88 45 e7             	mov    %al,-0x19(%ebp)
                    AddMacCommand( MOTE_MAC_NEW_CHANNEL_ANS, status, 0 );
40036db4:	31 d2                	xor    %edx,%edx
40036db6:	b8 07 00 00 00       	mov    $0x7,%eax
40036dbb:	e8 fc f3 ff ff       	call   400361bc <AddMacCommand>
                break;
40036dc0:	eb 5e                	jmp    40036e20 <ProcessMacCommands+0x3eb>
                    uint8_t delay = payload[macIndex++] & 0x0F;
40036dc2:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
40036dc6:	83 c3 02             	add    $0x2,%ebx
40036dc9:	8a 04 06             	mov    (%esi,%eax,1),%al
                    if( delay == 0 )
40036dcc:	24 0f                	and    $0xf,%al
40036dce:	75 02                	jne    40036dd2 <ProcessMacCommands+0x39d>
                        delay++;
40036dd0:	b0 01                	mov    $0x1,%al
                    LoRaMacParams.ReceiveDelay1 = delay * 1e3;
40036dd2:	0f b6 c0             	movzbl %al,%eax
40036dd5:	e8 9a a8 ff ff       	call   40031674 <__floatsidf>
40036dda:	68 00 40 8f 40       	push   $0x408f4000
40036ddf:	6a 00                	push   $0x0
40036de1:	e8 6a a3 ff ff       	call   40031150 <__muldf3>
40036de6:	59                   	pop    %ecx
40036de7:	5f                   	pop    %edi
40036de8:	e8 1a a8 ff ff       	call   40031607 <__fixunsdfsi>
40036ded:	a3 a8 84 00 a8       	mov    %eax,0xa80084a8
                    LoRaMacParams.ReceiveDelay2 = LoRaMacParams.ReceiveDelay1 + 1e3;
40036df2:	e8 0a a9 ff ff       	call   40031701 <__floatunsidf>
40036df7:	68 00 40 8f 40       	push   $0x408f4000
40036dfc:	6a 00                	push   $0x0
40036dfe:	e8 8e 93 ff ff       	call   40030191 <__adddf3>
40036e03:	59                   	pop    %ecx
40036e04:	5f                   	pop    %edi
40036e05:	e8 fd a7 ff ff       	call   40031607 <__fixunsdfsi>
                    AddMacCommand( MOTE_MAC_RX_TIMING_SETUP_ANS, 0, 0 );
40036e0a:	31 c9                	xor    %ecx,%ecx
                    LoRaMacParams.ReceiveDelay2 = LoRaMacParams.ReceiveDelay1 + 1e3;
40036e0c:	a3 ac 84 00 a8       	mov    %eax,0xa80084ac
                    AddMacCommand( MOTE_MAC_RX_TIMING_SETUP_ANS, 0, 0 );
40036e11:	31 d2                	xor    %edx,%edx
40036e13:	b8 08 00 00 00       	mov    $0x8,%eax
40036e18:	e8 9f f3 ff ff       	call   400361bc <AddMacCommand>
                    uint8_t delay = payload[macIndex++] & 0x0F;
40036e1d:	88 5d e7             	mov    %bl,-0x19(%ebp)
                MaxDCycle = payload[macIndex++];
40036e20:	8a 5d e7             	mov    -0x19(%ebp),%bl
40036e23:	e9 24 fc ff ff       	jmp    40036a4c <ProcessMacCommands+0x17>
                        status &= 0xFB; // TxPower KO
40036e28:	83 e3 fb             	and    $0xfffffffb,%ebx
40036e2b:	e9 de fd ff ff       	jmp    40036c0e <ProcessMacCommands+0x1d9>
                        status &= 0xFD; // Datarate KO
40036e30:	83 e1 fd             	and    $0xfffffffd,%ecx
40036e33:	e9 13 ff ff ff       	jmp    40036d4b <ProcessMacCommands+0x316>
                        status &= 0xFB; // Rx1DrOffset range KO
40036e38:	83 e1 fb             	and    $0xfffffffb,%ecx
40036e3b:	e9 25 ff ff ff       	jmp    40036d65 <ProcessMacCommands+0x330>
}
40036e40:	8d 65 f4             	lea    -0xc(%ebp),%esp
40036e43:	5b                   	pop    %ebx
40036e44:	5e                   	pop    %esi
40036e45:	5f                   	pop    %edi
40036e46:	5d                   	pop    %ebp
40036e47:	c3                   	ret    

40036e48 <OnRadioRxDone>:
{
40036e48:	55                   	push   %ebp
40036e49:	89 e5                	mov    %esp,%ebp
40036e4b:	57                   	push   %edi
40036e4c:	56                   	push   %esi
40036e4d:	53                   	push   %ebx
40036e4e:	83 ec 28             	sub    $0x28,%esp
40036e51:	89 c3                	mov    %eax,%ebx
40036e53:	8b 45 08             	mov    0x8(%ebp),%eax
40036e56:	89 55 ec             	mov    %edx,-0x14(%ebp)
40036e59:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uint32_t mic = 0;
40036e5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    McpsIndication.Snr = snr;
40036e63:	8a 45 d8             	mov    -0x28(%ebp),%al
    McpsConfirm.AckReceived = false;
40036e66:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
    McpsIndication.Snr = snr;
40036e6d:	a2 6c 77 00 a8       	mov    %al,0xa800776c
    McpsIndication.RxSlot = RxSlot;
40036e72:	a0 2c 77 00 a8       	mov    0xa800772c,%al
    McpsIndication.Rssi = rssi;
40036e77:	66 89 0d 6a 77 00 a8 	mov    %cx,0xa800776a
    McpsIndication.RxSlot = RxSlot;
40036e7e:	a2 6d 77 00 a8       	mov    %al,0xa800776d
    McpsIndication.Port = 0;
40036e83:	c6 05 61 77 00 a8 00 	movb   $0x0,0xa8007761
    McpsIndication.Multicast = 0;
40036e8a:	c6 05 60 77 00 a8 00 	movb   $0x0,0xa8007760
    McpsIndication.FramePending = 0;
40036e91:	c6 05 63 77 00 a8 00 	movb   $0x0,0xa8007763
    McpsIndication.Buffer = NULL;
40036e98:	c7 05 64 77 00 a8 00 	movl   $0x0,0xa8007764
40036e9f:	00 00 00 
    McpsIndication.BufferSize = 0;
40036ea2:	c6 05 68 77 00 a8 00 	movb   $0x0,0xa8007768
    McpsIndication.RxData = false;
40036ea9:	c6 05 69 77 00 a8 00 	movb   $0x0,0xa8007769
    McpsIndication.AckReceived = false;
40036eb0:	c6 05 6e 77 00 a8 00 	movb   $0x0,0xa800776e
    McpsIndication.DownLinkCounter = 0;
40036eb7:	c7 05 70 77 00 a8 00 	movl   $0x0,0xa8007770
40036ebe:	00 00 00 
    McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
40036ec1:	c7 05 58 77 00 a8 00 	movl   $0x0,0xa8007758
40036ec8:	00 00 00 
    if(LoRaMacDeviceClass != CLASS_C)
40036ecb:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
40036ed2:	74 0a                	je     40036ede <OnRadioRxDone+0x96>
        sx1276_set_sleep(dev);
40036ed4:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40036ed9:	e8 5c ee ff ff       	call   40035d3a <sx1276_set_sleep>
    k_timer_stop(&RxWindowTimer2);
40036ede:	b8 00 82 00 a8       	mov    $0xa8008200,%eax
40036ee3:	e8 91 38 00 00       	call   4003a779 <k_timer_stop>
    macHdr.Value = payload[pktHeaderLen++];
40036ee8:	8a 03                	mov    (%ebx),%al
40036eea:	88 45 d7             	mov    %al,-0x29(%ebp)
    switch(macHdr.Bits.MType)
40036eed:	c0 e8 05             	shr    $0x5,%al
40036ef0:	3c 03                	cmp    $0x3,%al
40036ef2:	0f 84 e3 01 00 00    	je     400370db <OnRadioRxDone+0x293>
40036ef8:	77 09                	ja     40036f03 <OnRadioRxDone+0xbb>
40036efa:	fe c8                	dec    %al
40036efc:	74 53                	je     40036f51 <OnRadioRxDone+0x109>
40036efe:	e9 2c 03 00 00       	jmp    4003722f <OnRadioRxDone+0x3e7>
40036f03:	3c 05                	cmp    $0x5,%al
40036f05:	0f 84 d0 01 00 00    	je     400370db <OnRadioRxDone+0x293>
40036f0b:	3c 07                	cmp    $0x7,%al
40036f0d:	0f 85 1c 03 00 00    	jne    4003722f <OnRadioRxDone+0x3e7>
                memcpy(LoRaMacRxPayload, &payload[pktHeaderLen], size);
40036f13:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
40036f17:	8d 53 01             	lea    0x1(%ebx),%edx
40036f1a:	b8 60 7a 00 a8       	mov    $0xa8007a60,%eax
40036f1f:	e8 46 91 ff ff       	call   4003006a <memcpy>
                McpsIndication.BufferSize = size - pktHeaderLen;
40036f24:	8a 55 ec             	mov    -0x14(%ebp),%dl
40036f27:	4a                   	dec    %edx
                McpsIndication.McpsIndication = MCPS_PROPRIETARY;
40036f28:	c7 05 58 77 00 a8 03 	movl   $0x3,0xa8007758
40036f2f:	00 00 00 
                McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
40036f32:	c7 05 5c 77 00 a8 00 	movl   $0x0,0xa800775c
40036f39:	00 00 00 
                McpsIndication.Buffer = LoRaMacRxPayload;
40036f3c:	c7 05 64 77 00 a8 60 	movl   $0xa8007a60,0xa8007764
40036f43:	7a 00 a8 
                McpsIndication.BufferSize = size - pktHeaderLen;
40036f46:	88 15 68 77 00 a8    	mov    %dl,0xa8007768
40036f4c:	e9 d5 02 00 00       	jmp    40037226 <OnRadioRxDone+0x3de>
            if(IsLoRaMacNetworkJoined == true)
40036f51:	80 3d 49 7a 00 a8 00 	cmpb   $0x0,0xa8007a49
40036f58:	74 0f                	je     40036f69 <OnRadioRxDone+0x121>
                McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
40036f5a:	c7 05 5c 77 00 a8 01 	movl   $0x1,0xa800775c
40036f61:	00 00 00 
40036f64:	e9 13 03 00 00       	jmp    4003727c <OnRadioRxDone+0x434>
            LoRaMacJoinDecrypt(payload + 1, size - 1, LoRaMacAppKey, LoRaMacRxPayload + 1);
40036f69:	8b 45 ec             	mov    -0x14(%ebp),%eax
40036f6c:	8b 0d b8 7d 00 a8    	mov    0xa8007db8,%ecx
40036f72:	68 61 7a 00 a8       	push   $0xa8007a61
40036f77:	8d 50 ff             	lea    -0x1(%eax),%edx
40036f7a:	8d 43 01             	lea    0x1(%ebx),%eax
40036f7d:	0f b7 d2             	movzwl %dx,%edx
40036f80:	e8 b4 1d 00 00       	call   40038d39 <LoRaMacJoinDecrypt>
            LoRaMacRxPayload[0] = macHdr.Value;
40036f85:	8a 45 d7             	mov    -0x29(%ebp),%al
40036f88:	a2 60 7a 00 a8       	mov    %al,0xa8007a60
            LoRaMacJoinComputeMic(LoRaMacRxPayload, size - LORAMAC_MFR_LEN, LoRaMacAppKey, &mic);
40036f8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
40036f90:	8b 0d b8 7d 00 a8    	mov    0xa8007db8,%ecx
40036f96:	8d 50 fc             	lea    -0x4(%eax),%edx
40036f99:	8d 45 f0             	lea    -0x10(%ebp),%eax
40036f9c:	89 04 24             	mov    %eax,(%esp)
40036f9f:	b8 60 7a 00 a8       	mov    $0xa8007a60,%eax
40036fa4:	0f b7 d2             	movzwl %dx,%edx
40036fa7:	e8 3d 1d 00 00       	call   40038ce9 <LoRaMacJoinComputeMic>
40036fac:	59                   	pop    %ecx
            micRx |= (uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN];
40036fad:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 1] << 8);
40036fb1:	0f b6 82 5d 7a 00 a8 	movzbl -0x57ff85a3(%edx),%eax
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 2] << 16);
40036fb8:	0f b6 8a 5e 7a 00 a8 	movzbl -0x57ff85a2(%edx),%ecx
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 1] << 8);
40036fbf:	c1 e0 08             	shl    $0x8,%eax
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 2] << 16);
40036fc2:	c1 e1 10             	shl    $0x10,%ecx
40036fc5:	09 c8                	or     %ecx,%eax
            micRx |= (uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN];
40036fc7:	0f b6 8a 5c 7a 00 a8 	movzbl -0x57ff85a4(%edx),%ecx
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 3] << 24);
40036fce:	0f b6 92 5f 7a 00 a8 	movzbl -0x57ff85a1(%edx),%edx
40036fd5:	c1 e2 18             	shl    $0x18,%edx
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 2] << 16);
40036fd8:	09 c8                	or     %ecx,%eax
            micRx |= ((uint32_t)LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 3] << 24);
40036fda:	09 d0                	or     %edx,%eax
            if( micRx == mic ) {
40036fdc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
40036fdf:	0f 85 e7 00 00 00    	jne    400370cc <OnRadioRxDone+0x284>
                LoRaMacJoinComputeSKeys(LoRaMacAppKey, LoRaMacRxPayload + 1, LoRaMacDevNonce, LoRaMacNwkSKey, LoRaMacAppSKey);
40036fe5:	0f b7 0d 94 7d 00 a8 	movzwl 0xa8007d94,%ecx
40036fec:	ba 61 7a 00 a8       	mov    $0xa8007a61,%edx
40036ff1:	a1 b8 7d 00 a8       	mov    0xa8007db8,%eax
40036ff6:	68 98 7d 00 a8       	push   $0xa8007d98
40036ffb:	68 a8 7d 00 a8       	push   $0xa8007da8
40037000:	e8 97 1d 00 00       	call   40038d9c <LoRaMacJoinComputeSKeys>
40037005:	58                   	pop    %eax
                LoRaMacNetID |= ((uint32_t)LoRaMacRxPayload[5] << 8);
40037006:	0f b6 05 65 7a 00 a8 	movzbl 0xa8007a65,%eax
4003700d:	c1 e0 08             	shl    $0x8,%eax
                LoRaMacJoinComputeSKeys(LoRaMacAppKey, LoRaMacRxPayload + 1, LoRaMacDevNonce, LoRaMacNwkSKey, LoRaMacAppSKey);
40037010:	5a                   	pop    %edx
                LoRaMacNetID |= ((uint32_t)LoRaMacRxPayload[6] << 16);
40037011:	0f b6 15 66 7a 00 a8 	movzbl 0xa8007a66,%edx
40037018:	c1 e2 10             	shl    $0x10,%edx
4003701b:	09 d0                	or     %edx,%eax
                LoRaMacNetID = (uint32_t)LoRaMacRxPayload[4];
4003701d:	0f b6 15 64 7a 00 a8 	movzbl 0xa8007a64,%edx
                LoRaMacNetID |= ((uint32_t)LoRaMacRxPayload[6] << 16);
40037024:	09 d0                	or     %edx,%eax
40037026:	a3 90 7d 00 a8       	mov    %eax,0xa8007d90
                LoRaMacDevAddr |= ((uint32_t)LoRaMacRxPayload[10] << 24);
4003702b:	a1 67 7a 00 a8       	mov    0xa8007a67,%eax
40037030:	a3 8c 7d 00 a8       	mov    %eax,0xa8007d8c
                LoRaMacParams.Rx1DrOffset = (LoRaMacRxPayload[11] >> 4) & 0x07;
40037035:	a0 6b 7a 00 a8       	mov    0xa8007a6b,%al
4003703a:	88 c2                	mov    %al,%dl
                LoRaMacParams.Rx2Channel.Datarate = LoRaMacRxPayload[11] & 0x0F;
4003703c:	83 e0 0f             	and    $0xf,%eax
                LoRaMacParams.Rx1DrOffset = (LoRaMacRxPayload[11] >> 4) & 0x07;
4003703f:	c0 ea 04             	shr    $0x4,%dl
                LoRaMacParams.Rx2Channel.Datarate = LoRaMacRxPayload[11] & 0x0F;
40037042:	a2 c0 84 00 a8       	mov    %al,0xa80084c0
                if(LoRaMacParams.ReceiveDelay1 == 0) {
40037047:	a0 6c 7a 00 a8       	mov    0xa8007a6c,%al
                LoRaMacParams.Rx1DrOffset = (LoRaMacRxPayload[11] >> 4) & 0x07;
4003704c:	83 e2 07             	and    $0x7,%edx
                if(LoRaMacParams.ReceiveDelay1 == 0) {
4003704f:	24 0f                	and    $0xf,%al
                LoRaMacParams.Rx1DrOffset = (LoRaMacRxPayload[11] >> 4) & 0x07;
40037051:	88 15 b9 84 00 a8    	mov    %dl,0xa80084b9
                if(LoRaMacParams.ReceiveDelay1 == 0) {
40037057:	74 0a                	je     40037063 <OnRadioRxDone+0x21b>
                LoRaMacParams.ReceiveDelay1 = (LoRaMacRxPayload[12] & 0x0F );
40037059:	0f b6 c0             	movzbl %al,%eax
4003705c:	a3 a8 84 00 a8       	mov    %eax,0xa80084a8
40037061:	eb 0a                	jmp    4003706d <OnRadioRxDone+0x225>
                    LoRaMacParams.ReceiveDelay1 = 1;
40037063:	c7 05 a8 84 00 a8 01 	movl   $0x1,0xa80084a8
4003706a:	00 00 00 
                LoRaMacParams.ReceiveDelay1 *= 1e3;
4003706d:	a1 a8 84 00 a8       	mov    0xa80084a8,%eax
40037072:	e8 8a a6 ff ff       	call   40031701 <__floatunsidf>
40037077:	68 00 40 8f 40       	push   $0x408f4000
4003707c:	6a 00                	push   $0x0
4003707e:	e8 cd a0 ff ff       	call   40031150 <__muldf3>
40037083:	59                   	pop    %ecx
40037084:	5b                   	pop    %ebx
40037085:	e8 7d a5 ff ff       	call   40031607 <__fixunsdfsi>
4003708a:	a3 a8 84 00 a8       	mov    %eax,0xa80084a8
                LoRaMacParams.ReceiveDelay2 = LoRaMacParams.ReceiveDelay1 + 1e3;
4003708f:	e8 6d a6 ff ff       	call   40031701 <__floatunsidf>
40037094:	68 00 40 8f 40       	push   $0x408f4000
40037099:	6a 00                	push   $0x0
4003709b:	e8 f1 90 ff ff       	call   40030191 <__adddf3>
400370a0:	5e                   	pop    %esi
400370a1:	5f                   	pop    %edi
400370a2:	e8 60 a5 ff ff       	call   40031607 <__fixunsdfsi>
400370a7:	a3 ac 84 00 a8       	mov    %eax,0xa80084ac
                LoRaMacParams.ChannelsDatarate = LoRaMacParamsDefaults.ChannelsDatarate;
400370ac:	a0 21 84 00 a8       	mov    0xa8008421,%al
                MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
400370b1:	c7 05 34 77 00 a8 00 	movl   $0x0,0xa8007734
400370b8:	00 00 00 
                IsLoRaMacNetworkJoined = true;
400370bb:	c6 05 49 7a 00 a8 01 	movb   $0x1,0xa8007a49
                LoRaMacParams.ChannelsDatarate = LoRaMacParamsDefaults.ChannelsDatarate;
400370c2:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
400370c7:	e9 72 01 00 00       	jmp    4003723e <OnRadioRxDone+0x3f6>
                MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
400370cc:	c7 05 34 77 00 a8 05 	movl   $0x5,0xa8007734
400370d3:	00 00 00 
400370d6:	e9 63 01 00 00       	jmp    4003723e <OnRadioRxDone+0x3f6>
                address |= ((uint32_t)payload[pktHeaderLen++] << 24);
400370db:	8b 43 01             	mov    0x1(%ebx),%eax
                    curMulticastParams = MulticastChannels;
400370de:	8b 35 88 7d 00 a8    	mov    0xa8007d88,%esi
                address |= ((uint32_t)payload[pktHeaderLen++] << 24);
400370e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
                if(address != LoRaMacDevAddr) {
400370e7:	3b 05 8c 7d 00 a8    	cmp    0xa8007d8c,%eax
400370ed:	74 2c                	je     4003711b <OnRadioRxDone+0x2d3>
                    while(curMulticastParams != NULL) {
400370ef:	85 f6                	test   %esi,%esi
400370f1:	0f 84 7b 01 00 00    	je     40037272 <OnRadioRxDone+0x42a>
                        if(address == curMulticastParams->Address) {
400370f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
400370fa:	3b 06                	cmp    (%esi),%eax
400370fc:	75 18                	jne    40037116 <OnRadioRxDone+0x2ce>
                            nwkSKey = curMulticastParams->NwkSKey;
400370fe:	8d 46 04             	lea    0x4(%esi),%eax
                            downLinkCounter = curMulticastParams->DownLinkCounter;
40037101:	c6 45 e6 01          	movb   $0x1,-0x1a(%ebp)
                            nwkSKey = curMulticastParams->NwkSKey;
40037105:	89 45 dc             	mov    %eax,-0x24(%ebp)
                            appSKey = curMulticastParams->AppSKey;
40037108:	8d 46 14             	lea    0x14(%esi),%eax
4003710b:	89 45 d0             	mov    %eax,-0x30(%ebp)
                            downLinkCounter = curMulticastParams->DownLinkCounter;
4003710e:	8b 46 24             	mov    0x24(%esi),%eax
40037111:	89 45 e0             	mov    %eax,-0x20(%ebp)
40037114:	eb 21                	jmp    40037137 <OnRadioRxDone+0x2ef>
                        curMulticastParams = curMulticastParams->Next;
40037116:	8b 76 28             	mov    0x28(%esi),%esi
40037119:	eb d4                	jmp    400370ef <OnRadioRxDone+0x2a7>
                    downLinkCounter = DownLinkCounter;
4003711b:	a1 4c 7a 00 a8       	mov    0xa8007a4c,%eax
                    multicast = 0;
40037120:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
                    downLinkCounter = DownLinkCounter;
40037124:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    appSKey = LoRaMacAppSKey;
40037127:	c7 45 d0 98 7d 00 a8 	movl   $0xa8007d98,-0x30(%ebp)
                    nwkSKey = LoRaMacNwkSKey;
4003712e:	c7 45 dc a8 7d 00 a8 	movl   $0xa8007da8,-0x24(%ebp)
    MulticastParams_t *curMulticastParams = NULL;
40037135:	31 f6                	xor    %esi,%esi
                micRx |= (uint32_t)payload[size - LORAMAC_MFR_LEN];
40037137:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
                fCtrl.Value = payload[pktHeaderLen++];
4003713b:	8a 43 05             	mov    0x5(%ebx),%al
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 2] << 16);
4003713e:	0f b6 4c 13 fe       	movzbl -0x2(%ebx,%edx,1),%ecx
40037143:	c1 e1 10             	shl    $0x10,%ecx
                fCtrl.Value = payload[pktHeaderLen++];
40037146:	88 45 e7             	mov    %al,-0x19(%ebp)
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 1] << 8);
40037149:	0f b6 44 13 fd       	movzbl -0x3(%ebx,%edx,1),%eax
4003714e:	c1 e0 08             	shl    $0x8,%eax
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 2] << 16);
40037151:	09 c8                	or     %ecx,%eax
                micRx |= (uint32_t)payload[size - LORAMAC_MFR_LEN];
40037153:	0f b6 4c 13 fc       	movzbl -0x4(%ebx,%edx,1),%ecx
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 3] << 24);
40037158:	0f b6 54 13 ff       	movzbl -0x1(%ebx,%edx,1),%edx
4003715d:	c1 e2 18             	shl    $0x18,%edx
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 2] << 16);
40037160:	09 c8                	or     %ecx,%eax
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 3] << 24);
40037162:	09 c2                	or     %eax,%edx
                sequenceCounter |= (uint16_t)payload[pktHeaderLen++] << 8;
40037164:	0f b6 43 07          	movzbl 0x7(%ebx),%eax
40037168:	c1 e0 08             	shl    $0x8,%eax
                micRx |= ((uint32_t)payload[size - LORAMAC_MFR_LEN + 3] << 24);
4003716b:	89 55 cc             	mov    %edx,-0x34(%ebp)
                sequenceCounter |= (uint16_t)payload[pktHeaderLen++] << 8;
4003716e:	89 c2                	mov    %eax,%edx
40037170:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
40037174:	09 d0                	or     %edx,%eax
                if(sequenceCounterDiff < (1 << 15)) {
40037176:	66 2b 45 e0          	sub    -0x20(%ebp),%ax
4003717a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
4003717e:	78 43                	js     400371c3 <OnRadioRxDone+0x37b>
                appPayloadStartIndex = 8 + fCtrl.Bits.FOptsLen;
40037180:	8a 45 e7             	mov    -0x19(%ebp),%al
                    downLinkCounter += sequenceCounterDiff;
40037183:	8b 7d e0             	mov    -0x20(%ebp),%edi
                appPayloadStartIndex = 8 + fCtrl.Bits.FOptsLen;
40037186:	83 e0 0f             	and    $0xf,%eax
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounter, &mic);
40037189:	8b 4d dc             	mov    -0x24(%ebp),%ecx
                appPayloadStartIndex = 8 + fCtrl.Bits.FOptsLen;
4003718c:	88 45 d6             	mov    %al,-0x2a(%ebp)
                    downLinkCounter += sequenceCounterDiff;
4003718f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
40037193:	01 c7                	add    %eax,%edi
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounter, &mic);
40037195:	8b 45 ec             	mov    -0x14(%ebp),%eax
40037198:	8d 50 fc             	lea    -0x4(%eax),%edx
4003719b:	8d 45 f0             	lea    -0x10(%ebp),%eax
4003719e:	50                   	push   %eax
4003719f:	57                   	push   %edi
400371a0:	6a 01                	push   $0x1
400371a2:	89 d8                	mov    %ebx,%eax
400371a4:	ff 75 e8             	pushl  -0x18(%ebp)
400371a7:	0f b7 d2             	movzwl %dx,%edx
400371aa:	e8 1f 19 00 00       	call   40038ace <LoRaMacComputeMic>
                    if(micRx == mic) {
400371af:	8b 45 cc             	mov    -0x34(%ebp),%eax
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounter, &mic);
400371b2:	83 c4 10             	add    $0x10,%esp
                    if(micRx == mic) {
400371b5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
400371b8:	0f 85 d3 02 00 00    	jne    40037491 <OnRadioRxDone+0x649>
400371be:	e9 c3 00 00 00       	jmp    40037286 <OnRadioRxDone+0x43e>
                    uint32_t  downLinkCounterTmp = downLinkCounter + 0x10000 + (int16_t)sequenceCounterDiff;
400371c3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
400371c7:	8b 75 e0             	mov    -0x20(%ebp),%esi
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounterTmp, &mic);
400371ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
400371cd:	83 ea 04             	sub    $0x4,%edx
400371d0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
                    uint32_t  downLinkCounterTmp = downLinkCounter + 0x10000 + (int16_t)sequenceCounterDiff;
400371d3:	8d bc 06 00 00 01 00 	lea    0x10000(%esi,%eax,1),%edi
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounterTmp, &mic);
400371da:	8d 45 f0             	lea    -0x10(%ebp),%eax
400371dd:	50                   	push   %eax
400371de:	57                   	push   %edi
400371df:	6a 01                	push   $0x1
400371e1:	89 d8                	mov    %ebx,%eax
400371e3:	ff 75 e8             	pushl  -0x18(%ebp)
400371e6:	0f b7 d2             	movzwl %dx,%edx
400371e9:	e8 e0 18 00 00       	call   40038ace <LoRaMacComputeMic>
                    if(micRx == mic) {
400371ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
                    LoRaMacComputeMic(payload, size - LORAMAC_MFR_LEN, nwkSKey, address, DOWN_LINK, downLinkCounterTmp, &mic);
400371f1:	83 c4 10             	add    $0x10,%esp
                    if(micRx == mic) {
400371f4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
400371f7:	74 03                	je     400371fc <OnRadioRxDone+0x3b4>
400371f9:	8b 7d e0             	mov    -0x20(%ebp),%edi
                    McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
400371fc:	c7 05 5c 77 00 a8 08 	movl   $0x8,0xa800775c
40037203:	00 00 00 
                    McpsIndication.DownLinkCounter = downLinkCounter;
40037206:	89 3d 70 77 00 a8    	mov    %edi,0xa8007770
4003720c:	eb 6e                	jmp    4003727c <OnRadioRxDone+0x434>
                            if(AckTimeoutRetriesCounter > AckTimeoutRetries) {
4003720e:	a0 1e 67 00 a8       	mov    0xa800671e,%al
                            McpsConfirm.AckReceived = false;
40037213:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
                            if(AckTimeoutRetriesCounter > AckTimeoutRetries) {
4003721a:	38 05 1d 67 00 a8    	cmp    %al,0xa800671d
40037220:	0f 87 5c 02 00 00    	ja     40037482 <OnRadioRxDone+0x63a>
                LoRaMacFlags.Bits.McpsInd = 1;
40037226:	80 0d 14 84 00 a8 02 	orb    $0x2,0xa8008414
                break;
4003722d:	eb 0f                	jmp    4003723e <OnRadioRxDone+0x3f6>
            McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
4003722f:	c7 05 5c 77 00 a8 01 	movl   $0x1,0xa800775c
40037236:	00 00 00 
            PrepareRxDoneAbort();
40037239:	e8 f1 f2 ff ff       	call   4003652f <PrepareRxDoneAbort>
    if((RxSlot == 0) && (LoRaMacDeviceClass == CLASS_C)) {
4003723e:	80 3d 2c 77 00 a8 00 	cmpb   $0x0,0xa800772c
40037245:	75 0e                	jne    40037255 <OnRadioRxDone+0x40d>
40037247:	83 3d 84 7d 00 a8 02 	cmpl   $0x2,0xa8007d84
4003724e:	75 05                	jne    40037255 <OnRadioRxDone+0x40d>
        OnRxWindow2TimerEvent();
40037250:	e8 40 f2 ff ff       	call   40036495 <OnRxWindow2TimerEvent>
    k_timer_start(&MacStateCheckTimer, 1, 0);
40037255:	31 c9                	xor    %ecx,%ecx
40037257:	ba 01 00 00 00       	mov    $0x1,%edx
4003725c:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
    LoRaMacFlags.Bits.MacDone = 1;
40037261:	80 0d 14 84 00 a8 08 	orb    $0x8,0xa8008414
    k_timer_start(&MacStateCheckTimer, 1, 0);
40037268:	e8 ad 34 00 00       	call   4003a71a <k_timer_start>
4003726d:	e9 3a 02 00 00       	jmp    400374ac <OnRadioRxDone+0x664>
                        McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;
40037272:	c7 05 5c 77 00 a8 09 	movl   $0x9,0xa800775c
40037279:	00 00 00 
                        PrepareRxDoneAbort();
4003727c:	e8 ae f2 ff ff       	call   4003652f <PrepareRxDoneAbort>
                        return;
40037281:	e9 26 02 00 00       	jmp    400374ac <OnRadioRxDone+0x664>
                if(sequenceCounterDiff >= MAX_FCNT_GAP) {
40037286:	66 81 7d e4 ff 3f    	cmpw   $0x3fff,-0x1c(%ebp)
4003728c:	0f 87 6a ff ff ff    	ja     400371fc <OnRadioRxDone+0x3b4>
                    McpsIndication.Multicast = multicast;
40037292:	8a 45 e6             	mov    -0x1a(%ebp),%al
                    McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
40037295:	c7 05 5c 77 00 a8 00 	movl   $0x0,0xa800775c
4003729c:	00 00 00 
                    McpsIndication.Multicast = multicast;
4003729f:	a2 60 77 00 a8       	mov    %al,0xa8007760
                    McpsIndication.FramePending = fCtrl.Bits.FPending;
400372a4:	8a 45 e7             	mov    -0x19(%ebp),%al
400372a7:	c0 e8 04             	shr    $0x4,%al
                    McpsIndication.Buffer = NULL;
400372aa:	c7 05 64 77 00 a8 00 	movl   $0x0,0xa8007764
400372b1:	00 00 00 
                    McpsIndication.FramePending = fCtrl.Bits.FPending;
400372b4:	83 e0 01             	and    $0x1,%eax
                    McpsIndication.BufferSize = 0;
400372b7:	c6 05 68 77 00 a8 00 	movb   $0x0,0xa8007768
                    McpsIndication.FramePending = fCtrl.Bits.FPending;
400372be:	a2 63 77 00 a8       	mov    %al,0xa8007763
                    McpsIndication.DownLinkCounter = downLinkCounter;
400372c3:	89 3d 70 77 00 a8    	mov    %edi,0xa8007770
                    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
400372c9:	c7 05 44 77 00 a8 00 	movl   $0x0,0xa8007744
400372d0:	00 00 00 
                    AdrAckCounter = 0;
400372d3:	c7 05 44 7a 00 a8 00 	movl   $0x0,0xa8007a44
400372da:	00 00 00 
                    MacCommandsBufferToRepeatIndex = 0;
400372dd:	c6 05 3f 7a 00 a8 00 	movb   $0x0,0xa8007a3f
                    if(multicast == 1) {
400372e4:	80 7d e6 01          	cmpb   $0x1,-0x1a(%ebp)
400372e8:	75 32                	jne    4003731c <OnRadioRxDone+0x4d4>
                        if((curMulticastParams->DownLinkCounter == downLinkCounter) &&
400372ea:	8b 46 24             	mov    0x24(%esi),%eax
                        McpsIndication.McpsIndication = MCPS_MULTICAST;
400372ed:	c7 05 58 77 00 a8 02 	movl   $0x2,0xa8007758
400372f4:	00 00 00 
                        if((curMulticastParams->DownLinkCounter == downLinkCounter) &&
400372f7:	85 c0                	test   %eax,%eax
400372f9:	0f 95 c2             	setne  %dl
400372fc:	39 c7                	cmp    %eax,%edi
400372fe:	0f 94 c0             	sete   %al
40037301:	20 c2                	and    %al,%dl
40037303:	88 55 e0             	mov    %dl,-0x20(%ebp)
40037306:	74 0f                	je     40037317 <OnRadioRxDone+0x4cf>
                            McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
40037308:	c7 05 5c 77 00 a8 06 	movl   $0x6,0xa800775c
4003730f:	00 00 00 
40037312:	e9 65 ff ff ff       	jmp    4003727c <OnRadioRxDone+0x434>
                        curMulticastParams->DownLinkCounter = downLinkCounter;
40037317:	89 7e 24             	mov    %edi,0x24(%esi)
4003731a:	eb 59                	jmp    40037375 <OnRadioRxDone+0x52d>
                        if(macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN) {
4003731c:	8a 45 d7             	mov    -0x29(%ebp),%al
4003731f:	83 e0 e0             	and    $0xffffffe0,%eax
40037322:	3c a0                	cmp    $0xa0,%al
40037324:	a1 4c 7a 00 a8       	mov    0xa8007a4c,%eax
40037329:	75 22                	jne    4003734d <OnRadioRxDone+0x505>
                            if((DownLinkCounter == downLinkCounter) &&
4003732b:	39 c7                	cmp    %eax,%edi
                            SrvAckRequested = true;
4003732d:	c6 05 42 7a 00 a8 01 	movb   $0x1,0xa8007a42
                            if((DownLinkCounter == downLinkCounter) &&
40037334:	0f 94 c2             	sete   %dl
40037337:	85 c0                	test   %eax,%eax
                            McpsIndication.McpsIndication = MCPS_CONFIRMED;
40037339:	c7 05 58 77 00 a8 01 	movl   $0x1,0xa8007758
40037340:	00 00 00 
                            if((DownLinkCounter == downLinkCounter) &&
40037343:	0f 95 c0             	setne  %al
40037346:	21 c2                	and    %eax,%edx
40037348:	88 55 e0             	mov    %dl,-0x20(%ebp)
4003734b:	eb 22                	jmp    4003736f <OnRadioRxDone+0x527>
                            if((DownLinkCounter == downLinkCounter) &&
4003734d:	39 c7                	cmp    %eax,%edi
                            SrvAckRequested = false;
4003734f:	c6 05 42 7a 00 a8 00 	movb   $0x0,0xa8007a42
                            if((DownLinkCounter == downLinkCounter) &&
40037356:	0f 94 c2             	sete   %dl
40037359:	85 c0                	test   %eax,%eax
                            McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
4003735b:	c7 05 58 77 00 a8 00 	movl   $0x0,0xa8007758
40037362:	00 00 00 
                            if((DownLinkCounter == downLinkCounter) &&
40037365:	0f 95 c0             	setne  %al
40037368:	20 c2                	and    %al,%dl
4003736a:	88 55 e0             	mov    %dl,-0x20(%ebp)
4003736d:	75 99                	jne    40037308 <OnRadioRxDone+0x4c0>
                        DownLinkCounter = downLinkCounter;
4003736f:	89 3d 4c 7a 00 a8    	mov    %edi,0xa8007a4c
                appPayloadStartIndex = 8 + fCtrl.Bits.FOptsLen;
40037375:	8a 45 d6             	mov    -0x2a(%ebp),%al
40037378:	8d 48 08             	lea    0x8(%eax),%ecx
                    if(((size - 4) - appPayloadStartIndex) > 0) {
4003737b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
4003737f:	0f b6 c9             	movzbl %cl,%ecx
40037382:	83 e8 04             	sub    $0x4,%eax
40037385:	29 c8                	sub    %ecx,%eax
40037387:	85 c0                	test   %eax,%eax
40037389:	0f 8e b9 00 00 00    	jle    40037448 <OnRadioRxDone+0x600>
                        port = payload[appPayloadStartIndex++];
4003738f:	8a 45 d6             	mov    -0x2a(%ebp),%al
                        frameLen = (size - 4) - appPayloadStartIndex;
40037392:	8a 55 ec             	mov    -0x14(%ebp),%dl
                        port = payload[appPayloadStartIndex++];
40037395:	83 c0 09             	add    $0x9,%eax
40037398:	88 45 e4             	mov    %al,-0x1c(%ebp)
4003739b:	8a 04 0b             	mov    (%ebx,%ecx,1),%al
                        frameLen = (size - 4) - appPayloadStartIndex;
4003739e:	2b 55 e4             	sub    -0x1c(%ebp),%edx
                        McpsIndication.Port = port;
400373a1:	a2 61 77 00 a8       	mov    %al,0xa8007761
                        frameLen = (size - 4) - appPayloadStartIndex;
400373a6:	83 ea 04             	sub    $0x4,%edx
                        if(port == 0) {
400373a9:	84 c0                	test   %al,%al
                        frameLen = (size - 4) - appPayloadStartIndex;
400373ab:	88 55 ec             	mov    %dl,-0x14(%ebp)
                        if(port == 0) {
400373ae:	75 3b                	jne    400373eb <OnRadioRxDone+0x5a3>
                            if(fCtrl.Bits.FOptsLen == 0) {
400373b0:	f6 45 e7 0f          	testb  $0xf,-0x19(%ebp)
400373b4:	0f 85 84 fe ff ff    	jne    4003723e <OnRadioRxDone+0x3f6>
                                LoRaMacPayloadDecrypt(payload + appPayloadStartIndex,
400373ba:	68 60 7a 00 a8       	push   $0xa8007a60
400373bf:	57                   	push   %edi
400373c0:	6a 01                	push   $0x1
400373c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
400373c5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
400373c9:	ff 75 e8             	pushl  -0x18(%ebp)
400373cc:	0f b6 f2             	movzbl %dl,%esi
400373cf:	01 d8                	add    %ebx,%eax
400373d1:	89 f2                	mov    %esi,%edx
400373d3:	e8 fc 18 00 00       	call   40038cd4 <LoRaMacPayloadDecrypt>
400373d8:	83 c4 10             	add    $0x10,%esp
                                ProcessMacCommands(LoRaMacRxPayload, 0, frameLen, snr);
400373db:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
400373df:	89 f1                	mov    %esi,%ecx
400373e1:	50                   	push   %eax
400373e2:	31 d2                	xor    %edx,%edx
400373e4:	b8 60 7a 00 a8       	mov    $0xa8007a60,%eax
400373e9:	eb 6f                	jmp    4003745a <OnRadioRxDone+0x612>
                            if(fCtrl.Bits.FOptsLen > 0) {
400373eb:	f6 45 e7 0f          	testb  $0xf,-0x19(%ebp)
400373ef:	74 12                	je     40037403 <OnRadioRxDone+0x5bb>
                                ProcessMacCommands(payload, 8, appPayloadStartIndex - 1, snr);
400373f1:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
400373f5:	ba 08 00 00 00       	mov    $0x8,%edx
400373fa:	50                   	push   %eax
400373fb:	89 d8                	mov    %ebx,%eax
400373fd:	e8 33 f6 ff ff       	call   40036a35 <ProcessMacCommands>
40037402:	5a                   	pop    %edx
                            LoRaMacPayloadDecrypt(payload + appPayloadStartIndex,
40037403:	68 60 7a 00 a8       	push   $0xa8007a60
40037408:	57                   	push   %edi
40037409:	6a 01                	push   $0x1
4003740b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
4003740e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
40037412:	ff 75 e8             	pushl  -0x18(%ebp)
40037415:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
40037419:	01 d8                	add    %ebx,%eax
4003741b:	e8 b4 18 00 00       	call   40038cd4 <LoRaMacPayloadDecrypt>
40037420:	83 c4 10             	add    $0x10,%esp
                            if(skipIndication == false) {
40037423:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
40037427:	0f 85 11 fe ff ff    	jne    4003723e <OnRadioRxDone+0x3f6>
                                McpsIndication.BufferSize = frameLen;
4003742d:	8a 45 ec             	mov    -0x14(%ebp),%al
                                McpsIndication.Buffer = LoRaMacRxPayload;
40037430:	c7 05 64 77 00 a8 60 	movl   $0xa8007a60,0xa8007764
40037437:	7a 00 a8 
                                McpsIndication.BufferSize = frameLen;
4003743a:	a2 68 77 00 a8       	mov    %al,0xa8007768
                                McpsIndication.RxData = true;
4003743f:	c6 05 69 77 00 a8 01 	movb   $0x1,0xa8007769
40037446:	eb 22                	jmp    4003746a <OnRadioRxDone+0x622>
                        if(fCtrl.Bits.FOptsLen > 0) {
40037448:	f6 45 e7 0f          	testb  $0xf,-0x19(%ebp)
4003744c:	74 12                	je     40037460 <OnRadioRxDone+0x618>
                            ProcessMacCommands(payload, 8, appPayloadStartIndex, snr);
4003744e:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
40037452:	ba 08 00 00 00       	mov    $0x8,%edx
40037457:	50                   	push   %eax
40037458:	89 d8                	mov    %ebx,%eax
4003745a:	e8 d6 f5 ff ff       	call   40036a35 <ProcessMacCommands>
4003745f:	58                   	pop    %eax
                    if(skipIndication == false) {
40037460:	80 7d e0 00          	cmpb   $0x0,-0x20(%ebp)
40037464:	0f 85 d4 fd ff ff    	jne    4003723e <OnRadioRxDone+0x3f6>
                        if(fCtrl.Bits.Ack == 1) {
4003746a:	f6 45 e7 20          	testb  $0x20,-0x19(%ebp)
4003746e:	0f 84 9a fd ff ff    	je     4003720e <OnRadioRxDone+0x3c6>
                            McpsConfirm.AckReceived = true;
40037474:	c6 05 4a 77 00 a8 01 	movb   $0x1,0xa800774a
                            McpsIndication.AckReceived = true;
4003747b:	c6 05 6e 77 00 a8 01 	movb   $0x1,0xa800776e
                                k_timer_stop(&AckTimeoutTimer);
40037482:	b8 e0 84 00 a8       	mov    $0xa80084e0,%eax
40037487:	e8 ed 32 00 00       	call   4003a779 <k_timer_stop>
4003748c:	e9 95 fd ff ff       	jmp    40037226 <OnRadioRxDone+0x3de>
                if(sequenceCounterDiff >= MAX_FCNT_GAP) {
40037491:	66 81 7d e4 ff 3f    	cmpw   $0x3fff,-0x1c(%ebp)
40037497:	0f 87 5f fd ff ff    	ja     400371fc <OnRadioRxDone+0x3b4>
                    McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
4003749d:	c7 05 5c 77 00 a8 0a 	movl   $0xa,0xa800775c
400374a4:	00 00 00 
400374a7:	e9 d0 fd ff ff       	jmp    4003727c <OnRadioRxDone+0x434>
}
400374ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
400374af:	5b                   	pop    %ebx
400374b0:	5e                   	pop    %esi
400374b1:	5f                   	pop    %edi
400374b2:	5d                   	pop    %ebp
400374b3:	c3                   	ret    

400374b4 <SendFrameOnChannel>:
    txPowerIndex = LimitTxPower( LoRaMacParams.ChannelsTxPower, Bands[channel.Band].TxMaxPower );
400374b4:	0f b6 d6             	movzbl %dh,%edx
400374b7:	6b d2 0c             	imul   $0xc,%edx,%edx
{
400374ba:	55                   	push   %ebp
400374bb:	89 e5                	mov    %esp,%ebp
400374bd:	56                   	push   %esi
400374be:	53                   	push   %ebx
400374bf:	51                   	push   %ecx
400374c0:	89 c6                	mov    %eax,%esi
    int8_t datarate = Datarates[LoRaMacParams.ChannelsDatarate];
400374c2:	0f be 05 a1 84 00 a8 	movsbl 0xa80084a1,%eax
400374c9:	89 c3                	mov    %eax,%ebx
400374cb:	8a 80 b4 cc 03 40    	mov    0x4003ccb4(%eax),%al
    txPowerIndex = LimitTxPower( LoRaMacParams.ChannelsTxPower, Bands[channel.Band].TxMaxPower );
400374d1:	0f be 92 22 67 00 a8 	movsbl -0x57ff98de(%edx),%edx
    int8_t datarate = Datarates[LoRaMacParams.ChannelsDatarate];
400374d8:	88 45 f7             	mov    %al,-0x9(%ebp)
    txPowerIndex = LimitTxPower( LoRaMacParams.ChannelsTxPower, Bands[channel.Band].TxMaxPower );
400374db:	0f be 05 a0 84 00 a8 	movsbl 0xa80084a0,%eax
400374e2:	e8 04 f5 ff ff       	call   400369eb <LimitTxPower>
    MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
400374e7:	c7 05 34 77 00 a8 01 	movl   $0x1,0xa8007734
400374ee:	00 00 00 
    txPower = TxPowers[txPowerIndex];
400374f1:	0f be d0             	movsbl %al,%edx
    McpsConfirm.TxPower = txPowerIndex;
400374f4:	a2 49 77 00 a8       	mov    %al,0xa8007749
    sx1276_set_channel(dev, channel.Frequency);
400374f9:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
    txPower = TxPowers[txPowerIndex];
400374fe:	8a 8a 74 cc 03 40    	mov    0x4003cc74(%edx),%cl
    sx1276_set_channel(dev, channel.Frequency);
40037504:	89 f2                	mov    %esi,%edx
    txPower = TxPowers[txPowerIndex];
40037506:	88 4d f6             	mov    %cl,-0xa(%ebp)
    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
40037509:	c7 05 44 77 00 a8 01 	movl   $0x1,0xa8007744
40037510:	00 00 00 
    McpsConfirm.Datarate = LoRaMacParams.ChannelsDatarate;
40037513:	88 1d 48 77 00 a8    	mov    %bl,0xa8007748
    McpsConfirm.UpLinkFrequency = channel.Frequency;
40037519:	89 35 54 77 00 a8    	mov    %esi,0xa8007754
    sx1276_set_channel(dev, channel.Frequency);
4003751f:	e8 63 d2 ff ff       	call   40034787 <sx1276_set_channel>
    sx1276_set_max_payload_length(dev, MODEM_LORA, LoRaMacBufferPktLen);
40037524:	31 d2                	xor    %edx,%edx
40037526:	0f b6 0d 60 7c 00 a8 	movzbl 0xa8007c60,%ecx
4003752d:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40037532:	e8 1f e8 ff ff       	call   40035d56 <sx1276_set_max_payload_length>
    if( LoRaMacParams.ChannelsDatarate >= DR_4 )
40037537:	80 3d a1 84 00 a8 03 	cmpb   $0x3,0xa80084a1
4003753e:	0f be 4d f6          	movsbl -0xa(%ebp),%ecx
40037542:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
40037546:	7e 13                	jle    4003755b <SendFrameOnChannel+0xa7>
        sx1276_set_tx_config(dev, MODEM_LORA, txPower, 0, 2, datarate, 1, 8, false, true, 0, 0, false);
40037548:	6a 00                	push   $0x0
4003754a:	6a 00                	push   $0x0
4003754c:	6a 00                	push   $0x0
4003754e:	6a 01                	push   $0x1
40037550:	6a 00                	push   $0x0
40037552:	6a 08                	push   $0x8
40037554:	6a 01                	push   $0x1
40037556:	50                   	push   %eax
40037557:	6a 02                	push   $0x2
40037559:	eb 11                	jmp    4003756c <SendFrameOnChannel+0xb8>
        sx1276_set_tx_config(dev, MODEM_LORA, txPower, 0, 0, datarate, 1, 8, false, true, 0, 0, false);
4003755b:	6a 00                	push   $0x0
4003755d:	6a 00                	push   $0x0
4003755f:	6a 00                	push   $0x0
40037561:	6a 01                	push   $0x1
40037563:	6a 00                	push   $0x0
40037565:	6a 08                	push   $0x8
40037567:	6a 01                	push   $0x1
40037569:	50                   	push   %eax
4003756a:	6a 00                	push   $0x0
4003756c:	31 d2                	xor    %edx,%edx
4003756e:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40037573:	6a 00                	push   $0x0
40037575:	e8 a5 d4 ff ff       	call   40034a1f <sx1276_set_tx_config>
        TxTimeOnAir = sx1276_get_time_on_air(dev, MODEM_LORA, LoRaMacBufferPktLen);
4003757a:	0f b6 0d 60 7c 00 a8 	movzbl 0xa8007c60,%ecx
        sx1276_set_tx_config(dev, MODEM_LORA, txPower, 0, 0, datarate, 1, 8, false, true, 0, 0, false);
40037581:	83 c4 28             	add    $0x28,%esp
        TxTimeOnAir = sx1276_get_time_on_air(dev, MODEM_LORA, LoRaMacBufferPktLen);
40037584:	31 d2                	xor    %edx,%edx
40037586:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
4003758b:	e8 97 e8 ff ff       	call   40035e27 <sx1276_get_time_on_air>
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
40037590:	31 c9                	xor    %ecx,%ecx
        TxTimeOnAir = sx1276_get_time_on_air(dev, MODEM_LORA, LoRaMacBufferPktLen);
40037592:	a3 78 77 00 a8       	mov    %eax,0xa8007778
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
40037597:	ba e8 03 00 00       	mov    $0x3e8,%edx
    McpsConfirm.TxTimeOnAir = TxTimeOnAir;
4003759c:	a1 78 77 00 a8       	mov    0xa8007778,%eax
400375a1:	a3 4c 77 00 a8       	mov    %eax,0xa800774c
    MlmeConfirm.TxTimeOnAir = TxTimeOnAir;
400375a6:	a3 38 77 00 a8       	mov    %eax,0xa8007738
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
400375ab:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
400375b0:	e8 65 31 00 00       	call   4003a71a <k_timer_start>
    if( IsLoRaMacNetworkJoined == false )
400375b5:	80 3d 49 7a 00 a8 00 	cmpb   $0x0,0xa8007a49
400375bc:	75 06                	jne    400375c4 <SendFrameOnChannel+0x110>
        JoinRequestTrials++;
400375be:	fe 05 75 77 00 a8    	incb   0xa8007775
    dev->settings->loraSettings->TxTimeout = 3e3;
400375c4:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
    sx1276_send(dev, LoRaMacBuffer, LoRaMacBufferPktLen, dev->settings->loraSettings->TxTimeout);
400375c9:	0f b6 0d 60 7c 00 a8 	movzbl 0xa8007c60,%ecx
    dev->settings->loraSettings->TxTimeout = 3e3;
400375d0:	8b 50 24             	mov    0x24(%eax),%edx
400375d3:	8b 52 0c             	mov    0xc(%edx),%edx
400375d6:	c7 42 18 b8 0b 00 00 	movl   $0xbb8,0x18(%edx)
    sx1276_send(dev, LoRaMacBuffer, LoRaMacBufferPktLen, dev->settings->loraSettings->TxTimeout);
400375dd:	ba 80 7c 00 a8       	mov    $0xa8007c80,%edx
400375e2:	68 b8 0b 00 00       	push   $0xbb8
400375e7:	e8 43 e6 ff ff       	call   40035c2f <sx1276_send>
400375ec:	58                   	pop    %eax
}
400375ed:	31 c0                	xor    %eax,%eax
    LoRaMacState |= LORAMAC_TX_RUNNING;
400375ef:	83 0d ac 77 00 a8 01 	orl    $0x1,0xa80077ac
}
400375f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
400375f9:	5b                   	pop    %ebx
400375fa:	5e                   	pop    %esi
400375fb:	5d                   	pop    %ebp
400375fc:	c3                   	ret    

400375fd <ScheduleTx>:
    if( MaxDCycle == 255 )
400375fd:	8a 15 c6 77 00 a8    	mov    0xa80077c6,%dl
        return LORAMAC_STATUS_DEVICE_OFF;
40037603:	b8 0a 00 00 00       	mov    $0xa,%eax
    if( MaxDCycle == 255 )
40037608:	80 fa ff             	cmp    $0xff,%dl
4003760b:	0f 84 62 02 00 00    	je     40037873 <ScheduleTx+0x276>
{
40037611:	55                   	push   %ebp
40037612:	89 e5                	mov    %esp,%ebp
40037614:	57                   	push   %edi
40037615:	56                   	push   %esi
40037616:	53                   	push   %ebx
40037617:	83 ec 6c             	sub    $0x6c,%esp
    if( MaxDCycle == 0 )
4003761a:	84 d2                	test   %dl,%dl
4003761c:	75 0a                	jne    40037628 <ScheduleTx+0x2b>
        AggregatedTimeOff = 0;
4003761e:	c7 05 bc 77 00 a8 00 	movl   $0x0,0xa80077bc
40037625:	00 00 00 
    memset( enabledChannels, 0, LORA_MAX_NB_CHANNELS );
40037628:	31 d2                	xor    %edx,%edx
4003762a:	b9 48 00 00 00       	mov    $0x48,%ecx
4003762f:	8d 45 ac             	lea    -0x54(%ebp),%eax
40037632:	e8 3e 8a ff ff       	call   40030075 <memset>
    if( CountNbEnabled125kHzChannels( ChannelsMaskRemaining ) == 0 )
40037637:	b8 c8 77 00 a8       	mov    $0xa80077c8,%eax
4003763c:	e8 5e f3 ff ff       	call   4003699f <CountNbEnabled125kHzChannels>
40037641:	84 c0                	test   %al,%al
40037643:	75 14                	jne    40037659 <ScheduleTx+0x5c>
        memcpy( ( uint8_t* ) ChannelsMaskRemaining, ( uint8_t* ) LoRaMacParams.ChannelsMask, 8 );
40037645:	b9 08 00 00 00       	mov    $0x8,%ecx
4003764a:	ba c4 84 00 a8       	mov    $0xa80084c4,%edx
4003764f:	b8 c8 77 00 a8       	mov    $0xa80077c8,%eax
40037654:	e8 11 8a ff ff       	call   4003006a <memcpy>
    if( ( LoRaMacParams.ChannelsDatarate >= DR_4 ) && ( ( ChannelsMaskRemaining[4] & 0x00FF ) == 0 ) )
40037659:	80 3d a1 84 00 a8 03 	cmpb   $0x3,0xa80084a1
40037660:	7e 14                	jle    40037676 <ScheduleTx+0x79>
40037662:	80 3d d0 77 00 a8 00 	cmpb   $0x0,0xa80077d0
40037669:	75 0b                	jne    40037676 <ScheduleTx+0x79>
        ChannelsMaskRemaining[4] = LoRaMacParams.ChannelsMask[4];
4003766b:	a1 cc 84 00 a8       	mov    0xa80084cc,%eax
40037670:	66 a3 d0 77 00 a8    	mov    %ax,0xa80077d0
40037676:	a1 c0 77 00 a8       	mov    0xa80077c0,%eax
4003767b:	89 45 9c             	mov    %eax,-0x64(%ebp)
    return k_uptime_delta_32(&ref_time);
4003767e:	8d 45 9c             	lea    -0x64(%ebp),%eax
40037681:	e8 89 2a 00 00       	call   4003a10f <k_uptime_delta_32>
    if( AggregatedTimeOff <= TimerGetElapsedTime( AggregatedLastTxDoneTime ) )
40037686:	8b 1d bc 77 00 a8    	mov    0xa80077bc,%ebx
4003768c:	39 d8                	cmp    %ebx,%eax
4003768e:	0f 82 20 01 00 00    	jb     400377b4 <ScheduleTx+0x1b7>
        AggregatedTimeOff = 0;
40037694:	c7 05 bc 77 00 a8 00 	movl   $0x0,0xa80077bc
4003769b:	00 00 00 
            if( ( IsLoRaMacNetworkJoined == false ) || ( DutyCycleOn == true ) )
4003769e:	80 3d 49 7a 00 a8 00 	cmpb   $0x0,0xa8007a49
400376a5:	74 09                	je     400376b0 <ScheduleTx+0xb3>
400376a7:	80 3d b9 77 00 a8 00 	cmpb   $0x0,0xa80077b9
400376ae:	74 5f                	je     4003770f <ScheduleTx+0x112>
400376b0:	a1 24 67 00 a8       	mov    0xa8006724,%eax
                if( Bands[i].TimeOff <= TimerGetElapsedTime( Bands[i].LastTxDoneTime ) )
400376b5:	8b 1d 28 67 00 a8    	mov    0xa8006728,%ebx
400376bb:	89 45 a8             	mov    %eax,-0x58(%ebp)
    return k_uptime_delta_32(&ref_time);
400376be:	8d 45 a8             	lea    -0x58(%ebp),%eax
400376c1:	e8 49 2a 00 00       	call   4003a10f <k_uptime_delta_32>
                if( Bands[i].TimeOff <= TimerGetElapsedTime( Bands[i].LastTxDoneTime ) )
400376c6:	39 c3                	cmp    %eax,%ebx
400376c8:	77 0a                	ja     400376d4 <ScheduleTx+0xd7>
                    Bands[i].TimeOff = 0;
400376ca:	c7 05 28 67 00 a8 00 	movl   $0x0,0xa8006728
400376d1:	00 00 00 
                if( Bands[i].TimeOff != 0 )
400376d4:	8b 1d 28 67 00 a8    	mov    0xa8006728,%ebx
400376da:	85 db                	test   %ebx,%ebx
400376dc:	74 3b                	je     40037719 <ScheduleTx+0x11c>
400376de:	a1 24 67 00 a8       	mov    0xa8006724,%eax
400376e3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    return k_uptime_delta_32(&ref_time);
400376e6:	8d 45 a4             	lea    -0x5c(%ebp),%eax
400376e9:	e8 21 2a 00 00       	call   4003a10f <k_uptime_delta_32>
                    nextTxDelay = UPM_MIN( Bands[i].TimeOff - TimerGetElapsedTime( Bands[i].LastTxDoneTime ), nextTxDelay );
400376ee:	29 c3                	sub    %eax,%ebx
400376f0:	43                   	inc    %ebx
400376f1:	74 26                	je     40037719 <ScheduleTx+0x11c>
400376f3:	a1 24 67 00 a8       	mov    0xa8006724,%eax
400376f8:	8b 1d 28 67 00 a8    	mov    0xa8006728,%ebx
400376fe:	89 45 a0             	mov    %eax,-0x60(%ebp)
    return k_uptime_delta_32(&ref_time);
40037701:	8d 45 a0             	lea    -0x60(%ebp),%eax
40037704:	e8 06 2a 00 00       	call   4003a10f <k_uptime_delta_32>
                    nextTxDelay = UPM_MIN( Bands[i].TimeOff - TimerGetElapsedTime( Bands[i].LastTxDoneTime ), nextTxDelay );
40037709:	89 da                	mov    %ebx,%edx
4003770b:	29 c2                	sub    %eax,%edx
4003770d:	eb 0d                	jmp    4003771c <ScheduleTx+0x11f>
                    Bands[i].TimeOff = 0;
4003770f:	c7 05 28 67 00 a8 00 	movl   $0x0,0xa8006728
40037716:	00 00 00 
40037719:	83 ca ff             	or     $0xffffffff,%edx
                    if( ( ( Channels[i + j].DrRange.Fields.Min <= LoRaMacParams.ChannelsDatarate ) &&
4003771c:	a0 a1 84 00 a8       	mov    0xa80084a1,%al
40037721:	bf c8 77 00 a8       	mov    $0xa80077c8,%edi
40037726:	88 45 96             	mov    %al,-0x6a(%ebp)
40037729:	c7 45 8c e0 77 00 a8 	movl   $0xa80077e0,-0x74(%ebp)
40037730:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
40037737:	c6 45 95 00          	movb   $0x0,-0x6b(%ebp)
4003773b:	c6 45 97 00          	movb   $0x0,-0x69(%ebp)
4003773f:	8a 45 90             	mov    -0x70(%ebp),%al
                if( ( ChannelsMaskRemaining[k] & ( 1 << j ) ) != 0 )
40037742:	8b 75 8c             	mov    -0x74(%ebp),%esi
40037745:	88 45 94             	mov    %al,-0x6c(%ebp)
40037748:	0f b7 07             	movzwl (%edi),%eax
4003774b:	89 45 88             	mov    %eax,-0x78(%ebp)
4003774e:	31 c0                	xor    %eax,%eax
40037750:	8b 5d 88             	mov    -0x78(%ebp),%ebx
40037753:	0f a3 c3             	bt     %eax,%ebx
40037756:	73 40                	jae    40037798 <ScheduleTx+0x19b>
40037758:	8b 4d 90             	mov    -0x70(%ebp),%ecx
                    if( Channels[i + j].Frequency == 0 )
4003775b:	83 3e 00             	cmpl   $0x0,(%esi)
4003775e:	8d 1c 08             	lea    (%eax,%ecx,1),%ebx
40037761:	74 35                	je     40037798 <ScheduleTx+0x19b>
                    if( ( ( Channels[i + j].DrRange.Fields.Min <= LoRaMacParams.ChannelsDatarate ) &&
40037763:	8a 1c dd e4 77 00 a8 	mov    -0x57ff881c(,%ebx,8),%bl
4003776a:	88 d9                	mov    %bl,%cl
4003776c:	c1 e3 04             	shl    $0x4,%ebx
4003776f:	c0 fb 04             	sar    $0x4,%bl
40037772:	3a 5d 96             	cmp    -0x6a(%ebp),%bl
40037775:	7f 21                	jg     40037798 <ScheduleTx+0x19b>
                          ( LoRaMacParams.ChannelsDatarate <= Channels[i + j].DrRange.Fields.Max ) ) == false )
40037777:	88 cb                	mov    %cl,%bl
40037779:	c0 fb 04             	sar    $0x4,%bl
                    if( ( ( Channels[i + j].DrRange.Fields.Min <= LoRaMacParams.ChannelsDatarate ) &&
4003777c:	38 5d 96             	cmp    %bl,-0x6a(%ebp)
4003777f:	7f 17                	jg     40037798 <ScheduleTx+0x19b>
                    if( Bands[Channels[i + j].Band].TimeOff > 0 )
40037781:	0f b6 5e 05          	movzbl 0x5(%esi),%ebx
40037785:	6b db 0c             	imul   $0xc,%ebx,%ebx
40037788:	83 bb 28 67 00 a8 00 	cmpl   $0x0,-0x57ff98d8(%ebx)
4003778f:	0f 84 b1 00 00 00    	je     40037846 <ScheduleTx+0x249>
                        delayTx++;
40037795:	fe 45 95             	incb   -0x6b(%ebp)
40037798:	40                   	inc    %eax
40037799:	83 c6 08             	add    $0x8,%esi
            for( uint8_t j = 0; j < 16; j++ )
4003779c:	83 f8 10             	cmp    $0x10,%eax
4003779f:	75 af                	jne    40037750 <ScheduleTx+0x153>
400377a1:	83 45 90 10          	addl   $0x10,-0x70(%ebp)
400377a5:	83 c7 02             	add    $0x2,%edi
400377a8:	83 6d 8c 80          	subl   $0xffffff80,-0x74(%ebp)
        for( uint8_t i = 0, k = 0; i < LORA_MAX_NB_CHANNELS; i += 16, k++ )
400377ac:	83 7d 90 50          	cmpl   $0x50,-0x70(%ebp)
400377b0:	75 8d                	jne    4003773f <ScheduleTx+0x142>
400377b2:	eb 16                	jmp    400377ca <ScheduleTx+0x1cd>
400377b4:	a1 c0 77 00 a8       	mov    0xa80077c0,%eax
400377b9:	89 45 98             	mov    %eax,-0x68(%ebp)
    return k_uptime_delta_32(&ref_time);
400377bc:	8d 45 98             	lea    -0x68(%ebp),%eax
400377bf:	e8 4b 29 00 00       	call   4003a10f <k_uptime_delta_32>
        nextTxDelay = AggregatedTimeOff - TimerGetElapsedTime( AggregatedLastTxDoneTime );
400377c4:	89 da                	mov    %ebx,%edx
400377c6:	29 c2                	sub    %eax,%edx
400377c8:	eb 45                	jmp    4003780f <ScheduleTx+0x212>
    if( nbEnabledChannels > 0 )
400377ca:	80 7d 97 00          	cmpb   $0x0,-0x69(%ebp)
400377ce:	74 39                	je     40037809 <ScheduleTx+0x20c>
        Channel = enabledChannels[upm_rand_range( 0, nbEnabledChannels - 1 )];
400377d0:	0f b6 55 97          	movzbl -0x69(%ebp),%edx
400377d4:	31 c0                	xor    %eax,%eax
400377d6:	4a                   	dec    %edx
400377d7:	e8 80 cd ff ff       	call   4003455c <upm_rand_range>
400377dc:	8a 4c 05 ac          	mov    -0x54(%ebp,%eax,1),%cl
400377e0:	88 0d b8 77 00 a8    	mov    %cl,0xa80077b8
        if( Channel < ( LORA_MAX_NB_CHANNELS - 8 ) )
400377e6:	80 f9 3f             	cmp    $0x3f,%cl
400377e9:	77 28                	ja     40037813 <ScheduleTx+0x216>
    index = id / 16;
400377eb:	88 ca                	mov    %cl,%dl
    mask[index] &= ~( 1 << ( id % 16 ) );
400377ed:	b8 01 00 00 00       	mov    $0x1,%eax
    index = id / 16;
400377f2:	c0 ea 04             	shr    $0x4,%dl
    mask[index] &= ~( 1 << ( id % 16 ) );
400377f5:	83 e1 0f             	and    $0xf,%ecx
400377f8:	0f b6 d2             	movzbl %dl,%edx
400377fb:	d3 e0                	shl    %cl,%eax
400377fd:	f7 d0                	not    %eax
400377ff:	66 21 84 12 c8 77 00 	and    %ax,-0x57ff8838(%edx,%edx,1)
40037806:	a8 
40037807:	eb 0a                	jmp    40037813 <ScheduleTx+0x216>
        if( delayTx > 0 )
40037809:	80 7d 95 00          	cmpb   $0x0,-0x6b(%ebp)
4003780d:	74 4e                	je     4003785d <ScheduleTx+0x260>
    if( dutyCycleTimeOff == 0 )
4003780f:	85 d2                	test   %edx,%edx
40037811:	75 1c                	jne    4003782f <ScheduleTx+0x232>
        return SendFrameOnChannel( Channels[Channel] );
40037813:	0f b6 05 b8 77 00 a8 	movzbl 0xa80077b8,%eax
4003781a:	8b 14 c5 e4 77 00 a8 	mov    -0x57ff881c(,%eax,8),%edx
40037821:	8b 04 c5 e0 77 00 a8 	mov    -0x57ff8820(,%eax,8),%eax
40037828:	e8 87 fc ff ff       	call   400374b4 <SendFrameOnChannel>
4003782d:	eb 3d                	jmp    4003786c <ScheduleTx+0x26f>
        k_timer_start(&TxDelayedTimer, dutyCycleTimeOff, 0);
4003782f:	b8 60 84 00 a8       	mov    $0xa8008460,%eax
40037834:	31 c9                	xor    %ecx,%ecx
        LoRaMacState |= LORAMAC_TX_DELAYED;
40037836:	83 0d ac 77 00 a8 10 	orl    $0x10,0xa80077ac
        k_timer_start(&TxDelayedTimer, dutyCycleTimeOff, 0);
4003783d:	e8 d8 2e 00 00       	call   4003a71a <k_timer_start>
        return LORAMAC_STATUS_OK;
40037842:	31 c0                	xor    %eax,%eax
40037844:	eb 26                	jmp    4003786c <ScheduleTx+0x26f>
                    enabledChannels[nbEnabledChannels++] = i + j;
40037846:	0f b6 5d 97          	movzbl -0x69(%ebp),%ebx
4003784a:	89 d9                	mov    %ebx,%ecx
4003784c:	8a 5d 94             	mov    -0x6c(%ebp),%bl
4003784f:	01 c3                	add    %eax,%ebx
40037851:	fe 45 97             	incb   -0x69(%ebp)
40037854:	88 5c 0d ac          	mov    %bl,-0x54(%ebp,%ecx,1)
40037858:	e9 3b ff ff ff       	jmp    40037798 <ScheduleTx+0x19b>
        LoRaMacParams.ChannelsDatarate = LoRaMacParamsDefaults.ChannelsDatarate;
4003785d:	a0 21 84 00 a8       	mov    0xa8008421,%al
40037862:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
40037867:	e9 bc fd ff ff       	jmp    40037628 <ScheduleTx+0x2b>
}
4003786c:	83 c4 6c             	add    $0x6c,%esp
4003786f:	5b                   	pop    %ebx
40037870:	5e                   	pop    %esi
40037871:	5f                   	pop    %edi
40037872:	5d                   	pop    %ebp
40037873:	c3                   	ret    

40037874 <SetTxContinuousWave>:
{
40037874:	55                   	push   %ebp
40037875:	89 e5                	mov    %esp,%ebp
40037877:	56                   	push   %esi
40037878:	89 c6                	mov    %eax,%esi
4003787a:	53                   	push   %ebx
    txPowerIndex = LimitTxPower( LoRaMacParams.ChannelsTxPower, Bands[Channels[Channel].Band].TxMaxPower );
4003787b:	0f b6 05 b8 77 00 a8 	movzbl 0xa80077b8,%eax
    sx1276_set_tx_continuous_wave(dev, Channels[Channel].Frequency, txPower, timeout);
40037882:	0f b7 f6             	movzwl %si,%esi
    txPowerIndex = LimitTxPower( LoRaMacParams.ChannelsTxPower, Bands[Channels[Channel].Band].TxMaxPower );
40037885:	0f b6 04 c5 e5 77 00 	movzbl -0x57ff881b(,%eax,8),%eax
4003788c:	a8 
4003788d:	6b c0 0c             	imul   $0xc,%eax,%eax
40037890:	0f be 90 22 67 00 a8 	movsbl -0x57ff98de(%eax),%edx
40037897:	0f be 05 a0 84 00 a8 	movsbl 0xa80084a0,%eax
4003789e:	e8 48 f1 ff ff       	call   400369eb <LimitTxPower>
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
400378a3:	31 c9                	xor    %ecx,%ecx
    txPower = TxPowers[txPowerIndex];
400378a5:	0f be c0             	movsbl %al,%eax
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
400378a8:	ba e8 03 00 00       	mov    $0x3e8,%edx
    txPower = TxPowers[txPowerIndex];
400378ad:	8a 98 74 cc 03 40    	mov    0x4003cc74(%eax),%bl
    k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
400378b3:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
400378b8:	e8 5d 2e 00 00       	call   4003a71a <k_timer_start>
    sx1276_set_tx_continuous_wave(dev, Channels[Channel].Frequency, txPower, timeout);
400378bd:	56                   	push   %esi
400378be:	0f b6 05 b8 77 00 a8 	movzbl 0xa80077b8,%eax
400378c5:	0f be cb             	movsbl %bl,%ecx
400378c8:	8b 14 c5 e0 77 00 a8 	mov    -0x57ff8820(,%eax,8),%edx
400378cf:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
400378d4:	e8 00 e7 ff ff       	call   40035fd9 <sx1276_set_tx_continuous_wave>
400378d9:	58                   	pop    %eax
    LoRaMacState |= LORAMAC_TX_RUNNING;
400378da:	83 0d ac 77 00 a8 01 	orl    $0x1,0xa80077ac
}
400378e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
400378e4:	31 c0                	xor    %eax,%eax
400378e6:	5b                   	pop    %ebx
400378e7:	5e                   	pop    %esi
400378e8:	5d                   	pop    %ebp
400378e9:	c3                   	ret    

400378ea <LoRaMacInitialization>:
{
400378ea:	55                   	push   %ebp
400378eb:	89 e5                	mov    %esp,%ebp
400378ed:	56                   	push   %esi
400378ee:	53                   	push   %ebx
400378ef:	89 c3                	mov    %eax,%ebx
printf("entering loramac init function\n");
400378f1:	68 3c cb 03 40       	push   $0x4003cb3c
{
400378f6:	89 d6                	mov    %edx,%esi
printf("entering loramac init function\n");
400378f8:	e8 7b 33 00 00       	call   4003ac78 <iprintf>
400378fd:	58                   	pop    %eax
    if( primitives == NULL )
400378fe:	85 db                	test   %ebx,%ebx
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037900:	b8 03 00 00 00       	mov    $0x3,%eax
    if( primitives == NULL )
40037905:	0f 84 89 02 00 00    	je     40037b94 <LoRaMacInitialization+0x2aa>
    if( ( primitives->MacMcpsConfirm == NULL ) ||
4003790b:	83 3b 00             	cmpl   $0x0,(%ebx)
4003790e:	0f 84 80 02 00 00    	je     40037b94 <LoRaMacInitialization+0x2aa>
40037914:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
40037918:	0f 84 76 02 00 00    	je     40037b94 <LoRaMacInitialization+0x2aa>
        ( primitives->MacMcpsIndication == NULL ) ||
4003791e:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
40037922:	0f 84 6c 02 00 00    	je     40037b94 <LoRaMacInitialization+0x2aa>
    LoRaMacPrimitives = primitives;
40037928:	89 1d a8 77 00 a8    	mov    %ebx,0xa80077a8
    LoRaMacCallbacks = callbacks;
4003792e:	89 35 a4 77 00 a8    	mov    %esi,0xa80077a4
    LoRaMacFlags.Value = 0;
40037934:	c6 05 14 84 00 a8 00 	movb   $0x0,0xa8008414
    LoRaMacDeviceClass = CLASS_A;
4003793b:	c7 05 84 7d 00 a8 00 	movl   $0x0,0xa8007d84
40037942:	00 00 00 
    LoRaMacState = LORAMAC_IDLE;
40037945:	c7 05 ac 77 00 a8 00 	movl   $0x0,0xa80077ac
4003794c:	00 00 00 
    JoinRequestTrials = 0;
4003794f:	c6 05 75 77 00 a8 00 	movb   $0x0,0xa8007775
    MaxJoinRequestTrials = 1;
40037956:	c6 05 74 77 00 a8 01 	movb   $0x1,0xa8007774
    RepeaterSupport = false;
4003795d:	c6 05 7f 7d 00 a8 00 	movb   $0x0,0xa8007d7f
    AggregatedLastTxDoneTime = 0;
40037964:	c7 05 c0 77 00 a8 00 	movl   $0x0,0xa80077c0
4003796b:	00 00 00 
    AggregatedTimeOff = 0;
4003796e:	c7 05 bc 77 00 a8 00 	movl   $0x0,0xa80077bc
40037975:	00 00 00 
    DutyCycleOn = false;
40037978:	c6 05 b9 77 00 a8 00 	movb   $0x0,0xa80077b9
    LoRaMacParamsDefaults.ChannelsTxPower = LORAMAC_DEFAULT_TX_POWER;
4003797f:	c6 05 20 84 00 a8 05 	movb   $0x5,0xa8008420
    LoRaMacParamsDefaults.ChannelsDatarate = LORAMAC_DEFAULT_DATARATE;
40037986:	c6 05 21 84 00 a8 00 	movb   $0x0,0xa8008421
    LoRaMacParamsDefaults.MaxRxWindow = MAX_RX_WINDOW;
4003798d:	c7 05 24 84 00 a8 b8 	movl   $0xbb8,0xa8008424
40037994:	0b 00 00 
    LoRaMacParamsDefaults.ReceiveDelay1 = RECEIVE_DELAY1;
40037997:	c7 05 28 84 00 a8 e8 	movl   $0x3e8,0xa8008428
4003799e:	03 00 00 
    LoRaMacParamsDefaults.ReceiveDelay2 = RECEIVE_DELAY2;
400379a1:	c7 05 2c 84 00 a8 d0 	movl   $0x7d0,0xa800842c
400379a8:	07 00 00 
    LoRaMacParamsDefaults.JoinAcceptDelay1 = JOIN_ACCEPT_DELAY1;
400379ab:	c7 05 30 84 00 a8 88 	movl   $0x1388,0xa8008430
400379b2:	13 00 00 
    LoRaMacParamsDefaults.JoinAcceptDelay2 = JOIN_ACCEPT_DELAY2;
400379b5:	c7 05 34 84 00 a8 70 	movl   $0x1770,0xa8008434
400379bc:	17 00 00 
    LoRaMacParamsDefaults.ChannelsNbRep = 1;
400379bf:	c6 05 38 84 00 a8 01 	movb   $0x1,0xa8008438
    LoRaMacParamsDefaults.Rx1DrOffset = 0;
400379c6:	c6 05 39 84 00 a8 00 	movb   $0x0,0xa8008439
    LoRaMacParamsDefaults.Rx2Channel = ( Rx2ChannelParams_t )RX_WND_2_CHANNEL;
400379cd:	c7 05 3c 84 00 a8 a0 	movl   $0x370870a0,0xa800843c
400379d4:	70 08 37 
400379d7:	c6 05 40 84 00 a8 08 	movb   $0x8,0xa8008440
    LoRaMacParamsDefaults.ChannelsMask[0] = 0xFFFF;
400379de:	66 c7 05 44 84 00 a8 	movw   $0xffff,0xa8008444
400379e5:	ff ff 
    LoRaMacParamsDefaults.ChannelsMask[1] = 0xFFFF;
400379e7:	66 c7 05 46 84 00 a8 	movw   $0xffff,0xa8008446
400379ee:	ff ff 
    LoRaMacParamsDefaults.ChannelsMask[2] = 0xFFFF;
400379f0:	66 c7 05 48 84 00 a8 	movw   $0xffff,0xa8008448
400379f7:	ff ff 
    LoRaMacParamsDefaults.ChannelsMask[3] = 0xFFFF;
400379f9:	66 c7 05 4a 84 00 a8 	movw   $0xffff,0xa800844a
40037a00:	ff ff 
    LoRaMacParamsDefaults.ChannelsMask[4] = 0x00FF;
40037a02:	66 c7 05 4c 84 00 a8 	movw   $0xff,0xa800844c
40037a09:	ff 00 
    LoRaMacParamsDefaults.ChannelsMask[5] = 0x0000;
40037a0b:	66 c7 05 4e 84 00 a8 	movw   $0x0,0xa800844e
40037a12:	00 00 
40037a14:	31 db                	xor    %ebx,%ebx
        Channels[i].Frequency = 902.3e6 + i * 200e3;
40037a16:	89 d8                	mov    %ebx,%eax
40037a18:	e8 57 9c ff ff       	call   40031674 <__floatsidf>
40037a1d:	68 00 6a 08 41       	push   $0x41086a00
40037a22:	6a 00                	push   $0x0
40037a24:	e8 27 97 ff ff       	call   40031150 <__muldf3>
40037a29:	59                   	pop    %ecx
40037a2a:	5e                   	pop    %esi
40037a2b:	68 00 e4 ca 41       	push   $0x41cae400
40037a30:	68 00 00 00 b0       	push   $0xb0000000
40037a35:	e8 57 87 ff ff       	call   40030191 <__adddf3>
40037a3a:	59                   	pop    %ecx
40037a3b:	5e                   	pop    %esi
40037a3c:	e8 c6 9b ff ff       	call   40031607 <__fixunsdfsi>
        Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
40037a41:	c6 04 dd e4 77 00 a8 	movb   $0x30,-0x57ff881c(,%ebx,8)
40037a48:	30 
        Channels[i].Frequency = 902.3e6 + i * 200e3;
40037a49:	89 04 dd e0 77 00 a8 	mov    %eax,-0x57ff8820(,%ebx,8)
        Channels[i].Band = 0;
40037a50:	c6 04 dd e5 77 00 a8 	movb   $0x0,-0x57ff881b(,%ebx,8)
40037a57:	00 
40037a58:	43                   	inc    %ebx
    for( uint8_t i = 0; i < LORA_MAX_NB_CHANNELS - 8; i++ )
40037a59:	83 fb 40             	cmp    $0x40,%ebx
40037a5c:	75 b8                	jne    40037a16 <LoRaMacInitialization+0x12c>
40037a5e:	31 db                	xor    %ebx,%ebx
        Channels[i].Frequency = 903.0e6 + ( i - ( LORA_MAX_NB_CHANNELS - 8 ) ) * 1.6e6;
40037a60:	89 d8                	mov    %ebx,%eax
40037a62:	e8 0d 9c ff ff       	call   40031674 <__floatsidf>
40037a67:	68 00 6a 38 41       	push   $0x41386a00
40037a6c:	6a 00                	push   $0x0
40037a6e:	e8 dd 96 ff ff       	call   40031150 <__muldf3>
40037a73:	59                   	pop    %ecx
40037a74:	5e                   	pop    %esi
40037a75:	68 57 e9 ca 41       	push   $0x41cae957
40037a7a:	68 00 00 00 e0       	push   $0xe0000000
40037a7f:	e8 0d 87 ff ff       	call   40030191 <__adddf3>
40037a84:	59                   	pop    %ecx
40037a85:	5e                   	pop    %esi
40037a86:	e8 7c 9b ff ff       	call   40031607 <__fixunsdfsi>
        Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
40037a8b:	c6 04 dd e4 79 00 a8 	movb   $0x44,-0x57ff861c(,%ebx,8)
40037a92:	44 
        Channels[i].Frequency = 903.0e6 + ( i - ( LORA_MAX_NB_CHANNELS - 8 ) ) * 1.6e6;
40037a93:	89 04 dd e0 79 00 a8 	mov    %eax,-0x57ff8620(,%ebx,8)
        Channels[i].Band = 0;
40037a9a:	c6 04 dd e5 79 00 a8 	movb   $0x0,-0x57ff861b(,%ebx,8)
40037aa1:	00 
40037aa2:	43                   	inc    %ebx
    for( uint8_t i = LORA_MAX_NB_CHANNELS - 8; i < LORA_MAX_NB_CHANNELS; i++ )
40037aa3:	83 fb 08             	cmp    $0x8,%ebx
40037aa6:	75 b8                	jne    40037a60 <LoRaMacInitialization+0x176>
    ResetMacParameters( );
40037aa8:	e8 52 eb ff ff       	call   400365ff <ResetMacParameters>
    k_timer_init(&MacStateCheckTimer, OnMacStateCheckTimerEvent, NULL);
40037aad:	31 c9                	xor    %ecx,%ecx
40037aaf:	ba ed 87 03 40       	mov    $0x400387ed,%edx
40037ab4:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
40037ab9:	e8 1e 2c 00 00       	call   4003a6dc <k_timer_init>
    k_timer_init(&TxDelayedTimer, OnTxDelayedTimerEvent, NULL);
40037abe:	31 c9                	xor    %ecx,%ecx
40037ac0:	ba 7b 87 03 40       	mov    $0x4003877b,%edx
40037ac5:	b8 60 84 00 a8       	mov    $0xa8008460,%eax
40037aca:	e8 0d 2c 00 00       	call   4003a6dc <k_timer_init>
    k_timer_init(&RxWindowTimer1, OnRxWindow1TimerEvent, NULL);
40037acf:	31 c9                	xor    %ecx,%ecx
40037ad1:	ba 77 65 03 40       	mov    $0x40036577,%edx
40037ad6:	b8 e0 83 00 a8       	mov    $0xa80083e0,%eax
40037adb:	e8 fc 2b 00 00       	call   4003a6dc <k_timer_init>
    k_timer_init(&RxWindowTimer2, OnRxWindow2TimerEvent, NULL);
40037ae0:	31 c9                	xor    %ecx,%ecx
40037ae2:	ba 95 64 03 40       	mov    $0x40036495,%edx
40037ae7:	b8 00 82 00 a8       	mov    $0xa8008200,%eax
40037aec:	e8 eb 2b 00 00       	call   4003a6dc <k_timer_init>
    k_timer_init(&AckTimeoutTimer, OnAckTimeoutTimerEvent, NULL);
40037af1:	31 c9                	xor    %ecx,%ecx
40037af3:	ba 7e 63 03 40       	mov    $0x4003637e,%edx
40037af8:	b8 e0 84 00 a8       	mov    $0xa80084e0,%eax
40037afd:	e8 da 2b 00 00       	call   4003a6dc <k_timer_init>
printf("multiple timer inits done\n");
40037b02:	68 5c cb 03 40       	push   $0x4003cb5c
40037b07:	e8 6c 31 00 00       	call   4003ac78 <iprintf>
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b0c:	b9 52 00 00 00       	mov    $0x52,%ecx
40037b11:	ba 3c 00 00 00       	mov    $0x3c,%edx
40037b16:	b8 01 00 00 00       	mov    $0x1,%eax
40037b1b:	c7 04 24 88 77 00 a8 	movl   $0xa8007788,(%esp)
    RadioEvents.TxDone = OnRadioTxDone;
40037b22:	c7 05 88 77 00 a8 3d 	movl   $0x4003673d,0xa8007788
40037b29:	67 03 40 
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b2c:	6a 50                	push   $0x50
    RadioEvents.RxDone = OnRadioRxDone;
40037b2e:	c7 05 90 77 00 a8 48 	movl   $0x40036e48,0xa8007790
40037b35:	6e 03 40 
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b38:	6a 4e                	push   $0x4e
    RadioEvents.RxError = OnRadioRxError;
40037b3a:	c7 05 98 77 00 a8 53 	movl   $0x40036953,0xa8007798
40037b41:	69 03 40 
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b44:	6a 4c                	push   $0x4c
    RadioEvents.TxTimeout = OnRadioTxTimeout;
40037b46:	c7 05 8c 77 00 a8 f5 	movl   $0x400364f5,0xa800778c
40037b4d:	64 03 40 
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b50:	6a 46                	push   $0x46
    RadioEvents.RxTimeout = OnRadioRxTimeout;
40037b52:	c7 05 94 77 00 a8 07 	movl   $0x40036907,0xa8007794
40037b59:	69 03 40 
    dev = sx1276_init(1, 60, 82, 72, 74, 70, 76, 78, 80, &RadioEvents);
40037b5c:	6a 4a                	push   $0x4a
40037b5e:	6a 48                	push   $0x48
40037b60:	e8 2d d8 ff ff       	call   40035392 <sx1276_init>
40037b65:	83 c4 1c             	add    $0x1c,%esp
40037b68:	a3 b0 77 00 a8       	mov    %eax,0xa80077b0
    sx1276_random(dev);
40037b6d:	e8 52 e2 ff ff       	call   40035dc4 <sx1276_random>
    sx1276_set_public_network(dev, PublicNetwork);
40037b72:	ba 01 00 00 00       	mov    $0x1,%edx
40037b77:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
    PublicNetwork = true;
40037b7c:	c6 05 80 7d 00 a8 01 	movb   $0x1,0xa8007d80
    sx1276_set_public_network(dev, PublicNetwork);
40037b83:	e8 fb e1 ff ff       	call   40035d83 <sx1276_set_public_network>
    sx1276_set_sleep(dev);
40037b88:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40037b8d:	e8 a8 e1 ff ff       	call   40035d3a <sx1276_set_sleep>
    return LORAMAC_STATUS_OK;
40037b92:	31 c0                	xor    %eax,%eax
}
40037b94:	8d 65 f8             	lea    -0x8(%ebp),%esp
40037b97:	5b                   	pop    %ebx
40037b98:	5e                   	pop    %esi
40037b99:	5d                   	pop    %ebp
40037b9a:	c3                   	ret    

40037b9b <LoRaMacQueryTxPossible>:
{
40037b9b:	55                   	push   %ebp
40037b9c:	89 e5                	mov    %esp,%ebp
40037b9e:	57                   	push   %edi
40037b9f:	56                   	push   %esi
40037ba0:	53                   	push   %ebx
40037ba1:	83 ec 0c             	sub    $0xc,%esp
    if( txInfo == NULL )
40037ba4:	85 d2                	test   %edx,%edx
    int8_t datarate = LoRaMacParamsDefaults.ChannelsDatarate;
40037ba6:	8a 0d 21 84 00 a8    	mov    0xa8008421,%cl
40037bac:	88 4d f3             	mov    %cl,-0xd(%ebp)
    if( txInfo == NULL )
40037baf:	0f 84 83 00 00 00    	je     40037c38 <LoRaMacQueryTxPossible+0x9d>
40037bb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    uint8_t fOptLen = MacCommandsBufferIndex + MacCommandsBufferToRepeatIndex;
40037bb8:	a0 3f 7a 00 a8       	mov    0xa8007a3f,%al
40037bbd:	88 45 ef             	mov    %al,-0x11(%ebp)
40037bc0:	89 d6                	mov    %edx,%esi
    AdrNextDr( AdrCtrlOn, false, &datarate );
40037bc2:	0f b6 05 48 7a 00 a8 	movzbl 0xa8007a48,%eax
40037bc9:	31 d2                	xor    %edx,%edx
40037bcb:	8d 4d f3             	lea    -0xd(%ebp),%ecx
    uint8_t fOptLen = MacCommandsBufferIndex + MacCommandsBufferToRepeatIndex;
40037bce:	8a 1d 40 7a 00 a8    	mov    0xa8007a40,%bl
    AdrNextDr( AdrCtrlOn, false, &datarate );
40037bd4:	e8 2b e7 ff ff       	call   40036304 <AdrNextDr>
    if( RepeaterSupport == true )
40037bd9:	80 3d 7f 7d 00 a8 00 	cmpb   $0x0,0xa8007d7f
40037be0:	0f be 7d f3          	movsbl -0xd(%ebp),%edi
40037be4:	74 08                	je     40037bee <LoRaMacQueryTxPossible+0x53>
        txInfo->CurrentPayloadSize = MaxPayloadOfDatarateRepeater[datarate];
40037be6:	8a 87 80 cc 03 40    	mov    0x4003cc80(%edi),%al
40037bec:	eb 06                	jmp    40037bf4 <LoRaMacQueryTxPossible+0x59>
        txInfo->CurrentPayloadSize = MaxPayloadOfDatarate[datarate];
40037bee:	8a 87 90 cc 03 40    	mov    0x4003cc90(%edi),%al
40037bf4:	88 46 01             	mov    %al,0x1(%esi)
    uint8_t fOptLen = MacCommandsBufferIndex + MacCommandsBufferToRepeatIndex;
40037bf7:	02 5d ef             	add    -0x11(%ebp),%bl
    if( txInfo->CurrentPayloadSize >= fOptLen )
40037bfa:	8a 46 01             	mov    0x1(%esi),%al
40037bfd:	38 c3                	cmp    %al,%bl
40037bff:	76 07                	jbe    40037c08 <LoRaMacQueryTxPossible+0x6d>
        return LORAMAC_STATUS_MAC_CMD_LENGTH_ERROR;
40037c01:	ba 09 00 00 00       	mov    $0x9,%edx
40037c06:	eb 35                	jmp    40037c3d <LoRaMacQueryTxPossible+0xa2>
        txInfo->MaxPossiblePayload = txInfo->CurrentPayloadSize - fOptLen;
40037c08:	29 d8                	sub    %ebx,%eax
    if( ValidatePayloadLength( size, datarate, 0 ) == false )
40037c0a:	31 c9                	xor    %ecx,%ecx
        txInfo->MaxPossiblePayload = txInfo->CurrentPayloadSize - fOptLen;
40037c0c:	88 06                	mov    %al,(%esi)
    if( ValidatePayloadLength( size, datarate, 0 ) == false )
40037c0e:	89 fa                	mov    %edi,%edx
40037c10:	0f b6 75 e8          	movzbl -0x18(%ebp),%esi
40037c14:	89 f0                	mov    %esi,%eax
40037c16:	e8 68 e5 ff ff       	call   40036183 <ValidatePayloadLength>
        return LORAMAC_STATUS_LENGTH_ERROR;
40037c1b:	ba 08 00 00 00       	mov    $0x8,%edx
    if( ValidatePayloadLength( size, datarate, 0 ) == false )
40037c20:	84 c0                	test   %al,%al
40037c22:	74 19                	je     40037c3d <LoRaMacQueryTxPossible+0xa2>
    if( ValidatePayloadLength( size, datarate, fOptLen ) == false )
40037c24:	89 fa                	mov    %edi,%edx
40037c26:	89 f0                	mov    %esi,%eax
40037c28:	0f b6 cb             	movzbl %bl,%ecx
40037c2b:	e8 53 e5 ff ff       	call   40036183 <ValidatePayloadLength>
    return LORAMAC_STATUS_OK;
40037c30:	31 d2                	xor    %edx,%edx
    if( ValidatePayloadLength( size, datarate, fOptLen ) == false )
40037c32:	84 c0                	test   %al,%al
40037c34:	74 cb                	je     40037c01 <LoRaMacQueryTxPossible+0x66>
40037c36:	eb 05                	jmp    40037c3d <LoRaMacQueryTxPossible+0xa2>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037c38:	ba 03 00 00 00       	mov    $0x3,%edx
}
40037c3d:	83 c4 0c             	add    $0xc,%esp
40037c40:	89 d0                	mov    %edx,%eax
40037c42:	5b                   	pop    %ebx
40037c43:	5e                   	pop    %esi
40037c44:	5f                   	pop    %edi
40037c45:	5d                   	pop    %ebp
40037c46:	c3                   	ret    

40037c47 <LoRaMacMibGetRequestConfirm>:
    if( mibGet == NULL )
40037c47:	85 c0                	test   %eax,%eax
40037c49:	0f 84 20 01 00 00    	je     40037d6f <LoRaMacMibGetRequestConfirm+0x128>
40037c4f:	89 c2                	mov    %eax,%edx
            status = LORAMAC_STATUS_SERVICE_UNKNOWN;
40037c51:	b8 02 00 00 00       	mov    $0x2,%eax
    switch( mibGet->Type )
40037c56:	83 3a 1a             	cmpl   $0x1a,(%edx)
40037c59:	0f 87 16 01 00 00    	ja     40037d75 <LoRaMacMibGetRequestConfirm+0x12e>
{
40037c5f:	55                   	push   %ebp
40037c60:	89 e5                	mov    %esp,%ebp
40037c62:	53                   	push   %ebx
    switch( mibGet->Type )
40037c63:	8b 02                	mov    (%edx),%eax
40037c65:	ff 24 85 78 cb 03 40 	jmp    *0x4003cb78(,%eax,4)
            mibGet->Param.Class = LoRaMacDeviceClass;
40037c6c:	a1 84 7d 00 a8       	mov    0xa8007d84,%eax
40037c71:	e9 f0 00 00 00       	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.IsNetworkJoined = IsLoRaMacNetworkJoined;
40037c76:	a0 49 7a 00 a8       	mov    0xa8007a49,%al
40037c7b:	e9 ce 00 00 00       	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.AdrEnable = AdrCtrlOn;
40037c80:	a0 48 7a 00 a8       	mov    0xa8007a48,%al
40037c85:	e9 c4 00 00 00       	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.NetID = LoRaMacNetID;
40037c8a:	a1 90 7d 00 a8       	mov    0xa8007d90,%eax
40037c8f:	e9 d2 00 00 00       	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.DevAddr = LoRaMacDevAddr;
40037c94:	a1 8c 7d 00 a8       	mov    0xa8007d8c,%eax
40037c99:	e9 c8 00 00 00       	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.NwkSKey = LoRaMacNwkSKey;
40037c9e:	c7 42 04 a8 7d 00 a8 	movl   $0xa8007da8,0x4(%edx)
40037ca5:	e9 bf 00 00 00       	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.AppSKey = LoRaMacAppSKey;
40037caa:	c7 42 04 98 7d 00 a8 	movl   $0xa8007d98,0x4(%edx)
40037cb1:	e9 b3 00 00 00       	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.EnablePublicNetwork = PublicNetwork;
40037cb6:	a0 80 7d 00 a8       	mov    0xa8007d80,%al
40037cbb:	e9 8e 00 00 00       	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.EnableRepeaterSupport = RepeaterSupport;
40037cc0:	a0 7f 7d 00 a8       	mov    0xa8007d7f,%al
40037cc5:	e9 84 00 00 00       	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.ChannelList = Channels;
40037cca:	c7 42 04 e0 77 00 a8 	movl   $0xa80077e0,0x4(%edx)
40037cd1:	e9 93 00 00 00       	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.Rx2Channel = LoRaMacParams.Rx2Channel;
40037cd6:	8b 0d bc 84 00 a8    	mov    0xa80084bc,%ecx
40037cdc:	8b 1d c0 84 00 a8    	mov    0xa80084c0,%ebx
40037ce2:	eb 0c                	jmp    40037cf0 <LoRaMacMibGetRequestConfirm+0xa9>
            mibGet->Param.Rx2Channel = LoRaMacParamsDefaults.Rx2Channel;
40037ce4:	8b 0d 3c 84 00 a8    	mov    0xa800843c,%ecx
40037cea:	8b 1d 40 84 00 a8    	mov    0xa8008440,%ebx
40037cf0:	89 4a 04             	mov    %ecx,0x4(%edx)
40037cf3:	89 5a 08             	mov    %ebx,0x8(%edx)
40037cf6:	eb 71                	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.ChannelsDefaultMask = LoRaMacParamsDefaults.ChannelsMask;
40037cf8:	c7 42 04 44 84 00 a8 	movl   $0xa8008444,0x4(%edx)
40037cff:	eb 68                	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.ChannelsMask = LoRaMacParams.ChannelsMask;
40037d01:	c7 42 04 c4 84 00 a8 	movl   $0xa80084c4,0x4(%edx)
40037d08:	eb 5f                	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.ChannelNbRep = LoRaMacParams.ChannelsNbRep;
40037d0a:	a0 b8 84 00 a8       	mov    0xa80084b8,%al
40037d0f:	eb 3d                	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.MaxRxWindow = LoRaMacParams.MaxRxWindow;
40037d11:	a1 a4 84 00 a8       	mov    0xa80084a4,%eax
40037d16:	eb 4e                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.ReceiveDelay1 = LoRaMacParams.ReceiveDelay1;
40037d18:	a1 a8 84 00 a8       	mov    0xa80084a8,%eax
40037d1d:	eb 47                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.ReceiveDelay2 = LoRaMacParams.ReceiveDelay2;
40037d1f:	a1 ac 84 00 a8       	mov    0xa80084ac,%eax
40037d24:	eb 40                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.JoinAcceptDelay1 = LoRaMacParams.JoinAcceptDelay1;
40037d26:	a1 b0 84 00 a8       	mov    0xa80084b0,%eax
40037d2b:	eb 39                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.JoinAcceptDelay2 = LoRaMacParams.JoinAcceptDelay2;
40037d2d:	a1 b4 84 00 a8       	mov    0xa80084b4,%eax
40037d32:	eb 32                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.ChannelsDefaultDatarate = LoRaMacParamsDefaults.ChannelsDatarate;
40037d34:	a0 21 84 00 a8       	mov    0xa8008421,%al
40037d39:	eb 13                	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.ChannelsDatarate = LoRaMacParams.ChannelsDatarate;
40037d3b:	a0 a1 84 00 a8       	mov    0xa80084a1,%al
40037d40:	eb 0c                	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.ChannelsDefaultTxPower = LoRaMacParamsDefaults.ChannelsTxPower;
40037d42:	a0 20 84 00 a8       	mov    0xa8008420,%al
40037d47:	eb 05                	jmp    40037d4e <LoRaMacMibGetRequestConfirm+0x107>
            mibGet->Param.ChannelsTxPower = LoRaMacParams.ChannelsTxPower;
40037d49:	a0 a0 84 00 a8       	mov    0xa80084a0,%al
40037d4e:	88 42 04             	mov    %al,0x4(%edx)
40037d51:	eb 16                	jmp    40037d69 <LoRaMacMibGetRequestConfirm+0x122>
            mibGet->Param.UpLinkCounter = UpLinkCounter;
40037d53:	a1 50 7a 00 a8       	mov    0xa8007a50,%eax
40037d58:	eb 0c                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.DownLinkCounter = DownLinkCounter;
40037d5a:	a1 4c 7a 00 a8       	mov    0xa8007a4c,%eax
40037d5f:	eb 05                	jmp    40037d66 <LoRaMacMibGetRequestConfirm+0x11f>
            mibGet->Param.MulticastList = MulticastChannels;
40037d61:	a1 88 7d 00 a8       	mov    0xa8007d88,%eax
40037d66:	89 42 04             	mov    %eax,0x4(%edx)
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
40037d69:	31 c0                	xor    %eax,%eax
}
40037d6b:	5b                   	pop    %ebx
40037d6c:	5d                   	pop    %ebp
40037d6d:	eb 06                	jmp    40037d75 <LoRaMacMibGetRequestConfirm+0x12e>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037d6f:	b8 03 00 00 00       	mov    $0x3,%eax
40037d74:	c3                   	ret    
}
40037d75:	c3                   	ret    

40037d76 <LoRaMacMibSetRequestConfirm>:
    if( mibSet == NULL )
40037d76:	85 c0                	test   %eax,%eax
40037d78:	0f 84 68 02 00 00    	je     40037fe6 <LoRaMacMibSetRequestConfirm+0x270>
        return LORAMAC_STATUS_BUSY;
40037d7e:	b9 01 00 00 00       	mov    $0x1,%ecx
    if( ( LoRaMacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
40037d83:	f6 05 ac 77 00 a8 01 	testb  $0x1,0xa80077ac
40037d8a:	0f 85 8a 02 00 00    	jne    4003801a <LoRaMacMibSetRequestConfirm+0x2a4>
    switch( mibSet->Type )
40037d90:	83 38 19             	cmpl   $0x19,(%eax)
40037d93:	0f 87 7c 02 00 00    	ja     40038015 <LoRaMacMibSetRequestConfirm+0x29f>
{
40037d99:	55                   	push   %ebp
40037d9a:	89 e5                	mov    %esp,%ebp
40037d9c:	53                   	push   %ebx
    switch( mibSet->Type )
40037d9d:	8b 10                	mov    (%eax),%edx
40037d9f:	ff 24 95 e4 cb 03 40 	jmp    *0x4003cbe4(,%edx,4)
            LoRaMacDeviceClass = mibSet->Param.Class;
40037da6:	8b 40 04             	mov    0x4(%eax),%eax
40037da9:	a3 84 7d 00 a8       	mov    %eax,0xa8007d84
            switch( LoRaMacDeviceClass )
40037dae:	85 c0                	test   %eax,%eax
40037db0:	74 1a                	je     40037dcc <LoRaMacMibSetRequestConfirm+0x56>
40037db2:	83 f8 02             	cmp    $0x2,%eax
40037db5:	0f 85 53 02 00 00    	jne    4003800e <LoRaMacMibSetRequestConfirm+0x298>
                    NodeAckRequested = false;
40037dbb:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
                    OnRxWindow2TimerEvent( );
40037dc2:	e8 ce e6 ff ff       	call   40036495 <OnRxWindow2TimerEvent>
40037dc7:	e9 42 02 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
                    sx1276_set_sleep(dev);
40037dcc:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
40037dd1:	e8 64 df ff ff       	call   40035d3a <sx1276_set_sleep>
40037dd6:	e9 33 02 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            IsLoRaMacNetworkJoined = mibSet->Param.IsNetworkJoined;
40037ddb:	8a 40 04             	mov    0x4(%eax),%al
40037dde:	a2 49 7a 00 a8       	mov    %al,0xa8007a49
40037de3:	e9 26 02 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            AdrCtrlOn = mibSet->Param.AdrEnable;
40037de8:	8a 40 04             	mov    0x4(%eax),%al
40037deb:	a2 48 7a 00 a8       	mov    %al,0xa8007a48
40037df0:	e9 19 02 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacNetID = mibSet->Param.NetID;
40037df5:	8b 40 04             	mov    0x4(%eax),%eax
40037df8:	a3 90 7d 00 a8       	mov    %eax,0xa8007d90
40037dfd:	e9 0c 02 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacDevAddr = mibSet->Param.DevAddr;
40037e02:	8b 40 04             	mov    0x4(%eax),%eax
40037e05:	a3 8c 7d 00 a8       	mov    %eax,0xa8007d8c
40037e0a:	e9 ff 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            if( mibSet->Param.NwkSKey != NULL )
40037e0f:	8b 50 04             	mov    0x4(%eax),%edx
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037e12:	b9 03 00 00 00       	mov    $0x3,%ecx
            if( mibSet->Param.NwkSKey != NULL )
40037e17:	85 d2                	test   %edx,%edx
40037e19:	0f 84 f1 01 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                memcpy( LoRaMacNwkSKey, mibSet->Param.NwkSKey,
40037e1f:	b9 10 00 00 00       	mov    $0x10,%ecx
40037e24:	b8 a8 7d 00 a8       	mov    $0xa8007da8,%eax
40037e29:	eb 1a                	jmp    40037e45 <LoRaMacMibSetRequestConfirm+0xcf>
            if( mibSet->Param.AppSKey != NULL )
40037e2b:	8b 50 04             	mov    0x4(%eax),%edx
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037e2e:	b9 03 00 00 00       	mov    $0x3,%ecx
            if( mibSet->Param.AppSKey != NULL )
40037e33:	85 d2                	test   %edx,%edx
40037e35:	0f 84 d5 01 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                memcpy( LoRaMacAppSKey, mibSet->Param.AppSKey,
40037e3b:	b9 10 00 00 00       	mov    $0x10,%ecx
40037e40:	b8 98 7d 00 a8       	mov    $0xa8007d98,%eax
40037e45:	e8 20 82 ff ff       	call   4003006a <memcpy>
40037e4a:	e9 bf 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            PublicNetwork = mibSet->Param.EnablePublicNetwork;
40037e4f:	0f b6 50 04          	movzbl 0x4(%eax),%edx
            sx1276_set_public_network(dev, PublicNetwork);
40037e53:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
            PublicNetwork = mibSet->Param.EnablePublicNetwork;
40037e58:	88 15 80 7d 00 a8    	mov    %dl,0xa8007d80
            sx1276_set_public_network(dev, PublicNetwork);
40037e5e:	e8 20 df ff ff       	call   40035d83 <sx1276_set_public_network>
40037e63:	e9 a6 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
             RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
40037e68:	8a 40 04             	mov    0x4(%eax),%al
40037e6b:	a2 7f 7d 00 a8       	mov    %al,0xa8007d7f
40037e70:	e9 99 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.Rx2Channel = mibSet->Param.Rx2Channel;
40037e75:	8b 50 08             	mov    0x8(%eax),%edx
40037e78:	8b 40 04             	mov    0x4(%eax),%eax
40037e7b:	a3 bc 84 00 a8       	mov    %eax,0xa80084bc
40037e80:	89 15 c0 84 00 a8    	mov    %edx,0xa80084c0
40037e86:	e9 83 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
40037e8b:	8b 50 08             	mov    0x8(%eax),%edx
40037e8e:	8b 40 04             	mov    0x4(%eax),%eax
40037e91:	a3 3c 84 00 a8       	mov    %eax,0xa800843c
40037e96:	89 15 40 84 00 a8    	mov    %edx,0xa8008440
40037e9c:	e9 6d 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            if( mibSet->Param.ChannelsDefaultMask )
40037ea1:	8b 58 04             	mov    0x4(%eax),%ebx
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037ea4:	b9 03 00 00 00       	mov    $0x3,%ecx
            if( mibSet->Param.ChannelsDefaultMask )
40037ea9:	85 db                	test   %ebx,%ebx
40037eab:	0f 84 5f 01 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                    if( ( CountNbEnabled125kHzChannels( mibSet->Param.ChannelsMask ) < 2 ) &&
40037eb1:	89 d8                	mov    %ebx,%eax
40037eb3:	e8 e7 ea ff ff       	call   4003699f <CountNbEnabled125kHzChannels>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037eb8:	b9 03 00 00 00       	mov    $0x3,%ecx
                    if( ( CountNbEnabled125kHzChannels( mibSet->Param.ChannelsMask ) < 2 ) &&
40037ebd:	fe c8                	dec    %al
40037ebf:	0f 84 4b 01 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                        memcpy( ( uint8_t* ) LoRaMacParamsDefaults.ChannelsMask,
40037ec5:	b9 0c 00 00 00       	mov    $0xc,%ecx
40037eca:	89 da                	mov    %ebx,%edx
40037ecc:	b8 44 84 00 a8       	mov    $0xa8008444,%eax
40037ed1:	e8 94 81 ff ff       	call   4003006a <memcpy>
40037ed6:	31 c0                	xor    %eax,%eax
                            ChannelsMaskRemaining[i] &= LoRaMacParamsDefaults.ChannelsMask[i];
40037ed8:	66 8b 90 c8 77 00 a8 	mov    -0x57ff8838(%eax),%dx
40037edf:	83 c0 02             	add    $0x2,%eax
40037ee2:	66 23 90 42 84 00 a8 	and    -0x57ff7bbe(%eax),%dx
40037ee9:	66 89 90 c6 77 00 a8 	mov    %dx,-0x57ff883a(%eax)
                        for ( uint8_t i = 0; i < sizeof( LoRaMacParamsDefaults.ChannelsMask ) / 2; i++ )
40037ef0:	83 f8 0c             	cmp    $0xc,%eax
40037ef3:	75 e3                	jne    40037ed8 <LoRaMacMibSetRequestConfirm+0x162>
40037ef5:	e9 14 01 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            if( mibSet->Param.ChannelsMask )
40037efa:	8b 58 04             	mov    0x4(%eax),%ebx
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037efd:	b9 03 00 00 00       	mov    $0x3,%ecx
            if( mibSet->Param.ChannelsMask )
40037f02:	85 db                	test   %ebx,%ebx
40037f04:	0f 84 06 01 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                    if( ( CountNbEnabled125kHzChannels( mibSet->Param.ChannelsMask ) < 2 ) &&
40037f0a:	89 d8                	mov    %ebx,%eax
40037f0c:	e8 8e ea ff ff       	call   4003699f <CountNbEnabled125kHzChannels>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037f11:	b9 03 00 00 00       	mov    $0x3,%ecx
                    if( ( CountNbEnabled125kHzChannels( mibSet->Param.ChannelsMask ) < 2 ) &&
40037f16:	fe c8                	dec    %al
40037f18:	0f 84 f2 00 00 00    	je     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                        memcpy( ( uint8_t* ) LoRaMacParams.ChannelsMask,
40037f1e:	b9 0c 00 00 00       	mov    $0xc,%ecx
40037f23:	89 da                	mov    %ebx,%edx
40037f25:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
40037f2a:	e8 3b 81 ff ff       	call   4003006a <memcpy>
40037f2f:	31 c0                	xor    %eax,%eax
                            ChannelsMaskRemaining[i] &= LoRaMacParams.ChannelsMask[i];
40037f31:	66 8b 90 c8 77 00 a8 	mov    -0x57ff8838(%eax),%dx
40037f38:	83 c0 02             	add    $0x2,%eax
40037f3b:	66 23 90 c2 84 00 a8 	and    -0x57ff7b3e(%eax),%dx
40037f42:	66 89 90 c6 77 00 a8 	mov    %dx,-0x57ff883a(%eax)
                        for ( uint8_t i = 0; i < sizeof( LoRaMacParams.ChannelsMask ) / 2; i++ )
40037f49:	83 f8 0c             	cmp    $0xc,%eax
40037f4c:	75 e3                	jne    40037f31 <LoRaMacMibSetRequestConfirm+0x1bb>
40037f4e:	e9 bb 00 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            if( ( mibSet->Param.ChannelNbRep >= 1 ) &&
40037f53:	8a 40 04             	mov    0x4(%eax),%al
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037f56:	b9 03 00 00 00       	mov    $0x3,%ecx
            if( ( mibSet->Param.ChannelNbRep >= 1 ) &&
40037f5b:	8d 50 ff             	lea    -0x1(%eax),%edx
40037f5e:	80 fa 0e             	cmp    $0xe,%dl
40037f61:	0f 87 a9 00 00 00    	ja     40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                LoRaMacParams.ChannelsNbRep = mibSet->Param.ChannelNbRep;
40037f67:	a2 b8 84 00 a8       	mov    %al,0xa80084b8
40037f6c:	e9 9d 00 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
40037f71:	8b 40 04             	mov    0x4(%eax),%eax
40037f74:	a3 a4 84 00 a8       	mov    %eax,0xa80084a4
40037f79:	e9 90 00 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
40037f7e:	8b 40 04             	mov    0x4(%eax),%eax
40037f81:	a3 a8 84 00 a8       	mov    %eax,0xa80084a8
40037f86:	e9 83 00 00 00       	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
40037f8b:	8b 40 04             	mov    0x4(%eax),%eax
40037f8e:	a3 ac 84 00 a8       	mov    %eax,0xa80084ac
40037f93:	eb 79                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
40037f95:	8b 40 04             	mov    0x4(%eax),%eax
40037f98:	a3 b0 84 00 a8       	mov    %eax,0xa80084b0
40037f9d:	eb 6f                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            LoRaMacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
40037f9f:	8b 40 04             	mov    0x4(%eax),%eax
40037fa2:	a3 b4 84 00 a8       	mov    %eax,0xa80084b4
40037fa7:	eb 65                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            if( ValueInRange( mibSet->Param.ChannelsDefaultDatarate,
40037fa9:	8a 40 04             	mov    0x4(%eax),%al
    if( ( value >= min ) && ( value <= max ) )
40037fac:	3c 04                	cmp    $0x4,%al
40037fae:	76 44                	jbe    40037ff4 <LoRaMacMibSetRequestConfirm+0x27e>
40037fb0:	eb 19                	jmp    40037fcb <LoRaMacMibSetRequestConfirm+0x255>
            if( ValueInRange( mibSet->Param.ChannelsDatarate,
40037fb2:	8a 40 04             	mov    0x4(%eax),%al
    if( ( value >= min ) && ( value <= max ) )
40037fb5:	3c 04                	cmp    $0x4,%al
40037fb7:	76 42                	jbe    40037ffb <LoRaMacMibSetRequestConfirm+0x285>
40037fb9:	eb 10                	jmp    40037fcb <LoRaMacMibSetRequestConfirm+0x255>
            if( ValueInRange( mibSet->Param.ChannelsDefaultTxPower,
40037fbb:	8a 40 04             	mov    0x4(%eax),%al
    if( ( value >= min ) && ( value <= max ) )
40037fbe:	3c 0a                	cmp    $0xa,%al
40037fc0:	76 40                	jbe    40038002 <LoRaMacMibSetRequestConfirm+0x28c>
40037fc2:	eb 07                	jmp    40037fcb <LoRaMacMibSetRequestConfirm+0x255>
            if( ValueInRange( mibSet->Param.ChannelsTxPower,
40037fc4:	8a 40 04             	mov    0x4(%eax),%al
    if( ( value >= min ) && ( value <= max ) )
40037fc7:	3c 0a                	cmp    $0xa,%al
40037fc9:	76 3e                	jbe    40038009 <LoRaMacMibSetRequestConfirm+0x293>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037fcb:	b9 03 00 00 00       	mov    $0x3,%ecx
40037fd0:	eb 3e                	jmp    40038010 <LoRaMacMibSetRequestConfirm+0x29a>
            UpLinkCounter = mibSet->Param.UpLinkCounter;
40037fd2:	8b 40 04             	mov    0x4(%eax),%eax
40037fd5:	a3 50 7a 00 a8       	mov    %eax,0xa8007a50
40037fda:	eb 32                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
            DownLinkCounter = mibSet->Param.DownLinkCounter;
40037fdc:	8b 40 04             	mov    0x4(%eax),%eax
40037fdf:	a3 4c 7a 00 a8       	mov    %eax,0xa8007a4c
40037fe4:	eb 28                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40037fe6:	b9 03 00 00 00       	mov    $0x3,%ecx
40037feb:	eb 2d                	jmp    4003801a <LoRaMacMibSetRequestConfirm+0x2a4>
            status = LORAMAC_STATUS_SERVICE_UNKNOWN;
40037fed:	b9 02 00 00 00       	mov    $0x2,%ecx
40037ff2:	eb 1c                	jmp    40038010 <LoRaMacMibSetRequestConfirm+0x29a>
                LoRaMacParamsDefaults.ChannelsDatarate = mibSet->Param.ChannelsDefaultDatarate;
40037ff4:	a2 21 84 00 a8       	mov    %al,0xa8008421
40037ff9:	eb 13                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
                LoRaMacParams.ChannelsDatarate = mibSet->Param.ChannelsDatarate;
40037ffb:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
40038000:	eb 0c                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
                LoRaMacParamsDefaults.ChannelsTxPower = mibSet->Param.ChannelsDefaultTxPower;
40038002:	a2 20 84 00 a8       	mov    %al,0xa8008420
40038007:	eb 05                	jmp    4003800e <LoRaMacMibSetRequestConfirm+0x298>
                LoRaMacParams.ChannelsTxPower = mibSet->Param.ChannelsTxPower;
40038009:	a2 a0 84 00 a8       	mov    %al,0xa80084a0
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
4003800e:	31 c9                	xor    %ecx,%ecx
}
40038010:	89 c8                	mov    %ecx,%eax
40038012:	5b                   	pop    %ebx
40038013:	5d                   	pop    %ebp
40038014:	c3                   	ret    
            status = LORAMAC_STATUS_SERVICE_UNKNOWN;
40038015:	b9 02 00 00 00       	mov    $0x2,%ecx
}
4003801a:	89 c8                	mov    %ecx,%eax
4003801c:	c3                   	ret    

4003801d <loramac_memcpyr>:
void loramac_memcpyr(uint8_t *dst, const uint8_t *src, uint16_t size) {
4003801d:	55                   	push   %ebp
4003801e:	89 e5                	mov    %esp,%ebp
40038020:	57                   	push   %edi
    dst = dst + ( size - 1 );
40038021:	0f b7 f9             	movzwl %cx,%edi
void loramac_memcpyr(uint8_t *dst, const uint8_t *src, uint16_t size) {
40038024:	56                   	push   %esi
40038025:	53                   	push   %ebx
    dst = dst + ( size - 1 );
40038026:	8d 5c 38 ff          	lea    -0x1(%eax,%edi,1),%ebx
    while( size-- )
4003802a:	31 c0                	xor    %eax,%eax
4003802c:	39 c7                	cmp    %eax,%edi
4003802e:	74 0d                	je     4003803d <loramac_memcpyr+0x20>
        *dst-- = *src++;
40038030:	89 c6                	mov    %eax,%esi
40038032:	8a 0c 02             	mov    (%edx,%eax,1),%cl
40038035:	f7 de                	neg    %esi
40038037:	40                   	inc    %eax
40038038:	88 0c 33             	mov    %cl,(%ebx,%esi,1)
4003803b:	eb ef                	jmp    4003802c <loramac_memcpyr+0xf>
}
4003803d:	5b                   	pop    %ebx
4003803e:	5e                   	pop    %esi
4003803f:	5f                   	pop    %edi
40038040:	5d                   	pop    %ebp
40038041:	c3                   	ret    

40038042 <PrepareFrame>:
{
40038042:	55                   	push   %ebp
40038043:	89 e5                	mov    %esp,%ebp
40038045:	57                   	push   %edi
40038046:	56                   	push   %esi
40038047:	53                   	push   %ebx
40038048:	83 ec 0c             	sub    $0xc,%esp
4003804b:	89 d6                	mov    %edx,%esi
4003804d:	8b 5d 08             	mov    0x8(%ebp),%ebx
40038050:	88 4d ea             	mov    %cl,-0x16(%ebp)
40038053:	8b 55 0c             	mov    0xc(%ebp),%edx
    uint32_t mic = 0;
40038056:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    LoRaMacBufferPktLen = 0;
4003805d:	66 c7 05 60 7c 00 a8 	movw   $0x0,0xa8007c60
40038064:	00 00 
    NodeAckRequested = false;
40038066:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
    if( fBuffer == NULL )
4003806d:	85 db                	test   %ebx,%ebx
4003806f:	75 02                	jne    40038073 <PrepareFrame+0x31>
        fBufferSize = 0;
40038071:	31 d2                	xor    %edx,%edx
    LoRaMacTxPayloadLen = fBufferSize;
40038073:	0f b6 ca             	movzbl %dl,%ecx
40038076:	88 15 5f 7c 00 a8    	mov    %dl,0xa8007c5f
    LoRaMacBuffer[pktHeaderLen++] = macHdr->Value;
4003807c:	8a 10                	mov    (%eax),%dl
4003807e:	88 15 80 7c 00 a8    	mov    %dl,0xa8007c80
    switch( macHdr->Bits.MType )
40038084:	8a 00                	mov    (%eax),%al
40038086:	c0 e8 05             	shr    $0x5,%al
40038089:	3c 02                	cmp    $0x2,%al
4003808b:	0f 84 14 01 00 00    	je     400381a5 <PrepareFrame+0x163>
40038091:	0f 87 f6 00 00 00    	ja     4003818d <PrepareFrame+0x14b>
40038097:	84 c0                	test   %al,%al
40038099:	0f 85 20 04 00 00    	jne    400384bf <PrepareFrame+0x47d>
            RxWindow1Delay = LoRaMacParams.JoinAcceptDelay1 - RADIO_WAKEUP_TIME;
4003809f:	a1 b0 84 00 a8       	mov    0xa80084b0,%eax
            loramac_memcpyr( LoRaMacBuffer + LoRaMacBufferPktLen, LoRaMacAppEui, 8 );
400380a4:	b9 08 00 00 00       	mov    $0x8,%ecx
            RxWindow1Delay = LoRaMacParams.JoinAcceptDelay1 - RADIO_WAKEUP_TIME;
400380a9:	83 e8 03             	sub    $0x3,%eax
            loramac_memcpyr( LoRaMacBuffer + LoRaMacBufferPktLen, LoRaMacAppEui, 8 );
400380ac:	8b 15 bc 7d 00 a8    	mov    0xa8007dbc,%edx
            RxWindow1Delay = LoRaMacParams.JoinAcceptDelay1 - RADIO_WAKEUP_TIME;
400380b2:	a3 84 77 00 a8       	mov    %eax,0xa8007784
            RxWindow2Delay = LoRaMacParams.JoinAcceptDelay2 - RADIO_WAKEUP_TIME;
400380b7:	a1 b4 84 00 a8       	mov    0xa80084b4,%eax
400380bc:	83 e8 03             	sub    $0x3,%eax
400380bf:	a3 80 77 00 a8       	mov    %eax,0xa8007780
            loramac_memcpyr( LoRaMacBuffer + LoRaMacBufferPktLen, LoRaMacAppEui, 8 );
400380c4:	b8 81 7c 00 a8       	mov    $0xa8007c81,%eax
400380c9:	e8 4f ff ff ff       	call   4003801d <loramac_memcpyr>
            loramac_memcpyr( LoRaMacBuffer + LoRaMacBufferPktLen, LoRaMacDevEui, 8 );
400380ce:	b9 08 00 00 00       	mov    $0x8,%ecx
400380d3:	8b 15 c0 7d 00 a8    	mov    0xa8007dc0,%edx
400380d9:	b8 89 7c 00 a8       	mov    $0xa8007c89,%eax
400380de:	e8 3a ff ff ff       	call   4003801d <loramac_memcpyr>
            LoRaMacDevNonce = sx1276_random(dev);
400380e3:	a1 b0 77 00 a8       	mov    0xa80077b0,%eax
            LoRaMacBufferPktLen += 8;
400380e8:	66 c7 05 60 7c 00 a8 	movw   $0x11,0xa8007c60
400380ef:	11 00 
            LoRaMacDevNonce = sx1276_random(dev);
400380f1:	e8 ce dc ff ff       	call   40035dc4 <sx1276_random>
            LoRaMacBuffer[LoRaMacBufferPktLen++] = LoRaMacDevNonce & 0xFF;
400380f6:	0f b7 15 60 7c 00 a8 	movzwl 0xa8007c60,%edx
400380fd:	89 d1                	mov    %edx,%ecx
            LoRaMacDevNonce = sx1276_random(dev);
400380ff:	66 a3 94 7d 00 a8    	mov    %ax,0xa8007d94
            LoRaMacBuffer[LoRaMacBufferPktLen++] = LoRaMacDevNonce & 0xFF;
40038105:	41                   	inc    %ecx
40038106:	88 82 80 7c 00 a8    	mov    %al,-0x57ff8380(%edx)
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( LoRaMacDevNonce >> 8 ) & 0xFF;
4003810c:	0f b7 c9             	movzwl %cx,%ecx
4003810f:	66 c1 e8 08          	shr    $0x8,%ax
40038113:	8d 52 02             	lea    0x2(%edx),%edx
40038116:	88 81 80 7c 00 a8    	mov    %al,-0x57ff8380(%ecx)
            LoRaMacJoinComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen & 0xFF, LoRaMacAppKey, &mic );
4003811c:	8d 45 f0             	lea    -0x10(%ebp),%eax
4003811f:	50                   	push   %eax
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( LoRaMacDevNonce >> 8 ) & 0xFF;
40038120:	66 89 15 60 7c 00 a8 	mov    %dx,0xa8007c60
            LoRaMacJoinComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen & 0xFF, LoRaMacAppKey, &mic );
40038127:	8b 0d b8 7d 00 a8    	mov    0xa8007db8,%ecx
4003812d:	b8 80 7c 00 a8       	mov    $0xa8007c80,%eax
40038132:	0f b6 d2             	movzbl %dl,%edx
40038135:	e8 af 0b 00 00       	call   40038ce9 <LoRaMacJoinComputeMic>
            LoRaMacBuffer[LoRaMacBufferPktLen++] = mic & 0xFF;
4003813a:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003813d:	0f b7 0d 60 7c 00 a8 	movzwl 0xa8007c60,%ecx
            LoRaMacJoinComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen & 0xFF, LoRaMacAppKey, &mic );
40038144:	58                   	pop    %eax
            LoRaMacBuffer[LoRaMacBufferPktLen++] = mic & 0xFF;
40038145:	89 c8                	mov    %ecx,%eax
40038147:	88 91 80 7c 00 a8    	mov    %dl,-0x57ff8380(%ecx)
4003814d:	8d 49 01             	lea    0x1(%ecx),%ecx
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 8 ) & 0xFF;
40038150:	0f b7 c9             	movzwl %cx,%ecx
40038153:	89 d3                	mov    %edx,%ebx
40038155:	c1 eb 08             	shr    $0x8,%ebx
40038158:	88 99 80 7c 00 a8    	mov    %bl,-0x57ff8380(%ecx)
4003815e:	8d 48 02             	lea    0x2(%eax),%ecx
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 16 ) & 0xFF;
40038161:	0f b7 c9             	movzwl %cx,%ecx
40038164:	89 d3                	mov    %edx,%ebx
40038166:	c1 eb 10             	shr    $0x10,%ebx
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 24 ) & 0xFF;
40038169:	c1 ea 18             	shr    $0x18,%edx
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 16 ) & 0xFF;
4003816c:	88 99 80 7c 00 a8    	mov    %bl,-0x57ff8380(%ecx)
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 24 ) & 0xFF;
40038172:	8d 48 04             	lea    0x4(%eax),%ecx
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 16 ) & 0xFF;
40038175:	83 c0 03             	add    $0x3,%eax
            LoRaMacBuffer[LoRaMacBufferPktLen++] = ( mic >> 24 ) & 0xFF;
40038178:	0f b7 c0             	movzwl %ax,%eax
4003817b:	66 89 0d 60 7c 00 a8 	mov    %cx,0xa8007c60
40038182:	88 90 80 7c 00 a8    	mov    %dl,-0x57ff8380(%eax)
40038188:	e9 39 03 00 00       	jmp    400384c6 <PrepareFrame+0x484>
    switch( macHdr->Bits.MType )
4003818d:	3c 04                	cmp    $0x4,%al
4003818f:	74 0d                	je     4003819e <PrepareFrame+0x15c>
40038191:	3c 07                	cmp    $0x7,%al
40038193:	0f 84 02 03 00 00    	je     4003849b <PrepareFrame+0x459>
40038199:	e9 21 03 00 00       	jmp    400384bf <PrepareFrame+0x47d>
            NodeAckRequested = true;
4003819e:	c6 05 43 7a 00 a8 01 	movb   $0x1,0xa8007a43
                return LORAMAC_STATUS_NO_NETWORK_JOINED; // No network has been joined yet
400381a5:	ba 07 00 00 00       	mov    $0x7,%edx
            if( IsLoRaMacNetworkJoined == false )
400381aa:	80 3d 49 7a 00 a8 00 	cmpb   $0x0,0xa8007a49
400381b1:	0f 84 11 03 00 00    	je     400384c8 <PrepareFrame+0x486>
            fCtrl->Bits.AdrAckReq = AdrNextDr( fCtrl->Bits.Adr, true, &LoRaMacParams.ChannelsDatarate );
400381b7:	0f be 06             	movsbl (%esi),%eax
400381ba:	b9 a1 84 00 a8       	mov    $0xa80084a1,%ecx
400381bf:	ba 01 00 00 00       	mov    $0x1,%edx
400381c4:	c1 e8 1f             	shr    $0x1f,%eax
400381c7:	e8 38 e1 ff ff       	call   40036304 <AdrNextDr>
400381cc:	0f b6 3e             	movzbl (%esi),%edi
400381cf:	83 e0 01             	and    $0x1,%eax
400381d2:	83 e7 bf             	and    $0xffffffbf,%edi
400381d5:	c1 e0 06             	shl    $0x6,%eax
400381d8:	09 c7                	or     %eax,%edi
400381da:	89 f8                	mov    %edi,%eax
400381dc:	88 06                	mov    %al,(%esi)
            if( ValidatePayloadLength( LoRaMacTxPayloadLen, LoRaMacParams.ChannelsDatarate, MacCommandsBufferIndex ) == false )
400381de:	0f b6 05 40 7a 00 a8 	movzbl 0xa8007a40,%eax
400381e5:	0f be 15 a1 84 00 a8 	movsbl 0xa80084a1,%edx
400381ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
400381ef:	0f b6 05 5f 7c 00 a8 	movzbl 0xa8007c5f,%eax
400381f6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400381f9:	e8 85 df ff ff       	call   40036183 <ValidatePayloadLength>
                return LORAMAC_STATUS_LENGTH_ERROR;
400381fe:	ba 08 00 00 00       	mov    $0x8,%edx
            if( ValidatePayloadLength( LoRaMacTxPayloadLen, LoRaMacParams.ChannelsDatarate, MacCommandsBufferIndex ) == false )
40038203:	84 c0                	test   %al,%al
40038205:	0f 84 bd 02 00 00    	je     400384c8 <PrepareFrame+0x486>
            RxWindow1Delay = LoRaMacParams.ReceiveDelay1 - RADIO_WAKEUP_TIME;
4003820b:	a1 a8 84 00 a8       	mov    0xa80084a8,%eax
40038210:	83 e8 03             	sub    $0x3,%eax
40038213:	a3 84 77 00 a8       	mov    %eax,0xa8007784
            RxWindow2Delay = LoRaMacParams.ReceiveDelay2 - RADIO_WAKEUP_TIME;
40038218:	a1 ac 84 00 a8       	mov    0xa80084ac,%eax
4003821d:	83 e8 03             	sub    $0x3,%eax
40038220:	a3 80 77 00 a8       	mov    %eax,0xa8007780
            if( SrvAckRequested == true )
40038225:	80 3d 42 7a 00 a8 00 	cmpb   $0x0,0xa8007a42
4003822c:	74 0e                	je     4003823c <PrepareFrame+0x1fa>
                fCtrl->Bits.Ack = 1;
4003822e:	89 f8                	mov    %edi,%eax
                SrvAckRequested = false;
40038230:	c6 05 42 7a 00 a8 00 	movb   $0x0,0xa8007a42
                fCtrl->Bits.Ack = 1;
40038237:	83 c8 20             	or     $0x20,%eax
4003823a:	88 06                	mov    %al,(%esi)
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr ) & 0xFF;
4003823c:	a1 8c 7d 00 a8       	mov    0xa8007d8c,%eax
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 8 ) & 0xFF;
40038241:	89 c2                	mov    %eax,%edx
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr ) & 0xFF;
40038243:	a2 81 7c 00 a8       	mov    %al,0xa8007c81
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 8 ) & 0xFF;
40038248:	c1 ea 08             	shr    $0x8,%edx
4003824b:	88 15 82 7c 00 a8    	mov    %dl,0xa8007c82
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 16 ) & 0xFF;
40038251:	89 c2                	mov    %eax,%edx
40038253:	c1 ea 10             	shr    $0x10,%edx
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 24 ) & 0xFF;
40038256:	c1 e8 18             	shr    $0x18,%eax
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 16 ) & 0xFF;
40038259:	88 15 83 7c 00 a8    	mov    %dl,0xa8007c83
            LoRaMacBuffer[pktHeaderLen++] = ( LoRaMacDevAddr >> 24 ) & 0xFF;
4003825f:	a2 84 7c 00 a8       	mov    %al,0xa8007c84
            memcpy( &MacCommandsBuffer[MacCommandsBufferIndex], MacCommandsBufferToRepeat, MacCommandsBufferToRepeatIndex );
40038264:	ba 20 7a 00 a8       	mov    $0xa8007a20,%edx
            LoRaMacBuffer[pktHeaderLen++] = fCtrl->Value;
40038269:	8a 06                	mov    (%esi),%al
4003826b:	a2 85 7c 00 a8       	mov    %al,0xa8007c85
            LoRaMacBuffer[pktHeaderLen++] = UpLinkCounter & 0xFF;
40038270:	a1 50 7a 00 a8       	mov    0xa8007a50,%eax
40038275:	a2 86 7c 00 a8       	mov    %al,0xa8007c86
            LoRaMacBuffer[pktHeaderLen++] = ( UpLinkCounter >> 8 ) & 0xFF;
4003827a:	c1 e8 08             	shr    $0x8,%eax
4003827d:	a2 87 7c 00 a8       	mov    %al,0xa8007c87
            memcpy( &MacCommandsBuffer[MacCommandsBufferIndex], MacCommandsBufferToRepeat, MacCommandsBufferToRepeatIndex );
40038282:	8b 45 ec             	mov    -0x14(%ebp),%eax
40038285:	0f b6 0d 3f 7a 00 a8 	movzbl 0xa8007a3f,%ecx
4003828c:	05 30 7a 00 a8       	add    $0xa8007a30,%eax
40038291:	e8 d4 7d ff ff       	call   4003006a <memcpy>
            MacCommandsBufferIndex += MacCommandsBufferToRepeatIndex;
40038296:	8a 15 3f 7a 00 a8    	mov    0xa8007a3f,%dl
4003829c:	02 15 40 7a 00 a8    	add    0xa8007a40,%dl
            if( ( payload != NULL ) && ( LoRaMacTxPayloadLen > 0 ) )
400382a2:	85 db                	test   %ebx,%ebx
            MacCommandsBufferIndex += MacCommandsBufferToRepeatIndex;
400382a4:	88 15 40 7a 00 a8    	mov    %dl,0xa8007a40
            if( ( payload != NULL ) && ( LoRaMacTxPayloadLen > 0 ) )
400382aa:	74 4c                	je     400382f8 <PrepareFrame+0x2b6>
400382ac:	80 3d 5f 7c 00 a8 00 	cmpb   $0x0,0xa8007c5f
400382b3:	74 43                	je     400382f8 <PrepareFrame+0x2b6>
                if( ( MacCommandsBufferIndex <= LORA_MAC_COMMAND_MAX_LENGTH ) && ( MacCommandsInNextTx == true ) )
400382b5:	80 fa 0f             	cmp    $0xf,%dl
400382b8:	77 5e                	ja     40038318 <PrepareFrame+0x2d6>
400382ba:	80 3d 41 7a 00 a8 00 	cmpb   $0x0,0xa8007a41
400382c1:	74 55                	je     40038318 <PrepareFrame+0x2d6>
                    fCtrl->Bits.FOptsLen += MacCommandsBufferIndex;
400382c3:	8a 06                	mov    (%esi),%al
400382c5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
400382c8:	83 e0 f0             	and    $0xfffffff0,%eax
400382cb:	83 e1 0f             	and    $0xf,%ecx
400382ce:	09 c8                	or     %ecx,%eax
400382d0:	88 06                	mov    %al,(%esi)
                    LoRaMacBuffer[0x05] = fCtrl->Value;
400382d2:	a2 85 7c 00 a8       	mov    %al,0xa8007c85
                    for( i = 0; i < MacCommandsBufferIndex; i++ )
400382d7:	0f b6 f2             	movzbl %dl,%esi
400382da:	31 c0                	xor    %eax,%eax
400382dc:	66 39 c6             	cmp    %ax,%si
400382df:	76 0f                	jbe    400382f0 <PrepareFrame+0x2ae>
                        LoRaMacBuffer[pktHeaderLen++] = MacCommandsBuffer[i];
400382e1:	8a 88 30 7a 00 a8    	mov    -0x57ff85d0(%eax),%cl
400382e7:	40                   	inc    %eax
400382e8:	88 88 87 7c 00 a8    	mov    %cl,-0x57ff8379(%eax)
400382ee:	eb ec                	jmp    400382dc <PrepareFrame+0x29a>
400382f0:	8d 4a 08             	lea    0x8(%edx),%ecx
                    for( i = 0; i < MacCommandsBufferIndex; i++ )
400382f3:	89 5d ec             	mov    %ebx,-0x14(%ebp)
400382f6:	eb 25                	jmp    4003831d <PrepareFrame+0x2db>
                if( ( MacCommandsBufferIndex > 0 ) && ( MacCommandsInNextTx ) )
400382f8:	84 d2                	test   %dl,%dl
400382fa:	74 1c                	je     40038318 <PrepareFrame+0x2d6>
400382fc:	80 3d 41 7a 00 a8 00 	cmpb   $0x0,0xa8007a41
40038303:	74 13                	je     40038318 <PrepareFrame+0x2d6>
                    LoRaMacTxPayloadLen = MacCommandsBufferIndex;
40038305:	88 15 5f 7c 00 a8    	mov    %dl,0xa8007c5f
                    framePort = 0;
4003830b:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
                    payload = MacCommandsBuffer;
4003830f:	c7 45 ec 30 7a 00 a8 	movl   $0xa8007a30,-0x14(%ebp)
40038316:	eb 03                	jmp    4003831b <PrepareFrame+0x2d9>
40038318:	89 5d ec             	mov    %ebx,-0x14(%ebp)
            LoRaMacBuffer[pktHeaderLen++] = ( UpLinkCounter >> 8 ) & 0xFF;
4003831b:	b1 08                	mov    $0x8,%cl
            MacCommandsInNextTx = false;
4003831d:	c6 05 41 7a 00 a8 00 	movb   $0x0,0xa8007a41
40038324:	31 db                	xor    %ebx,%ebx
40038326:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)
    for( i = 0; i < length; i++ )
4003832a:	3a 55 eb             	cmp    -0x15(%ebp),%dl
4003832d:	76 61                	jbe    40038390 <PrepareFrame+0x34e>
        switch( cmdBufIn[i] )
4003832f:	0f b6 75 eb          	movzbl -0x15(%ebp),%esi
40038333:	0f b6 b6 30 7a 00 a8 	movzbl -0x57ff85d0(%esi),%esi
4003833a:	8d 46 fd             	lea    -0x3(%esi),%eax
4003833d:	3c 05                	cmp    $0x5,%al
4003833f:	77 4a                	ja     4003838b <PrepareFrame+0x349>
40038341:	0f b6 f0             	movzbl %al,%esi
40038344:	ff 24 b5 4c cc 03 40 	jmp    *0x4003cc4c(,%esi,4)
                cmdBufOut[cmdCount++] = cmdBufIn[i++];
4003834b:	fe 45 eb             	incb   -0x15(%ebp)
4003834e:	8d 7b 01             	lea    0x1(%ebx),%edi
40038351:	0f b6 f3             	movzbl %bl,%esi
                cmdBufOut[cmdCount++] = cmdBufIn[i];
40038354:	89 f8                	mov    %edi,%eax
40038356:	83 c3 02             	add    $0x2,%ebx
40038359:	0f b6 7d eb          	movzbl -0x15(%ebp),%edi
                cmdBufOut[cmdCount++] = cmdBufIn[i++];
4003835d:	c6 86 20 7a 00 a8 05 	movb   $0x5,-0x57ff85e0(%esi)
                cmdBufOut[cmdCount++] = cmdBufIn[i];
40038364:	0f b6 f0             	movzbl %al,%esi
40038367:	8a 87 30 7a 00 a8    	mov    -0x57ff85d0(%edi),%al
4003836d:	88 86 20 7a 00 a8    	mov    %al,-0x57ff85e0(%esi)
40038373:	eb 16                	jmp    4003838b <PrepareFrame+0x349>
                cmdBufOut[cmdCount++] = cmdBufIn[i];
40038375:	0f b6 f3             	movzbl %bl,%esi
40038378:	43                   	inc    %ebx
40038379:	c6 86 20 7a 00 a8 08 	movb   $0x8,-0x57ff85e0(%esi)
40038380:	eb 09                	jmp    4003838b <PrepareFrame+0x349>
                i += 2;
40038382:	80 45 eb 02          	addb   $0x2,-0x15(%ebp)
40038386:	eb 03                	jmp    4003838b <PrepareFrame+0x349>
                i++;
40038388:	fe 45 eb             	incb   -0x15(%ebp)
    for( i = 0; i < length; i++ )
4003838b:	fe 45 eb             	incb   -0x15(%ebp)
4003838e:	eb 9a                	jmp    4003832a <PrepareFrame+0x2e8>
            MacCommandsBufferToRepeatIndex = ParseMacCommandsToRepeat( MacCommandsBuffer, MacCommandsBufferIndex, MacCommandsBufferToRepeat );
40038390:	88 1d 3f 7a 00 a8    	mov    %bl,0xa8007a3f
            if( MacCommandsBufferToRepeatIndex > 0 )
40038396:	84 db                	test   %bl,%bl
40038398:	74 07                	je     400383a1 <PrepareFrame+0x35f>
                MacCommandsInNextTx = true;
4003839a:	c6 05 41 7a 00 a8 01 	movb   $0x1,0xa8007a41
            MacCommandsBufferIndex = 0;
400383a1:	c6 05 40 7a 00 a8 00 	movb   $0x0,0xa8007a40
            if( ( payload != NULL ) && ( LoRaMacTxPayloadLen > 0 ) )
400383a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400383ac:	74 76                	je     40038424 <PrepareFrame+0x3e2>
400383ae:	0f b6 15 5f 7c 00 a8 	movzbl 0xa8007c5f,%edx
400383b5:	84 d2                	test   %dl,%dl
400383b7:	74 6b                	je     40038424 <PrepareFrame+0x3e2>
                LoRaMacBuffer[pktHeaderLen++] = framePort;
400383b9:	8d 59 01             	lea    0x1(%ecx),%ebx
400383bc:	8a 45 ea             	mov    -0x16(%ebp),%al
400383bf:	0f b6 c9             	movzbl %cl,%ecx
                if( framePort == 0 )
400383c2:	84 c0                	test   %al,%al
                LoRaMacBuffer[pktHeaderLen++] = framePort;
400383c4:	88 81 80 7c 00 a8    	mov    %al,-0x57ff8380(%ecx)
                if( framePort == 0 )
400383ca:	75 1a                	jne    400383e6 <PrepareFrame+0x3a4>
                    LoRaMacPayloadEncrypt( (uint8_t* ) payload, LoRaMacTxPayloadLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, LoRaMacPayload );
400383cc:	68 60 7b 00 a8       	push   $0xa8007b60
400383d1:	b9 a8 7d 00 a8       	mov    $0xa8007da8,%ecx
400383d6:	ff 35 50 7a 00 a8    	pushl  0xa8007a50
400383dc:	6a 00                	push   $0x0
400383de:	ff 35 8c 7d 00 a8    	pushl  0xa8007d8c
400383e4:	eb 18                	jmp    400383fe <PrepareFrame+0x3bc>
                    LoRaMacPayloadEncrypt( (uint8_t* ) payload, LoRaMacTxPayloadLen, LoRaMacAppSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, LoRaMacPayload );
400383e6:	68 60 7b 00 a8       	push   $0xa8007b60
400383eb:	b9 98 7d 00 a8       	mov    $0xa8007d98,%ecx
400383f0:	ff 35 50 7a 00 a8    	pushl  0xa8007a50
400383f6:	6a 00                	push   $0x0
400383f8:	ff 35 8c 7d 00 a8    	pushl  0xa8007d8c
400383fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
40038401:	e8 89 07 00 00       	call   40038b8f <LoRaMacPayloadEncrypt>
40038406:	83 c4 10             	add    $0x10,%esp
                memcpy( LoRaMacBuffer + pktHeaderLen, LoRaMacPayload, LoRaMacTxPayloadLen );
40038409:	0f b6 0d 5f 7c 00 a8 	movzbl 0xa8007c5f,%ecx
40038410:	0f b6 c3             	movzbl %bl,%eax
40038413:	05 80 7c 00 a8       	add    $0xa8007c80,%eax
40038418:	ba 60 7b 00 a8       	mov    $0xa8007b60,%edx
4003841d:	e8 48 7c ff ff       	call   4003006a <memcpy>
                LoRaMacBuffer[pktHeaderLen++] = framePort;
40038422:	88 d9                	mov    %bl,%cl
            LoRaMacComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, &mic );
40038424:	8d 45 f0             	lea    -0x10(%ebp),%eax
40038427:	50                   	push   %eax
40038428:	b8 80 7c 00 a8       	mov    $0xa8007c80,%eax
4003842d:	ff 35 50 7a 00 a8    	pushl  0xa8007a50
            LoRaMacBufferPktLen = pktHeaderLen + LoRaMacTxPayloadLen;
40038433:	0f b6 15 5f 7c 00 a8 	movzbl 0xa8007c5f,%edx
            LoRaMacComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, &mic );
4003843a:	6a 00                	push   $0x0
4003843c:	ff 35 8c 7d 00 a8    	pushl  0xa8007d8c
            LoRaMacBufferPktLen = pktHeaderLen + LoRaMacTxPayloadLen;
40038442:	0f b6 c9             	movzbl %cl,%ecx
40038445:	01 d1                	add    %edx,%ecx
            LoRaMacComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, &mic );
40038447:	0f b7 d1             	movzwl %cx,%edx
            LoRaMacBufferPktLen = pktHeaderLen + LoRaMacTxPayloadLen;
4003844a:	66 89 0d 60 7c 00 a8 	mov    %cx,0xa8007c60
            LoRaMacComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, &mic );
40038451:	b9 a8 7d 00 a8       	mov    $0xa8007da8,%ecx
40038456:	e8 73 06 00 00       	call   40038ace <LoRaMacComputeMic>
            LoRaMacBuffer[LoRaMacBufferPktLen + 0] = mic & 0xFF;
4003845b:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003845e:	0f b7 0d 60 7c 00 a8 	movzwl 0xa8007c60,%ecx
            LoRaMacBuffer[LoRaMacBufferPktLen + 1] = ( mic >> 8 ) & 0xFF;
40038465:	89 c3                	mov    %eax,%ebx
            LoRaMacBuffer[LoRaMacBufferPktLen + 0] = mic & 0xFF;
40038467:	89 ca                	mov    %ecx,%edx
            LoRaMacBuffer[LoRaMacBufferPktLen + 1] = ( mic >> 8 ) & 0xFF;
40038469:	c1 eb 08             	shr    $0x8,%ebx
            LoRaMacBuffer[LoRaMacBufferPktLen + 0] = mic & 0xFF;
4003846c:	88 81 80 7c 00 a8    	mov    %al,-0x57ff8380(%ecx)
            LoRaMacBuffer[LoRaMacBufferPktLen + 1] = ( mic >> 8 ) & 0xFF;
40038472:	88 99 81 7c 00 a8    	mov    %bl,-0x57ff837f(%ecx)
            LoRaMacBuffer[LoRaMacBufferPktLen + 2] = ( mic >> 16 ) & 0xFF;
40038478:	89 c3                	mov    %eax,%ebx
4003847a:	c1 eb 10             	shr    $0x10,%ebx
            LoRaMacBufferPktLen += LORAMAC_MFR_LEN;
4003847d:	83 c2 04             	add    $0x4,%edx
            LoRaMacBuffer[LoRaMacBufferPktLen + 3] = ( mic >> 24 ) & 0xFF;
40038480:	c1 e8 18             	shr    $0x18,%eax
            LoRaMacComputeMic( LoRaMacBuffer, LoRaMacBufferPktLen, LoRaMacNwkSKey, LoRaMacDevAddr, UP_LINK, UpLinkCounter, &mic );
40038483:	83 c4 10             	add    $0x10,%esp
            LoRaMacBuffer[LoRaMacBufferPktLen + 2] = ( mic >> 16 ) & 0xFF;
40038486:	88 99 82 7c 00 a8    	mov    %bl,-0x57ff837e(%ecx)
            LoRaMacBuffer[LoRaMacBufferPktLen + 3] = ( mic >> 24 ) & 0xFF;
4003848c:	88 81 83 7c 00 a8    	mov    %al,-0x57ff837d(%ecx)
            LoRaMacBufferPktLen += LORAMAC_MFR_LEN;
40038492:	66 89 15 60 7c 00 a8 	mov    %dx,0xa8007c60
40038499:	eb 2b                	jmp    400384c6 <PrepareFrame+0x484>
            if( ( fBuffer != NULL ) && ( LoRaMacTxPayloadLen > 0 ) )
4003849b:	84 c9                	test   %cl,%cl
4003849d:	74 27                	je     400384c6 <PrepareFrame+0x484>
4003849f:	85 db                	test   %ebx,%ebx
400384a1:	74 23                	je     400384c6 <PrepareFrame+0x484>
                memcpy( LoRaMacBuffer + pktHeaderLen, ( uint8_t* ) fBuffer, LoRaMacTxPayloadLen );
400384a3:	89 da                	mov    %ebx,%edx
400384a5:	b8 81 7c 00 a8       	mov    $0xa8007c81,%eax
400384aa:	e8 bb 7b ff ff       	call   4003006a <memcpy>
                LoRaMacBufferPktLen = pktHeaderLen + LoRaMacTxPayloadLen;
400384af:	0f b6 05 5f 7c 00 a8 	movzbl 0xa8007c5f,%eax
400384b6:	40                   	inc    %eax
400384b7:	66 a3 60 7c 00 a8    	mov    %ax,0xa8007c60
400384bd:	eb 07                	jmp    400384c6 <PrepareFrame+0x484>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
400384bf:	ba 02 00 00 00       	mov    $0x2,%edx
400384c4:	eb 02                	jmp    400384c8 <PrepareFrame+0x486>
    return LORAMAC_STATUS_OK;
400384c6:	31 d2                	xor    %edx,%edx
}
400384c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
400384cb:	89 d0                	mov    %edx,%eax
400384cd:	5b                   	pop    %ebx
400384ce:	5e                   	pop    %esi
400384cf:	5f                   	pop    %edi
400384d0:	5d                   	pop    %ebp
400384d1:	c3                   	ret    

400384d2 <Send>:
{
400384d2:	55                   	push   %ebp
400384d3:	89 e5                	mov    %esp,%ebp
400384d5:	53                   	push   %ebx
400384d6:	53                   	push   %ebx
    fCtrl.Bits.Adr           = AdrCtrlOn;
400384d7:	8a 1d 48 7a 00 a8    	mov    0xa8007a48,%bl
400384dd:	c1 e3 07             	shl    $0x7,%ebx
400384e0:	88 5d fb             	mov    %bl,-0x5(%ebp)
    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );
400384e3:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
400384e7:	0f b6 d2             	movzbl %dl,%edx
400384ea:	53                   	push   %ebx
400384eb:	51                   	push   %ecx
400384ec:	89 d1                	mov    %edx,%ecx
400384ee:	8d 55 fb             	lea    -0x5(%ebp),%edx
400384f1:	e8 4c fb ff ff       	call   40038042 <PrepareFrame>
400384f6:	5a                   	pop    %edx
    if( status != LORAMAC_STATUS_OK )
400384f7:	85 c0                	test   %eax,%eax
    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );
400384f9:	59                   	pop    %ecx
    if( status != LORAMAC_STATUS_OK )
400384fa:	75 1d                	jne    40038519 <Send+0x47>
    McpsConfirm.UpLinkCounter = UpLinkCounter;
400384fc:	a1 50 7a 00 a8       	mov    0xa8007a50,%eax
    McpsConfirm.NbRetries = 0;
40038501:	c6 05 4b 77 00 a8 00 	movb   $0x0,0xa800774b
    McpsConfirm.AckReceived = false;
40038508:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
    McpsConfirm.UpLinkCounter = UpLinkCounter;
4003850f:	a3 50 77 00 a8       	mov    %eax,0xa8007750
    status = ScheduleTx( );
40038514:	e8 e4 f0 ff ff       	call   400375fd <ScheduleTx>
}
40038519:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4003851c:	c9                   	leave  
4003851d:	c3                   	ret    

4003851e <LoRaMacMlmeRequest>:
    if( mlmeRequest == NULL )
4003851e:	85 c0                	test   %eax,%eax
40038520:	0f 84 4d 01 00 00    	je     40038673 <LoRaMacMlmeRequest+0x155>
    if( ( LoRaMacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
40038526:	f6 05 ac 77 00 a8 01 	testb  $0x1,0xa80077ac
4003852d:	0f 85 46 01 00 00    	jne    40038679 <LoRaMacMlmeRequest+0x15b>
{
40038533:	55                   	push   %ebp
    memset( ( uint8_t* ) &MlmeConfirm, 0, sizeof( MlmeConfirm ) );
40038534:	31 d2                	xor    %edx,%edx
{
40038536:	89 e5                	mov    %esp,%ebp
40038538:	56                   	push   %esi
40038539:	53                   	push   %ebx
4003853a:	89 c3                	mov    %eax,%ebx
4003853c:	51                   	push   %ecx
    memset( ( uint8_t* ) &MlmeConfirm, 0, sizeof( MlmeConfirm ) );
4003853d:	b8 30 77 00 a8       	mov    $0xa8007730,%eax
40038542:	b9 10 00 00 00       	mov    $0x10,%ecx
40038547:	e8 29 7b ff ff       	call   40030075 <memset>
    switch( mlmeRequest->Type )
4003854c:	8b 03                	mov    (%ebx),%eax
    MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
4003854e:	c7 05 34 77 00 a8 01 	movl   $0x1,0xa8007734
40038555:	00 00 00 
    switch( mlmeRequest->Type )
40038558:	83 f8 01             	cmp    $0x1,%eax
4003855b:	0f 84 d3 00 00 00    	je     40038634 <LoRaMacMlmeRequest+0x116>
40038561:	72 28                	jb     4003858b <LoRaMacMlmeRequest+0x6d>
40038563:	83 f8 02             	cmp    $0x2,%eax
40038566:	0f 85 ed 00 00 00    	jne    40038659 <LoRaMacMlmeRequest+0x13b>
            LoRaMacFlags.Bits.MlmeReq = 1;
4003856c:	80 0d 14 84 00 a8 04 	orb    $0x4,0xa8008414
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
40038573:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
            MlmeConfirm.MlmeRequest = mlmeRequest->Type;
40038577:	c7 05 30 77 00 a8 02 	movl   $0x2,0xa8007730
4003857e:	00 00 00 
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
40038581:	e8 ee f2 ff ff       	call   40037874 <SetTxContinuousWave>
            break;
40038586:	e9 c8 00 00 00       	jmp    40038653 <LoRaMacMlmeRequest+0x135>
        return LORAMAC_STATUS_BUSY;
4003858b:	b8 01 00 00 00       	mov    $0x1,%eax
            if( ( LoRaMacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
40038590:	f6 05 ac 77 00 a8 10 	testb  $0x10,0xa80077ac
40038597:	0f 85 cf 00 00 00    	jne    4003866c <LoRaMacMlmeRequest+0x14e>
            if( ( mlmeRequest->Req.Join.DevEui == NULL ) ||
4003859d:	8b 73 04             	mov    0x4(%ebx),%esi
400385a0:	85 f6                	test   %esi,%esi
400385a2:	75 0a                	jne    400385ae <LoRaMacMlmeRequest+0x90>
        return LORAMAC_STATUS_PARAMETER_INVALID;
400385a4:	b8 03 00 00 00       	mov    $0x3,%eax
400385a9:	e9 be 00 00 00       	jmp    4003866c <LoRaMacMlmeRequest+0x14e>
                ( mlmeRequest->Req.Join.AppEui == NULL ) ||
400385ae:	8b 53 08             	mov    0x8(%ebx),%edx
            if( ( mlmeRequest->Req.Join.DevEui == NULL ) ||
400385b1:	85 d2                	test   %edx,%edx
400385b3:	74 ef                	je     400385a4 <LoRaMacMlmeRequest+0x86>
                ( mlmeRequest->Req.Join.AppKey == NULL ) ||
400385b5:	8b 43 0c             	mov    0xc(%ebx),%eax
                ( mlmeRequest->Req.Join.AppEui == NULL ) ||
400385b8:	85 c0                	test   %eax,%eax
400385ba:	74 e8                	je     400385a4 <LoRaMacMlmeRequest+0x86>
                ( mlmeRequest->Req.Join.NbTrials == 0 ) )
400385bc:	8a 4b 10             	mov    0x10(%ebx),%cl
                ( mlmeRequest->Req.Join.AppKey == NULL ) ||
400385bf:	84 c9                	test   %cl,%cl
400385c1:	74 e1                	je     400385a4 <LoRaMacMlmeRequest+0x86>
            if( mlmeRequest->Req.Join.NbTrials < 2 )
400385c3:	80 f9 01             	cmp    $0x1,%cl
400385c6:	77 04                	ja     400385cc <LoRaMacMlmeRequest+0xae>
                mlmeRequest->Req.Join.NbTrials = 2;
400385c8:	c6 43 10 02          	movb   $0x2,0x10(%ebx)
            LoRaMacFlags.Bits.MlmeReq = 1;
400385cc:	80 0d 14 84 00 a8 04 	orb    $0x4,0xa8008414
            LoRaMacAppKey = mlmeRequest->Req.Join.AppKey;
400385d3:	a3 b8 7d 00 a8       	mov    %eax,0xa8007db8
            MaxJoinRequestTrials = mlmeRequest->Req.Join.NbTrials;
400385d8:	8a 43 10             	mov    0x10(%ebx),%al
            LoRaMacAppEui = mlmeRequest->Req.Join.AppEui;
400385db:	89 15 bc 7d 00 a8    	mov    %edx,0xa8007dbc
            MaxJoinRequestTrials = mlmeRequest->Req.Join.NbTrials;
400385e1:	a2 74 77 00 a8       	mov    %al,0xa8007774
            MlmeConfirm.MlmeRequest = mlmeRequest->Type;
400385e6:	c7 05 30 77 00 a8 00 	movl   $0x0,0xa8007730
400385ed:	00 00 00 
            LoRaMacDevEui = mlmeRequest->Req.Join.DevEui;
400385f0:	89 35 c0 7d 00 a8    	mov    %esi,0xa8007dc0
            JoinRequestTrials = 0;
400385f6:	c6 05 75 77 00 a8 00 	movb   $0x0,0xa8007775
            macHdr.Bits.MType  = FRAME_TYPE_JOIN_REQ;
400385fd:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
            ResetMacParameters( );
40038601:	e8 f9 df ff ff       	call   400365ff <ResetMacParameters>
            status = Send( &macHdr, 0, NULL, 0 );
40038606:	6a 00                	push   $0x0
            LoRaMacParams.ChannelsDatarate = AlternateDatarate( JoinRequestTrials + 1 );
40038608:	0f b6 05 75 77 00 a8 	movzbl 0xa8007775,%eax
        datarate = DR_0;
4003860f:	a8 01                	test   $0x1,%al
    LoRaMacParams.ChannelsMask[4] = 0x00FF;
40038611:	66 c7 05 cc 84 00 a8 	movw   $0xff,0xa80084cc
40038618:	ff 00 
        datarate = DR_0;
4003861a:	0f 94 c0             	sete   %al
4003861d:	c1 e0 02             	shl    $0x2,%eax
            status = Send( &macHdr, 0, NULL, 0 );
40038620:	31 d2                	xor    %edx,%edx
            LoRaMacParams.ChannelsDatarate = AlternateDatarate( JoinRequestTrials + 1 );
40038622:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
            status = Send( &macHdr, 0, NULL, 0 );
40038627:	31 c9                	xor    %ecx,%ecx
40038629:	8d 45 f7             	lea    -0x9(%ebp),%eax
4003862c:	e8 a1 fe ff ff       	call   400384d2 <Send>
40038631:	5a                   	pop    %edx
            break;
40038632:	eb 1f                	jmp    40038653 <LoRaMacMlmeRequest+0x135>
            status = AddMacCommand( MOTE_MAC_LINK_CHECK_REQ, 0, 0 );
40038634:	31 c9                	xor    %ecx,%ecx
40038636:	31 d2                	xor    %edx,%edx
40038638:	b8 02 00 00 00       	mov    $0x2,%eax
            MlmeConfirm.MlmeRequest = mlmeRequest->Type;
4003863d:	c7 05 30 77 00 a8 01 	movl   $0x1,0xa8007730
40038644:	00 00 00 
            LoRaMacFlags.Bits.MlmeReq = 1;
40038647:	80 0d 14 84 00 a8 04 	orb    $0x4,0xa8008414
            status = AddMacCommand( MOTE_MAC_LINK_CHECK_REQ, 0, 0 );
4003864e:	e8 69 db ff ff       	call   400361bc <AddMacCommand>
    if( status != LORAMAC_STATUS_OK )
40038653:	85 c0                	test   %eax,%eax
40038655:	74 15                	je     4003866c <LoRaMacMlmeRequest+0x14e>
40038657:	eb 05                	jmp    4003865e <LoRaMacMlmeRequest+0x140>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
40038659:	b8 02 00 00 00       	mov    $0x2,%eax
        LoRaMacFlags.Bits.MlmeReq = 0;
4003865e:	80 25 14 84 00 a8 fb 	andb   $0xfb,0xa8008414
        NodeAckRequested = false;
40038665:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
}
4003866c:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003866f:	5b                   	pop    %ebx
40038670:	5e                   	pop    %esi
40038671:	5d                   	pop    %ebp
40038672:	c3                   	ret    
        return LORAMAC_STATUS_PARAMETER_INVALID;
40038673:	b8 03 00 00 00       	mov    $0x3,%eax
40038678:	c3                   	ret    
        return LORAMAC_STATUS_BUSY;
40038679:	b8 01 00 00 00       	mov    $0x1,%eax
}
4003867e:	c3                   	ret    

4003867f <LoRaMacMcpsRequest>:
    if( mcpsRequest == NULL )
4003867f:	85 c0                	test   %eax,%eax
40038681:	0f 84 ee 00 00 00    	je     40038775 <LoRaMacMcpsRequest+0xf6>
{
40038687:	55                   	push   %ebp
40038688:	89 e5                	mov    %esp,%ebp
4003868a:	56                   	push   %esi
4003868b:	53                   	push   %ebx
4003868c:	51                   	push   %ecx
4003868d:	89 c3                	mov    %eax,%ebx
    if( ( ( LoRaMacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING ) ||
4003868f:	f6 05 ac 77 00 a8 11 	testb  $0x11,0xa80077ac
        return LORAMAC_STATUS_BUSY;
40038696:	b8 01 00 00 00       	mov    $0x1,%eax
    if( ( ( LoRaMacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING ) ||
4003869b:	0f 85 cd 00 00 00    	jne    4003876e <LoRaMacMcpsRequest+0xef>
    memset ( ( uint8_t* ) &McpsConfirm, 0, sizeof( McpsConfirm ) );
400386a1:	31 d2                	xor    %edx,%edx
400386a3:	b9 18 00 00 00       	mov    $0x18,%ecx
400386a8:	b8 40 77 00 a8       	mov    $0xa8007740,%eax
    macHdr.Value = 0;
400386ad:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
    memset ( ( uint8_t* ) &McpsConfirm, 0, sizeof( McpsConfirm ) );
400386b1:	e8 bf 79 ff ff       	call   40030075 <memset>
    switch( mcpsRequest->Type )
400386b6:	8b 03                	mov    (%ebx),%eax
    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
400386b8:	c7 05 44 77 00 a8 01 	movl   $0x1,0xa8007744
400386bf:	00 00 00 
    switch( mcpsRequest->Type )
400386c2:	83 f8 01             	cmp    $0x1,%eax
400386c5:	74 32                	je     400386f9 <LoRaMacMcpsRequest+0x7a>
400386c7:	72 1e                	jb     400386e7 <LoRaMacMcpsRequest+0x68>
400386c9:	83 f8 03             	cmp    $0x3,%eax
400386cc:	75 56                	jne    40038724 <LoRaMacMcpsRequest+0xa5>
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
400386ce:	80 4d f7 e0          	orb    $0xe0,-0x9(%ebp)
            AckTimeoutRetries = 1;
400386d2:	c6 05 1e 67 00 a8 01 	movb   $0x1,0xa800671e
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
400386d9:	8b 73 04             	mov    0x4(%ebx),%esi
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
400386dc:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
            datarate = mcpsRequest->Req.Proprietary.Datarate;
400386e0:	8a 4b 0a             	mov    0xa(%ebx),%cl
    uint8_t fPort = 0;
400386e3:	31 d2                	xor    %edx,%edx
            break;
400386e5:	eb 44                	jmp    4003872b <LoRaMacMcpsRequest+0xac>
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
400386e7:	8a 45 f7             	mov    -0x9(%ebp),%al
            AckTimeoutRetries = 1;
400386ea:	c6 05 1e 67 00 a8 01 	movb   $0x1,0xa800671e
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
400386f1:	83 e0 1f             	and    $0x1f,%eax
400386f4:	83 c8 40             	or     $0x40,%eax
400386f7:	eb 18                	jmp    40038711 <LoRaMacMcpsRequest+0x92>
            AckTimeoutRetries = mcpsRequest->Req.Confirmed.NbTrials;
400386f9:	8a 43 0f             	mov    0xf(%ebx),%al
            AckTimeoutRetriesCounter = 1;
400386fc:	c6 05 1d 67 00 a8 01 	movb   $0x1,0xa800671d
            AckTimeoutRetries = mcpsRequest->Req.Confirmed.NbTrials;
40038703:	a2 1e 67 00 a8       	mov    %al,0xa800671e
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
40038708:	8a 45 f7             	mov    -0x9(%ebp),%al
4003870b:	83 e0 1f             	and    $0x1f,%eax
4003870e:	83 c8 80             	or     $0xffffff80,%eax
40038711:	88 45 f7             	mov    %al,-0x9(%ebp)
            fPort = mcpsRequest->Req.Confirmed.fPort;
40038714:	0f b6 53 04          	movzbl 0x4(%ebx),%edx
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
40038718:	8b 73 08             	mov    0x8(%ebx),%esi
            datarate = mcpsRequest->Req.Confirmed.Datarate;
4003871b:	8a 4b 0e             	mov    0xe(%ebx),%cl
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
4003871e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
            break;
40038722:	eb 07                	jmp    4003872b <LoRaMacMcpsRequest+0xac>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
40038724:	b8 02 00 00 00       	mov    $0x2,%eax
40038729:	eb 43                	jmp    4003876e <LoRaMacMcpsRequest+0xef>
        if( AdrCtrlOn == false )
4003872b:	80 3d 48 7a 00 a8 00 	cmpb   $0x0,0xa8007a48
40038732:	75 12                	jne    40038746 <LoRaMacMcpsRequest+0xc7>
    if( ( value >= min ) && ( value <= max ) )
40038734:	80 f9 04             	cmp    $0x4,%cl
40038737:	76 07                	jbe    40038740 <LoRaMacMcpsRequest+0xc1>
        return LORAMAC_STATUS_PARAMETER_INVALID;
40038739:	b8 03 00 00 00       	mov    $0x3,%eax
4003873e:	eb 2e                	jmp    4003876e <LoRaMacMcpsRequest+0xef>
                LoRaMacParams.ChannelsDatarate = datarate;
40038740:	88 0d a1 84 00 a8    	mov    %cl,0xa80084a1
        status = Send( &macHdr, fPort, fBuffer, fBufferSize );
40038746:	50                   	push   %eax
40038747:	89 f1                	mov    %esi,%ecx
40038749:	8d 45 f7             	lea    -0x9(%ebp),%eax
4003874c:	e8 81 fd ff ff       	call   400384d2 <Send>
40038751:	5a                   	pop    %edx
        if( status == LORAMAC_STATUS_OK )
40038752:	85 c0                	test   %eax,%eax
40038754:	75 11                	jne    40038767 <LoRaMacMcpsRequest+0xe8>
            McpsConfirm.McpsRequest = mcpsRequest->Type;
40038756:	8b 13                	mov    (%ebx),%edx
40038758:	89 15 40 77 00 a8    	mov    %edx,0xa8007740
            LoRaMacFlags.Bits.McpsReq = 1;
4003875e:	80 0d 14 84 00 a8 01 	orb    $0x1,0xa8008414
40038765:	eb 07                	jmp    4003876e <LoRaMacMcpsRequest+0xef>
            NodeAckRequested = false;
40038767:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
}
4003876e:	8d 65 f8             	lea    -0x8(%ebp),%esp
40038771:	5b                   	pop    %ebx
40038772:	5e                   	pop    %esi
40038773:	5d                   	pop    %ebp
40038774:	c3                   	ret    
        return LORAMAC_STATUS_PARAMETER_INVALID;
40038775:	b8 03 00 00 00       	mov    $0x3,%eax
}
4003877a:	c3                   	ret    

4003877b <OnTxDelayedTimerEvent>:
{
4003877b:	55                   	push   %ebp
    k_timer_stop(&TxDelayedTimer);
4003877c:	b8 60 84 00 a8       	mov    $0xa8008460,%eax
{
40038781:	89 e5                	mov    %esp,%ebp
40038783:	51                   	push   %ecx
    k_timer_stop(&TxDelayedTimer);
40038784:	e8 f0 1f 00 00       	call   4003a779 <k_timer_stop>
    LoRaMacState &= ~LORAMAC_TX_DELAYED;
40038789:	83 25 ac 77 00 a8 ef 	andl   $0xffffffef,0xa80077ac
    if( ( LoRaMacFlags.Bits.MlmeReq == 1 ) && ( MlmeConfirm.MlmeRequest == MLME_JOIN ) )
40038790:	f6 05 14 84 00 a8 04 	testb  $0x4,0xa8008414
40038797:	74 4d                	je     400387e6 <OnTxDelayedTimerEvent+0x6b>
40038799:	83 3d 30 77 00 a8 00 	cmpl   $0x0,0xa8007730
400387a0:	75 44                	jne    400387e6 <OnTxDelayedTimerEvent+0x6b>
        ResetMacParameters( );
400387a2:	e8 58 de ff ff       	call   400365ff <ResetMacParameters>
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387a7:	8d 55 ff             	lea    -0x1(%ebp),%edx
        LoRaMacParams.ChannelsDatarate = AlternateDatarate( JoinRequestTrials + 1 );
400387aa:	0f b6 05 75 77 00 a8 	movzbl 0xa8007775,%eax
        datarate = DR_0;
400387b1:	a8 01                	test   $0x1,%al
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387b3:	6a 00                	push   $0x0
        datarate = DR_0;
400387b5:	0f 94 c0             	sete   %al
400387b8:	c1 e0 02             	shl    $0x2,%eax
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387bb:	31 c9                	xor    %ecx,%ecx
        LoRaMacParams.ChannelsDatarate = AlternateDatarate( JoinRequestTrials + 1 );
400387bd:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
        fCtrl.Bits.Adr = AdrCtrlOn;
400387c2:	a0 48 7a 00 a8       	mov    0xa8007a48,%al
400387c7:	c1 e0 07             	shl    $0x7,%eax
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387ca:	6a 00                	push   $0x0
        fCtrl.Bits.Adr = AdrCtrlOn;
400387cc:	88 45 ff             	mov    %al,-0x1(%ebp)
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387cf:	8d 45 fe             	lea    -0x2(%ebp),%eax
    LoRaMacParams.ChannelsMask[4] = 0x00FF;
400387d2:	66 c7 05 cc 84 00 a8 	movw   $0xff,0xa80084cc
400387d9:	ff 00 
        macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;
400387db:	c6 45 fe 00          	movb   $0x0,-0x2(%ebp)
        PrepareFrame( &macHdr, &fCtrl, 0, NULL, 0 );
400387df:	e8 5e f8 ff ff       	call   40038042 <PrepareFrame>
400387e4:	58                   	pop    %eax
400387e5:	5a                   	pop    %edx
    ScheduleTx( );
400387e6:	e8 12 ee ff ff       	call   400375fd <ScheduleTx>
}
400387eb:	c9                   	leave  
400387ec:	c3                   	ret    

400387ed <OnMacStateCheckTimerEvent>:
{
400387ed:	55                   	push   %ebp
    k_timer_stop(&MacStateCheckTimer);
400387ee:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
{
400387f3:	89 e5                	mov    %esp,%ebp
400387f5:	57                   	push   %edi
400387f6:	56                   	push   %esi
400387f7:	53                   	push   %ebx
    k_timer_stop(&MacStateCheckTimer);
400387f8:	e8 7c 1f 00 00       	call   4003a779 <k_timer_stop>
    if( LoRaMacFlags.Bits.MacDone == 1 )
400387fd:	a0 14 84 00 a8       	mov    0xa8008414,%al
40038802:	a8 08                	test   $0x8,%al
40038804:	0f 84 32 02 00 00    	je     40038a3c <OnMacStateCheckTimerEvent+0x24f>
        if( ( LoRaMacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
4003880a:	8b 15 ac 77 00 a8    	mov    0xa80077ac,%edx
40038810:	f6 c2 40             	test   $0x40,%dl
40038813:	74 09                	je     4003881e <OnMacStateCheckTimerEvent+0x31>
            LoRaMacState &= ~LORAMAC_TX_RUNNING;
40038815:	83 e2 be             	and    $0xffffffbe,%edx
40038818:	89 15 ac 77 00 a8    	mov    %edx,0xa80077ac
        if( ( LoRaMacFlags.Bits.MlmeReq == 1 ) || ( ( LoRaMacFlags.Bits.McpsReq == 1 ) ) )
4003881e:	88 c1                	mov    %al,%cl
    bool txTimeout = false;
40038820:	31 d2                	xor    %edx,%edx
        if( ( LoRaMacFlags.Bits.MlmeReq == 1 ) || ( ( LoRaMacFlags.Bits.McpsReq == 1 ) ) )
40038822:	80 e1 05             	and    $0x5,%cl
40038825:	74 38                	je     4003885f <OnMacStateCheckTimerEvent+0x72>
            if( ( McpsConfirm.Status == LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT ) ||
40038827:	83 3d 44 77 00 a8 02 	cmpl   $0x2,0xa8007744
4003882e:	74 09                	je     40038839 <OnMacStateCheckTimerEvent+0x4c>
40038830:	83 3d 34 77 00 a8 02 	cmpl   $0x2,0xa8007734
40038837:	75 26                	jne    4003885f <OnMacStateCheckTimerEvent+0x72>
                LoRaMacState &= ~LORAMAC_TX_RUNNING;
40038839:	83 25 ac 77 00 a8 fe 	andl   $0xfffffffe,0xa80077ac
                McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
40038840:	8a 15 1d 67 00 a8    	mov    0xa800671d,%dl
                McpsConfirm.AckReceived = false;
40038846:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
                McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
4003884d:	88 15 4b 77 00 a8    	mov    %dl,0xa800774b
                McpsConfirm.TxTimeOnAir = 0;
40038853:	c7 05 4c 77 00 a8 00 	movl   $0x0,0xa800774c
4003885a:	00 00 00 
                txTimeout = true;
4003885d:	b2 01                	mov    $0x1,%dl
            if( ( LoRaMacFlags.Bits.MlmeReq == 1 ) || ( ( LoRaMacFlags.Bits.McpsReq == 1 ) ) )
4003885f:	0a 15 43 7a 00 a8    	or     0xa8007a43,%dl
40038865:	84 c9                	test   %cl,%cl
40038867:	0f 95 c1             	setne  %cl
4003886a:	38 ca                	cmp    %cl,%dl
4003886c:	0f 83 80 00 00 00    	jae    400388f2 <OnMacStateCheckTimerEvent+0x105>
                if( ( LoRaMacFlags.Bits.MlmeReq == 1 ) && ( MlmeConfirm.MlmeRequest == MLME_JOIN ) )
40038872:	a8 04                	test   $0x4,%al
40038874:	74 39                	je     400388af <OnMacStateCheckTimerEvent+0xc2>
40038876:	83 3d 30 77 00 a8 00 	cmpl   $0x0,0xa8007730
4003887d:	75 30                	jne    400388af <OnMacStateCheckTimerEvent+0xc2>
                    MlmeConfirm.NbRetries = JoinRequestTrials;
4003887f:	a0 75 77 00 a8       	mov    0xa8007775,%al
40038884:	a2 3e 77 00 a8       	mov    %al,0xa800773e
                    if( MlmeConfirm.Status == LORAMAC_EVENT_INFO_STATUS_OK )
40038889:	83 3d 34 77 00 a8 00 	cmpl   $0x0,0xa8007734
40038890:	75 13                	jne    400388a5 <OnMacStateCheckTimerEvent+0xb8>
                        UpLinkCounter = 0;
40038892:	c7 05 50 7a 00 a8 00 	movl   $0x0,0xa8007a50
40038899:	00 00 00 
                        ChannelsNbRepCounter = 0;
4003889c:	c6 05 c7 77 00 a8 00 	movb   $0x0,0xa80077c7
400388a3:	eb 46                	jmp    400388eb <OnMacStateCheckTimerEvent+0xfe>
                        if( ( JoinRequestTrials >= MaxJoinRequestTrials ) )
400388a5:	3a 05 74 77 00 a8    	cmp    0xa8007774,%al
400388ab:	73 3e                	jae    400388eb <OnMacStateCheckTimerEvent+0xfe>
400388ad:	eb 12                	jmp    400388c1 <OnMacStateCheckTimerEvent+0xd4>
                    if( ( ChannelsNbRepCounter >= LoRaMacParams.ChannelsNbRep ) || ( LoRaMacFlags.Bits.McpsInd == 1 ) )
400388af:	8a 1d c7 77 00 a8    	mov    0xa80077c7,%bl
400388b5:	38 1d b8 84 00 a8    	cmp    %bl,0xa80084b8
400388bb:	76 12                	jbe    400388cf <OnMacStateCheckTimerEvent+0xe2>
400388bd:	a8 02                	test   $0x2,%al
400388bf:	75 0e                	jne    400388cf <OnMacStateCheckTimerEvent+0xe2>
                            LoRaMacFlags.Bits.MacDone = 0;
400388c1:	80 25 14 84 00 a8 f7 	andb   $0xf7,0xa8008414
                            OnTxDelayedTimerEvent( );
400388c8:	e8 ae fe ff ff       	call   4003877b <OnTxDelayedTimerEvent>
400388cd:	eb 23                	jmp    400388f2 <OnMacStateCheckTimerEvent+0x105>
                        AdrAckCounter++;
400388cf:	ff 05 44 7a 00 a8    	incl   0xa8007a44
                        ChannelsNbRepCounter = 0;
400388d5:	c6 05 c7 77 00 a8 00 	movb   $0x0,0xa80077c7
                        if( IsUpLinkCounterFixed == false )
400388dc:	80 3d 4a 7a 00 a8 00 	cmpb   $0x0,0xa8007a4a
400388e3:	75 06                	jne    400388eb <OnMacStateCheckTimerEvent+0xfe>
                            UpLinkCounter++;
400388e5:	ff 05 50 7a 00 a8    	incl   0xa8007a50
                        LoRaMacState &= ~LORAMAC_TX_RUNNING;
400388eb:	83 25 ac 77 00 a8 fe 	andl   $0xfffffffe,0xa80077ac
        if( LoRaMacFlags.Bits.McpsInd == 1 )
400388f2:	f6 05 14 84 00 a8 02 	testb  $0x2,0xa8008414
400388f9:	74 3f                	je     4003893a <OnMacStateCheckTimerEvent+0x14d>
            if( ( McpsConfirm.AckReceived == true ) || ( AckTimeoutRetriesCounter > AckTimeoutRetries ) )
400388fb:	80 3d 4a 77 00 a8 00 	cmpb   $0x0,0xa800774a
40038902:	a0 1d 67 00 a8       	mov    0xa800671d,%al
40038907:	75 08                	jne    40038911 <OnMacStateCheckTimerEvent+0x124>
40038909:	3a 05 1e 67 00 a8    	cmp    0xa800671e,%al
4003890f:	76 29                	jbe    4003893a <OnMacStateCheckTimerEvent+0x14d>
                AckTimeoutRetry = false;
40038911:	c6 05 7c 77 00 a8 00 	movb   $0x0,0xa800777c
                NodeAckRequested = false;
40038918:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
                if( IsUpLinkCounterFixed == false )
4003891f:	80 3d 4a 7a 00 a8 00 	cmpb   $0x0,0xa8007a4a
40038926:	75 06                	jne    4003892e <OnMacStateCheckTimerEvent+0x141>
                    UpLinkCounter++;
40038928:	ff 05 50 7a 00 a8    	incl   0xa8007a50
                LoRaMacState &= ~LORAMAC_TX_RUNNING;
4003892e:	83 25 ac 77 00 a8 fe 	andl   $0xfffffffe,0xa80077ac
                McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
40038935:	a2 4b 77 00 a8       	mov    %al,0xa800774b
        if( ( AckTimeoutRetry == true ) && ( ( LoRaMacState & LORAMAC_TX_DELAYED ) == 0 ) )
4003893a:	80 3d 7c 77 00 a8 00 	cmpb   $0x0,0xa800777c
40038941:	0f 84 f5 00 00 00    	je     40038a3c <OnMacStateCheckTimerEvent+0x24f>
40038947:	8b 3d ac 77 00 a8    	mov    0xa80077ac,%edi
4003894d:	f7 c7 10 00 00 00    	test   $0x10,%edi
40038953:	0f 85 e3 00 00 00    	jne    40038a3c <OnMacStateCheckTimerEvent+0x24f>
            if( ( AckTimeoutRetriesCounter < AckTimeoutRetries ) && ( AckTimeoutRetriesCounter <= MAX_ACK_RETRIES ) )
40038959:	a0 1d 67 00 a8       	mov    0xa800671d,%al
            AckTimeoutRetry = false;
4003895e:	c6 05 7c 77 00 a8 00 	movb   $0x0,0xa800777c
            if( ( AckTimeoutRetriesCounter < AckTimeoutRetries ) && ( AckTimeoutRetriesCounter <= MAX_ACK_RETRIES ) )
40038965:	3a 05 1e 67 00 a8    	cmp    0xa800671e,%al
4003896b:	0f 83 89 00 00 00    	jae    400389fa <OnMacStateCheckTimerEvent+0x20d>
40038971:	3c 08                	cmp    $0x8,%al
40038973:	0f 87 81 00 00 00    	ja     400389fa <OnMacStateCheckTimerEvent+0x20d>
                AckTimeoutRetriesCounter++;
40038979:	8d 70 01             	lea    0x1(%eax),%esi
4003897c:	89 f0                	mov    %esi,%eax
4003897e:	a2 1d 67 00 a8       	mov    %al,0xa800671d
                if( ( AckTimeoutRetriesCounter % 2 ) == 1 )
40038983:	f7 c6 01 00 00 00    	test   $0x1,%esi
40038989:	74 11                	je     4003899c <OnMacStateCheckTimerEvent+0x1af>
                    LoRaMacParams.ChannelsDatarate = UPM_MAX( LoRaMacParams.ChannelsDatarate - 1, LORAMAC_TX_MIN_DATARATE );
4003898b:	0f be 05 a1 84 00 a8 	movsbl 0xa80084a1,%eax
40038992:	48                   	dec    %eax
40038993:	79 02                	jns    40038997 <OnMacStateCheckTimerEvent+0x1aa>
40038995:	31 c0                	xor    %eax,%eax
40038997:	a2 a1 84 00 a8       	mov    %al,0xa80084a1
                if( ValidatePayloadLength( LoRaMacTxPayloadLen, LoRaMacParams.ChannelsDatarate, MacCommandsBufferIndex ) == true )
4003899c:	0f be 15 a1 84 00 a8 	movsbl 0xa80084a1,%edx
400389a3:	0f b6 0d 40 7a 00 a8 	movzbl 0xa8007a40,%ecx
400389aa:	0f b6 05 5f 7c 00 a8 	movzbl 0xa8007c5f,%eax
400389b1:	89 d3                	mov    %edx,%ebx
400389b3:	e8 cb d7 ff ff       	call   40036183 <ValidatePayloadLength>
400389b8:	84 c0                	test   %al,%al
400389ba:	74 0e                	je     400389ca <OnMacStateCheckTimerEvent+0x1dd>
                    LoRaMacFlags.Bits.MacDone = 0;
400389bc:	80 25 14 84 00 a8 f7 	andb   $0xf7,0xa8008414
                    ScheduleTx( );
400389c3:	e8 35 ec ff ff       	call   400375fd <ScheduleTx>
400389c8:	eb 72                	jmp    40038a3c <OnMacStateCheckTimerEvent+0x24f>
                    LoRaMacState &= ~LORAMAC_TX_RUNNING;
400389ca:	83 e7 fe             	and    $0xfffffffe,%edi
                    McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
400389cd:	89 f0                	mov    %esi,%eax
                    McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
400389cf:	c7 05 44 77 00 a8 07 	movl   $0x7,0xa8007744
400389d6:	00 00 00 
                    LoRaMacState &= ~LORAMAC_TX_RUNNING;
400389d9:	89 3d ac 77 00 a8    	mov    %edi,0xa80077ac
                    NodeAckRequested = false;
400389df:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
                    McpsConfirm.AckReceived = false;
400389e6:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
                    McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
400389ed:	a2 4b 77 00 a8       	mov    %al,0xa800774b
                    McpsConfirm.Datarate = LoRaMacParams.ChannelsDatarate;
400389f2:	88 1d 48 77 00 a8    	mov    %bl,0xa8007748
400389f8:	eb 33                	jmp    40038a2d <OnMacStateCheckTimerEvent+0x240>
                memcpy( ( uint8_t* )LoRaMacParams.ChannelsMask, ( uint8_t* )LoRaMacParamsDefaults.ChannelsMask, sizeof( LoRaMacParams.ChannelsMask ) );
400389fa:	b9 0c 00 00 00       	mov    $0xc,%ecx
400389ff:	ba 44 84 00 a8       	mov    $0xa8008444,%edx
40038a04:	b8 c4 84 00 a8       	mov    $0xa80084c4,%eax
40038a09:	e8 5c 76 ff ff       	call   4003006a <memcpy>
                McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
40038a0e:	a0 1d 67 00 a8       	mov    0xa800671d,%al
                LoRaMacState &= ~LORAMAC_TX_RUNNING;
40038a13:	83 25 ac 77 00 a8 fe 	andl   $0xfffffffe,0xa80077ac
                NodeAckRequested = false;
40038a1a:	c6 05 43 7a 00 a8 00 	movb   $0x0,0xa8007a43
                McpsConfirm.AckReceived = false;
40038a21:	c6 05 4a 77 00 a8 00 	movb   $0x0,0xa800774a
                McpsConfirm.NbRetries = AckTimeoutRetriesCounter;
40038a28:	a2 4b 77 00 a8       	mov    %al,0xa800774b
                if( IsUpLinkCounterFixed == false )
40038a2d:	80 3d 4a 7a 00 a8 00 	cmpb   $0x0,0xa8007a4a
40038a34:	75 06                	jne    40038a3c <OnMacStateCheckTimerEvent+0x24f>
                    UpLinkCounter++;
40038a36:	ff 05 50 7a 00 a8    	incl   0xa8007a50
    if( ( LoRaMacState & LORAMAC_RX ) == LORAMAC_RX )
40038a3c:	a1 ac 77 00 a8       	mov    0xa80077ac,%eax
40038a41:	a8 02                	test   $0x2,%al
40038a43:	74 08                	je     40038a4d <OnMacStateCheckTimerEvent+0x260>
        LoRaMacState &= ~LORAMAC_RX;
40038a45:	83 e0 fd             	and    $0xfffffffd,%eax
40038a48:	a3 ac 77 00 a8       	mov    %eax,0xa80077ac
    if( LoRaMacState == LORAMAC_IDLE )
40038a4d:	83 3d ac 77 00 a8 00 	cmpl   $0x0,0xa80077ac
40038a54:	75 44                	jne    40038a9a <OnMacStateCheckTimerEvent+0x2ad>
        if( LoRaMacFlags.Bits.McpsReq == 1 )
40038a56:	f6 05 14 84 00 a8 01 	testb  $0x1,0xa8008414
40038a5d:	74 14                	je     40038a73 <OnMacStateCheckTimerEvent+0x286>
            LoRaMacPrimitives->MacMcpsConfirm( &McpsConfirm );
40038a5f:	8b 15 a8 77 00 a8    	mov    0xa80077a8,%edx
40038a65:	b8 40 77 00 a8       	mov    $0xa8007740,%eax
40038a6a:	ff 12                	call   *(%edx)
            LoRaMacFlags.Bits.McpsReq = 0;
40038a6c:	80 25 14 84 00 a8 fe 	andb   $0xfe,0xa8008414
        if( LoRaMacFlags.Bits.MlmeReq == 1 )
40038a73:	f6 05 14 84 00 a8 04 	testb  $0x4,0xa8008414
40038a7a:	74 15                	je     40038a91 <OnMacStateCheckTimerEvent+0x2a4>
            LoRaMacPrimitives->MacMlmeConfirm( &MlmeConfirm );
40038a7c:	8b 15 a8 77 00 a8    	mov    0xa80077a8,%edx
40038a82:	b8 30 77 00 a8       	mov    $0xa8007730,%eax
40038a87:	ff 52 08             	call   *0x8(%edx)
            LoRaMacFlags.Bits.MlmeReq = 0;
40038a8a:	80 25 14 84 00 a8 fb 	andb   $0xfb,0xa8008414
        LoRaMacFlags.Bits.MacDone = 0;
40038a91:	80 25 14 84 00 a8 f7 	andb   $0xf7,0xa8008414
40038a98:	eb 11                	jmp    40038aab <OnMacStateCheckTimerEvent+0x2be>
        k_timer_start(&MacStateCheckTimer, MAC_STATE_CHECK_TIMEOUT, 0);
40038a9a:	31 c9                	xor    %ecx,%ecx
40038a9c:	ba e8 03 00 00       	mov    $0x3e8,%edx
40038aa1:	b8 c0 81 00 a8       	mov    $0xa80081c0,%eax
40038aa6:	e8 6f 1c 00 00       	call   4003a71a <k_timer_start>
    if( LoRaMacFlags.Bits.McpsInd == 1 )
40038aab:	f6 05 14 84 00 a8 02 	testb  $0x2,0xa8008414
40038ab2:	74 15                	je     40038ac9 <OnMacStateCheckTimerEvent+0x2dc>
        LoRaMacPrimitives->MacMcpsIndication( &McpsIndication );
40038ab4:	8b 15 a8 77 00 a8    	mov    0xa80077a8,%edx
40038aba:	b8 58 77 00 a8       	mov    $0xa8007758,%eax
40038abf:	ff 52 04             	call   *0x4(%edx)
        LoRaMacFlags.Bits.McpsInd = 0;
40038ac2:	80 25 14 84 00 a8 fd 	andb   $0xfd,0xa8008414
}
40038ac9:	5b                   	pop    %ebx
40038aca:	5e                   	pop    %esi
40038acb:	5f                   	pop    %edi
40038acc:	5d                   	pop    %ebp
40038acd:	c3                   	ret    

40038ace <LoRaMacComputeMic>:
 * \param [IN]  dir             Frame direction [0: uplink, 1: downlink]
 * \param [IN]  sequenceCounter Frame sequence counter
 * \param [OUT] mic Computed MIC field
 */
void LoRaMacComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint32_t *mic )
{
40038ace:	55                   	push   %ebp
40038acf:	89 e5                	mov    %esp,%ebp
40038ad1:	57                   	push   %edi
40038ad2:	89 cf                	mov    %ecx,%edi
40038ad4:	56                   	push   %esi
40038ad5:	8b 4d 08             	mov    0x8(%ebp),%ecx
40038ad8:	53                   	push   %ebx
40038ad9:	89 d3                	mov    %edx,%ebx
    MicBlockB0[5] = dir;
40038adb:	8b 55 0c             	mov    0xc(%ebp),%edx
40038ade:	88 15 45 67 00 a8    	mov    %dl,0xa8006745
    
    MicBlockB0[6] = ( address ) & 0xFF;
    MicBlockB0[7] = ( address >> 8 ) & 0xFF;
40038ae4:	89 ca                	mov    %ecx,%edx
40038ae6:	c1 ea 08             	shr    $0x8,%edx
{
40038ae9:	89 c6                	mov    %eax,%esi
    MicBlockB0[7] = ( address >> 8 ) & 0xFF;
40038aeb:	88 15 47 67 00 a8    	mov    %dl,0xa8006747
    MicBlockB0[8] = ( address >> 16 ) & 0xFF;
40038af1:	89 ca                	mov    %ecx,%edx
{
40038af3:	8b 45 10             	mov    0x10(%ebp),%eax
    MicBlockB0[6] = ( address ) & 0xFF;
40038af6:	88 0d 46 67 00 a8    	mov    %cl,0xa8006746
    MicBlockB0[8] = ( address >> 16 ) & 0xFF;
40038afc:	c1 ea 10             	shr    $0x10,%edx
    MicBlockB0[9] = ( address >> 24 ) & 0xFF;

    MicBlockB0[10] = ( sequenceCounter ) & 0xFF;
40038aff:	a2 4a 67 00 a8       	mov    %al,0xa800674a
    MicBlockB0[8] = ( address >> 16 ) & 0xFF;
40038b04:	88 15 48 67 00 a8    	mov    %dl,0xa8006748
    MicBlockB0[11] = ( sequenceCounter >> 8 ) & 0xFF;
40038b0a:	89 c2                	mov    %eax,%edx
40038b0c:	c1 ea 08             	shr    $0x8,%edx
    MicBlockB0[12] = ( sequenceCounter >> 16 ) & 0xFF;
    MicBlockB0[13] = ( sequenceCounter >> 24 ) & 0xFF;

    MicBlockB0[15] = size & 0xFF;
40038b0f:	88 1d 4f 67 00 a8    	mov    %bl,0xa800674f
    MicBlockB0[9] = ( address >> 24 ) & 0xFF;
40038b15:	c1 e9 18             	shr    $0x18,%ecx
    MicBlockB0[11] = ( sequenceCounter >> 8 ) & 0xFF;
40038b18:	88 15 4b 67 00 a8    	mov    %dl,0xa800674b
    MicBlockB0[12] = ( sequenceCounter >> 16 ) & 0xFF;
40038b1e:	89 c2                	mov    %eax,%edx
    MicBlockB0[9] = ( address >> 24 ) & 0xFF;
40038b20:	88 0d 49 67 00 a8    	mov    %cl,0xa8006749
    MicBlockB0[13] = ( sequenceCounter >> 24 ) & 0xFF;
40038b26:	c1 e8 18             	shr    $0x18,%eax
    MicBlockB0[12] = ( sequenceCounter >> 16 ) & 0xFF;
40038b29:	c1 ea 10             	shr    $0x10,%edx
    MicBlockB0[13] = ( sequenceCounter >> 24 ) & 0xFF;
40038b2c:	a2 4d 67 00 a8       	mov    %al,0xa800674d

    AES_CMAC_Init( AesCmacCtx );
40038b31:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
    MicBlockB0[12] = ( sequenceCounter >> 16 ) & 0xFF;
40038b36:	88 15 4c 67 00 a8    	mov    %dl,0xa800674c
    AES_CMAC_Init( AesCmacCtx );
40038b3c:	e8 c5 08 00 00       	call   40039406 <AES_CMAC_Init>

    AES_CMAC_SetKey( AesCmacCtx, key );
40038b41:	89 fa                	mov    %edi,%edx
40038b43:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
40038b48:	e8 eb 08 00 00       	call   40039438 <AES_CMAC_SetKey>

    AES_CMAC_Update( AesCmacCtx, MicBlockB0, LORAMAC_MIC_BLOCK_B0_SIZE );
40038b4d:	b9 10 00 00 00       	mov    $0x10,%ecx
40038b52:	ba 40 67 00 a8       	mov    $0xa8006740,%edx
40038b57:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
40038b5c:	e8 ed 08 00 00       	call   4003944e <AES_CMAC_Update>
    
    AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
40038b61:	89 f2                	mov    %esi,%edx
40038b63:	0f b6 cb             	movzbl %bl,%ecx
40038b66:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
40038b6b:	e8 de 08 00 00       	call   4003944e <AES_CMAC_Update>
    
    AES_CMAC_Final( Mic, AesCmacCtx );
40038b70:	ba e0 7d 00 a8       	mov    $0xa8007de0,%edx
40038b75:	b8 04 80 00 a8       	mov    $0xa8008004,%eax
40038b7a:	e8 c5 09 00 00       	call   40039544 <AES_CMAC_Final>
    
    *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
40038b7f:	8b 45 14             	mov    0x14(%ebp),%eax
40038b82:	8b 15 04 80 00 a8    	mov    0xa8008004,%edx
40038b88:	89 10                	mov    %edx,(%eax)
}
40038b8a:	5b                   	pop    %ebx
40038b8b:	5e                   	pop    %esi
40038b8c:	5f                   	pop    %edi
40038b8d:	5d                   	pop    %ebp
40038b8e:	c3                   	ret    

40038b8f <LoRaMacPayloadEncrypt>:

void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint8_t *encBuffer )
{
40038b8f:	55                   	push   %ebp
40038b90:	89 e5                	mov    %esp,%ebp
40038b92:	57                   	push   %edi
40038b93:	56                   	push   %esi
40038b94:	53                   	push   %ebx
40038b95:	83 ec 0c             	sub    $0xc,%esp
40038b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
40038b9b:	8b 45 0c             	mov    0xc(%ebp),%eax
40038b9e:	89 d6                	mov    %edx,%esi
40038ba0:	89 cf                	mov    %ecx,%edi
40038ba2:	89 45 f0             	mov    %eax,-0x10(%ebp)
40038ba5:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    uint16_t i;
    uint8_t bufferIndex = 0;
    uint16_t ctr = 1;

    memset( AesContext.ksch, '\0', 240 );
40038ba9:	b9 f0 00 00 00       	mov    $0xf0,%ecx
40038bae:	31 d2                	xor    %edx,%edx
40038bb0:	b8 00 7f 00 a8       	mov    $0xa8007f00,%eax
{
40038bb5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    memset( AesContext.ksch, '\0', 240 );
40038bb8:	e8 b8 74 ff ff       	call   40030075 <memset>
    aes_set_key( key, 16, &AesContext );
40038bbd:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038bc2:	ba 10 00 00 00       	mov    $0x10,%edx
40038bc7:	89 f8                	mov    %edi,%eax
40038bc9:	e8 82 03 00 00       	call   40038f50 <aes_set_key>

    aBlock[5] = dir;
40038bce:	8a 45 f0             	mov    -0x10(%ebp),%al
40038bd1:	a2 35 67 00 a8       	mov    %al,0xa8006735

    aBlock[6] = ( address ) & 0xFF;
    aBlock[7] = ( address >> 8 ) & 0xFF;
40038bd6:	89 d8                	mov    %ebx,%eax
40038bd8:	c1 e8 08             	shr    $0x8,%eax
    aBlock[6] = ( address ) & 0xFF;
40038bdb:	88 1d 36 67 00 a8    	mov    %bl,0xa8006736
    aBlock[7] = ( address >> 8 ) & 0xFF;
40038be1:	a2 37 67 00 a8       	mov    %al,0xa8006737
    aBlock[8] = ( address >> 16 ) & 0xFF;
40038be6:	89 d8                	mov    %ebx,%eax
40038be8:	c1 e8 10             	shr    $0x10,%eax
    uint16_t ctr = 1;
40038beb:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
    aBlock[9] = ( address >> 24 ) & 0xFF;
40038bf1:	c1 eb 18             	shr    $0x18,%ebx
    aBlock[8] = ( address >> 16 ) & 0xFF;
40038bf4:	a2 38 67 00 a8       	mov    %al,0xa8006738

    aBlock[10] = ( sequenceCounter ) & 0xFF;
40038bf9:	8a 45 10             	mov    0x10(%ebp),%al
    aBlock[9] = ( address >> 24 ) & 0xFF;
40038bfc:	88 1d 39 67 00 a8    	mov    %bl,0xa8006739
    aBlock[10] = ( sequenceCounter ) & 0xFF;
40038c02:	a2 3a 67 00 a8       	mov    %al,0xa800673a
    aBlock[11] = ( sequenceCounter >> 8 ) & 0xFF;
40038c07:	8b 45 10             	mov    0x10(%ebp),%eax
40038c0a:	c1 e8 08             	shr    $0x8,%eax
    aBlock[12] = ( sequenceCounter >> 16 ) & 0xFF;
    aBlock[13] = ( sequenceCounter >> 24 ) & 0xFF;

    while( size >= 16 )
40038c0d:	89 f3                	mov    %esi,%ebx
    aBlock[11] = ( sequenceCounter >> 8 ) & 0xFF;
40038c0f:	a2 3b 67 00 a8       	mov    %al,0xa800673b
    aBlock[12] = ( sequenceCounter >> 16 ) & 0xFF;
40038c14:	8b 45 10             	mov    0x10(%ebp),%eax
40038c17:	c1 e8 10             	shr    $0x10,%eax
40038c1a:	a2 3c 67 00 a8       	mov    %al,0xa800673c
    aBlock[13] = ( sequenceCounter >> 24 ) & 0xFF;
40038c1f:	8b 45 10             	mov    0x10(%ebp),%eax
40038c22:	c1 e8 18             	shr    $0x18,%eax
40038c25:	a2 3d 67 00 a8       	mov    %al,0xa800673d
40038c2a:	8a 45 e8             	mov    -0x18(%ebp),%al
40038c2d:	29 d8                	sub    %ebx,%eax
    while( size >= 16 )
40038c2f:	66 83 fb 0f          	cmp    $0xf,%bx
40038c33:	88 45 eb             	mov    %al,-0x15(%ebp)
40038c36:	76 47                	jbe    40038c7f <LoRaMacPayloadEncrypt+0xf0>
    {
        aBlock[15] = ( ( ctr ) & 0xFF );
40038c38:	8a 45 f0             	mov    -0x10(%ebp),%al
        ctr++;
        aes_encrypt( aBlock, sBlock, &AesContext );
40038c3b:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
        aBlock[15] = ( ( ctr ) & 0xFF );
40038c40:	a2 3f 67 00 a8       	mov    %al,0xa800673f
        aes_encrypt( aBlock, sBlock, &AesContext );
40038c45:	ba f4 7f 00 a8       	mov    $0xa8007ff4,%edx
        ctr++;
40038c4a:	66 ff 45 f0          	incw   -0x10(%ebp)
        aes_encrypt( aBlock, sBlock, &AesContext );
40038c4e:	b8 30 67 00 a8       	mov    $0xa8006730,%eax
40038c53:	e8 4a 04 00 00       	call   400390a2 <aes_encrypt>
        for( i = 0; i < 16; i++ )
        {
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
40038c58:	8b 7d 14             	mov    0x14(%ebp),%edi
40038c5b:	0f b6 4d eb          	movzbl -0x15(%ebp),%ecx
        aes_encrypt( aBlock, sBlock, &AesContext );
40038c5f:	31 c0                	xor    %eax,%eax
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
40038c61:	01 cf                	add    %ecx,%edi
40038c63:	8b 55 ec             	mov    -0x14(%ebp),%edx
40038c66:	01 ca                	add    %ecx,%edx
40038c68:	8a 14 02             	mov    (%edx,%eax,1),%dl
40038c6b:	32 90 f4 7f 00 a8    	xor    -0x57ff800c(%eax),%dl
40038c71:	88 14 07             	mov    %dl,(%edi,%eax,1)
40038c74:	40                   	inc    %eax
        for( i = 0; i < 16; i++ )
40038c75:	83 f8 10             	cmp    $0x10,%eax
40038c78:	75 e9                	jne    40038c63 <LoRaMacPayloadEncrypt+0xd4>
        }
        size -= 16;
40038c7a:	83 eb 10             	sub    $0x10,%ebx
40038c7d:	eb ab                	jmp    40038c2a <LoRaMacPayloadEncrypt+0x9b>
40038c7f:	89 f0                	mov    %esi,%eax
40038c81:	66 c1 e8 04          	shr    $0x4,%ax
40038c85:	88 c3                	mov    %al,%bl
40038c87:	40                   	inc    %eax
40038c88:	c1 e3 04             	shl    $0x4,%ebx
        bufferIndex += 16;
    }

    if( size > 0 )
40038c8b:	66 83 e6 0f          	and    $0xf,%si
40038c8f:	74 3b                	je     40038ccc <LoRaMacPayloadEncrypt+0x13d>
    {
        aBlock[15] = ( ( ctr ) & 0xFF );
40038c91:	a2 3f 67 00 a8       	mov    %al,0xa800673f
        aes_encrypt( aBlock, sBlock, &AesContext );
40038c96:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038c9b:	ba f4 7f 00 a8       	mov    $0xa8007ff4,%edx
40038ca0:	b8 30 67 00 a8       	mov    $0xa8006730,%eax
40038ca5:	e8 f8 03 00 00       	call   400390a2 <aes_encrypt>
        for( i = 0; i < size; i++ )
        {
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
40038caa:	8b 4d 14             	mov    0x14(%ebp),%ecx
40038cad:	0f b6 db             	movzbl %bl,%ebx
        aes_encrypt( aBlock, sBlock, &AesContext );
40038cb0:	31 c0                	xor    %eax,%eax
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
40038cb2:	01 d9                	add    %ebx,%ecx
40038cb4:	8b 7d ec             	mov    -0x14(%ebp),%edi
40038cb7:	8d 14 1f             	lea    (%edi,%ebx,1),%edx
40038cba:	8a 14 02             	mov    (%edx,%eax,1),%dl
40038cbd:	32 90 f4 7f 00 a8    	xor    -0x57ff800c(%eax),%dl
40038cc3:	88 14 01             	mov    %dl,(%ecx,%eax,1)
40038cc6:	40                   	inc    %eax
        for( i = 0; i < size; i++ )
40038cc7:	66 39 c6             	cmp    %ax,%si
40038cca:	77 e8                	ja     40038cb4 <LoRaMacPayloadEncrypt+0x125>
        }
    }
}
40038ccc:	83 c4 0c             	add    $0xc,%esp
40038ccf:	5b                   	pop    %ebx
40038cd0:	5e                   	pop    %esi
40038cd1:	5f                   	pop    %edi
40038cd2:	5d                   	pop    %ebp
40038cd3:	c3                   	ret    

40038cd4 <LoRaMacPayloadDecrypt>:

void LoRaMacPayloadDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint8_t *decBuffer )
{
40038cd4:	55                   	push   %ebp
40038cd5:	89 e5                	mov    %esp,%ebp
40038cd7:	53                   	push   %ebx
    LoRaMacPayloadEncrypt( buffer, size, key, address, dir, sequenceCounter, decBuffer );
40038cd8:	0f b7 d2             	movzwl %dx,%edx
40038cdb:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
40038cdf:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
40038ce2:	5b                   	pop    %ebx
40038ce3:	5d                   	pop    %ebp
    LoRaMacPayloadEncrypt( buffer, size, key, address, dir, sequenceCounter, decBuffer );
40038ce4:	e9 a6 fe ff ff       	jmp    40038b8f <LoRaMacPayloadEncrypt>

40038ce9 <LoRaMacJoinComputeMic>:

void LoRaMacJoinComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t *mic )
{
40038ce9:	55                   	push   %ebp
40038cea:	89 e5                	mov    %esp,%ebp
40038cec:	57                   	push   %edi
40038ced:	89 cf                	mov    %ecx,%edi
40038cef:	56                   	push   %esi
40038cf0:	89 c6                	mov    %eax,%esi
    AES_CMAC_Init( AesCmacCtx );
40038cf2:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
{
40038cf7:	53                   	push   %ebx
40038cf8:	89 d3                	mov    %edx,%ebx
    AES_CMAC_Init( AesCmacCtx );
40038cfa:	e8 07 07 00 00       	call   40039406 <AES_CMAC_Init>

    AES_CMAC_SetKey( AesCmacCtx, key );
40038cff:	89 fa                	mov    %edi,%edx
40038d01:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
40038d06:	e8 2d 07 00 00       	call   40039438 <AES_CMAC_SetKey>

    AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
40038d0b:	89 f2                	mov    %esi,%edx
40038d0d:	0f b6 cb             	movzbl %bl,%ecx
40038d10:	b8 e0 7d 00 a8       	mov    $0xa8007de0,%eax
40038d15:	e8 34 07 00 00       	call   4003944e <AES_CMAC_Update>

    AES_CMAC_Final( Mic, AesCmacCtx );
40038d1a:	ba e0 7d 00 a8       	mov    $0xa8007de0,%edx
40038d1f:	b8 04 80 00 a8       	mov    $0xa8008004,%eax
40038d24:	e8 1b 08 00 00       	call   40039544 <AES_CMAC_Final>

    *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
40038d29:	8b 45 08             	mov    0x8(%ebp),%eax
40038d2c:	8b 15 04 80 00 a8    	mov    0xa8008004,%edx
40038d32:	89 10                	mov    %edx,(%eax)
}
40038d34:	5b                   	pop    %ebx
40038d35:	5e                   	pop    %esi
40038d36:	5f                   	pop    %edi
40038d37:	5d                   	pop    %ebp
40038d38:	c3                   	ret    

40038d39 <LoRaMacJoinDecrypt>:

void LoRaMacJoinDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint8_t *decBuffer )
{
40038d39:	55                   	push   %ebp
40038d3a:	89 e5                	mov    %esp,%ebp
40038d3c:	57                   	push   %edi
40038d3d:	89 cf                	mov    %ecx,%edi
40038d3f:	56                   	push   %esi
    memset( AesContext.ksch, '\0', 240 );
40038d40:	b9 f0 00 00 00       	mov    $0xf0,%ecx
{
40038d45:	53                   	push   %ebx
40038d46:	89 c3                	mov    %eax,%ebx
40038d48:	56                   	push   %esi
    memset( AesContext.ksch, '\0', 240 );
40038d49:	b8 00 7f 00 a8       	mov    $0xa8007f00,%eax
{
40038d4e:	89 55 f0             	mov    %edx,-0x10(%ebp)
    memset( AesContext.ksch, '\0', 240 );
40038d51:	31 d2                	xor    %edx,%edx
{
40038d53:	8b 75 08             	mov    0x8(%ebp),%esi
    memset( AesContext.ksch, '\0', 240 );
40038d56:	e8 1a 73 ff ff       	call   40030075 <memset>
    aes_set_key( key, 16, &AesContext );
40038d5b:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038d60:	ba 10 00 00 00       	mov    $0x10,%edx
40038d65:	89 f8                	mov    %edi,%eax
40038d67:	e8 e4 01 00 00       	call   40038f50 <aes_set_key>
    aes_encrypt( buffer, decBuffer, &AesContext );
40038d6c:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038d71:	89 f2                	mov    %esi,%edx
40038d73:	89 d8                	mov    %ebx,%eax
40038d75:	e8 28 03 00 00       	call   400390a2 <aes_encrypt>
    // Check if optional CFList is included
    if( size >= 16 )
40038d7a:	66 83 7d f0 0f       	cmpw   $0xf,-0x10(%ebp)
40038d7f:	76 15                	jbe    40038d96 <LoRaMacJoinDecrypt+0x5d>
    {
        aes_encrypt( buffer + 16, decBuffer + 16, &AesContext );
40038d81:	8d 56 10             	lea    0x10(%esi),%edx
40038d84:	8d 43 10             	lea    0x10(%ebx),%eax
40038d87:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
    }
}
40038d8c:	5b                   	pop    %ebx
40038d8d:	5b                   	pop    %ebx
40038d8e:	5e                   	pop    %esi
40038d8f:	5f                   	pop    %edi
40038d90:	5d                   	pop    %ebp
        aes_encrypt( buffer + 16, decBuffer + 16, &AesContext );
40038d91:	e9 0c 03 00 00       	jmp    400390a2 <aes_encrypt>
}
40038d96:	58                   	pop    %eax
40038d97:	5b                   	pop    %ebx
40038d98:	5e                   	pop    %esi
40038d99:	5f                   	pop    %edi
40038d9a:	5d                   	pop    %ebp
40038d9b:	c3                   	ret    

40038d9c <LoRaMacJoinComputeSKeys>:

void LoRaMacJoinComputeSKeys( const uint8_t *key, const uint8_t *appNonce, uint16_t devNonce, uint8_t *nwkSKey, uint8_t *appSKey )
{
40038d9c:	55                   	push   %ebp
40038d9d:	89 e5                	mov    %esp,%ebp
40038d9f:	56                   	push   %esi
40038da0:	53                   	push   %ebx
40038da1:	89 c6                	mov    %eax,%esi
40038da3:	83 ec 14             	sub    $0x14,%esp
40038da6:	89 d3                	mov    %edx,%ebx
40038da8:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    uint8_t nonce[16];
    uint8_t *pDevNonce = ( uint8_t * )&devNonce;
    
    memset( AesContext.ksch, '\0', 240 );
40038dac:	31 d2                	xor    %edx,%edx
40038dae:	b9 f0 00 00 00       	mov    $0xf0,%ecx
40038db3:	b8 00 7f 00 a8       	mov    $0xa8007f00,%eax
40038db8:	e8 b8 72 ff ff       	call   40030075 <memset>
    aes_set_key( key, 16, &AesContext );
40038dbd:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038dc2:	ba 10 00 00 00       	mov    $0x10,%edx
40038dc7:	89 f0                	mov    %esi,%eax
40038dc9:	e8 82 01 00 00       	call   40038f50 <aes_set_key>

    memset( nonce, 0, sizeof( nonce ) );
40038dce:	b9 10 00 00 00       	mov    $0x10,%ecx
40038dd3:	31 d2                	xor    %edx,%edx
40038dd5:	8d 45 e8             	lea    -0x18(%ebp),%eax
40038dd8:	e8 98 72 ff ff       	call   40030075 <memset>
    nonce[0] = 0x01;
    memcpy( nonce + 1, appNonce, 6 );
40038ddd:	89 da                	mov    %ebx,%edx
40038ddf:	b9 06 00 00 00       	mov    $0x6,%ecx
40038de4:	8d 45 e9             	lea    -0x17(%ebp),%eax
    nonce[0] = 0x01;
40038de7:	c6 45 e8 01          	movb   $0x1,-0x18(%ebp)
    memcpy( nonce + 1, appNonce, 6 );
40038deb:	e8 7a 72 ff ff       	call   4003006a <memcpy>
    memcpy( nonce + 7, pDevNonce, 2 );
40038df0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
40038df3:	b9 02 00 00 00       	mov    $0x2,%ecx
40038df8:	8d 45 ef             	lea    -0x11(%ebp),%eax
40038dfb:	e8 6a 72 ff ff       	call   4003006a <memcpy>
    aes_encrypt( nonce, nwkSKey, &AesContext );
40038e00:	8b 55 08             	mov    0x8(%ebp),%edx
40038e03:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038e08:	8d 45 e8             	lea    -0x18(%ebp),%eax
40038e0b:	e8 92 02 00 00       	call   400390a2 <aes_encrypt>

    memset( nonce, 0, sizeof( nonce ) );
40038e10:	b9 10 00 00 00       	mov    $0x10,%ecx
40038e15:	31 d2                	xor    %edx,%edx
40038e17:	8d 45 e8             	lea    -0x18(%ebp),%eax
40038e1a:	e8 56 72 ff ff       	call   40030075 <memset>
    nonce[0] = 0x02;
    memcpy( nonce + 1, appNonce, 6 );
40038e1f:	89 da                	mov    %ebx,%edx
40038e21:	b9 06 00 00 00       	mov    $0x6,%ecx
40038e26:	8d 45 e9             	lea    -0x17(%ebp),%eax
    nonce[0] = 0x02;
40038e29:	c6 45 e8 02          	movb   $0x2,-0x18(%ebp)
    memcpy( nonce + 1, appNonce, 6 );
40038e2d:	e8 38 72 ff ff       	call   4003006a <memcpy>
    memcpy( nonce + 7, pDevNonce, 2 );
40038e32:	8d 55 e4             	lea    -0x1c(%ebp),%edx
40038e35:	b9 02 00 00 00       	mov    $0x2,%ecx
40038e3a:	8d 45 ef             	lea    -0x11(%ebp),%eax
40038e3d:	e8 28 72 ff ff       	call   4003006a <memcpy>
    aes_encrypt( nonce, appSKey, &AesContext );
40038e42:	8b 55 0c             	mov    0xc(%ebp),%edx
40038e45:	8d 45 e8             	lea    -0x18(%ebp),%eax
40038e48:	b9 00 7f 00 a8       	mov    $0xa8007f00,%ecx
40038e4d:	e8 50 02 00 00       	call   400390a2 <aes_encrypt>
}
40038e52:	83 c4 14             	add    $0x14,%esp
40038e55:	5b                   	pop    %ebx
40038e56:	5e                   	pop    %esi
40038e57:	5d                   	pop    %ebp
40038e58:	c3                   	ret    

40038e59 <xor_block>:
        //*((uint8_t*)d)++ = *((uint8_t*)s)++;
        *d++ = *s++;
}

static void xor_block( void *d, const void *s )
{
40038e59:	55                   	push   %ebp
    ((uint32_t*)d)[ 0] ^= ((uint32_t*)s)[ 0];
    ((uint32_t*)d)[ 1] ^= ((uint32_t*)s)[ 1];
    ((uint32_t*)d)[ 2] ^= ((uint32_t*)s)[ 2];
    ((uint32_t*)d)[ 3] ^= ((uint32_t*)s)[ 3];
#else
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
40038e5a:	8a 0a                	mov    (%edx),%cl
{
40038e5c:	89 e5                	mov    %esp,%ebp
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
40038e5e:	30 08                	xor    %cl,(%eax)
    ((uint8_t*)d)[ 1] ^= ((uint8_t*)s)[ 1];
40038e60:	8a 4a 01             	mov    0x1(%edx),%cl
40038e63:	30 48 01             	xor    %cl,0x1(%eax)
    ((uint8_t*)d)[ 2] ^= ((uint8_t*)s)[ 2];
40038e66:	8a 4a 02             	mov    0x2(%edx),%cl
40038e69:	30 48 02             	xor    %cl,0x2(%eax)
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
40038e6c:	8a 4a 03             	mov    0x3(%edx),%cl
40038e6f:	30 48 03             	xor    %cl,0x3(%eax)
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
40038e72:	8a 4a 04             	mov    0x4(%edx),%cl
40038e75:	30 48 04             	xor    %cl,0x4(%eax)
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
40038e78:	8a 4a 05             	mov    0x5(%edx),%cl
40038e7b:	30 48 05             	xor    %cl,0x5(%eax)
    ((uint8_t*)d)[ 6] ^= ((uint8_t*)s)[ 6];
40038e7e:	8a 4a 06             	mov    0x6(%edx),%cl
40038e81:	30 48 06             	xor    %cl,0x6(%eax)
    ((uint8_t*)d)[ 7] ^= ((uint8_t*)s)[ 7];
40038e84:	8a 4a 07             	mov    0x7(%edx),%cl
40038e87:	30 48 07             	xor    %cl,0x7(%eax)
    ((uint8_t*)d)[ 8] ^= ((uint8_t*)s)[ 8];
40038e8a:	8a 4a 08             	mov    0x8(%edx),%cl
40038e8d:	30 48 08             	xor    %cl,0x8(%eax)
    ((uint8_t*)d)[ 9] ^= ((uint8_t*)s)[ 9];
40038e90:	8a 4a 09             	mov    0x9(%edx),%cl
40038e93:	30 48 09             	xor    %cl,0x9(%eax)
    ((uint8_t*)d)[10] ^= ((uint8_t*)s)[10];
40038e96:	8a 4a 0a             	mov    0xa(%edx),%cl
40038e99:	30 48 0a             	xor    %cl,0xa(%eax)
    ((uint8_t*)d)[11] ^= ((uint8_t*)s)[11];
40038e9c:	8a 4a 0b             	mov    0xb(%edx),%cl
40038e9f:	30 48 0b             	xor    %cl,0xb(%eax)
    ((uint8_t*)d)[12] ^= ((uint8_t*)s)[12];
    ((uint8_t*)d)[13] ^= ((uint8_t*)s)[13];
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
#endif
}
40038ea2:	5d                   	pop    %ebp
    ((uint8_t*)d)[12] ^= ((uint8_t*)s)[12];
40038ea3:	8a 4a 0c             	mov    0xc(%edx),%cl
40038ea6:	30 48 0c             	xor    %cl,0xc(%eax)
    ((uint8_t*)d)[13] ^= ((uint8_t*)s)[13];
40038ea9:	8a 4a 0d             	mov    0xd(%edx),%cl
40038eac:	30 48 0d             	xor    %cl,0xd(%eax)
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
40038eaf:	8a 4a 0e             	mov    0xe(%edx),%cl
40038eb2:	30 48 0e             	xor    %cl,0xe(%eax)
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
40038eb5:	8a 52 0f             	mov    0xf(%edx),%dl
40038eb8:	30 50 0f             	xor    %dl,0xf(%eax)
}
40038ebb:	c3                   	ret    

40038ebc <copy_and_key>:

static void copy_and_key( void *d, const void *s, const void *k )
{
40038ebc:	55                   	push   %ebp
40038ebd:	89 e5                	mov    %esp,%ebp
40038ebf:	53                   	push   %ebx
    ((uint32_t*)d)[ 0] = ((uint32_t*)s)[ 0] ^ ((uint32_t*)k)[ 0];
    ((uint32_t*)d)[ 1] = ((uint32_t*)s)[ 1] ^ ((uint32_t*)k)[ 1];
    ((uint32_t*)d)[ 2] = ((uint32_t*)s)[ 2] ^ ((uint32_t*)k)[ 2];
    ((uint32_t*)d)[ 3] = ((uint32_t*)s)[ 3] ^ ((uint32_t*)k)[ 3];
#elif 1
    ((uint8_t*)d)[ 0] = ((uint8_t*)s)[ 0] ^ ((uint8_t*)k)[ 0];
40038ec0:	8a 1a                	mov    (%edx),%bl
40038ec2:	32 19                	xor    (%ecx),%bl
40038ec4:	88 18                	mov    %bl,(%eax)
    ((uint8_t*)d)[ 1] = ((uint8_t*)s)[ 1] ^ ((uint8_t*)k)[ 1];
40038ec6:	8a 5a 01             	mov    0x1(%edx),%bl
40038ec9:	32 59 01             	xor    0x1(%ecx),%bl
40038ecc:	88 58 01             	mov    %bl,0x1(%eax)
    ((uint8_t*)d)[ 2] = ((uint8_t*)s)[ 2] ^ ((uint8_t*)k)[ 2];
40038ecf:	8a 5a 02             	mov    0x2(%edx),%bl
40038ed2:	32 59 02             	xor    0x2(%ecx),%bl
40038ed5:	88 58 02             	mov    %bl,0x2(%eax)
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3] ^ ((uint8_t*)k)[ 3];
40038ed8:	8a 5a 03             	mov    0x3(%edx),%bl
40038edb:	32 59 03             	xor    0x3(%ecx),%bl
40038ede:	88 58 03             	mov    %bl,0x3(%eax)
    ((uint8_t*)d)[ 4] = ((uint8_t*)s)[ 4] ^ ((uint8_t*)k)[ 4];
40038ee1:	8a 5a 04             	mov    0x4(%edx),%bl
40038ee4:	32 59 04             	xor    0x4(%ecx),%bl
40038ee7:	88 58 04             	mov    %bl,0x4(%eax)
    ((uint8_t*)d)[ 5] = ((uint8_t*)s)[ 5] ^ ((uint8_t*)k)[ 5];
40038eea:	8a 5a 05             	mov    0x5(%edx),%bl
40038eed:	32 59 05             	xor    0x5(%ecx),%bl
40038ef0:	88 58 05             	mov    %bl,0x5(%eax)
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6] ^ ((uint8_t*)k)[ 6];
40038ef3:	8a 5a 06             	mov    0x6(%edx),%bl
40038ef6:	32 59 06             	xor    0x6(%ecx),%bl
40038ef9:	88 58 06             	mov    %bl,0x6(%eax)
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7] ^ ((uint8_t*)k)[ 7];
40038efc:	8a 5a 07             	mov    0x7(%edx),%bl
40038eff:	32 59 07             	xor    0x7(%ecx),%bl
40038f02:	88 58 07             	mov    %bl,0x7(%eax)
    ((uint8_t*)d)[ 8] = ((uint8_t*)s)[ 8] ^ ((uint8_t*)k)[ 8];
40038f05:	8a 5a 08             	mov    0x8(%edx),%bl
40038f08:	32 59 08             	xor    0x8(%ecx),%bl
40038f0b:	88 58 08             	mov    %bl,0x8(%eax)
    ((uint8_t*)d)[ 9] = ((uint8_t*)s)[ 9] ^ ((uint8_t*)k)[ 9];
40038f0e:	8a 5a 09             	mov    0x9(%edx),%bl
40038f11:	32 59 09             	xor    0x9(%ecx),%bl
40038f14:	88 58 09             	mov    %bl,0x9(%eax)
    ((uint8_t*)d)[10] = ((uint8_t*)s)[10] ^ ((uint8_t*)k)[10];
40038f17:	8a 5a 0a             	mov    0xa(%edx),%bl
40038f1a:	32 59 0a             	xor    0xa(%ecx),%bl
40038f1d:	88 58 0a             	mov    %bl,0xa(%eax)
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11] ^ ((uint8_t*)k)[11];
40038f20:	8a 5a 0b             	mov    0xb(%edx),%bl
40038f23:	32 59 0b             	xor    0xb(%ecx),%bl
40038f26:	88 58 0b             	mov    %bl,0xb(%eax)
    ((uint8_t*)d)[12] = ((uint8_t*)s)[12] ^ ((uint8_t*)k)[12];
40038f29:	8a 5a 0c             	mov    0xc(%edx),%bl
40038f2c:	32 59 0c             	xor    0xc(%ecx),%bl
40038f2f:	88 58 0c             	mov    %bl,0xc(%eax)
    ((uint8_t*)d)[13] = ((uint8_t*)s)[13] ^ ((uint8_t*)k)[13];
40038f32:	8a 5a 0d             	mov    0xd(%edx),%bl
40038f35:	32 59 0d             	xor    0xd(%ecx),%bl
40038f38:	88 58 0d             	mov    %bl,0xd(%eax)
    ((uint8_t*)d)[14] = ((uint8_t*)s)[14] ^ ((uint8_t*)k)[14];
40038f3b:	8a 5a 0e             	mov    0xe(%edx),%bl
40038f3e:	32 59 0e             	xor    0xe(%ecx),%bl
40038f41:	88 58 0e             	mov    %bl,0xe(%eax)
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
#else
    block_copy(d, s);
    xor_block(d, k);
#endif
}
40038f44:	5b                   	pop    %ebx
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
40038f45:	8a 52 0f             	mov    0xf(%edx),%dl
}
40038f48:	5d                   	pop    %ebp
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
40038f49:	32 51 0f             	xor    0xf(%ecx),%dl
40038f4c:	88 50 0f             	mov    %dl,0xf(%eax)
}
40038f4f:	c3                   	ret    

40038f50 <aes_set_key>:
#if defined( AES_ENC_PREKEYED ) || defined( AES_DEC_PREKEYED )

/*  Set the cipher key for the pre-keyed version */

return_type aes_set_key( const uint8_t key[], length_type keylen, aes_context ctx[1] )
{
40038f50:	55                   	push   %ebp
40038f51:	89 e5                	mov    %esp,%ebp
40038f53:	57                   	push   %edi
40038f54:	56                   	push   %esi
40038f55:	53                   	push   %ebx
40038f56:	89 cb                	mov    %ecx,%ebx
40038f58:	8d 4a f0             	lea    -0x10(%edx),%ecx
40038f5b:	83 ec 08             	sub    $0x8,%esp
40038f5e:	88 55 ef             	mov    %dl,-0x11(%ebp)
40038f61:	80 f9 10             	cmp    $0x10,%cl
40038f64:	77 0f                	ja     40038f75 <aes_set_key+0x25>
40038f66:	be 01 00 00 00       	mov    $0x1,%esi
40038f6b:	d3 e6                	shl    %cl,%esi
40038f6d:	81 e6 01 01 01 00    	and    $0x10101,%esi
40038f73:	75 0e                	jne    40038f83 <aes_set_key+0x33>
    case 16:
    case 24:
    case 32:
        break;
    default:
        ctx->rnd = 0;
40038f75:	c6 83 f0 00 00 00 00 	movb   $0x0,0xf0(%ebx)
        return ( uint8_t )-1;
40038f7c:	b0 ff                	mov    $0xff,%al
40038f7e:	e9 18 01 00 00       	jmp    4003909b <aes_set_key+0x14b>
40038f83:	89 d7                	mov    %edx,%edi
    }
    block_copy_nn(ctx->ksch, key, keylen);
40038f85:	31 c9                	xor    %ecx,%ecx
40038f87:	0f b6 f2             	movzbl %dl,%esi
        *d++ = *s++;
40038f8a:	8a 14 08             	mov    (%eax,%ecx,1),%dl
40038f8d:	88 14 0b             	mov    %dl,(%ebx,%ecx,1)
40038f90:	41                   	inc    %ecx
    while( nn-- )
40038f91:	39 ce                	cmp    %ecx,%esi
40038f93:	75 f5                	jne    40038f8a <aes_set_key+0x3a>
    hi = (keylen + 28) << 2;
40038f95:	8d 47 1c             	lea    0x1c(%edi),%eax
40038f98:	c1 e0 02             	shl    $0x2,%eax
40038f9b:	88 45 ee             	mov    %al,-0x12(%ebp)
    ctx->rnd = (hi >> 4) - 1;
40038f9e:	c0 e8 04             	shr    $0x4,%al
40038fa1:	48                   	dec    %eax
40038fa2:	88 83 f0 00 00 00    	mov    %al,0xf0(%ebx)
40038fa8:	89 f8                	mov    %edi,%eax
40038faa:	88 45 f0             	mov    %al,-0x10(%ebp)
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
40038fad:	bf 01 00 00 00       	mov    $0x1,%edi
    {   uint8_t tt, t0, t1, t2, t3;

        t0 = ctx->ksch[cc - 4];
40038fb2:	0f b6 75 f0          	movzbl -0x10(%ebp),%esi
40038fb6:	8a 44 33 fc          	mov    -0x4(%ebx,%esi,1),%al
40038fba:	88 45 f3             	mov    %al,-0xd(%ebp)
        t1 = ctx->ksch[cc - 3];
        t2 = ctx->ksch[cc - 2];
40038fbd:	8a 44 33 fe          	mov    -0x2(%ebx,%esi,1),%al
40038fc1:	88 45 f2             	mov    %al,-0xe(%ebp)
        t3 = ctx->ksch[cc - 1];
40038fc4:	8a 44 33 ff          	mov    -0x1(%ebx,%esi,1),%al
40038fc8:	88 45 f1             	mov    %al,-0xf(%ebp)
        if( cc % keylen == 0 )
40038fcb:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
40038fcf:	f6 75 ef             	divb   -0x11(%ebp)
40038fd2:	88 e0                	mov    %ah,%al
        t1 = ctx->ksch[cc - 3];
40038fd4:	0f b6 4c 33 fd       	movzbl -0x3(%ebx,%esi,1),%ecx
        if( cc % keylen == 0 )
40038fd9:	84 c0                	test   %al,%al
40038fdb:	75 45                	jne    40039022 <aes_set_key+0xd2>
        {
            tt = t0;
            t0 = s_box(t1) ^ rc;
40038fdd:	89 f8                	mov    %edi,%eax
40038fdf:	32 81 e0 ce 03 40    	xor    0x4003cee0(%ecx),%al
40038fe5:	88 45 ed             	mov    %al,-0x13(%ebp)
            t1 = s_box(t2);
            t2 = s_box(t3);
40038fe8:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
            t1 = s_box(t2);
40038fec:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
            t2 = s_box(t3);
40038ff0:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
40038ff6:	88 45 f2             	mov    %al,-0xe(%ebp)
            t1 = s_box(t2);
40038ff9:	8a 8a e0 ce 03 40    	mov    0x4003cee0(%edx),%cl
            t3 = s_box(tt);
40038fff:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
            rc = f2(rc);
40039003:	b2 1b                	mov    $0x1b,%dl
            t3 = s_box(tt);
40039005:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
4003900b:	88 45 f1             	mov    %al,-0xf(%ebp)
            rc = f2(rc);
4003900e:	89 f8                	mov    %edi,%eax
40039010:	c0 e8 07             	shr    $0x7,%al
40039013:	01 ff                	add    %edi,%edi
40039015:	0f af c2             	imul   %edx,%eax
40039018:	31 c7                	xor    %eax,%edi
            t0 = s_box(t1) ^ rc;
4003901a:	8a 45 ed             	mov    -0x13(%ebp),%al
4003901d:	88 45 f3             	mov    %al,-0xd(%ebp)
40039020:	eb 37                	jmp    40039059 <aes_set_key+0x109>
        }
        else if( keylen > 24 && cc % keylen == 16 )
40039022:	80 7d ef 18          	cmpb   $0x18,-0x11(%ebp)
40039026:	76 31                	jbe    40039059 <aes_set_key+0x109>
40039028:	3c 10                	cmp    $0x10,%al
4003902a:	75 2d                	jne    40039059 <aes_set_key+0x109>
        {
            t0 = s_box(t0);
4003902c:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
            t1 = s_box(t1);
            t2 = s_box(t2);
40039030:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
            t0 = s_box(t0);
40039034:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
            t1 = s_box(t1);
4003903a:	8a 89 e0 ce 03 40    	mov    0x4003cee0(%ecx),%cl
            t0 = s_box(t0);
40039040:	88 45 f3             	mov    %al,-0xd(%ebp)
            t2 = s_box(t2);
40039043:	8a 82 e0 ce 03 40    	mov    0x4003cee0(%edx),%al
40039049:	88 45 f2             	mov    %al,-0xe(%ebp)
            t3 = s_box(t3);
4003904c:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
40039050:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
40039056:	88 45 f1             	mov    %al,-0xf(%ebp)
        }
        tt = cc - keylen;
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
40039059:	8a 45 f0             	mov    -0x10(%ebp),%al
4003905c:	8a 55 f3             	mov    -0xd(%ebp),%dl
4003905f:	2a 45 ef             	sub    -0x11(%ebp),%al
40039062:	0f b6 c0             	movzbl %al,%eax
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
40039065:	80 45 f0 04          	addb   $0x4,-0x10(%ebp)
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
40039069:	32 14 03             	xor    (%ebx,%eax,1),%dl
4003906c:	88 14 33             	mov    %dl,(%ebx,%esi,1)
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
4003906f:	8a 55 f2             	mov    -0xe(%ebp),%dl
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
40039072:	32 4c 03 01          	xor    0x1(%ebx,%eax,1),%cl
40039076:	88 4c 33 01          	mov    %cl,0x1(%ebx,%esi,1)
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
4003907a:	8a 4d f0             	mov    -0x10(%ebp),%cl
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
4003907d:	32 54 03 02          	xor    0x2(%ebx,%eax,1),%dl
40039081:	88 54 33 02          	mov    %dl,0x2(%ebx,%esi,1)
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
40039085:	8a 55 f1             	mov    -0xf(%ebp),%dl
40039088:	32 54 03 03          	xor    0x3(%ebx,%eax,1),%dl
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
4003908c:	38 4d ee             	cmp    %cl,-0x12(%ebp)
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
4003908f:	88 54 33 03          	mov    %dl,0x3(%ebx,%esi,1)
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
40039093:	0f 87 19 ff ff ff    	ja     40038fb2 <aes_set_key+0x62>
    }
    return 0;
40039099:	31 c0                	xor    %eax,%eax
}
4003909b:	5a                   	pop    %edx
4003909c:	59                   	pop    %ecx
4003909d:	5b                   	pop    %ebx
4003909e:	5e                   	pop    %esi
4003909f:	5f                   	pop    %edi
400390a0:	5d                   	pop    %ebp
400390a1:	c3                   	ret    

400390a2 <aes_encrypt>:

/*  Encrypt a single block of 16 bytes */

return_type aes_encrypt( const uint8_t in[N_BLOCK], uint8_t  out[N_BLOCK], const aes_context ctx[1] )
{
    if( ctx->rnd )
400390a2:	80 b9 f0 00 00 00 00 	cmpb   $0x0,0xf0(%ecx)
400390a9:	0f 84 54 03 00 00    	je     40039403 <aes_encrypt+0x361>
{
400390af:	55                   	push   %ebp
400390b0:	89 e5                	mov    %esp,%ebp
400390b2:	57                   	push   %edi
400390b3:	56                   	push   %esi
400390b4:	53                   	push   %ebx
    {
        uint8_t s1[N_BLOCK], r;
        copy_and_key( s1, in, ctx->ksch );
400390b5:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
{
400390b8:	83 ec 24             	sub    $0x24,%esp
400390bb:	89 55 d0             	mov    %edx,-0x30(%ebp)
400390be:	89 c2                	mov    %eax,%edx
        copy_and_key( s1, in, ctx->ksch );
400390c0:	89 d8                	mov    %ebx,%eax
400390c2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
400390c5:	e8 f2 fd ff ff       	call   40038ebc <copy_and_key>

        for( r = 1 ; r < ctx->rnd ; ++r )
400390ca:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
    xor_block(d, k);
400390ce:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
        for( r = 1 ; r < ctx->rnd ; ++r )
400390d1:	8b 75 dc             	mov    -0x24(%ebp),%esi
400390d4:	8a 45 e3             	mov    -0x1d(%ebp),%al
400390d7:	0f b6 5d e9          	movzbl -0x17(%ebp),%ebx
400390db:	3a 86 f0 00 00 00    	cmp    0xf0(%esi),%al
400390e1:	8a 45 e5             	mov    -0x1b(%ebp),%al
400390e4:	88 45 e1             	mov    %al,-0x1f(%ebp)
400390e7:	8a 45 e6             	mov    -0x1a(%ebp),%al
400390ea:	88 45 e0             	mov    %al,-0x20(%ebp)
400390ed:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
400390f1:	0f b6 4d ee          	movzbl -0x12(%ebp),%ecx
400390f5:	0f 83 25 02 00 00    	jae    40039320 <aes_encrypt+0x27e>
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3];
400390fb:	8a 45 e7             	mov    -0x19(%ebp),%al
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
400390fe:	8a 96 e0 cd 03 40    	mov    0x4003cde0(%esi),%dl
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3];
40039104:	88 45 db             	mov    %al,-0x25(%ebp)
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6];
40039107:	8a 45 ea             	mov    -0x16(%ebp),%al
4003910a:	88 45 da             	mov    %al,-0x26(%ebp)
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7];
4003910d:	8a 45 eb             	mov    -0x15(%ebp),%al
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
40039110:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
40039114:	32 93 e0 cc 03 40    	xor    0x4003cce0(%ebx),%dl
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7];
4003911a:	88 45 d9             	mov    %al,-0x27(%ebp)
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11];
4003911d:	8a 45 ef             	mov    -0x11(%ebp),%al
40039120:	88 45 d8             	mov    %al,-0x28(%ebp)
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
40039123:	8a 81 e0 ce 03 40    	mov    0x4003cee0(%ecx),%al
40039129:	31 c2                	xor    %eax,%edx
4003912b:	32 97 e0 ce 03 40    	xor    0x4003cee0(%edi),%dl
40039131:	88 55 e4             	mov    %dl,-0x1c(%ebp)
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
40039134:	8a 97 e0 ce 03 40    	mov    0x4003cee0(%edi),%dl
4003913a:	32 96 e0 ce 03 40    	xor    0x4003cee0(%esi),%dl
40039140:	32 93 e0 cd 03 40    	xor    0x4003cde0(%ebx),%dl
40039146:	32 91 e0 cc 03 40    	xor    0x4003cce0(%ecx),%dl
4003914c:	88 55 e5             	mov    %dl,-0x1b(%ebp)
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
4003914f:	8a 93 e0 ce 03 40    	mov    0x4003cee0(%ebx),%dl
40039155:	88 d3                	mov    %dl,%bl
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
40039157:	31 d0                	xor    %edx,%eax
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
40039159:	32 9e e0 ce 03 40    	xor    0x4003cee0(%esi),%bl
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
4003915f:	32 86 e0 cc 03 40    	xor    0x4003cce0(%esi),%al
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
40039165:	32 99 e0 cd 03 40    	xor    0x4003cde0(%ecx),%bl
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
4003916b:	32 87 e0 cd 03 40    	xor    0x4003cde0(%edi),%al
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
40039171:	32 9f e0 cc 03 40    	xor    0x4003cce0(%edi),%bl
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
40039177:	88 45 e7             	mov    %al,-0x19(%ebp)
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
4003917a:	0f b6 75 f2          	movzbl -0xe(%ebp),%esi
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
4003917e:	88 5d e6             	mov    %bl,-0x1a(%ebp)
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
40039181:	0f b6 5d e8          	movzbl -0x18(%ebp),%ebx
40039185:	0f b6 7d ed          	movzbl -0x13(%ebp),%edi
40039189:	8a 86 e0 ce 03 40    	mov    0x4003cee0(%esi),%al
4003918f:	88 45 e2             	mov    %al,-0x1e(%ebp)
40039192:	0f b6 4d db          	movzbl -0x25(%ebp),%ecx
40039196:	8a 93 e0 cd 03 40    	mov    0x4003cde0(%ebx),%dl
4003919c:	32 97 e0 cc 03 40    	xor    0x4003cce0(%edi),%dl
400391a2:	31 c2                	xor    %eax,%edx
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
400391a4:	8a 86 e0 cd 03 40    	mov    0x4003cde0(%esi),%al
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
400391aa:	32 91 e0 ce 03 40    	xor    0x4003cee0(%ecx),%dl
400391b0:	88 55 e8             	mov    %dl,-0x18(%ebp)
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
400391b3:	8a 91 e0 ce 03 40    	mov    0x4003cee0(%ecx),%dl
400391b9:	32 93 e0 ce 03 40    	xor    0x4003cee0(%ebx),%dl
400391bf:	32 97 e0 cd 03 40    	xor    0x4003cde0(%edi),%dl
400391c5:	32 96 e0 cc 03 40    	xor    0x4003cce0(%esi),%dl
400391cb:	88 55 e9             	mov    %dl,-0x17(%ebp)
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
400391ce:	8a 97 e0 ce 03 40    	mov    0x4003cee0(%edi),%dl
400391d4:	0f b6 bb e0 ce 03 40 	movzbl 0x4003cee0(%ebx),%edi
400391db:	31 d7                	xor    %edx,%edi
400391dd:	31 c7                	xor    %eax,%edi
400391df:	8a 81 e0 cc 03 40    	mov    0x4003cce0(%ecx),%al
400391e5:	31 c7                	xor    %eax,%edi
400391e7:	89 f8                	mov    %edi,%eax
400391e9:	88 45 ea             	mov    %al,-0x16(%ebp)
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
400391ec:	8a 45 e2             	mov    -0x1e(%ebp),%al
400391ef:	31 d0                	xor    %edx,%eax
400391f1:	32 83 e0 cc 03 40    	xor    0x4003cce0(%ebx),%al
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
400391f7:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
400391fb:	0f b6 7d f1          	movzbl -0xf(%ebp),%edi
400391ff:	0f b6 75 e0          	movzbl -0x20(%ebp),%esi
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
40039203:	32 81 e0 cd 03 40    	xor    0x4003cde0(%ecx),%al
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
40039209:	8a 93 e0 cd 03 40    	mov    0x4003cde0(%ebx),%dl
4003920f:	0f b6 4d d9          	movzbl -0x27(%ebp),%ecx
40039213:	32 97 e0 cc 03 40    	xor    0x4003cce0(%edi),%dl
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
40039219:	88 45 eb             	mov    %al,-0x15(%ebp)
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
4003921c:	8a 86 e0 ce 03 40    	mov    0x4003cee0(%esi),%al
40039222:	31 c2                	xor    %eax,%edx
40039224:	88 45 e2             	mov    %al,-0x1e(%ebp)
40039227:	32 91 e0 ce 03 40    	xor    0x4003cee0(%ecx),%dl
4003922d:	88 55 ec             	mov    %dl,-0x14(%ebp)
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
40039230:	8a 91 e0 ce 03 40    	mov    0x4003cee0(%ecx),%dl
40039236:	32 93 e0 ce 03 40    	xor    0x4003cee0(%ebx),%dl
4003923c:	32 97 e0 cd 03 40    	xor    0x4003cde0(%edi),%dl
40039242:	32 96 e0 cc 03 40    	xor    0x4003cce0(%esi),%dl
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
40039248:	8a 86 e0 cd 03 40    	mov    0x4003cde0(%esi),%al
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
4003924e:	88 55 ed             	mov    %dl,-0x13(%ebp)
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
40039251:	8a 97 e0 ce 03 40    	mov    0x4003cee0(%edi),%dl
40039257:	0f b6 bb e0 ce 03 40 	movzbl 0x4003cee0(%ebx),%edi
4003925e:	31 d7                	xor    %edx,%edi
40039260:	31 c7                	xor    %eax,%edi
40039262:	8a 81 e0 cc 03 40    	mov    0x4003cce0(%ecx),%al
40039268:	31 c7                	xor    %eax,%edi
4003926a:	89 f8                	mov    %edi,%eax
4003926c:	88 45 ee             	mov    %al,-0x12(%ebp)
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
4003926f:	8a 45 e2             	mov    -0x1e(%ebp),%al
40039272:	31 d0                	xor    %edx,%eax
40039274:	32 83 e0 cc 03 40    	xor    0x4003cce0(%ebx),%al
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
4003927a:	0f b6 5d f0          	movzbl -0x10(%ebp),%ebx
4003927e:	0f b6 7d e1          	movzbl -0x1f(%ebp),%edi
40039282:	0f b6 75 da          	movzbl -0x26(%ebp),%esi
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
40039286:	32 81 e0 cd 03 40    	xor    0x4003cde0(%ecx),%al
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
4003928c:	8a 93 e0 cd 03 40    	mov    0x4003cde0(%ebx),%dl
40039292:	0f b6 4d d8          	movzbl -0x28(%ebp),%ecx
40039296:	32 97 e0 cc 03 40    	xor    0x4003cce0(%edi),%dl
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
4003929c:	88 45 ef             	mov    %al,-0x11(%ebp)
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
4003929f:	8a 86 e0 ce 03 40    	mov    0x4003cee0(%esi),%al
400392a5:	31 c2                	xor    %eax,%edx
400392a7:	88 45 e2             	mov    %al,-0x1e(%ebp)
400392aa:	32 91 e0 ce 03 40    	xor    0x4003cee0(%ecx),%dl
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
400392b0:	8a 86 e0 cd 03 40    	mov    0x4003cde0(%esi),%al
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
400392b6:	88 55 f0             	mov    %dl,-0x10(%ebp)
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
400392b9:	8a 91 e0 ce 03 40    	mov    0x4003cee0(%ecx),%dl
400392bf:	32 93 e0 ce 03 40    	xor    0x4003cee0(%ebx),%dl
400392c5:	32 97 e0 cd 03 40    	xor    0x4003cde0(%edi),%dl
400392cb:	32 96 e0 cc 03 40    	xor    0x4003cce0(%esi),%dl
400392d1:	88 55 f1             	mov    %dl,-0xf(%ebp)
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
400392d4:	8a 97 e0 ce 03 40    	mov    0x4003cee0(%edi),%dl
400392da:	0f b6 bb e0 ce 03 40 	movzbl 0x4003cee0(%ebx),%edi
400392e1:	31 d7                	xor    %edx,%edi
400392e3:	31 c7                	xor    %eax,%edi
400392e5:	8a 81 e0 cc 03 40    	mov    0x4003cce0(%ecx),%al
400392eb:	31 c7                	xor    %eax,%edi
400392ed:	89 f8                	mov    %edi,%eax
400392ef:	88 45 f2             	mov    %al,-0xe(%ebp)
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
400392f2:	8a 45 e2             	mov    -0x1e(%ebp),%al
400392f5:	31 d0                	xor    %edx,%eax
400392f7:	32 83 e0 cc 03 40    	xor    0x4003cce0(%ebx),%al
#if defined( VERSION_1 )
        {
            mix_sub_columns( s1 );
            add_round_key( s1, ctx->ksch + r * N_BLOCK);
400392fd:	0f b6 55 e3          	movzbl -0x1d(%ebp),%edx
40039301:	c1 e2 04             	shl    $0x4,%edx
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
40039304:	32 81 e0 cd 03 40    	xor    0x4003cde0(%ecx),%al
            add_round_key( s1, ctx->ksch + r * N_BLOCK);
4003930a:	03 55 dc             	add    -0x24(%ebp),%edx
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
4003930d:	88 45 f3             	mov    %al,-0xd(%ebp)
    xor_block(d, k);
40039310:	8b 45 d4             	mov    -0x2c(%ebp),%eax
40039313:	e8 41 fb ff ff       	call   40038e59 <xor_block>
        for( r = 1 ; r < ctx->rnd ; ++r )
40039318:	fe 45 e3             	incb   -0x1d(%ebp)
4003931b:	e9 b1 fd ff ff       	jmp    400390d1 <aes_encrypt+0x2f>
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
40039320:	8a 86 e0 ce 03 40    	mov    0x4003cee0(%esi),%al
40039326:	88 45 e4             	mov    %al,-0x1c(%ebp)
40039329:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    tt = st[6]; st[ 6] = s_box(st[14]); st[14] = s_box( tt );
4003932d:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
40039331:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
40039337:	88 45 e8             	mov    %al,-0x18(%ebp)
    tt = st[6]; st[ 6] = s_box(st[14]); st[14] = s_box( tt );
4003933a:	8a 92 e0 ce 03 40    	mov    0x4003cee0(%edx),%dl
    st[ 8] = s_box(st[ 8]); st[12] = s_box(st[12]);
40039340:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
40039344:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
4003934a:	88 45 ec             	mov    %al,-0x14(%ebp)
4003934d:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
40039351:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
40039357:	88 45 f0             	mov    %al,-0x10(%ebp)
    tt = st[1]; st[ 1] = s_box(st[ 5]); st[ 5] = s_box(st[ 9]);
4003935a:	8a 83 e0 ce 03 40    	mov    0x4003cee0(%ebx),%al
40039360:	88 45 e5             	mov    %al,-0x1b(%ebp)
40039363:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
40039367:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
4003936d:	88 45 e9             	mov    %al,-0x17(%ebp)
    st[ 9] = s_box(st[13]); st[13] = s_box( tt );
40039370:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
40039374:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
4003937a:	88 45 ed             	mov    %al,-0x13(%ebp)
4003937d:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
40039381:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
40039387:	88 45 f1             	mov    %al,-0xf(%ebp)
    tt = st[2]; st[ 2] = s_box(st[10]); st[10] = s_box( tt );
4003938a:	8a 81 e0 ce 03 40    	mov    0x4003cee0(%ecx),%al
40039390:	88 45 e6             	mov    %al,-0x1a(%ebp)
40039393:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
40039397:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
4003939d:	88 45 ee             	mov    %al,-0x12(%ebp)
    tt = st[6]; st[ 6] = s_box(st[14]); st[14] = s_box( tt );
400393a0:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
400393a4:	88 55 ea             	mov    %dl,-0x16(%ebp)
400393a7:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
400393ad:	88 45 f2             	mov    %al,-0xe(%ebp)
    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
400393b0:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
400393b4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
400393b8:	8a 92 e0 ce 03 40    	mov    0x4003cee0(%edx),%dl
400393be:	88 55 f3             	mov    %dl,-0xd(%ebp)
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
400393c1:	8a 80 e0 ce 03 40    	mov    0x4003cee0(%eax),%al
    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
400393c7:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
            mix_sub_columns( s2, s1 );
            copy_and_key( s1, s2, ctx->ksch + r * N_BLOCK);
        }
#endif
        shift_sub_rows( s1 );
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
400393cb:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
400393cf:	c1 e1 04             	shl    $0x4,%ecx
    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
400393d2:	8a 92 e0 ce 03 40    	mov    0x4003cee0(%edx),%dl
400393d8:	88 55 ef             	mov    %dl,-0x11(%ebp)
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
400393db:	03 4d dc             	add    -0x24(%ebp),%ecx
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
400393de:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
400393e2:	88 45 e7             	mov    %al,-0x19(%ebp)
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
400393e5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
400393e8:	8a 92 e0 ce 03 40    	mov    0x4003cee0(%edx),%dl
400393ee:	88 55 eb             	mov    %dl,-0x15(%ebp)
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
400393f1:	8d 55 e4             	lea    -0x1c(%ebp),%edx
400393f4:	e8 c3 fa ff ff       	call   40038ebc <copy_and_key>
    }
    else
        return ( uint8_t )-1;
    return 0;
}
400393f9:	83 c4 24             	add    $0x24,%esp
400393fc:	31 c0                	xor    %eax,%eax
400393fe:	5b                   	pop    %ebx
400393ff:	5e                   	pop    %esi
40039400:	5f                   	pop    %edi
40039401:	5d                   	pop    %ebp
40039402:	c3                   	ret    
        return ( uint8_t )-1;
40039403:	b0 ff                	mov    $0xff,%al
40039405:	c3                   	ret    

40039406 <AES_CMAC_Init>:
        }                          \
    } while (0) \


void AES_CMAC_Init(AES_CMAC_CTX *ctx)
{
40039406:	55                   	push   %ebp
            memset(ctx->X, 0, sizeof ctx->X);
40039407:	b9 10 00 00 00       	mov    $0x10,%ecx
{
4003940c:	89 e5                	mov    %esp,%ebp
            memset(ctx->X, 0, sizeof ctx->X);
4003940e:	31 d2                	xor    %edx,%edx
{
40039410:	53                   	push   %ebx
40039411:	89 c3                	mov    %eax,%ebx
            memset(ctx->X, 0, sizeof ctx->X);
40039413:	8d 80 f1 00 00 00    	lea    0xf1(%eax),%eax
40039419:	e8 57 6c ff ff       	call   40030075 <memset>
            ctx->M_n = 0;
4003941e:	c7 83 14 01 00 00 00 	movl   $0x0,0x114(%ebx)
40039425:	00 00 00 
        memset(ctx->rijndael.ksch, '\0', 240);
40039428:	89 d8                	mov    %ebx,%eax
4003942a:	b9 f0 00 00 00       	mov    $0xf0,%ecx
4003942f:	31 d2                	xor    %edx,%edx
}
40039431:	5b                   	pop    %ebx
40039432:	5d                   	pop    %ebp
        memset(ctx->rijndael.ksch, '\0', 240);
40039433:	e9 3d 6c ff ff       	jmp    40030075 <memset>

40039438 <AES_CMAC_SetKey>:
    
void AES_CMAC_SetKey(AES_CMAC_CTX *ctx, const uint8_t key[AES_CMAC_KEY_LENGTH])
{
40039438:	55                   	push   %ebp
           //rijndael_set_key_enc_only(&ctx->rijndael, key, 128);
       aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael);
40039439:	89 c1                	mov    %eax,%ecx
{
4003943b:	89 e5                	mov    %esp,%ebp
4003943d:	53                   	push   %ebx
4003943e:	89 d3                	mov    %edx,%ebx
       aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael);
40039440:	ba 10 00 00 00       	mov    $0x10,%edx
40039445:	89 d8                	mov    %ebx,%eax
}
40039447:	5b                   	pop    %ebx
40039448:	5d                   	pop    %ebp
       aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael);
40039449:	e9 02 fb ff ff       	jmp    40038f50 <aes_set_key>

4003944e <AES_CMAC_Update>:
    
void AES_CMAC_Update(AES_CMAC_CTX *ctx, const uint8_t *data, uint32_t len)
{
4003944e:	55                   	push   %ebp
4003944f:	89 e5                	mov    %esp,%ebp
40039451:	57                   	push   %edi
40039452:	56                   	push   %esi
40039453:	53                   	push   %ebx
40039454:	83 ec 18             	sub    $0x18,%esp
40039457:	89 c3                	mov    %eax,%ebx
            uint32_t mlen;
        uint8_t in[16];
    
            if (ctx->M_n > 0) {
40039459:	8b 80 14 01 00 00    	mov    0x114(%eax),%eax
{
4003945f:	89 55 e0             	mov    %edx,-0x20(%ebp)
40039462:	89 cf                	mov    %ecx,%edi
            if (ctx->M_n > 0) {
40039464:	85 c0                	test   %eax,%eax
40039466:	74 67                	je     400394cf <AES_CMAC_Update+0x81>
                  mlen = UPM_MIN(16 - ctx->M_n, len);
40039468:	be 10 00 00 00       	mov    $0x10,%esi
4003946d:	29 c6                	sub    %eax,%esi
4003946f:	39 ce                	cmp    %ecx,%esi
40039471:	76 02                	jbe    40039475 <AES_CMAC_Update+0x27>
40039473:	89 ce                	mov    %ecx,%esi
                    memcpy(ctx->M_last + ctx->M_n, data, mlen);
40039475:	8d 84 03 01 01 00 00 	lea    0x101(%ebx,%eax,1),%eax
4003947c:	89 f1                	mov    %esi,%ecx
4003947e:	8b 55 e0             	mov    -0x20(%ebp),%edx
40039481:	e8 e4 6b ff ff       	call   4003006a <memcpy>
                    ctx->M_n += mlen;
40039486:	8b 83 14 01 00 00    	mov    0x114(%ebx),%eax
4003948c:	01 f0                	add    %esi,%eax
4003948e:	89 83 14 01 00 00    	mov    %eax,0x114(%ebx)
                    if (ctx->M_n < 16 || len == mlen)
40039494:	83 f8 0f             	cmp    $0xf,%eax
40039497:	0f 86 9f 00 00 00    	jbe    4003953c <AES_CMAC_Update+0xee>
4003949d:	39 f7                	cmp    %esi,%edi
4003949f:	0f 84 97 00 00 00    	je     4003953c <AES_CMAC_Update+0xee>
400394a5:	31 c0                	xor    %eax,%eax
                            return;
                   XOR(ctx->M_last, ctx->X);
400394a7:	8a 94 03 01 01 00 00 	mov    0x101(%ebx,%eax,1),%dl
400394ae:	30 94 03 f1 00 00 00 	xor    %dl,0xf1(%ebx,%eax,1)
400394b5:	40                   	inc    %eax
400394b6:	83 f8 10             	cmp    $0x10,%eax
400394b9:	75 ec                	jne    400394a7 <AES_CMAC_Update+0x59>
                    //rijndael_encrypt(&ctx->rijndael, ctx->X, ctx->X);
            aes_encrypt( ctx->X, ctx->X, &ctx->rijndael);
400394bb:	8d 83 f1 00 00 00    	lea    0xf1(%ebx),%eax
400394c1:	89 d9                	mov    %ebx,%ecx
400394c3:	89 c2                	mov    %eax,%edx
                    data += mlen;
                    len -= mlen;
400394c5:	29 f7                	sub    %esi,%edi
            aes_encrypt( ctx->X, ctx->X, &ctx->rijndael);
400394c7:	e8 d6 fb ff ff       	call   400390a2 <aes_encrypt>
                    data += mlen;
400394cc:	01 75 e0             	add    %esi,-0x20(%ebp)
            while (len > 16) {      /* not last block */

                    XOR(data, ctx->X);
                    //rijndael_encrypt(&ctx->rijndael, ctx->X, ctx->X);

                    memcpy(in, &ctx->X[0], 16); //Bestela ez du ondo iten
400394cf:	8d 83 f1 00 00 00    	lea    0xf1(%ebx),%eax
400394d5:	89 fe                	mov    %edi,%esi
400394d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
400394da:	89 fa                	mov    %edi,%edx
400394dc:	29 f2                	sub    %esi,%edx
400394de:	03 55 e0             	add    -0x20(%ebp),%edx
            while (len > 16) {      /* not last block */
400394e1:	83 fe 10             	cmp    $0x10,%esi
400394e4:	76 43                	jbe    40039529 <AES_CMAC_Update+0xdb>
400394e6:	31 c0                	xor    %eax,%eax
                    XOR(data, ctx->X);
400394e8:	8a 0c 02             	mov    (%edx,%eax,1),%cl
400394eb:	30 8c 03 f1 00 00 00 	xor    %cl,0xf1(%ebx,%eax,1)
400394f2:	40                   	inc    %eax
400394f3:	83 f8 10             	cmp    $0x10,%eax
400394f6:	75 f0                	jne    400394e8 <AES_CMAC_Update+0x9a>
                    memcpy(in, &ctx->X[0], 16); //Bestela ez du ondo iten
400394f8:	b9 10 00 00 00       	mov    $0x10,%ecx
400394fd:	8b 55 dc             	mov    -0x24(%ebp),%edx
40039500:	8d 45 e4             	lea    -0x1c(%ebp),%eax
            aes_encrypt( in, in, &ctx->rijndael);
                    memcpy(&ctx->X[0], in, 16);

                    data += 16;
                    len -= 16;
40039503:	83 ee 10             	sub    $0x10,%esi
                    memcpy(in, &ctx->X[0], 16); //Bestela ez du ondo iten
40039506:	e8 5f 6b ff ff       	call   4003006a <memcpy>
            aes_encrypt( in, in, &ctx->rijndael);
4003950b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
4003950e:	89 d9                	mov    %ebx,%ecx
40039510:	89 d0                	mov    %edx,%eax
40039512:	e8 8b fb ff ff       	call   400390a2 <aes_encrypt>
                    memcpy(&ctx->X[0], in, 16);
40039517:	b9 10 00 00 00       	mov    $0x10,%ecx
4003951c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
4003951f:	8b 45 dc             	mov    -0x24(%ebp),%eax
40039522:	e8 43 6b ff ff       	call   4003006a <memcpy>
40039527:	eb b1                	jmp    400394da <AES_CMAC_Update+0x8c>
            }
            /* potential last block, save it */
            memcpy(ctx->M_last, data, len);
40039529:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
4003952f:	89 f1                	mov    %esi,%ecx
40039531:	e8 34 6b ff ff       	call   4003006a <memcpy>
            ctx->M_n = len;
40039536:	89 b3 14 01 00 00    	mov    %esi,0x114(%ebx)
}
4003953c:	83 c4 18             	add    $0x18,%esp
4003953f:	5b                   	pop    %ebx
40039540:	5e                   	pop    %esi
40039541:	5f                   	pop    %edi
40039542:	5d                   	pop    %ebp
40039543:	c3                   	ret    

40039544 <AES_CMAC_Final>:
   
void AES_CMAC_Final(uint8_t digest[AES_CMAC_DIGEST_LENGTH], AES_CMAC_CTX *ctx)
{
40039544:	55                   	push   %ebp
            uint8_t K[16];
        uint8_t in[16];
            /* generate subkey K1 */
            memset(K, '\0', 16);
40039545:	b9 10 00 00 00       	mov    $0x10,%ecx
{
4003954a:	89 e5                	mov    %esp,%ebp
4003954c:	57                   	push   %edi
4003954d:	56                   	push   %esi
4003954e:	53                   	push   %ebx
4003954f:	83 ec 24             	sub    $0x24,%esp
40039552:	89 d3                	mov    %edx,%ebx
40039554:	89 45 d0             	mov    %eax,-0x30(%ebp)
            memset(K, '\0', 16);
40039557:	31 d2                	xor    %edx,%edx
40039559:	8d 45 d4             	lea    -0x2c(%ebp),%eax
4003955c:	e8 14 6b ff ff       	call   40030075 <memset>

            //rijndael_encrypt(&ctx->rijndael, K, K);

            aes_encrypt( K, K, &ctx->rijndael);
40039561:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40039564:	89 d9                	mov    %ebx,%ecx
40039566:	89 d0                	mov    %edx,%eax
40039568:	e8 35 fb ff ff       	call   400390a2 <aes_encrypt>
4003956d:	8d 45 d4             	lea    -0x2c(%ebp),%eax

            if (K[0] & 0x80) {
40039570:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
40039574:	8d 4d e3             	lea    -0x1d(%ebp),%ecx
40039577:	79 22                	jns    4003959b <AES_CMAC_Final+0x57>
                    LSHIFT(K, K);
40039579:	0f b6 10             	movzbl (%eax),%edx
4003957c:	40                   	inc    %eax
4003957d:	8d 34 12             	lea    (%edx,%edx,1),%esi
40039580:	8a 10                	mov    (%eax),%dl
40039582:	c0 ea 07             	shr    $0x7,%dl
40039585:	09 f2                	or     %esi,%edx
40039587:	88 50 ff             	mov    %dl,-0x1(%eax)
4003958a:	39 c1                	cmp    %eax,%ecx
4003958c:	75 eb                	jne    40039579 <AES_CMAC_Final+0x35>
4003958e:	8a 45 e3             	mov    -0x1d(%ebp),%al
40039591:	01 c0                	add    %eax,%eax
                   K[15] ^= 0x87;
40039593:	83 f0 87             	xor    $0xffffff87,%eax
40039596:	88 45 e3             	mov    %al,-0x1d(%ebp)
40039599:	eb 18                	jmp    400395b3 <AES_CMAC_Final+0x6f>
            } else
                    LSHIFT(K, K);
4003959b:	0f b6 10             	movzbl (%eax),%edx
4003959e:	40                   	inc    %eax
4003959f:	8d 34 12             	lea    (%edx,%edx,1),%esi
400395a2:	8a 10                	mov    (%eax),%dl
400395a4:	c0 ea 07             	shr    $0x7,%dl
400395a7:	09 f2                	or     %esi,%edx
400395a9:	88 50 ff             	mov    %dl,-0x1(%eax)
400395ac:	39 c1                	cmp    %eax,%ecx
400395ae:	75 eb                	jne    4003959b <AES_CMAC_Final+0x57>
400395b0:	d0 65 e3             	shlb   -0x1d(%ebp)


            if (ctx->M_n == 16) {
400395b3:	8b 8b 14 01 00 00    	mov    0x114(%ebx),%ecx
400395b9:	83 f9 10             	cmp    $0x10,%ecx
400395bc:	75 1a                	jne    400395d8 <AES_CMAC_Final+0x94>
400395be:	31 c0                	xor    %eax,%eax
                    /* last block was a complete block */
                    XOR(K, ctx->M_last);
400395c0:	8a 54 05 d4          	mov    -0x2c(%ebp,%eax,1),%dl
400395c4:	30 94 03 01 01 00 00 	xor    %dl,0x101(%ebx,%eax,1)
400395cb:	40                   	inc    %eax
400395cc:	83 f8 10             	cmp    $0x10,%eax
400395cf:	75 ef                	jne    400395c0 <AES_CMAC_Final+0x7c>
                  } else
                           LSHIFT(K, K);

                   /* padding(M_last) */
                   ctx->M_last[ctx->M_n] = 0x80;
                   while (++ctx->M_n < 16)
400395d1:	31 c0                	xor    %eax,%eax
400395d3:	e9 82 00 00 00       	jmp    4003965a <AES_CMAC_Final+0x116>
400395d8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
400395db:	8d 75 e3             	lea    -0x1d(%ebp),%esi
                  if (K[0] & 0x80) {
400395de:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
400395e2:	79 22                	jns    40039606 <AES_CMAC_Final+0xc2>
                          LSHIFT(K, K);
400395e4:	0f b6 38             	movzbl (%eax),%edi
400395e7:	8a 50 01             	mov    0x1(%eax),%dl
400395ea:	01 ff                	add    %edi,%edi
400395ec:	c0 ea 07             	shr    $0x7,%dl
400395ef:	40                   	inc    %eax
400395f0:	09 fa                	or     %edi,%edx
400395f2:	88 50 ff             	mov    %dl,-0x1(%eax)
400395f5:	39 c6                	cmp    %eax,%esi
400395f7:	75 eb                	jne    400395e4 <AES_CMAC_Final+0xa0>
400395f9:	8a 45 e3             	mov    -0x1d(%ebp),%al
400395fc:	01 c0                	add    %eax,%eax
                          K[15] ^= 0x87;
400395fe:	83 f0 87             	xor    $0xffffff87,%eax
40039601:	88 45 e3             	mov    %al,-0x1d(%ebp)
40039604:	eb 18                	jmp    4003961e <AES_CMAC_Final+0xda>
                           LSHIFT(K, K);
40039606:	0f b6 38             	movzbl (%eax),%edi
40039609:	8a 50 01             	mov    0x1(%eax),%dl
4003960c:	01 ff                	add    %edi,%edi
4003960e:	c0 ea 07             	shr    $0x7,%dl
40039611:	40                   	inc    %eax
40039612:	09 fa                	or     %edi,%edx
40039614:	88 50 ff             	mov    %dl,-0x1(%eax)
40039617:	39 c6                	cmp    %eax,%esi
40039619:	75 eb                	jne    40039606 <AES_CMAC_Final+0xc2>
4003961b:	d0 65 e3             	shlb   -0x1d(%ebp)
                   ctx->M_last[ctx->M_n] = 0x80;
4003961e:	c6 84 0b 01 01 00 00 	movb   $0x80,0x101(%ebx,%ecx,1)
40039625:	80 
40039626:	8b 83 14 01 00 00    	mov    0x114(%ebx),%eax
                   while (++ctx->M_n < 16)
4003962c:	40                   	inc    %eax
4003962d:	83 f8 0f             	cmp    $0xf,%eax
40039630:	77 0a                	ja     4003963c <AES_CMAC_Final+0xf8>
                         ctx->M_last[ctx->M_n] = 0;
40039632:	c6 84 03 01 01 00 00 	movb   $0x0,0x101(%ebx,%eax,1)
40039639:	00 
4003963a:	eb f0                	jmp    4003962c <AES_CMAC_Final+0xe8>
4003963c:	89 83 14 01 00 00    	mov    %eax,0x114(%ebx)
                   while (++ctx->M_n < 16)
40039642:	31 c0                	xor    %eax,%eax
   
                  XOR(K, ctx->M_last);
40039644:	8a 54 28 d4          	mov    -0x2c(%eax,%ebp,1),%dl
40039648:	30 94 03 01 01 00 00 	xor    %dl,0x101(%ebx,%eax,1)
4003964f:	40                   	inc    %eax
40039650:	83 f8 10             	cmp    $0x10,%eax
40039653:	75 ef                	jne    40039644 <AES_CMAC_Final+0x100>
40039655:	e9 77 ff ff ff       	jmp    400395d1 <AES_CMAC_Final+0x8d>


           }
           XOR(ctx->M_last, ctx->X);
4003965a:	8a 94 03 01 01 00 00 	mov    0x101(%ebx,%eax,1),%dl
40039661:	30 94 03 f1 00 00 00 	xor    %dl,0xf1(%ebx,%eax,1)
40039668:	40                   	inc    %eax
40039669:	83 f8 10             	cmp    $0x10,%eax
4003966c:	75 ec                	jne    4003965a <AES_CMAC_Final+0x116>

           //rijndael_encrypt(&ctx->rijndael, ctx->X, digest);

       memcpy(in, &ctx->X[0], 16); //Bestela ez du ondo iten
4003966e:	8d 93 f1 00 00 00    	lea    0xf1(%ebx),%edx
40039674:	b9 10 00 00 00       	mov    $0x10,%ecx
40039679:	8d 45 e4             	lea    -0x1c(%ebp),%eax
4003967c:	e8 e9 69 ff ff       	call   4003006a <memcpy>
       aes_encrypt(in, digest, &ctx->rijndael);
40039681:	89 d9                	mov    %ebx,%ecx
40039683:	8b 55 d0             	mov    -0x30(%ebp),%edx
40039686:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40039689:	e8 14 fa ff ff       	call   400390a2 <aes_encrypt>
           memset(K, 0, sizeof K);
4003968e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
40039691:	b9 10 00 00 00       	mov    $0x10,%ecx
40039696:	31 d2                	xor    %edx,%edx
40039698:	e8 d8 69 ff ff       	call   40030075 <memset>

}
4003969d:	83 c4 24             	add    $0x24,%esp
400396a0:	5b                   	pop    %ebx
400396a1:	5e                   	pop    %esi
400396a2:	5f                   	pop    %edi
400396a3:	5d                   	pop    %ebp
400396a4:	c3                   	ret    

400396a5 <_arc_init>:
{
	uint32_t *reset_vector;

	ARG_UNUSED(arg);

	if (!SCSS_REG_VAL(SCSS_SS_STS)) {
400396a5:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400396aa:	85 c0                	test   %eax,%eax
400396ac:	75 15                	jne    400396c3 <_arc_init+0x1e>
{
400396ae:	55                   	push   %ebp
400396af:	89 e5                	mov    %esp,%ebp
		/* ARC shouldn't already be running! */
		printk("ARC core already running!");
400396b1:	68 e0 cf 03 40       	push   $0x4003cfe0
400396b6:	e8 3d 95 ff ff       	call   40032bf8 <printk>
400396bb:	58                   	pop    %eax
		return -EIO;
400396bc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}

skip_arc_init:

	return 0;
}
400396c1:	c9                   	leave  
400396c2:	c3                   	ret    
	shared_data->arc_start = *reset_vector;
400396c3:	a1 00 00 00 40       	mov    0x40000000,%eax
400396c8:	a3 00 00 00 a8       	mov    %eax,0xa8000000
	shared_data->flags = 0;
400396cd:	c7 05 04 00 00 a8 00 	movl   $0x0,0xa8000004
400396d4:	00 00 00 
	if (!shared_data->arc_start) {
400396d7:	a1 00 00 00 a8       	mov    0xa8000000,%eax
400396dc:	85 c0                	test   %eax,%eax
400396de:	75 03                	jne    400396e3 <_arc_init+0x3e>
	return 0;
400396e0:	31 c0                	xor    %eax,%eax
400396e2:	c3                   	ret    
	SCSS_REG_VAL(SCSS_SS_CFG) |= ARC_RUN_REQ_A;
400396e3:	a1 00 06 80 b0       	mov    0xb0800600,%eax
400396e8:	0d 00 00 00 01       	or     $0x1000000,%eax
400396ed:	a3 00 06 80 b0       	mov    %eax,0xb0800600
	while (SCSS_REG_VAL(SCSS_SS_STS) & 0x4000) {
400396f2:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400396f7:	0f ba e0 0e          	bt     $0xe,%eax
400396fb:	72 f5                	jb     400396f2 <_arc_init+0x4d>
	while (!(shared_data->flags & ARC_READY)) {
400396fd:	a1 04 00 00 a8       	mov    0xa8000004,%eax
40039702:	a8 01                	test   $0x1,%al
40039704:	74 f7                	je     400396fd <_arc_init+0x58>
40039706:	eb d8                	jmp    400396e0 <_arc_init+0x3b>

40039708 <_lakemont_eoi>:
#include <arch/x86/irq_controller.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
40039708:	55                   	push   %ebp
40039709:	89 e5                	mov    %esp,%ebp
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
4003970b:	e8 eb 88 ff ff       	call   40031ffb <__irq_controller_isr_vector_get>
40039710:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
40039715:	31 c0                	xor    %eax,%eax
40039717:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	sys_write32(_irq_controller_isr_vector_get(),
		    CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);

	/* Send EOI to the LOAPIC as well */
	sys_write32(0, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI);
}
4003971c:	5d                   	pop    %ebp
4003971d:	c3                   	ret    

4003971e <k_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void k_cpu_idle(void)
{
4003971e:	55                   	push   %ebp
4003971f:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
40039721:	fb                   	sti    
40039722:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
40039723:	5d                   	pop    %ebp
40039724:	c3                   	ret    

40039725 <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
40039725:	55                   	push   %ebp
40039726:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
40039728:	e8 cf 0c 00 00       	call   4003a3fc <k_is_in_isr>
4003972d:	85 c0                	test   %eax,%eax
4003972f:	74 15                	je     40039746 <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
40039731:	e8 c6 0c 00 00       	call   4003a3fc <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
40039736:	ba fa cf 03 40       	mov    $0x4003cffa,%edx
4003973b:	85 c0                	test   %eax,%eax
4003973d:	75 2c                	jne    4003976b <_SysFatalErrorHandler+0x46>
4003973f:	ba fe cf 03 40       	mov    $0x4003cffe,%edx
40039744:	eb 25                	jmp    4003976b <_SysFatalErrorHandler+0x46>
	if (k_is_in_isr() || _is_thread_essential()) {
40039746:	e8 c2 0c 00 00       	call   4003a40d <_is_thread_essential>
4003974b:	85 c0                	test   %eax,%eax
4003974d:	75 e2                	jne    40039731 <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
4003974f:	ff 35 28 80 00 a8    	pushl  0xa8008028
40039755:	68 2f d0 03 40       	push   $0x4003d02f
4003975a:	e8 99 94 ff ff       	call   40032bf8 <printk>
4003975f:	58                   	pop    %eax
	k_thread_abort(_current);
40039760:	a1 28 80 00 a8       	mov    0xa8008028,%eax
	printk("Fatal fault in thread %p! Aborting.\n", _current);
40039765:	5a                   	pop    %edx
	k_thread_abort(_current);
40039766:	e8 12 0e 00 00       	call   4003a57d <k_thread_abort>
		printk("Fatal fault in %s! Spinning...\n",
4003976b:	52                   	push   %edx
4003976c:	68 0f d0 03 40       	push   $0x4003d00f
40039771:	e8 82 94 ff ff       	call   40032bf8 <printk>
40039776:	59                   	pop    %ecx
40039777:	58                   	pop    %eax
40039778:	eb fe                	jmp    40039778 <_SysFatalErrorHandler+0x53>

4003977a <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
4003977a:	53                   	push   %ebx
	movl $1, %eax
4003977b:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
40039780:	0f a2                	cpuid  
	movl %ebx, %eax
40039782:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
40039784:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
40039789:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
4003978c:	5b                   	pop    %ebx
	ret
4003978d:	c3                   	ret    

4003978e <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
4003978e:	55                   	push   %ebp
4003978f:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
40039791:	e8 e4 ff ff ff       	call   4003977a <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
40039796:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
40039797:	a3 2c 85 00 a8       	mov    %eax,0xa800852c
}
4003979c:	31 c0                	xor    %eax,%eax
4003979e:	c3                   	ret    

4003979f <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
4003979f:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
400397a0:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
400397a3:	50                   	push   %eax
	pushl	%edx
400397a4:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
400397a5:	57                   	push   %edi
	pushl	%esi
400397a6:	56                   	push   %esi
	pushl	%ebx
400397a7:	53                   	push   %ebx
	pushl	%ebp
400397a8:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
400397a9:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
400397ad:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
400397ae:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
400397b5:	00 
	je	allDone
400397b6:	74 01                	je     400397b9 <allDone>
	sti
400397b8:	fb                   	sti    

400397b9 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
400397b9:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
400397bb:	ff d1                	call   *%ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
400397bd:	5d                   	pop    %ebp
	popl	%ebp
400397be:	5d                   	pop    %ebp
	popl	%ebx
400397bf:	5b                   	pop    %ebx
	popl	%esi
400397c0:	5e                   	pop    %esi
	popl	%edi
400397c1:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
400397c2:	5a                   	pop    %edx
	popl	%eax
400397c3:	58                   	pop    %eax
	popl	%ecx
400397c4:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
400397c5:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
400397c8:	cf                   	iret   

400397c9 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
400397c9:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
400397ca:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
400397ce:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
400397d1:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
400397d2:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
400397d3:	b9 20 80 00 a8       	mov    $0xa8008020,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
400397d8:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
400397da:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
400397dd:	75 06                	jne    400397e5 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
400397df:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
400397e1:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
400397e4:	57                   	push   %edi

400397e5 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
400397e5:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
400397e6:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
400397e8:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
400397e9:	e8 1a ff ff ff       	call   40039708 <_lakemont_eoi>
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
400397ee:	b9 20 80 00 a8       	mov    $0xa8008020,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
400397f3:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
400397f5:	75 1e                	jne    40039815 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
400397f7:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
400397fa:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
40039800:	73 12                	jae    40039814 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
40039802:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
40039805:	74 0d                	je     40039814 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
40039807:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
40039808:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
40039809:	58                   	pop    %eax
#endif
	call	_Swap
4003980a:	e8 27 00 00 00       	call   40039836 <_Swap>

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
4003980f:	5f                   	pop    %edi
	popl	%ecx
40039810:	59                   	pop    %ecx
	popl	%edx
40039811:	5a                   	pop    %edx
	popl	%eax
40039812:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40039813:	cf                   	iret   

40039814 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
40039814:	5c                   	pop    %esp

40039815 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
40039815:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
40039816:	59                   	pop    %ecx
	popl	%edx
40039817:	5a                   	pop    %edx
	popl	%eax
40039818:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40039819:	cf                   	iret   

4003981a <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
4003981a:	6a 00                	push   $0x0

4003981c <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
4003981c:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
4003981d:	50                   	push   %eax
	pushl %ecx
4003981e:	51                   	push   %ecx
	pushl %edx
4003981f:	52                   	push   %edx
	pushl %edi
40039820:	57                   	push   %edi
	pushl %esi
40039821:	56                   	push   %esi
	pushl %ebx
40039822:	53                   	push   %ebx
	pushl %ebp
40039823:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
40039824:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
40039828:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
40039829:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
4003982b:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
4003982c:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
40039831:	e8 9b 00 00 00       	call   400398d1 <_NanoFatalErrorHandler>

40039836 <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
40039836:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
40039839:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
4003983d:	57                   	push   %edi

	movl	$_kernel, %edi
4003983e:	bf 20 80 00 a8       	mov    $0xa8008020,%edi

	pushl	%esi
40039843:	56                   	push   %esi
	pushl	%ebx
40039844:	53                   	push   %ebx
	pushl	%ebp
40039845:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
40039846:	ff 35 24 d2 03 40    	pushl  0x4003d224


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
4003984c:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
4003984f:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
40039852:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
40039855:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
40039858:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
4003985b:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
4003985c:	5d                   	pop    %ebp
	popl	%ebx
4003985d:	5b                   	pop    %ebx
	popl	%esi
4003985e:	5e                   	pop    %esi
	popl	%edi
4003985f:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
40039860:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
40039864:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
40039865:	5a                   	pop    %edx
	movl	%edx, (%esp)
40039866:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
40039869:	c3                   	ret    

4003986a <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
4003986a:	55                   	push   %ebp
4003986b:	89 e5                	mov    %esp,%ebp
4003986d:	56                   	push   %esi
4003986e:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
4003986f:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
40039872:	83 e3 fc             	and    $0xfffffffc,%ebx
{
40039875:	89 c6                	mov    %eax,%esi
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
40039877:	8b 45 10             	mov    0x10(%ebp),%eax
4003987a:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
4003987d:	8b 45 0c             	mov    0xc(%ebp),%eax
40039880:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
40039883:	8b 45 08             	mov    0x8(%ebp),%eax
40039886:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
40039889:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
4003988c:	9c                   	pushf  
4003988d:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
4003988e:	80 e4 cd             	and    $0xcd,%ah
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
40039891:	c7 43 e8 60 00 03 40 	movl   $0x40030060,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40039898:	80 cc 02             	or     $0x2,%ah
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
4003989b:	8b 55 14             	mov    0x14(%ebp),%edx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
4003989e:	89 43 ec             	mov    %eax,-0x14(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400398a1:	b9 04 00 00 00       	mov    $0x4,%ecx
400398a6:	ff 75 18             	pushl  0x18(%ebp)
400398a9:	89 f0                	mov    %esi,%eax
	pInitialCtx -= 11;
400398ab:	83 eb 2c             	sub    $0x2c,%ebx
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400398ae:	e8 97 0c 00 00       	call   4003a54a <_init_thread_base>
	pInitialCtx -= 11;
400398b3:	89 5e 28             	mov    %ebx,0x28(%esi)
	thread->init_data = NULL;
400398b6:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
400398bd:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400398c4:	58                   	pop    %eax
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
400398c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
400398c8:	5b                   	pop    %ebx
400398c9:	5e                   	pop    %esi
400398ca:	5d                   	pop    %ebp
400398cb:	c3                   	ret    

400398cc <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
400398cc:	55                   	push   %ebp
400398cd:	89 e5                	mov    %esp,%ebp
400398cf:	5d                   	pop    %ebp
400398d0:	c3                   	ret    

400398d1 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
400398d1:	55                   	push   %ebp
400398d2:	89 e5                	mov    %esp,%ebp
400398d4:	57                   	push   %edi
400398d5:	56                   	push   %esi
400398d6:	53                   	push   %ebx
400398d7:	83 ec 28             	sub    $0x28,%esp
400398da:	89 c6                	mov    %eax,%esi
	_debug_fatal_hook(pEsf);
400398dc:	89 d0                	mov    %edx,%eax
{
400398de:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
400398e0:	e8 e7 ff ff ff       	call   400398cc <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
400398e5:	83 fe 03             	cmp    $0x3,%esi
400398e8:	74 3e                	je     40039928 <_NanoFatalErrorHandler+0x57>
400398ea:	77 06                	ja     400398f2 <_NanoFatalErrorHandler+0x21>
400398ec:	85 f6                	test   %esi,%esi
400398ee:	74 0e                	je     400398fe <_NanoFatalErrorHandler+0x2d>
400398f0:	eb 4a                	jmp    4003993c <_NanoFatalErrorHandler+0x6b>
400398f2:	83 fe 05             	cmp    $0x5,%esi
400398f5:	74 3e                	je     40039935 <_NanoFatalErrorHandler+0x64>
400398f7:	83 fe 06             	cmp    $0x6,%esi
400398fa:	74 4d                	je     40039949 <_NanoFatalErrorHandler+0x78>
400398fc:	eb 3e                	jmp    4003993c <_NanoFatalErrorHandler+0x6b>
400398fe:	e8 f8 86 ff ff       	call   40031ffb <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
40039903:	68 54 d0 03 40       	push   $0x4003d054
40039908:	89 c3                	mov    %eax,%ebx
4003990a:	e8 e9 92 ff ff       	call   40032bf8 <printk>
4003990f:	58                   	pop    %eax
		if (vector >= 0) {
40039910:	85 db                	test   %ebx,%ebx
40039912:	78 0d                	js     40039921 <_NanoFatalErrorHandler+0x50>
			printk("%d ", vector);
40039914:	53                   	push   %ebx
40039915:	68 76 d0 03 40       	push   $0x4003d076
4003991a:	e8 d9 92 ff ff       	call   40032bf8 <printk>
4003991f:	5b                   	pop    %ebx
40039920:	58                   	pop    %eax
		}
		printk("*****\n");
40039921:	68 9d d0 03 40       	push   $0x4003d09d
40039926:	eb 05                	jmp    4003992d <_NanoFatalErrorHandler+0x5c>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
40039928:	68 7a d0 03 40       	push   $0x4003d07a
4003992d:	e8 c6 92 ff ff       	call   40032bf8 <printk>
40039932:	59                   	pop    %ecx
		break;
40039933:	eb 14                	jmp    40039949 <_NanoFatalErrorHandler+0x78>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40039935:	68 a4 d0 03 40       	push   $0x4003d0a4
4003993a:	eb f1                	jmp    4003992d <_NanoFatalErrorHandler+0x5c>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
4003993c:	56                   	push   %esi
4003993d:	68 ca d0 03 40       	push   $0x4003d0ca
40039942:	e8 b1 92 ff ff       	call   40032bf8 <printk>
40039947:	58                   	pop    %eax
40039948:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
40039949:	8b 47 04             	mov    0x4(%edi),%eax
4003994c:	8b 4f 2c             	mov    0x2c(%edi),%ecx
4003994f:	89 45 f0             	mov    %eax,-0x10(%ebp)
40039952:	8b 47 10             	mov    0x10(%edi),%eax
40039955:	89 45 ec             	mov    %eax,-0x14(%ebp)
40039958:	8b 47 0c             	mov    0xc(%edi),%eax
4003995b:	89 45 e8             	mov    %eax,-0x18(%ebp)
4003995e:	8b 47 14             	mov    0x14(%edi),%eax
40039961:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40039964:	8b 47 1c             	mov    0x1c(%edi),%eax
40039967:	89 45 e0             	mov    %eax,-0x20(%ebp)
4003996a:	8b 47 08             	mov    0x8(%edi),%eax
4003996d:	89 45 dc             	mov    %eax,-0x24(%ebp)
40039970:	8b 47 18             	mov    0x18(%edi),%eax
40039973:	8b 17                	mov    (%edi),%edx
40039975:	89 45 d8             	mov    %eax,-0x28(%ebp)
40039978:	8b 47 24             	mov    0x24(%edi),%eax
4003997b:	89 4d cc             	mov    %ecx,-0x34(%ebp)
4003997e:	89 55 d0             	mov    %edx,-0x30(%ebp)
40039981:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40039984:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
40039988:	e8 b3 05 00 00       	call   40039f40 <k_current_get>
4003998d:	8b 55 d0             	mov    -0x30(%ebp),%edx
40039990:	8b 4d cc             	mov    -0x34(%ebp),%ecx
40039993:	51                   	push   %ecx
40039994:	52                   	push   %edx
40039995:	ff 75 f0             	pushl  -0x10(%ebp)
40039998:	ff 75 ec             	pushl  -0x14(%ebp)
4003999b:	ff 75 e8             	pushl  -0x18(%ebp)
4003999e:	ff 75 e4             	pushl  -0x1c(%ebp)
400399a1:	ff 75 e0             	pushl  -0x20(%ebp)
400399a4:	ff 75 dc             	pushl  -0x24(%ebp)
400399a7:	ff 75 d8             	pushl  -0x28(%ebp)
400399aa:	ff 75 d4             	pushl  -0x2c(%ebp)
400399ad:	53                   	push   %ebx
400399ae:	50                   	push   %eax
400399af:	68 ed d0 03 40       	push   $0x4003d0ed
400399b4:	e8 3f 92 ff ff       	call   40032bf8 <printk>
400399b9:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
400399bc:	89 fa                	mov    %edi,%edx
400399be:	89 f0                	mov    %esi,%eax
400399c0:	e8 60 fd ff ff       	call   40039725 <_SysFatalErrorHandler>

400399c5 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
400399c5:	55                   	push   %ebp
400399c6:	89 e5                	mov    %esp,%ebp
400399c8:	56                   	push   %esi
400399c9:	89 c6                	mov    %eax,%esi
400399cb:	53                   	push   %ebx
400399cc:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
400399ce:	50                   	push   %eax
400399cf:	68 8c d1 03 40       	push   $0x4003d18c
400399d4:	e8 1f 92 ff ff       	call   40032bf8 <printk>
400399d9:	59                   	pop    %ecx
400399da:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
400399db:	b8 00 7d 02 00       	mov    $0x27d00,%eax
400399e0:	0f a3 f0             	bt     %esi,%eax
400399e3:	73 0f                	jae    400399f4 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
400399e5:	ff 73 20             	pushl  0x20(%ebx)
400399e8:	68 a4 d1 03 40       	push   $0x4003d1a4
400399ed:	e8 06 92 ff ff       	call   40032bf8 <printk>
400399f2:	58                   	pop    %eax
400399f3:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
400399f4:	89 da                	mov    %ebx,%edx
400399f6:	b8 06 00 00 00       	mov    $0x6,%eax
400399fb:	e8 d1 fe ff ff       	call   400398d1 <_NanoFatalErrorHandler>

40039a00 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
40039a00:	55                   	push   %ebp
40039a01:	89 c2                	mov    %eax,%edx
40039a03:	89 e5                	mov    %esp,%ebp
40039a05:	31 c0                	xor    %eax,%eax
40039a07:	e8 b9 ff ff ff       	call   400399c5 <generic_exc_handle>

40039a0c <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
40039a0c:	55                   	push   %ebp
40039a0d:	89 c2                	mov    %eax,%edx
40039a0f:	89 e5                	mov    %esp,%ebp
40039a11:	b8 02 00 00 00       	mov    $0x2,%eax
40039a16:	e8 aa ff ff ff       	call   400399c5 <generic_exc_handle>

40039a1b <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
40039a1b:	55                   	push   %ebp
40039a1c:	89 c2                	mov    %eax,%edx
40039a1e:	89 e5                	mov    %esp,%ebp
40039a20:	b8 04 00 00 00       	mov    $0x4,%eax
40039a25:	e8 9b ff ff ff       	call   400399c5 <generic_exc_handle>

40039a2a <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
40039a2a:	55                   	push   %ebp
40039a2b:	89 c2                	mov    %eax,%edx
40039a2d:	89 e5                	mov    %esp,%ebp
40039a2f:	b8 05 00 00 00       	mov    $0x5,%eax
40039a34:	e8 8c ff ff ff       	call   400399c5 <generic_exc_handle>

40039a39 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
40039a39:	55                   	push   %ebp
40039a3a:	89 c2                	mov    %eax,%edx
40039a3c:	89 e5                	mov    %esp,%ebp
40039a3e:	b8 06 00 00 00       	mov    $0x6,%eax
40039a43:	e8 7d ff ff ff       	call   400399c5 <generic_exc_handle>

40039a48 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
40039a48:	55                   	push   %ebp
40039a49:	89 c2                	mov    %eax,%edx
40039a4b:	89 e5                	mov    %esp,%ebp
40039a4d:	b8 07 00 00 00       	mov    $0x7,%eax
40039a52:	e8 6e ff ff ff       	call   400399c5 <generic_exc_handle>

40039a57 <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
40039a57:	55                   	push   %ebp
40039a58:	89 c2                	mov    %eax,%edx
40039a5a:	89 e5                	mov    %esp,%ebp
40039a5c:	b8 08 00 00 00       	mov    $0x8,%eax
40039a61:	e8 5f ff ff ff       	call   400399c5 <generic_exc_handle>

40039a66 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
40039a66:	55                   	push   %ebp
40039a67:	89 c2                	mov    %eax,%edx
40039a69:	89 e5                	mov    %esp,%ebp
40039a6b:	b8 0a 00 00 00       	mov    $0xa,%eax
40039a70:	e8 50 ff ff ff       	call   400399c5 <generic_exc_handle>

40039a75 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
40039a75:	55                   	push   %ebp
40039a76:	89 c2                	mov    %eax,%edx
40039a78:	89 e5                	mov    %esp,%ebp
40039a7a:	b8 0b 00 00 00       	mov    $0xb,%eax
40039a7f:	e8 41 ff ff ff       	call   400399c5 <generic_exc_handle>

40039a84 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
40039a84:	55                   	push   %ebp
40039a85:	89 c2                	mov    %eax,%edx
40039a87:	89 e5                	mov    %esp,%ebp
40039a89:	b8 0c 00 00 00       	mov    $0xc,%eax
40039a8e:	e8 32 ff ff ff       	call   400399c5 <generic_exc_handle>

40039a93 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
40039a93:	55                   	push   %ebp
40039a94:	89 c2                	mov    %eax,%edx
40039a96:	89 e5                	mov    %esp,%ebp
40039a98:	b8 0d 00 00 00       	mov    $0xd,%eax
40039a9d:	e8 23 ff ff ff       	call   400399c5 <generic_exc_handle>

40039aa2 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
40039aa2:	55                   	push   %ebp
40039aa3:	89 c2                	mov    %eax,%edx
40039aa5:	89 e5                	mov    %esp,%ebp
40039aa7:	b8 0e 00 00 00       	mov    $0xe,%eax
40039aac:	e8 14 ff ff ff       	call   400399c5 <generic_exc_handle>

40039ab1 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
40039ab1:	55                   	push   %ebp
40039ab2:	89 c2                	mov    %eax,%edx
40039ab4:	89 e5                	mov    %esp,%ebp
40039ab6:	b8 10 00 00 00       	mov    $0x10,%eax
40039abb:	e8 05 ff ff ff       	call   400399c5 <generic_exc_handle>

40039ac0 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
40039ac0:	55                   	push   %ebp
40039ac1:	89 c2                	mov    %eax,%edx
40039ac3:	89 e5                	mov    %esp,%ebp
40039ac5:	b8 11 00 00 00       	mov    $0x11,%eax
40039aca:	e8 f6 fe ff ff       	call   400399c5 <generic_exc_handle>

40039acf <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
40039acf:	55                   	push   %ebp
40039ad0:	89 c2                	mov    %eax,%edx
40039ad2:	89 e5                	mov    %esp,%ebp
40039ad4:	b8 12 00 00 00       	mov    $0x12,%eax
40039ad9:	e8 e7 fe ff ff       	call   400399c5 <generic_exc_handle>

40039ade <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
40039ade:	55                   	push   %ebp
40039adf:	89 e5                	mov    %esp,%ebp
40039ae1:	56                   	push   %esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40039ae2:	8d 70 01             	lea    0x1(%eax),%esi
{
40039ae5:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40039ae6:	8b 1c 85 00 d2 03 40 	mov    0x4003d200(,%eax,4),%ebx
40039aed:	3b 1c b5 00 d2 03 40 	cmp    0x4003d200(,%esi,4),%ebx
40039af4:	73 0c                	jae    40039b02 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
40039af6:	8b 13                	mov    (%ebx),%edx
40039af8:	89 d8                	mov    %ebx,%eax
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40039afa:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
40039afd:	ff 52 04             	call   *0x4(%edx)
40039b00:	eb eb                	jmp    40039aed <_sys_device_do_config_level+0xf>
	}
}
40039b02:	5b                   	pop    %ebx
40039b03:	5e                   	pop    %esi
40039b04:	5d                   	pop    %ebp
40039b05:	c3                   	ret    

40039b06 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
40039b06:	55                   	push   %ebp
40039b07:	89 e5                	mov    %esp,%ebp
40039b09:	56                   	push   %esi
40039b0a:	89 c6                	mov    %eax,%esi
40039b0c:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40039b0d:	bb 58 67 00 a8       	mov    $0xa8006758,%ebx
40039b12:	81 fb 00 68 00 a8    	cmp    $0xa8006800,%ebx
40039b18:	74 1c                	je     40039b36 <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40039b1a:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
40039b1e:	75 05                	jne    40039b25 <device_get_binding+0x1f>
	for (info = __device_init_start; info != __device_init_end; info++) {
40039b20:	83 c3 0c             	add    $0xc,%ebx
40039b23:	eb ed                	jmp    40039b12 <device_get_binding+0xc>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40039b25:	8b 03                	mov    (%ebx),%eax
40039b27:	8b 10                	mov    (%eax),%edx
40039b29:	89 f0                	mov    %esi,%eax
40039b2b:	e8 f1 11 00 00       	call   4003ad21 <strcmp>
40039b30:	85 c0                	test   %eax,%eax
40039b32:	75 ec                	jne    40039b20 <device_get_binding+0x1a>
40039b34:	eb 02                	jmp    40039b38 <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
40039b36:	31 db                	xor    %ebx,%ebx
}
40039b38:	89 d8                	mov    %ebx,%eax
40039b3a:	5b                   	pop    %ebx
40039b3b:	5e                   	pop    %esi
40039b3c:	5d                   	pop    %ebp
40039b3d:	c3                   	ret    

40039b3e <device_busy_set>:
40039b3e:	55                   	push   %ebp
40039b3f:	89 e5                	mov    %esp,%ebp
40039b41:	5d                   	pop    %ebp
40039b42:	c3                   	ret    

40039b43 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
40039b43:	55                   	push   %ebp
40039b44:	89 e5                	mov    %esp,%ebp
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
40039b46:	5d                   	pop    %ebp
40039b47:	c3                   	ret    

40039b48 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
40039b48:	55                   	push   %ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40039b49:	b8 02 00 00 00       	mov    $0x2,%eax
{
40039b4e:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40039b50:	e8 89 ff ff ff       	call   40039ade <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40039b55:	b8 05 00 00 00       	mov    $0x5,%eax
40039b5a:	e8 7f ff ff ff       	call   40039ade <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
40039b5f:	b8 06 00 00 00       	mov    $0x6,%eax
40039b64:	e8 75 ff ff ff       	call   40039ade <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
40039b69:	b8 07 00 00 00       	mov    $0x7,%eax
40039b6e:	e8 6b ff ff ff       	call   40039ade <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
40039b73:	b8 03 00 00 00       	mov    $0x3,%eax
40039b78:	e8 61 ff ff ff       	call   40039ade <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
40039b7d:	e8 4f 09 00 00       	call   4003a4d1 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
40039b82:	e8 a4 7e ff ff       	call   40031a2b <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}
40039b87:	5d                   	pop    %ebp
	_main_thread->base.user_options &= ~K_ESSENTIAL;
40039b88:	80 25 54 8e 00 a8 fe 	andb   $0xfe,0xa8008e54
}
40039b8f:	c3                   	ret    

40039b90 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40039b90:	55                   	push   %ebp
40039b91:	89 e5                	mov    %esp,%ebp
40039b93:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
40039b96:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
40039b99:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
40039b9d:	a3 28 80 00 a8       	mov    %eax,0xa8008028
	dummy_thread->base.user_options = K_ESSENTIAL;
40039ba2:	b8 1c 00 00 00       	mov    $0x1c,%eax
40039ba7:	8d 90 20 80 00 a8    	lea    -0x57ff7fe0(%eax),%edx
40039bad:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
40039bb0:	89 90 18 80 00 a8    	mov    %edx,-0x57ff7fe8(%eax)
	list->tail = (sys_dnode_t *)list;
40039bb6:	89 90 1c 80 00 a8    	mov    %edx,-0x57ff7fe4(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
40039bbc:	3d 1c 01 00 00       	cmp    $0x11c,%eax
40039bc1:	75 e4                	jne    40039ba7 <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40039bc3:	6a 01                	push   $0x1
40039bc5:	b9 48 9b 03 40       	mov    $0x40039b48,%ecx
40039bca:	6a 00                	push   $0x0
40039bcc:	ba 00 04 00 00       	mov    $0x400,%edx
40039bd1:	6a 00                	push   $0x0
40039bd3:	b8 4c 8e 00 a8       	mov    $0xa8008e4c,%eax
40039bd8:	6a 00                	push   $0x0
40039bda:	6a 00                	push   $0x0
	_ready_q.cache = _main_thread;
40039bdc:	c7 05 34 80 00 a8 4c 	movl   $0xa8008e4c,0xa8008034
40039be3:	8e 00 a8 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40039be6:	e8 7f fc ff ff       	call   4003986a <_new_thread>
40039beb:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_main_thread);
40039bee:	b8 4c 8e 00 a8       	mov    $0xa8008e4c,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40039bf3:	80 25 55 8e 00 a8 fb 	andb   $0xfb,0xa8008e55
40039bfa:	e8 2c 01 00 00       	call   40039d2b <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
40039bff:	b9 22 a8 03 40       	mov    $0x4003a822,%ecx
40039c04:	ba 00 01 00 00       	mov    $0x100,%edx
40039c09:	6a 01                	push   $0x1
40039c0b:	b8 4c 8d 00 a8       	mov    $0xa8008d4c,%eax
40039c10:	6a 0f                	push   $0xf
40039c12:	6a 00                	push   $0x0
40039c14:	6a 00                	push   $0x0
40039c16:	6a 00                	push   $0x0
40039c18:	e8 4d fc ff ff       	call   4003986a <_new_thread>
40039c1d:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_idle_thread);
40039c20:	b8 4c 8d 00 a8       	mov    $0xa8008d4c,%eax
40039c25:	80 25 55 8d 00 a8 fb 	andb   $0xfb,0xa8008d55
40039c2c:	e8 fa 00 00 00       	call   40039d2b <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
40039c31:	b8 04 00 00 00       	mov    $0x4,%eax
	list->head = (sys_dnode_t *)list;
40039c36:	c7 05 2c 80 00 a8 2c 	movl   $0xa800802c,0xa800802c
40039c3d:	80 00 a8 
	list->tail = (sys_dnode_t *)list;
40039c40:	c7 05 30 80 00 a8 2c 	movl   $0xa800802c,0xa8008030
40039c47:	80 00 a8 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
40039c4a:	c7 05 20 80 00 a8 00 	movl   $0x0,0xa8008020
40039c51:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
40039c54:	c7 05 24 80 00 a8 4c 	movl   $0xa8008d4c,0xa8008024
40039c5b:	8d 00 a8 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
40039c5e:	c7 05 30 85 00 a8 00 	movl   $0x800,0xa8008530
40039c65:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
40039c68:	c7 05 14 85 00 a8 9f 	movl   $0x4003979f,0xa8008514
40039c6f:	97 03 40 
40039c72:	e8 67 fe ff ff       	call   40039ade <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40039c77:	31 c0                	xor    %eax,%eax
40039c79:	e8 60 fe ff ff       	call   40039ade <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
40039c7e:	b8 01 00 00 00       	mov    $0x1,%eax
40039c83:	e8 56 fe ff ff       	call   40039ade <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
40039c88:	68 28 d2 03 40       	push   $0x4003d228
40039c8d:	68 44 d2 03 40       	push   $0x4003d244
40039c92:	e8 61 8f ff ff       	call   40032bf8 <printk>
40039c97:	58                   	pop    %eax
40039c98:	5a                   	pop    %edx
	__asm__ volatile (
40039c99:	9c                   	pushf  
40039c9a:	fa                   	cli    
40039c9b:	58                   	pop    %eax
	_Swap(irq_lock());
40039c9c:	e8 95 fb ff ff       	call   40039836 <_Swap>

40039ca1 <_get_highest_ready_prio>:
{
40039ca1:	55                   	push   %ebp
40039ca2:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40039ca4:	0f bc 05 38 80 00 a8 	bsf    0xa8008038,%eax
40039cab:	75 05                	jne    40039cb2 <_get_highest_ready_prio+0x11>
40039cad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
40039cb2:	83 e8 10             	sub    $0x10,%eax
}
40039cb5:	5d                   	pop    %ebp
40039cb6:	c3                   	ret    

40039cb7 <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
40039cb7:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
40039cb8:	89 42 08             	mov    %eax,0x8(%edx)
{
40039cbb:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
40039cbd:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
40039cc0:	53                   	push   %ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
40039cc1:	a1 2c 80 00 a8       	mov    0xa800802c,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40039cc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40039cc9:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40039ccb:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40039cce:	74 07                	je     40039cd7 <_add_timeout+0x20>
40039cd0:	3d 2c 80 00 a8       	cmp    $0xa800802c,%eax
40039cd5:	75 1d                	jne    40039cf4 <_add_timeout+0x3d>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
40039cd7:	c7 02 2c 80 00 a8    	movl   $0xa800802c,(%edx)
	node->prev = list->tail;
40039cdd:	a1 30 80 00 a8       	mov    0xa8008030,%eax
40039ce2:	89 42 04             	mov    %eax,0x4(%edx)

	list->tail->next = node;
40039ce5:	a1 30 80 00 a8       	mov    0xa8008030,%eax
40039cea:	89 10                	mov    %edx,(%eax)
	list->tail = node;
40039cec:	89 15 30 80 00 a8    	mov    %edx,0xa8008030
40039cf2:	eb 34                	jmp    40039d28 <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
40039cf4:	8b 4a 10             	mov    0x10(%edx),%ecx
40039cf7:	8b 58 10             	mov    0x10(%eax),%ebx
40039cfa:	39 d9                	cmp    %ebx,%ecx
40039cfc:	7f 17                	jg     40039d15 <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
40039cfe:	29 cb                	sub    %ecx,%ebx
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
40039d00:	8b 48 04             	mov    0x4(%eax),%ecx
40039d03:	89 58 10             	mov    %ebx,0x10(%eax)
40039d06:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
40039d09:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
40039d0b:	8b 48 04             	mov    0x4(%eax),%ecx
40039d0e:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
40039d10:	89 50 04             	mov    %edx,0x4(%eax)
40039d13:	eb 13                	jmp    40039d28 <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
40039d15:	29 d9                	sub    %ebx,%ecx
40039d17:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
40039d1a:	3b 05 30 80 00 a8    	cmp    0xa8008030,%eax
40039d20:	74 b5                	je     40039cd7 <_add_timeout+0x20>
40039d22:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40039d24:	85 c0                	test   %eax,%eax
40039d26:	eb ad                	jmp    40039cd5 <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
40039d28:	5b                   	pop    %ebx
40039d29:	5d                   	pop    %ebp
40039d2a:	c3                   	ret    

40039d2b <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
40039d2b:	55                   	push   %ebp
40039d2c:	89 e5                	mov    %esp,%ebp
40039d2e:	56                   	push   %esi
40039d2f:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40039d30:	bb 01 00 00 00       	mov    $0x1,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40039d35:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
40039d39:	8d 4a 10             	lea    0x10(%edx),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40039d3c:	89 ce                	mov    %ecx,%esi
40039d3e:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40039d41:	d3 e3                	shl    %cl,%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
40039d43:	8d 0c d5 bc 80 00 a8 	lea    -0x57ff7f44(,%edx,8),%ecx
	node->prev = list->tail;
40039d4a:	83 c2 14             	add    $0x14,%edx
	*bmap |= _get_ready_q_prio_bit(prio);
40039d4d:	09 1c b5 38 80 00 a8 	or     %ebx,-0x57ff7fc8(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
40039d54:	89 08                	mov    %ecx,(%eax)
40039d56:	8b 0c d5 20 80 00 a8 	mov    -0x57ff7fe0(,%edx,8),%ecx
40039d5d:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40039d60:	8b 0c d5 20 80 00 a8 	mov    -0x57ff7fe0(,%edx,8),%ecx
40039d67:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40039d69:	89 04 d5 20 80 00 a8 	mov    %eax,-0x57ff7fe0(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40039d70:	8b 15 34 80 00 a8    	mov    0xa8008034,%edx
40039d76:	8a 5a 0a             	mov    0xa(%edx),%bl
40039d79:	38 58 0a             	cmp    %bl,0xa(%eax)
40039d7c:	7c 02                	jl     40039d80 <_add_thread_to_ready_q+0x55>
40039d7e:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
40039d80:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40039d81:	a3 34 80 00 a8       	mov    %eax,0xa8008034
}
40039d86:	5e                   	pop    %esi
40039d87:	5d                   	pop    %ebp
40039d88:	c3                   	ret    

40039d89 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
40039d89:	55                   	push   %ebp
40039d8a:	89 e5                	mov    %esp,%ebp
40039d8c:	53                   	push   %ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40039d8d:	8b 48 04             	mov    0x4(%eax),%ecx
40039d90:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40039d92:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40039d96:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
40039d98:	8b 18                	mov    (%eax),%ebx
40039d9a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
40039d9d:	8d 0c d5 bc 80 00 a8 	lea    -0x57ff7f44(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
40039da4:	3b 0c d5 bc 80 00 a8 	cmp    -0x57ff7f44(,%edx,8),%ecx
40039dab:	75 1c                	jne    40039dc9 <_remove_thread_from_ready_q+0x40>
		_clear_ready_q_prio_bit(thread->base.prio);
40039dad:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40039db1:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40039db4:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
40039db9:	89 cb                	mov    %ecx,%ebx
40039dbb:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40039dbe:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
40039dc0:	f7 d2                	not    %edx
40039dc2:	21 14 9d 38 80 00 a8 	and    %edx,-0x57ff7fc8(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40039dc9:	8b 15 34 80 00 a8    	mov    0xa8008034,%edx
40039dcf:	39 d0                	cmp    %edx,%eax
40039dd1:	75 0c                	jne    40039ddf <_remove_thread_from_ready_q+0x56>
	int prio = _get_highest_ready_prio();
40039dd3:	e8 c9 fe ff ff       	call   40039ca1 <_get_highest_ready_prio>
40039dd8:	8b 14 c5 bc 80 00 a8 	mov    -0x57ff7f44(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
40039ddf:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40039de0:	89 15 34 80 00 a8    	mov    %edx,0xa8008034
}
40039de6:	5d                   	pop    %ebp
40039de7:	c3                   	ret    

40039de8 <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
40039de8:	55                   	push   %ebp
40039de9:	89 e5                	mov    %esp,%ebp
40039deb:	57                   	push   %edi
40039dec:	56                   	push   %esi
40039ded:	53                   	push   %ebx
	return list->head == list;
40039dee:	8b 1a                	mov    (%edx),%ebx
40039df0:	89 cf                	mov    %ecx,%edi
	return sys_dlist_is_empty(list) ? NULL : list->head;
40039df2:	39 da                	cmp    %ebx,%edx
40039df4:	75 0b                	jne    40039e01 <_pend_thread+0x19>
40039df6:	31 db                	xor    %ebx,%ebx
40039df8:	eb 07                	jmp    40039e01 <_pend_thread+0x19>
	return (node == list->tail) ? NULL : node->next;
40039dfa:	3b 5a 04             	cmp    0x4(%edx),%ebx
40039dfd:	74 20                	je     40039e1f <_pend_thread+0x37>
40039dff:	8b 1b                	mov    (%ebx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
40039e01:	85 db                	test   %ebx,%ebx
40039e03:	74 1a                	je     40039e1f <_pend_thread+0x37>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
40039e05:	8a 4b 0a             	mov    0xa(%ebx),%cl
40039e08:	38 48 0a             	cmp    %cl,0xa(%eax)
40039e0b:	7d ed                	jge    40039dfa <_pend_thread+0x12>
		node->prev = insert_point->prev;
40039e0d:	8b 73 04             	mov    0x4(%ebx),%esi
		node->next = insert_point;
40039e10:	89 18                	mov    %ebx,(%eax)
		node->prev = insert_point->prev;
40039e12:	89 70 04             	mov    %esi,0x4(%eax)
		insert_point->prev->next = node;
40039e15:	8b 73 04             	mov    0x4(%ebx),%esi
40039e18:	89 06                	mov    %eax,(%esi)
		insert_point->prev = node;
40039e1a:	89 43 04             	mov    %eax,0x4(%ebx)
40039e1d:	eb 10                	jmp    40039e2f <_pend_thread+0x47>
	node->next = list;
40039e1f:	89 10                	mov    %edx,(%eax)
	node->prev = list->tail;
40039e21:	8b 5a 04             	mov    0x4(%edx),%ebx
40039e24:	89 58 04             	mov    %ebx,0x4(%eax)
	list->tail->next = node;
40039e27:	8b 5a 04             	mov    0x4(%edx),%ebx
40039e2a:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
40039e2c:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state |= _THREAD_PENDING;
40039e2f:	80 48 09 02          	orb    $0x2,0x9(%eax)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
40039e33:	83 ff ff             	cmp    $0xffffffff,%edi
40039e36:	74 1f                	je     40039e57 <_pend_thread+0x6f>
40039e38:	89 d1                	mov    %edx,%ecx
40039e3a:	89 c3                	mov    %eax,%ebx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40039e3c:	8d 70 10             	lea    0x10(%eax),%esi
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40039e3f:	31 d2                	xor    %edx,%edx
40039e41:	8d 47 09             	lea    0x9(%edi),%eax
40039e44:	bf 0a 00 00 00       	mov    $0xa,%edi
40039e49:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
40039e4b:	40                   	inc    %eax
40039e4c:	89 f2                	mov    %esi,%edx
40039e4e:	50                   	push   %eax
40039e4f:	89 d8                	mov    %ebx,%eax
40039e51:	e8 61 fe ff ff       	call   40039cb7 <_add_timeout>
40039e56:	58                   	pop    %eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
40039e57:	8d 65 f4             	lea    -0xc(%ebp),%esp
40039e5a:	5b                   	pop    %ebx
40039e5b:	5e                   	pop    %esi
40039e5c:	5f                   	pop    %edi
40039e5d:	5d                   	pop    %ebp
40039e5e:	c3                   	ret    

40039e5f <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
40039e5f:	55                   	push   %ebp
40039e60:	89 e5                	mov    %esp,%ebp
40039e62:	56                   	push   %esi
40039e63:	53                   	push   %ebx
40039e64:	89 c3                	mov    %eax,%ebx
	_remove_thread_from_ready_q(_current);
40039e66:	a1 28 80 00 a8       	mov    0xa8008028,%eax
{
40039e6b:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
40039e6d:	e8 17 ff ff ff       	call   40039d89 <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
40039e72:	89 f1                	mov    %esi,%ecx
40039e74:	89 da                	mov    %ebx,%edx
40039e76:	a1 28 80 00 a8       	mov    0xa8008028,%eax
}
40039e7b:	5b                   	pop    %ebx
40039e7c:	5e                   	pop    %esi
40039e7d:	5d                   	pop    %ebp
	_pend_thread(_current, wait_q, timeout);
40039e7e:	e9 65 ff ff ff       	jmp    40039de8 <_pend_thread>

40039e83 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
40039e83:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
40039e84:	a1 28 80 00 a8       	mov    0xa8008028,%eax
{
40039e89:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
40039e8b:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40039e8f:	e8 0d fe ff ff       	call   40039ca1 <_get_highest_ready_prio>
#else
	return 0;
#endif
}
40039e94:	5d                   	pop    %ebp
	return prio1 < prio2;
40039e95:	39 c2                	cmp    %eax,%edx
40039e97:	0f 9f c0             	setg   %al
40039e9a:	0f b6 c0             	movzbl %al,%eax
40039e9d:	c3                   	ret    

40039e9e <_reschedule_threads>:
{
40039e9e:	89 c1                	mov    %eax,%ecx
	return _is_preempt(_current) && __must_switch_threads();
40039ea0:	a1 28 80 00 a8       	mov    0xa8008028,%eax
40039ea5:	55                   	push   %ebp
40039ea6:	89 e5                	mov    %esp,%ebp
40039ea8:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40039ead:	77 09                	ja     40039eb8 <_reschedule_threads+0x1a>
40039eaf:	e8 cf ff ff ff       	call   40039e83 <__must_switch_threads>
40039eb4:	85 c0                	test   %eax,%eax
40039eb6:	75 09                	jne    40039ec1 <_reschedule_threads+0x23>
40039eb8:	0f ba e1 09          	bt     $0x9,%ecx
40039ebc:	73 0b                	jae    40039ec9 <_reschedule_threads+0x2b>
	__asm__ volatile (
40039ebe:	fb                   	sti    
}
40039ebf:	eb 08                	jmp    40039ec9 <_reschedule_threads+0x2b>
		_Swap(key);
40039ec1:	89 c8                	mov    %ecx,%eax
}
40039ec3:	5d                   	pop    %ebp
		_Swap(key);
40039ec4:	e9 6d f9 ff ff       	jmp    40039836 <_Swap>
}
40039ec9:	5d                   	pop    %ebp
40039eca:	c3                   	ret    

40039ecb <k_sched_unlock>:
{
40039ecb:	55                   	push   %ebp
40039ecc:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40039ece:	9c                   	pushf  
40039ecf:	fa                   	cli    
40039ed0:	58                   	pop    %eax
	++_current->base.sched_locked;
40039ed1:	8b 15 28 80 00 a8    	mov    0xa8008028,%edx
40039ed7:	fe 42 0b             	incb   0xb(%edx)
}
40039eda:	5d                   	pop    %ebp
	_reschedule_threads(key);
40039edb:	e9 be ff ff ff       	jmp    40039e9e <_reschedule_threads>

40039ee0 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40039ee0:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
40039ee4:	8d 0c d5 bc 80 00 a8 	lea    -0x57ff7f44(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
40039eeb:	3b 41 04             	cmp    0x4(%ecx),%eax
40039eee:	74 4f                	je     40039f3f <_move_thread_to_end_of_prio_q+0x5f>
{
40039ef0:	55                   	push   %ebp
	node->prev = list->tail;
40039ef1:	83 c2 14             	add    $0x14,%edx
40039ef4:	89 e5                	mov    %esp,%ebp
40039ef6:	56                   	push   %esi
40039ef7:	53                   	push   %ebx
	node->prev->next = node->next;
40039ef8:	8b 58 04             	mov    0x4(%eax),%ebx
40039efb:	8b 30                	mov    (%eax),%esi
40039efd:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
40039eff:	8b 30                	mov    (%eax),%esi
40039f01:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
40039f04:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
40039f06:	8b 0c d5 20 80 00 a8 	mov    -0x57ff7fe0(,%edx,8),%ecx
40039f0d:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40039f10:	8b 0c d5 20 80 00 a8 	mov    -0x57ff7fe0(,%edx,8),%ecx
40039f17:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40039f19:	89 04 d5 20 80 00 a8 	mov    %eax,-0x57ff7fe0(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40039f20:	8b 15 34 80 00 a8    	mov    0xa8008034,%edx
40039f26:	39 d0                	cmp    %edx,%eax
40039f28:	75 0c                	jne    40039f36 <_move_thread_to_end_of_prio_q+0x56>
	int prio = _get_highest_ready_prio();
40039f2a:	e8 72 fd ff ff       	call   40039ca1 <_get_highest_ready_prio>
40039f2f:	8b 14 c5 bc 80 00 a8 	mov    -0x57ff7f44(,%eax,8),%edx
#endif
}
40039f36:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40039f37:	89 15 34 80 00 a8    	mov    %edx,0xa8008034
}
40039f3d:	5e                   	pop    %esi
40039f3e:	5d                   	pop    %ebp
40039f3f:	c3                   	ret    

40039f40 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
40039f40:	55                   	push   %ebp
	return _current;
}
40039f41:	a1 28 80 00 a8       	mov    0xa8008028,%eax
{
40039f46:	89 e5                	mov    %esp,%ebp
}
40039f48:	5d                   	pop    %ebp
40039f49:	c3                   	ret    

40039f4a <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40039f4a:	8a 50 09             	mov    0x9(%eax),%dl
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
40039f4d:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40039f4e:	88 d1                	mov    %dl,%cl
{
40039f50:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40039f52:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40039f55:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40039f58:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40039f5b:	75 0c                	jne    40039f69 <_ready_thread+0x1f>
40039f5d:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40039f61:	75 06                	jne    40039f69 <_ready_thread+0x1f>
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
	}
}
40039f63:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40039f64:	e9 c2 fd ff ff       	jmp    40039d2b <_add_thread_to_ready_q>
}
40039f69:	5d                   	pop    %ebp
40039f6a:	c3                   	ret    

40039f6b <_unpend_first_thread>:
}

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
40039f6b:	55                   	push   %ebp
	if (_handling_timeouts) {
40039f6c:	8b 15 34 85 00 a8    	mov    0xa8008534,%edx
{
40039f72:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
40039f74:	85 d2                	test   %edx,%edx
40039f76:	8b 08                	mov    (%eax),%ecx
40039f78:	74 1f                	je     40039f99 <_unpend_first_thread+0x2e>
	return list->head == list;
40039f7a:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
40039f7c:	39 c8                	cmp    %ecx,%eax
40039f7e:	75 11                	jne    40039f91 <_unpend_first_thread+0x26>
40039f80:	31 d2                	xor    %edx,%edx
40039f82:	eb 0d                	jmp    40039f91 <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
40039f84:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
40039f88:	75 1b                	jne    40039fa5 <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
40039f8a:	3b 50 04             	cmp    0x4(%eax),%edx
40039f8d:	74 06                	je     40039f95 <_unpend_first_thread+0x2a>
40039f8f:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
40039f91:	85 d2                	test   %edx,%edx
40039f93:	75 ef                	jne    40039f84 <_unpend_first_thread+0x19>
40039f95:	31 d2                	xor    %edx,%edx
40039f97:	eb 1c                	jmp    40039fb5 <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
40039f99:	31 d2                	xor    %edx,%edx
40039f9b:	39 c8                	cmp    %ecx,%eax
40039f9d:	74 16                	je     40039fb5 <_unpend_first_thread+0x4a>
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
40039f9f:	85 c9                	test   %ecx,%ecx
40039fa1:	74 12                	je     40039fb5 <_unpend_first_thread+0x4a>
40039fa3:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
40039fa5:	8b 42 04             	mov    0x4(%edx),%eax
40039fa8:	8b 0a                	mov    (%edx),%ecx
40039faa:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40039fac:	8b 0a                	mov    (%edx),%ecx
40039fae:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40039fb1:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
40039fb5:	89 d0                	mov    %edx,%eax
40039fb7:	5d                   	pop    %ebp
40039fb8:	c3                   	ret    

40039fb9 <_abort_timeout>:
{
40039fb9:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40039fba:	8b 48 10             	mov    0x10(%eax),%ecx
{
40039fbd:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40039fbf:	83 f9 ff             	cmp    $0xffffffff,%ecx
40039fc2:	74 24                	je     40039fe8 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
40039fc4:	3b 05 30 80 00 a8    	cmp    0xa8008030,%eax
40039fca:	74 05                	je     40039fd1 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40039fcc:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40039fce:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40039fd1:	8b 50 04             	mov    0x4(%eax),%edx
40039fd4:	8b 08                	mov    (%eax),%ecx
40039fd6:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40039fd8:	8b 08                	mov    (%eax),%ecx
40039fda:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40039fdd:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
40039fe4:	31 c0                	xor    %eax,%eax
40039fe6:	eb 03                	jmp    40039feb <_abort_timeout+0x32>
		return _INACTIVE;
40039fe8:	83 c8 ff             	or     $0xffffffff,%eax
}
40039feb:	5d                   	pop    %ebp
40039fec:	c3                   	ret    

40039fed <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
40039fed:	55                   	push   %ebp
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
40039fee:	89 50 08             	mov    %edx,0x8(%eax)
{
40039ff1:	89 e5                	mov    %esp,%ebp
	sem->limit = limit;
40039ff3:	89 48 0c             	mov    %ecx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
40039ff6:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
40039ff8:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
40039ffb:	5d                   	pop    %ebp
40039ffc:	c3                   	ret    

40039ffd <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
40039ffd:	55                   	push   %ebp
40039ffe:	89 e5                	mov    %esp,%ebp
4003a000:	57                   	push   %edi
4003a001:	56                   	push   %esi
4003a002:	89 c6                	mov    %eax,%esi
4003a004:	53                   	push   %ebx
4003a005:	9c                   	pushf  
4003a006:	fa                   	cli    
4003a007:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
4003a008:	e8 5e ff ff ff       	call   40039f6b <_unpend_first_thread>
	if (!thread) {
4003a00d:	85 c0                	test   %eax,%eax
4003a00f:	75 12                	jne    4003a023 <k_sem_give+0x26>
	sem->count += (sem->count != sem->limit);
4003a011:	8b 56 08             	mov    0x8(%esi),%edx
4003a014:	31 c0                	xor    %eax,%eax
4003a016:	39 56 0c             	cmp    %edx,0xc(%esi)
4003a019:	0f 95 c0             	setne  %al
4003a01c:	01 d0                	add    %edx,%eax
4003a01e:	89 46 08             	mov    %eax,0x8(%esi)
4003a021:	eb 43                	jmp    4003a066 <k_sem_give+0x69>
4003a023:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
4003a025:	8d 40 10             	lea    0x10(%eax),%eax
4003a028:	e8 8c ff ff ff       	call   40039fb9 <_abort_timeout>
	_ready_thread(thread);
4003a02d:	89 d8                	mov    %ebx,%eax
4003a02f:	e8 16 ff ff ff       	call   40039f4a <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
4003a034:	8b 43 28             	mov    0x28(%ebx),%eax
4003a037:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
4003a03d:	83 3d 20 80 00 a8 00 	cmpl   $0x0,0xa8008020
4003a044:	75 20                	jne    4003a066 <k_sem_give+0x69>
	return _is_preempt(_current) && __must_switch_threads();
4003a046:	a1 28 80 00 a8       	mov    0xa8008028,%eax
4003a04b:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
4003a050:	77 14                	ja     4003a066 <k_sem_give+0x69>
4003a052:	e8 2c fe ff ff       	call   40039e83 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
4003a057:	85 c0                	test   %eax,%eax
4003a059:	74 0b                	je     4003a066 <k_sem_give+0x69>
		_Swap(key);
4003a05b:	89 f8                	mov    %edi,%eax
	} else {
		irq_unlock(key);
	}
}
4003a05d:	5b                   	pop    %ebx
4003a05e:	5e                   	pop    %esi
4003a05f:	5f                   	pop    %edi
4003a060:	5d                   	pop    %ebp
		_Swap(key);
4003a061:	e9 d0 f7 ff ff       	jmp    40039836 <_Swap>
4003a066:	0f ba e7 09          	bt     $0x9,%edi
4003a06a:	73 01                	jae    4003a06d <k_sem_give+0x70>
	__asm__ volatile (
4003a06c:	fb                   	sti    
}
4003a06d:	5b                   	pop    %ebx
4003a06e:	5e                   	pop    %esi
4003a06f:	5f                   	pop    %edi
4003a070:	5d                   	pop    %ebp
4003a071:	c3                   	ret    

4003a072 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
4003a072:	55                   	push   %ebp
4003a073:	89 e5                	mov    %esp,%ebp
4003a075:	53                   	push   %ebx
	__asm__ volatile (
4003a076:	9c                   	pushf  
4003a077:	fa                   	cli    
4003a078:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
4003a079:	8b 48 08             	mov    0x8(%eax),%ecx
4003a07c:	85 c9                	test   %ecx,%ecx
4003a07e:	74 08                	je     4003a088 <k_sem_take+0x16>
		sem->count--;
4003a080:	49                   	dec    %ecx
4003a081:	89 48 08             	mov    %ecx,0x8(%eax)
		irq_unlock(key);
		return 0;
4003a084:	31 c0                	xor    %eax,%eax
4003a086:	eb 09                	jmp    4003a091 <k_sem_take+0x1f>
	}

	if (timeout == K_NO_WAIT) {
4003a088:	85 d2                	test   %edx,%edx
4003a08a:	75 0e                	jne    4003a09a <k_sem_take+0x28>
		irq_unlock(key);
		return -EBUSY;
4003a08c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
4003a091:	0f ba e3 09          	bt     $0x9,%ebx
4003a095:	73 11                	jae    4003a0a8 <k_sem_take+0x36>
	__asm__ volatile (
4003a097:	fb                   	sti    
4003a098:	eb 0e                	jmp    4003a0a8 <k_sem_take+0x36>
	}

	_pend_current_thread(&sem->wait_q, timeout);
4003a09a:	e8 c0 fd ff ff       	call   40039e5f <_pend_current_thread>

	return _Swap(key);
4003a09f:	89 d8                	mov    %ebx,%eax
}
4003a0a1:	5b                   	pop    %ebx
4003a0a2:	5d                   	pop    %ebp
	return _Swap(key);
4003a0a3:	e9 8e f7 ff ff       	jmp    40039836 <_Swap>
}
4003a0a8:	5b                   	pop    %ebx
4003a0a9:	5d                   	pop    %ebp
4003a0aa:	c3                   	ret    

4003a0ab <k_uptime_get_32>:
	return (uint32_t)_sys_clock_tick_count;
}
FUNC_ALIAS(_tick_get_32, sys_tick_get_32, uint32_t);

uint32_t k_uptime_get_32(void)
{
4003a0ab:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
4003a0ac:	b8 0a 00 00 00       	mov    $0xa,%eax
4003a0b1:	89 e5                	mov    %esp,%ebp
	return __ticks_to_ms(_tick_get_32());
}
4003a0b3:	5d                   	pop    %ebp
4003a0b4:	f7 25 3c 85 00 a8    	mull   0xa800853c
4003a0ba:	c3                   	ret    

4003a0bb <_tick_get>:
 *
 * @return the current system tick count
 *
 */
int64_t _tick_get(void)
{
4003a0bb:	55                   	push   %ebp
4003a0bc:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
4003a0be:	9c                   	pushf  
4003a0bf:	fa                   	cli    
4003a0c0:	59                   	pop    %ecx
	 * so we have to lock the timer interrupt that causes change of
	 * _sys_clock_tick_count
	 */
	unsigned int imask = irq_lock();

	tmp_sys_clock_tick_count = _sys_clock_tick_count;
4003a0c1:	a1 3c 85 00 a8       	mov    0xa800853c,%eax
4003a0c6:	8b 15 40 85 00 a8    	mov    0xa8008540,%edx
4003a0cc:	0f ba e1 09          	bt     $0x9,%ecx
4003a0d0:	73 01                	jae    4003a0d3 <_tick_get+0x18>
	__asm__ volatile (
4003a0d2:	fb                   	sti    
	irq_unlock(imask);
	return tmp_sys_clock_tick_count;
}
4003a0d3:	5d                   	pop    %ebp
4003a0d4:	c3                   	ret    

4003a0d5 <k_uptime_get>:
FUNC_ALIAS(_tick_get, sys_tick_get, int64_t);

int64_t k_uptime_get(void)
{
4003a0d5:	55                   	push   %ebp
4003a0d6:	89 e5                	mov    %esp,%ebp
	return __ticks_to_ms(_tick_get());
4003a0d8:	e8 de ff ff ff       	call   4003a0bb <_tick_get>
}
4003a0dd:	5d                   	pop    %ebp
4003a0de:	6b ca 0a             	imul   $0xa,%edx,%ecx
4003a0e1:	ba 0a 00 00 00       	mov    $0xa,%edx
4003a0e6:	f7 e2                	mul    %edx
4003a0e8:	01 ca                	add    %ecx,%edx
4003a0ea:	c3                   	ret    

4003a0eb <k_uptime_delta>:
{
	return (uint32_t)_nano_tick_delta(reftime);
}

int64_t k_uptime_delta(int64_t *reftime)
{
4003a0eb:	55                   	push   %ebp
4003a0ec:	89 e5                	mov    %esp,%ebp
4003a0ee:	57                   	push   %edi
4003a0ef:	56                   	push   %esi
4003a0f0:	53                   	push   %ebx
4003a0f1:	89 c3                	mov    %eax,%ebx
	int64_t uptime, delta;

	uptime = k_uptime_get();
4003a0f3:	e8 dd ff ff ff       	call   4003a0d5 <k_uptime_get>
	delta = uptime - *reftime;
4003a0f8:	89 c6                	mov    %eax,%esi
4003a0fa:	89 d7                	mov    %edx,%edi
4003a0fc:	2b 33                	sub    (%ebx),%esi
	*reftime = uptime;
4003a0fe:	89 03                	mov    %eax,(%ebx)
	delta = uptime - *reftime;
4003a100:	1b 7b 04             	sbb    0x4(%ebx),%edi

	return delta;
}
4003a103:	89 f0                	mov    %esi,%eax
	*reftime = uptime;
4003a105:	89 53 04             	mov    %edx,0x4(%ebx)
}
4003a108:	5b                   	pop    %ebx
4003a109:	89 fa                	mov    %edi,%edx
4003a10b:	5e                   	pop    %esi
4003a10c:	5f                   	pop    %edi
4003a10d:	5d                   	pop    %ebp
4003a10e:	c3                   	ret    

4003a10f <k_uptime_delta_32>:

uint32_t k_uptime_delta_32(int64_t *reftime)
{
4003a10f:	55                   	push   %ebp
4003a110:	89 e5                	mov    %esp,%ebp
	return (uint32_t)k_uptime_delta(reftime);
4003a112:	e8 d4 ff ff ff       	call   4003a0eb <k_uptime_delta>
}
4003a117:	5d                   	pop    %ebp
4003a118:	c3                   	ret    

4003a119 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
4003a119:	55                   	push   %ebp
4003a11a:	89 e5                	mov    %esp,%ebp
4003a11c:	57                   	push   %edi
4003a11d:	56                   	push   %esi
4003a11e:	53                   	push   %ebx
4003a11f:	83 ec 08             	sub    $0x8,%esp
4003a122:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
4003a124:	9c                   	pushf  
4003a125:	fa                   	cli    
4003a126:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
4003a127:	89 df                	mov    %ebx,%edi
4003a129:	c1 ff 1f             	sar    $0x1f,%edi
4003a12c:	01 1d 3c 85 00 a8    	add    %ebx,0xa800853c
4003a132:	11 3d 40 85 00 a8    	adc    %edi,0xa8008540
4003a138:	0f ba e0 09          	bt     $0x9,%eax
4003a13c:	73 01                	jae    4003a13f <_nano_sys_clock_tick_announce+0x26>
	__asm__ volatile (
4003a13e:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
4003a13f:	8d 4d ec             	lea    -0x14(%ebp),%ecx
4003a142:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
4003a145:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
4003a148:	9c                   	pushf  
4003a149:	fa                   	cli    
4003a14a:	5e                   	pop    %esi
	return list->head == list;
4003a14b:	a1 2c 80 00 a8       	mov    0xa800802c,%eax
4003a150:	89 f2                	mov    %esi,%edx
	if (!head) {
4003a152:	85 c0                	test   %eax,%eax
4003a154:	74 07                	je     4003a15d <_nano_sys_clock_tick_announce+0x44>
4003a156:	3d 2c 80 00 a8       	cmp    $0xa800802c,%eax
4003a15b:	75 10                	jne    4003a16d <_nano_sys_clock_tick_announce+0x54>
4003a15d:	0f ba e6 09          	bt     $0x9,%esi
4003a161:	0f 83 07 01 00 00    	jae    4003a26e <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
4003a167:	fb                   	sti    
4003a168:	e9 01 01 00 00       	jmp    4003a26e <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
4003a16d:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
4003a170:	c7 05 34 85 00 a8 01 	movl   $0x1,0xa8008534
4003a177:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
4003a17a:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
4003a17e:	75 3e                	jne    4003a1be <_nano_sys_clock_tick_announce+0xa5>
	node->prev->next = node->next;
4003a180:	8b 70 04             	mov    0x4(%eax),%esi
4003a183:	8b 38                	mov    (%eax),%edi
4003a185:	0f ba e2 09          	bt     $0x9,%edx
4003a189:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
4003a18b:	8b 38                	mov    (%eax),%edi
4003a18d:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
4003a190:	8b 75 ec             	mov    -0x14(%ebp),%esi
4003a193:	89 30                	mov    %esi,(%eax)
	node->prev = list;
4003a195:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
4003a198:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
4003a19b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
4003a19e:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
4003a1a1:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
4003a1a8:	73 01                	jae    4003a1ab <_nano_sys_clock_tick_announce+0x92>
4003a1aa:	fb                   	sti    
	__asm__ volatile (
4003a1ab:	9c                   	pushf  
4003a1ac:	fa                   	cli    
4003a1ad:	5a                   	pop    %edx
	return list->head == list;
4003a1ae:	a1 2c 80 00 a8       	mov    0xa800802c,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003a1b3:	3d 2c 80 00 a8       	cmp    $0xa800802c,%eax
4003a1b8:	74 04                	je     4003a1be <_nano_sys_clock_tick_announce+0xa5>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
4003a1ba:	85 c0                	test   %eax,%eax
4003a1bc:	75 bc                	jne    4003a17a <_nano_sys_clock_tick_announce+0x61>
4003a1be:	0f ba e2 09          	bt     $0x9,%edx
4003a1c2:	73 01                	jae    4003a1c5 <_nano_sys_clock_tick_announce+0xac>
	__asm__ volatile (
4003a1c4:	fb                   	sti    
	return list->head == list;
4003a1c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
4003a1c8:	39 ca                	cmp    %ecx,%edx
4003a1ca:	74 04                	je     4003a1d0 <_nano_sys_clock_tick_announce+0xb7>
4003a1cc:	85 d2                	test   %edx,%edx
4003a1ce:	75 0f                	jne    4003a1df <_nano_sys_clock_tick_announce+0xc6>
	_handling_timeouts = 0;
4003a1d0:	c7 05 34 85 00 a8 00 	movl   $0x0,0xa8008534
4003a1d7:	00 00 00 
4003a1da:	e9 8f 00 00 00       	jmp    4003a26e <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
4003a1df:	31 f6                	xor    %esi,%esi
4003a1e1:	3b 55 f0             	cmp    -0x10(%ebp),%edx
4003a1e4:	74 4d                	je     4003a233 <_nano_sys_clock_tick_announce+0x11a>
4003a1e6:	8b 32                	mov    (%edx),%esi
4003a1e8:	eb 49                	jmp    4003a233 <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
4003a1ea:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
4003a1ee:	74 17                	je     4003a207 <_nano_sys_clock_tick_announce+0xee>
	node->prev->next = node->next;
4003a1f0:	8b 50 04             	mov    0x4(%eax),%edx
4003a1f3:	8b 08                	mov    (%eax),%ecx
4003a1f5:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003a1f7:	8b 08                	mov    (%eax),%ecx
4003a1f9:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
4003a1fc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003a203:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a207:	8a 50 09             	mov    0x9(%eax),%dl
4003a20a:	88 d1                	mov    %dl,%cl
4003a20c:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
4003a20f:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a212:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
4003a215:	74 3b                	je     4003a252 <_nano_sys_clock_tick_announce+0x139>
4003a217:	0f ba e7 09          	bt     $0x9,%edi
4003a21b:	73 01                	jae    4003a21e <_nano_sys_clock_tick_announce+0x105>
4003a21d:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
4003a21e:	85 f6                	test   %esi,%esi
4003a220:	74 ae                	je     4003a1d0 <_nano_sys_clock_tick_announce+0xb7>
	return (node == list->tail) ? NULL : node->next;
4003a222:	31 c0                	xor    %eax,%eax
4003a224:	39 75 f0             	cmp    %esi,-0x10(%ebp)
4003a227:	74 02                	je     4003a22b <_nano_sys_clock_tick_announce+0x112>
4003a229:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
4003a22b:	85 f6                	test   %esi,%esi
4003a22d:	74 a1                	je     4003a1d0 <_nano_sys_clock_tick_announce+0xb7>
4003a22f:	89 f2                	mov    %esi,%edx
4003a231:	89 c6                	mov    %eax,%esi
	node->prev->next = node->next;
4003a233:	8b 42 04             	mov    0x4(%edx),%eax
4003a236:	8b 0a                	mov    (%edx),%ecx
4003a238:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
4003a23a:	8b 0a                	mov    (%edx),%ecx
4003a23c:	89 41 04             	mov    %eax,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
4003a23f:	8b 42 08             	mov    0x8(%edx),%eax
	__asm__ volatile (
4003a242:	9c                   	pushf  
4003a243:	fa                   	cli    
4003a244:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
4003a245:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
4003a24c:	85 c0                	test   %eax,%eax
4003a24e:	75 9a                	jne    4003a1ea <_nano_sys_clock_tick_announce+0xd1>
4003a250:	eb 08                	jmp    4003a25a <_nano_sys_clock_tick_announce+0x141>
4003a252:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003a256:	75 bf                	jne    4003a217 <_nano_sys_clock_tick_announce+0xfe>
4003a258:	eb 64                	jmp    4003a2be <_nano_sys_clock_tick_announce+0x1a5>
4003a25a:	0f ba e7 09          	bt     $0x9,%edi
4003a25e:	73 01                	jae    4003a261 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
4003a260:	fb                   	sti    
		if (timeout->func) {
4003a261:	8b 4a 14             	mov    0x14(%edx),%ecx
4003a264:	85 c9                	test   %ecx,%ecx
4003a266:	74 b6                	je     4003a21e <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
4003a268:	89 d0                	mov    %edx,%eax
4003a26a:	ff d1                	call   *%ecx
4003a26c:	eb b0                	jmp    4003a21e <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
4003a26e:	a1 40 81 00 a8       	mov    0xa8008140,%eax
4003a273:	85 c0                	test   %eax,%eax
4003a275:	74 51                	je     4003a2c8 <_nano_sys_clock_tick_announce+0x1af>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
4003a277:	8b 15 28 80 00 a8    	mov    0xa8008028,%edx
4003a27d:	0f be 52 0a          	movsbl 0xa(%edx),%edx
4003a281:	39 15 3c 81 00 a8    	cmp    %edx,0xa800813c
4003a287:	7f 3f                	jg     4003a2c8 <_nano_sys_clock_tick_announce+0x1af>
4003a289:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
4003a28c:	03 1d 38 85 00 a8    	add    0xa8008538,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
4003a292:	39 d8                	cmp    %ebx,%eax
4003a294:	7e 08                	jle    4003a29e <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
4003a296:	89 1d 38 85 00 a8    	mov    %ebx,0xa8008538
4003a29c:	eb 2a                	jmp    4003a2c8 <_nano_sys_clock_tick_announce+0x1af>
		_time_slice_elapsed = 0;
4003a29e:	c7 05 38 85 00 a8 00 	movl   $0x0,0xa8008538
4003a2a5:	00 00 00 
	__asm__ volatile (
4003a2a8:	9c                   	pushf  
4003a2a9:	fa                   	cli    
4003a2aa:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
4003a2ab:	a1 28 80 00 a8       	mov    0xa8008028,%eax
4003a2b0:	e8 2b fc ff ff       	call   40039ee0 <_move_thread_to_end_of_prio_q>
4003a2b5:	0f ba e3 09          	bt     $0x9,%ebx
4003a2b9:	73 0d                	jae    4003a2c8 <_nano_sys_clock_tick_announce+0x1af>
	__asm__ volatile (
4003a2bb:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
4003a2bc:	eb 0a                	jmp    4003a2c8 <_nano_sys_clock_tick_announce+0x1af>
		_add_thread_to_ready_q(thread);
4003a2be:	e8 68 fa ff ff       	call   40039d2b <_add_thread_to_ready_q>
4003a2c3:	e9 4f ff ff ff       	jmp    4003a217 <_nano_sys_clock_tick_announce+0xfe>
4003a2c8:	58                   	pop    %eax
4003a2c9:	5a                   	pop    %edx
4003a2ca:	5b                   	pop    %ebx
4003a2cb:	5e                   	pop    %esi
4003a2cc:	5f                   	pop    %edi
4003a2cd:	5d                   	pop    %ebp
4003a2ce:	c3                   	ret    

4003a2cf <_is_thread_ready>:
{
4003a2cf:	55                   	push   %ebp
4003a2d0:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
4003a2d2:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
4003a2d6:	75 09                	jne    4003a2e1 <_is_thread_ready+0x12>
4003a2d8:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003a2dc:	0f 94 c0             	sete   %al
4003a2df:	eb 02                	jmp    4003a2e3 <_is_thread_ready+0x14>
4003a2e1:	31 c0                	xor    %eax,%eax
4003a2e3:	0f b6 c0             	movzbl %al,%eax
}
4003a2e6:	5d                   	pop    %ebp
4003a2e7:	c3                   	ret    

4003a2e8 <_abort_timeout>:
{
4003a2e8:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
4003a2e9:	8b 48 10             	mov    0x10(%eax),%ecx
{
4003a2ec:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
4003a2ee:	83 f9 ff             	cmp    $0xffffffff,%ecx
4003a2f1:	74 24                	je     4003a317 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
4003a2f3:	3b 05 30 80 00 a8    	cmp    0xa8008030,%eax
4003a2f9:	74 05                	je     4003a300 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
4003a2fb:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
4003a2fd:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
4003a300:	8b 50 04             	mov    0x4(%eax),%edx
4003a303:	8b 08                	mov    (%eax),%ecx
4003a305:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003a307:	8b 08                	mov    (%eax),%ecx
4003a309:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
4003a30c:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
4003a313:	31 c0                	xor    %eax,%eax
4003a315:	eb 03                	jmp    4003a31a <_abort_timeout+0x32>
		return _INACTIVE;
4003a317:	83 c8 ff             	or     $0xffffffff,%eax
}
4003a31a:	5d                   	pop    %ebp
4003a31b:	c3                   	ret    

4003a31c <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
4003a31c:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
4003a31d:	85 d2                	test   %edx,%edx
{
4003a31f:	89 e5                	mov    %esp,%ebp
4003a321:	57                   	push   %edi
4003a322:	56                   	push   %esi
4003a323:	53                   	push   %ebx
4003a324:	51                   	push   %ecx
4003a325:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
4003a327:	75 41                	jne    4003a36a <schedule_new_thread+0x4e>
	__asm__ volatile (
4003a329:	9c                   	pushf  
4003a32a:	fa                   	cli    
4003a32b:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a32c:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
4003a330:	e8 9a ff ff ff       	call   4003a2cf <_is_thread_ready>
4003a335:	85 c0                	test   %eax,%eax
4003a337:	75 09                	jne    4003a342 <schedule_new_thread+0x26>
4003a339:	0f ba e3 09          	bt     $0x9,%ebx
4003a33d:	e9 b1 00 00 00       	jmp    4003a3f3 <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
4003a342:	89 c8                	mov    %ecx,%eax
4003a344:	e8 e2 f9 ff ff       	call   40039d2b <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
4003a349:	a1 28 80 00 a8       	mov    0xa8008028,%eax
4003a34e:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
4003a353:	77 e4                	ja     4003a339 <schedule_new_thread+0x1d>
4003a355:	e8 29 fb ff ff       	call   40039e83 <__must_switch_threads>
4003a35a:	85 c0                	test   %eax,%eax
4003a35c:	74 db                	je     4003a339 <schedule_new_thread+0x1d>
			_Swap(key);
4003a35e:	89 d8                	mov    %ebx,%eax
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
4003a360:	5a                   	pop    %edx
4003a361:	5b                   	pop    %ebx
4003a362:	5e                   	pop    %esi
4003a363:	5f                   	pop    %edi
4003a364:	5d                   	pop    %ebp
			_Swap(key);
4003a365:	e9 cc f4 ff ff       	jmp    40039836 <_Swap>
4003a36a:	9c                   	pushf  
4003a36b:	fa                   	cli    
4003a36c:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
4003a36f:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
4003a374:	8d 58 10             	lea    0x10(%eax),%ebx
4003a377:	8d 42 09             	lea    0x9(%edx),%eax
4003a37a:	31 d2                	xor    %edx,%edx
4003a37c:	f7 f6                	div    %esi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
4003a37e:	40                   	inc    %eax
	timeout->thread = thread;
4003a37f:	89 49 18             	mov    %ecx,0x18(%ecx)
4003a382:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
4003a385:	a1 2c 80 00 a8       	mov    0xa800802c,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003a38a:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003a391:	85 c0                	test   %eax,%eax
4003a393:	74 0d                	je     4003a3a2 <schedule_new_thread+0x86>
4003a395:	8b 3d 30 80 00 a8    	mov    0xa8008030,%edi
4003a39b:	3d 2c 80 00 a8       	cmp    $0xa800802c,%eax
4003a3a0:	75 19                	jne    4003a3bb <schedule_new_thread+0x9f>
	node->next = list;
4003a3a2:	c7 41 10 2c 80 00 a8 	movl   $0xa800802c,0x10(%ecx)
	node->prev = list->tail;
4003a3a9:	a1 30 80 00 a8       	mov    0xa8008030,%eax
4003a3ae:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
4003a3b1:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
4003a3b3:	89 1d 30 80 00 a8    	mov    %ebx,0xa8008030
4003a3b9:	eb 31                	jmp    4003a3ec <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
4003a3bb:	8b 51 20             	mov    0x20(%ecx),%edx
4003a3be:	8b 70 10             	mov    0x10(%eax),%esi
4003a3c1:	39 f2                	cmp    %esi,%edx
4003a3c3:	7f 18                	jg     4003a3dd <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
4003a3c5:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
4003a3c7:	8b 50 04             	mov    0x4(%eax),%edx
4003a3ca:	89 70 10             	mov    %esi,0x10(%eax)
4003a3cd:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
4003a3d0:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
4003a3d3:	8b 50 04             	mov    0x4(%eax),%edx
4003a3d6:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
4003a3d8:	89 58 04             	mov    %ebx,0x4(%eax)
4003a3db:	eb 0f                	jmp    4003a3ec <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
4003a3dd:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
4003a3df:	39 f8                	cmp    %edi,%eax
4003a3e1:	89 51 20             	mov    %edx,0x20(%ecx)
4003a3e4:	74 bc                	je     4003a3a2 <schedule_new_thread+0x86>
4003a3e6:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003a3e8:	85 c0                	test   %eax,%eax
4003a3ea:	eb b4                	jmp    4003a3a0 <schedule_new_thread+0x84>
4003a3ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003a3ef:	0f ba e0 09          	bt     $0x9,%eax
4003a3f3:	73 01                	jae    4003a3f6 <schedule_new_thread+0xda>
	__asm__ volatile (
4003a3f5:	fb                   	sti    
}
4003a3f6:	58                   	pop    %eax
4003a3f7:	5b                   	pop    %ebx
4003a3f8:	5e                   	pop    %esi
4003a3f9:	5f                   	pop    %edi
4003a3fa:	5d                   	pop    %ebp
4003a3fb:	c3                   	ret    

4003a3fc <k_is_in_isr>:
{
4003a3fc:	55                   	push   %ebp
	return _is_in_isr();
4003a3fd:	31 c0                	xor    %eax,%eax
{
4003a3ff:	89 e5                	mov    %esp,%ebp
}
4003a401:	5d                   	pop    %ebp
	return _is_in_isr();
4003a402:	83 3d 20 80 00 a8 00 	cmpl   $0x0,0xa8008020
4003a409:	0f 95 c0             	setne  %al
}
4003a40c:	c3                   	ret    

4003a40d <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
4003a40d:	a1 28 80 00 a8       	mov    0xa8008028,%eax
{
4003a412:	55                   	push   %ebp
4003a413:	89 e5                	mov    %esp,%ebp
}
4003a415:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
4003a416:	8a 40 08             	mov    0x8(%eax),%al
4003a419:	83 e0 01             	and    $0x1,%eax
}
4003a41c:	c3                   	ret    

4003a41d <k_busy_wait>:
		(uint64_t)usec_to_wait *
4003a41d:	ba 00 48 e8 01       	mov    $0x1e84800,%edx
{
4003a422:	55                   	push   %ebp
		(uint64_t)usec_to_wait *
4003a423:	f7 e2                	mul    %edx
{
4003a425:	89 e5                	mov    %esp,%ebp
4003a427:	56                   	push   %esi
4003a428:	53                   	push   %ebx
		(uint64_t)sys_clock_hw_cycles_per_sec /
4003a429:	6a 00                	push   $0x0
4003a42b:	68 40 42 0f 00       	push   $0xf4240
4003a430:	e8 66 5c ff ff       	call   4003009b <__udivdi3>
4003a435:	5a                   	pop    %edx
4003a436:	89 c3                	mov    %eax,%ebx
4003a438:	59                   	pop    %ecx
	uint32_t start_cycles = k_cycle_get_32();
4003a439:	e8 bb 7a ff ff       	call   40031ef9 <_timer_cycle_get_32>
4003a43e:	89 c6                	mov    %eax,%esi
		uint32_t current_cycles = k_cycle_get_32();
4003a440:	e8 b4 7a ff ff       	call   40031ef9 <_timer_cycle_get_32>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
4003a445:	29 f0                	sub    %esi,%eax
4003a447:	39 c3                	cmp    %eax,%ebx
4003a449:	77 f5                	ja     4003a440 <k_busy_wait+0x23>
}
4003a44b:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003a44e:	5b                   	pop    %ebx
4003a44f:	5e                   	pop    %esi
4003a450:	5d                   	pop    %ebp
4003a451:	c3                   	ret    

4003a452 <_thread_entry>:
{
4003a452:	55                   	push   %ebp
4003a453:	89 e5                	mov    %esp,%ebp
4003a455:	53                   	push   %ebx
4003a456:	89 c3                	mov    %eax,%ebx
4003a458:	89 d0                	mov    %edx,%eax
4003a45a:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
4003a45c:	8b 4d 08             	mov    0x8(%ebp),%ecx
4003a45f:	ff d3                	call   *%ebx
	if (_is_thread_essential()) {
4003a461:	e8 a7 ff ff ff       	call   4003a40d <_is_thread_essential>
4003a466:	85 c0                	test   %eax,%eax
4003a468:	74 0f                	je     4003a479 <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
4003a46a:	ba c0 d1 03 40       	mov    $0x4003d1c0,%edx
4003a46f:	b8 03 00 00 00       	mov    $0x3,%eax
4003a474:	e8 58 f4 ff ff       	call   400398d1 <_NanoFatalErrorHandler>
	k_thread_abort(_current);
4003a479:	a1 28 80 00 a8       	mov    0xa8008028,%eax
4003a47e:	e8 fa 00 00 00       	call   4003a57d <k_thread_abort>

4003a483 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
4003a483:	55                   	push   %ebp
4003a484:	89 e5                	mov    %esp,%ebp
4003a486:	53                   	push   %ebx
4003a487:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
4003a489:	8b 40 30             	mov    0x30(%eax),%eax
4003a48c:	85 c0                	test   %eax,%eax
4003a48e:	74 02                	je     4003a492 <_k_thread_single_abort+0xf>
		thread->fn_abort();
4003a490:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
4003a492:	89 d8                	mov    %ebx,%eax
4003a494:	e8 36 fe ff ff       	call   4003a2cf <_is_thread_ready>
4003a499:	85 c0                	test   %eax,%eax
4003a49b:	74 09                	je     4003a4a6 <_k_thread_single_abort+0x23>
		_remove_thread_from_ready_q(thread);
4003a49d:	89 d8                	mov    %ebx,%eax
4003a49f:	e8 e5 f8 ff ff       	call   40039d89 <_remove_thread_from_ready_q>
4003a4a4:	eb 24                	jmp    4003a4ca <_k_thread_single_abort+0x47>
	} else {
		if (_is_thread_pending(thread)) {
4003a4a6:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
4003a4aa:	74 10                	je     4003a4bc <_k_thread_single_abort+0x39>
	node->prev->next = node->next;
4003a4ac:	8b 43 04             	mov    0x4(%ebx),%eax
4003a4af:	8b 13                	mov    (%ebx),%edx
4003a4b1:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
4003a4b3:	8b 13                	mov    (%ebx),%edx
4003a4b5:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003a4b8:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
4003a4bc:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
4003a4c0:	74 08                	je     4003a4ca <_k_thread_single_abort+0x47>
	return _abort_timeout(&thread->base.timeout);
4003a4c2:	8d 43 10             	lea    0x10(%ebx),%eax
4003a4c5:	e8 1e fe ff ff       	call   4003a2e8 <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
4003a4ca:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
4003a4ce:	5b                   	pop    %ebx
4003a4cf:	5d                   	pop    %ebp
4003a4d0:	c3                   	ret    

4003a4d1 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
4003a4d1:	55                   	push   %ebp
4003a4d2:	89 e5                	mov    %esp,%ebp
4003a4d4:	56                   	push   %esi
4003a4d5:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
4003a4d6:	bb 00 68 00 a8       	mov    $0xa8006800,%ebx
4003a4db:	81 fb 00 68 00 a8    	cmp    $0xa8006800,%ebx
4003a4e1:	73 29                	jae    4003a50c <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
4003a4e3:	ff 73 1c             	pushl  0x1c(%ebx)
4003a4e6:	ff 73 18             	pushl  0x18(%ebx)
4003a4e9:	ff 73 14             	pushl  0x14(%ebx)
4003a4ec:	ff 73 10             	pushl  0x10(%ebx)
4003a4ef:	ff 73 0c             	pushl  0xc(%ebx)
4003a4f2:	8b 03                	mov    (%ebx),%eax
4003a4f4:	8b 4b 08             	mov    0x8(%ebx),%ecx
4003a4f7:	8b 53 04             	mov    0x4(%ebx),%edx
4003a4fa:	e8 6b f3 ff ff       	call   4003986a <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
4003a4ff:	8b 03                	mov    (%ebx),%eax
		_new_thread(
4003a501:	83 c4 14             	add    $0x14,%esp
		thread_data->thread->init_data = thread_data;
4003a504:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
4003a507:	83 c3 2c             	add    $0x2c,%ebx
4003a50a:	eb cf                	jmp    4003a4db <_init_static_threads+0xa>
	--_current->base.sched_locked;
4003a50c:	a1 28 80 00 a8       	mov    0xa8008028,%eax
4003a511:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
4003a514:	9c                   	pushf  
4003a515:	fa                   	cli    
4003a516:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
4003a517:	bb 00 68 00 a8       	mov    $0xa8006800,%ebx
4003a51c:	81 fb 00 68 00 a8    	cmp    $0xa8006800,%ebx
4003a522:	73 14                	jae    4003a538 <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
4003a524:	8b 53 20             	mov    0x20(%ebx),%edx
4003a527:	83 fa ff             	cmp    $0xffffffff,%edx
4003a52a:	74 07                	je     4003a533 <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
4003a52c:	8b 03                	mov    (%ebx),%eax
4003a52e:	e8 e9 fd ff ff       	call   4003a31c <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
4003a533:	83 c3 2c             	add    $0x2c,%ebx
4003a536:	eb e4                	jmp    4003a51c <_init_static_threads+0x4b>
4003a538:	0f ba e6 09          	bt     $0x9,%esi
4003a53c:	73 01                	jae    4003a53f <_init_static_threads+0x6e>
	__asm__ volatile (
4003a53e:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
4003a53f:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003a542:	5b                   	pop    %ebx
4003a543:	5e                   	pop    %esi
4003a544:	5d                   	pop    %ebp
	k_sched_unlock();
4003a545:	e9 81 f9 ff ff       	jmp    40039ecb <k_sched_unlock>

4003a54a <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
4003a54a:	55                   	push   %ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;
4003a54b:	88 48 09             	mov    %cl,0x9(%eax)
{
4003a54e:	89 e5                	mov    %esp,%ebp
4003a550:	53                   	push   %ebx

	thread_base->prio = priority;
4003a551:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
4003a554:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	thread_base->user_options = (uint8_t)options;
4003a558:	8a 5d 08             	mov    0x8(%ebp),%bl
	t->delta_ticks_from_prev = _INACTIVE;
4003a55b:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
4003a562:	88 58 08             	mov    %bl,0x8(%eax)
	t->wait_q = NULL;
4003a565:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
4003a56c:	5b                   	pop    %ebx
	t->thread = NULL;
4003a56d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
4003a574:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
4003a57b:	5d                   	pop    %ebp
4003a57c:	c3                   	ret    

4003a57d <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
4003a57d:	55                   	push   %ebp
4003a57e:	89 e5                	mov    %esp,%ebp
4003a580:	56                   	push   %esi
4003a581:	89 c6                	mov    %eax,%esi
4003a583:	53                   	push   %ebx
	__asm__ volatile (
4003a584:	9c                   	pushf  
4003a585:	fa                   	cli    
4003a586:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
4003a587:	e8 f7 fe ff ff       	call   4003a483 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
		_Swap(key);
4003a58c:	89 d8                	mov    %ebx,%eax
	if (_current == thread) {
4003a58e:	3b 35 28 80 00 a8    	cmp    0xa8008028,%esi
4003a594:	75 05                	jne    4003a59b <k_thread_abort+0x1e>
		_Swap(key);
4003a596:	e8 9b f2 ff ff       	call   40039836 <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
}
4003a59b:	5b                   	pop    %ebx
4003a59c:	5e                   	pop    %esi
4003a59d:	5d                   	pop    %ebp
	_reschedule_threads(key);
4003a59e:	e9 fb f8 ff ff       	jmp    40039e9e <_reschedule_threads>

4003a5a3 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a5a3:	8a 50 09             	mov    0x9(%eax),%dl
{
4003a5a6:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a5a7:	88 d1                	mov    %dl,%cl
{
4003a5a9:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a5ab:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
4003a5ae:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003a5b1:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
4003a5b4:	75 0c                	jne    4003a5c2 <_ready_thread+0x1f>
4003a5b6:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003a5ba:	75 06                	jne    4003a5c2 <_ready_thread+0x1f>
}
4003a5bc:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
4003a5bd:	e9 69 f7 ff ff       	jmp    40039d2b <_add_thread_to_ready_q>
}
4003a5c2:	5d                   	pop    %ebp
4003a5c3:	c3                   	ret    

4003a5c4 <_abort_timeout>:
{
4003a5c4:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
4003a5c5:	8b 48 10             	mov    0x10(%eax),%ecx
{
4003a5c8:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
4003a5ca:	83 f9 ff             	cmp    $0xffffffff,%ecx
4003a5cd:	74 24                	je     4003a5f3 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
4003a5cf:	3b 05 30 80 00 a8    	cmp    0xa8008030,%eax
4003a5d5:	74 05                	je     4003a5dc <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
4003a5d7:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
4003a5d9:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
4003a5dc:	8b 50 04             	mov    0x4(%eax),%edx
4003a5df:	8b 08                	mov    (%eax),%ecx
4003a5e1:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003a5e3:	8b 08                	mov    (%eax),%ecx
4003a5e5:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
4003a5e8:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
4003a5ef:	31 c0                	xor    %eax,%eax
4003a5f1:	eb 03                	jmp    4003a5f6 <_abort_timeout+0x32>
		return _INACTIVE;
4003a5f3:	83 c8 ff             	or     $0xffffffff,%eax
}
4003a5f6:	5d                   	pop    %ebp
4003a5f7:	c3                   	ret    

4003a5f8 <_add_timeout.constprop.7>:
	timeout->thread = thread;
4003a5f8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003a5ff:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003a602:	55                   	push   %ebp
	return list->head == list;
4003a603:	8b 15 2c 80 00 a8    	mov    0xa800802c,%edx
4003a609:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
4003a60b:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003a60e:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003a60f:	85 d2                	test   %edx,%edx
4003a611:	74 08                	je     4003a61b <_add_timeout.constprop.7+0x23>
4003a613:	81 fa 2c 80 00 a8    	cmp    $0xa800802c,%edx
4003a619:	75 1e                	jne    4003a639 <_add_timeout.constprop.7+0x41>
	node->next = list;
4003a61b:	c7 00 2c 80 00 a8    	movl   $0xa800802c,(%eax)
	node->prev = list->tail;
4003a621:	8b 15 30 80 00 a8    	mov    0xa8008030,%edx
4003a627:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
4003a62a:	8b 15 30 80 00 a8    	mov    0xa8008030,%edx
4003a630:	89 02                	mov    %eax,(%edx)
	list->tail = node;
4003a632:	a3 30 80 00 a8       	mov    %eax,0xa8008030
4003a637:	eb 34                	jmp    4003a66d <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
4003a639:	8b 48 10             	mov    0x10(%eax),%ecx
4003a63c:	8b 5a 10             	mov    0x10(%edx),%ebx
4003a63f:	39 d9                	cmp    %ebx,%ecx
4003a641:	7f 17                	jg     4003a65a <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
4003a643:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
4003a645:	8b 4a 04             	mov    0x4(%edx),%ecx
4003a648:	89 5a 10             	mov    %ebx,0x10(%edx)
4003a64b:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
4003a64e:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
4003a650:	8b 4a 04             	mov    0x4(%edx),%ecx
4003a653:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
4003a655:	89 42 04             	mov    %eax,0x4(%edx)
4003a658:	eb 13                	jmp    4003a66d <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
4003a65a:	29 d9                	sub    %ebx,%ecx
4003a65c:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
4003a65f:	3b 15 30 80 00 a8    	cmp    0xa8008030,%edx
4003a665:	74 b4                	je     4003a61b <_add_timeout.constprop.7+0x23>
4003a667:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003a669:	85 d2                	test   %edx,%edx
4003a66b:	eb ac                	jmp    4003a619 <_add_timeout.constprop.7+0x21>
}
4003a66d:	5b                   	pop    %ebx
4003a66e:	5d                   	pop    %ebp
4003a66f:	c3                   	ret    

4003a670 <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
4003a670:	55                   	push   %ebp
4003a671:	89 e5                	mov    %esp,%ebp
4003a673:	56                   	push   %esi
4003a674:	53                   	push   %ebx
4003a675:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
4003a677:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
4003a67b:	7e 15                	jle    4003a692 <_timer_expiration_handler+0x22>
4003a67d:	9c                   	pushf  
4003a67e:	fa                   	cli    
4003a67f:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
4003a680:	8b 48 28             	mov    0x28(%eax),%ecx
4003a683:	8d 50 18             	lea    0x18(%eax),%edx
4003a686:	e8 6d ff ff ff       	call   4003a5f8 <_add_timeout.constprop.7>
4003a68b:	0f ba e6 09          	bt     $0x9,%esi
4003a68f:	73 01                	jae    4003a692 <_timer_expiration_handler+0x22>
	__asm__ volatile (
4003a691:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
4003a692:	8b 53 20             	mov    0x20(%ebx),%edx
	timer->status += 1;
4003a695:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
4003a698:	85 d2                	test   %edx,%edx
4003a69a:	74 04                	je     4003a6a0 <_timer_expiration_handler+0x30>
		timer->expiry_fn(timer);
4003a69c:	89 d8                	mov    %ebx,%eax
4003a69e:	ff d2                	call   *%edx
	return list->head == list;
4003a6a0:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
4003a6a3:	85 f6                	test   %esi,%esi
4003a6a5:	74 31                	je     4003a6d8 <_timer_expiration_handler+0x68>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
4003a6a7:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
4003a6aa:	39 de                	cmp    %ebx,%esi
4003a6ac:	74 2a                	je     4003a6d8 <_timer_expiration_handler+0x68>
	node->prev->next = node->next;
4003a6ae:	8b 46 04             	mov    0x4(%esi),%eax
4003a6b1:	8b 16                	mov    (%esi),%edx
4003a6b3:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
4003a6b5:	8b 16                	mov    (%esi),%edx
4003a6b7:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003a6ba:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
4003a6be:	9c                   	pushf  
4003a6bf:	fa                   	cli    
4003a6c0:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
4003a6c1:	89 f0                	mov    %esi,%eax
4003a6c3:	e8 db fe ff ff       	call   4003a5a3 <_ready_thread>
4003a6c8:	0f ba e3 09          	bt     $0x9,%ebx
4003a6cc:	73 01                	jae    4003a6cf <_timer_expiration_handler+0x5f>
	__asm__ volatile (
4003a6ce:	fb                   	sti    
4003a6cf:	8b 46 28             	mov    0x28(%esi),%eax
4003a6d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
4003a6d8:	5b                   	pop    %ebx
4003a6d9:	5e                   	pop    %esi
4003a6da:	5d                   	pop    %ebp
4003a6db:	c3                   	ret    

4003a6dc <k_timer_init>:


void k_timer_init(struct k_timer *timer,
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
4003a6dc:	55                   	push   %ebp
	timer->expiry_fn = expiry_fn;
4003a6dd:	89 50 20             	mov    %edx,0x20(%eax)
	timer->stop_fn = stop_fn;
	timer->status = 0;

	sys_dlist_init(&timer->wait_q);
4003a6e0:	8d 50 18             	lea    0x18(%eax),%edx
{
4003a6e3:	89 e5                	mov    %esp,%ebp
	timer->stop_fn = stop_fn;
4003a6e5:	89 48 24             	mov    %ecx,0x24(%eax)
	timer->status = 0;
4003a6e8:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
	list->head = (sys_dnode_t *)list;
4003a6ef:	89 50 18             	mov    %edx,0x18(%eax)
	list->tail = (sys_dnode_t *)list;
4003a6f2:	89 50 1c             	mov    %edx,0x1c(%eax)
	t->delta_ticks_from_prev = _INACTIVE;
4003a6f5:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	t->wait_q = NULL;
4003a6fc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	t->thread = NULL;
4003a703:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	t->func = func;
4003a70a:	c7 40 14 70 a6 03 40 	movl   $0x4003a670,0x14(%eax)
	_init_timeout(&timer->timeout, _timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = 0;
4003a711:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
}
4003a718:	5d                   	pop    %ebp
4003a719:	c3                   	ret    

4003a71a <k_timer_start>:


void k_timer_start(struct k_timer *timer, int32_t duration, int32_t period)
{
4003a71a:	55                   	push   %ebp
4003a71b:	89 e5                	mov    %esp,%ebp
4003a71d:	57                   	push   %edi
4003a71e:	bf 0a 00 00 00       	mov    $0xa,%edi
4003a723:	56                   	push   %esi
4003a724:	89 c6                	mov    %eax,%esi
4003a726:	53                   	push   %ebx
4003a727:	8d 41 09             	lea    0x9(%ecx),%eax
4003a72a:	89 d3                	mov    %edx,%ebx
4003a72c:	31 d2                	xor    %edx,%edx
4003a72e:	83 ec 08             	sub    $0x8,%esp
4003a731:	f7 f7                	div    %edi
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile int32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = _ms_to_ticks(period);
4003a733:	89 45 ec             	mov    %eax,-0x14(%ebp)
4003a736:	31 d2                	xor    %edx,%edx
4003a738:	8d 43 09             	lea    0x9(%ebx),%eax
4003a73b:	f7 f7                	div    %edi
	duration_in_ticks = _TICK_ALIGN + _ms_to_ticks(duration);
4003a73d:	40                   	inc    %eax
4003a73e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm__ volatile (
4003a741:	9c                   	pushf  
4003a742:	fa                   	cli    
4003a743:	5b                   	pop    %ebx

	unsigned int key = irq_lock();

	if (timer->timeout.delta_ticks_from_prev != _INACTIVE) {
4003a744:	83 7e 10 ff          	cmpl   $0xffffffff,0x10(%esi)
4003a748:	74 07                	je     4003a751 <k_timer_start+0x37>
		_abort_timeout(&timer->timeout);
4003a74a:	89 f0                	mov    %esi,%eax
4003a74c:	e8 73 fe ff ff       	call   4003a5c4 <_abort_timeout>
	}

	timer->period = period_in_ticks;
4003a751:	8b 45 ec             	mov    -0x14(%ebp),%eax
	_add_timeout(NULL, &timer->timeout, &timer->wait_q, duration_in_ticks);
4003a754:	8d 56 18             	lea    0x18(%esi),%edx
	timer->period = period_in_ticks;
4003a757:	89 46 28             	mov    %eax,0x28(%esi)
	_add_timeout(NULL, &timer->timeout, &timer->wait_q, duration_in_ticks);
4003a75a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4003a75d:	89 f0                	mov    %esi,%eax
4003a75f:	e8 94 fe ff ff       	call   4003a5f8 <_add_timeout.constprop.7>
	timer->status = 0;
4003a764:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
4003a76b:	0f ba e3 09          	bt     $0x9,%ebx
4003a76f:	73 01                	jae    4003a772 <k_timer_start+0x58>
	__asm__ volatile (
4003a771:	fb                   	sti    
	irq_unlock(key);
}
4003a772:	58                   	pop    %eax
4003a773:	5a                   	pop    %edx
4003a774:	5b                   	pop    %ebx
4003a775:	5e                   	pop    %esi
4003a776:	5f                   	pop    %edi
4003a777:	5d                   	pop    %ebp
4003a778:	c3                   	ret    

4003a779 <k_timer_stop>:


void k_timer_stop(struct k_timer *timer)
{
4003a779:	55                   	push   %ebp
4003a77a:	89 e5                	mov    %esp,%ebp
4003a77c:	56                   	push   %esi
4003a77d:	53                   	push   %ebx
4003a77e:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
4003a780:	9c                   	pushf  
4003a781:	fa                   	cli    
4003a782:	5e                   	pop    %esi
	int key = irq_lock();
	int inactive = (_abort_timeout(&timer->timeout) == _INACTIVE);
4003a783:	e8 3c fe ff ff       	call   4003a5c4 <_abort_timeout>
4003a788:	0f ba e6 09          	bt     $0x9,%esi
4003a78c:	73 01                	jae    4003a78f <k_timer_stop+0x16>
	__asm__ volatile (
4003a78e:	fb                   	sti    

	irq_unlock(key);

	if (inactive) {
4003a78f:	40                   	inc    %eax
4003a790:	74 71                	je     4003a803 <k_timer_stop+0x8a>
		return;
	}

	if (timer->stop_fn) {
4003a792:	8b 53 24             	mov    0x24(%ebx),%edx
4003a795:	85 d2                	test   %edx,%edx
4003a797:	74 04                	je     4003a79d <k_timer_stop+0x24>
		timer->stop_fn(timer);
4003a799:	89 d8                	mov    %ebx,%eax
4003a79b:	ff d2                	call   *%edx
	__asm__ volatile (
4003a79d:	9c                   	pushf  
4003a79e:	fa                   	cli    
4003a79f:	5e                   	pop    %esi
	if (_handling_timeouts) {
4003a7a0:	a1 34 85 00 a8       	mov    0xa8008534,%eax
	}

	key = irq_lock();
	struct k_thread *pending_thread = _unpend_first_thread(&timer->wait_q);
4003a7a5:	8d 53 18             	lea    0x18(%ebx),%edx
4003a7a8:	85 c0                	test   %eax,%eax
4003a7aa:	8b 43 18             	mov    0x18(%ebx),%eax
4003a7ad:	74 1b                	je     4003a7ca <k_timer_stop+0x51>
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003a7af:	39 c2                	cmp    %eax,%edx
4003a7b1:	75 11                	jne    4003a7c4 <k_timer_stop+0x4b>
4003a7b3:	31 c0                	xor    %eax,%eax
4003a7b5:	eb 0d                	jmp    4003a7c4 <k_timer_stop+0x4b>
			if (_is_thread_timeout_expired(thread)) {
4003a7b7:	83 78 20 fe          	cmpl   $0xfffffffe,0x20(%eax)
4003a7bb:	75 15                	jne    4003a7d2 <k_timer_stop+0x59>
	return (node == list->tail) ? NULL : node->next;
4003a7bd:	3b 43 1c             	cmp    0x1c(%ebx),%eax
4003a7c0:	74 25                	je     4003a7e7 <k_timer_stop+0x6e>
4003a7c2:	8b 00                	mov    (%eax),%eax
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
4003a7c4:	85 c0                	test   %eax,%eax
4003a7c6:	75 ef                	jne    4003a7b7 <k_timer_stop+0x3e>
4003a7c8:	eb 1d                	jmp    4003a7e7 <k_timer_stop+0x6e>
	if (thread) {
4003a7ca:	85 c0                	test   %eax,%eax
4003a7cc:	74 19                	je     4003a7e7 <k_timer_stop+0x6e>
4003a7ce:	39 c2                	cmp    %eax,%edx
4003a7d0:	74 15                	je     4003a7e7 <k_timer_stop+0x6e>
	node->prev->next = node->next;
4003a7d2:	8b 50 04             	mov    0x4(%eax),%edx
4003a7d5:	8b 08                	mov    (%eax),%ecx
4003a7d7:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003a7d9:	8b 08                	mov    (%eax),%ecx
4003a7db:	89 51 04             	mov    %edx,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003a7de:	80 60 09 fd          	andb   $0xfd,0x9(%eax)

	if (pending_thread) {
		_ready_thread(pending_thread);
4003a7e2:	e8 bc fd ff ff       	call   4003a5a3 <_ready_thread>
	}

	if (_is_in_isr()) {
4003a7e7:	83 3d 20 80 00 a8 00 	cmpl   $0x0,0xa8008020
4003a7ee:	74 09                	je     4003a7f9 <k_timer_stop+0x80>
4003a7f0:	0f ba e6 09          	bt     $0x9,%esi
4003a7f4:	73 0d                	jae    4003a803 <k_timer_stop+0x8a>
	__asm__ volatile (
4003a7f6:	fb                   	sti    
4003a7f7:	eb 0a                	jmp    4003a803 <k_timer_stop+0x8a>
		irq_unlock(key);
	} else {
		_reschedule_threads(key);
4003a7f9:	89 f0                	mov    %esi,%eax
	}
}
4003a7fb:	5b                   	pop    %ebx
4003a7fc:	5e                   	pop    %esi
4003a7fd:	5d                   	pop    %ebp
		_reschedule_threads(key);
4003a7fe:	e9 9b f6 ff ff       	jmp    40039e9e <_reschedule_threads>
}
4003a803:	5b                   	pop    %ebx
4003a804:	5e                   	pop    %esi
4003a805:	5d                   	pop    %ebp
4003a806:	c3                   	ret    

4003a807 <k_timer_status_get>:


uint32_t k_timer_status_get(struct k_timer *timer)
{
4003a807:	55                   	push   %ebp
4003a808:	89 c2                	mov    %eax,%edx
4003a80a:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
4003a80c:	9c                   	pushf  
4003a80d:	fa                   	cli    
4003a80e:	59                   	pop    %ecx
4003a80f:	0f ba e1 09          	bt     $0x9,%ecx
	unsigned int key = irq_lock();
	uint32_t result = timer->status;
4003a813:	8b 40 2c             	mov    0x2c(%eax),%eax

	timer->status = 0;
4003a816:	c7 42 2c 00 00 00 00 	movl   $0x0,0x2c(%edx)
4003a81d:	73 01                	jae    4003a820 <k_timer_status_get+0x19>
	__asm__ volatile (
4003a81f:	fb                   	sti    
	irq_unlock(key);

	return result;
}
4003a820:	5d                   	pop    %ebp
4003a821:	c3                   	ret    

4003a822 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while ((0))
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
4003a822:	55                   	push   %ebp
4003a823:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
4003a825:	9c                   	pushf  
4003a826:	fa                   	cli    
4003a827:	58                   	pop    %eax
	k_cpu_idle();
4003a828:	e8 f1 ee ff ff       	call   4003971e <k_cpu_idle>
4003a82d:	eb f6                	jmp    4003a825 <idle+0x3>

4003a82f <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
4003a82f:	55                   	push   %ebp
4003a830:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
4003a832:	5d                   	pop    %ebp
4003a833:	c3                   	ret    

4003a834 <ceil>:
4003a834:	89 d1                	mov    %edx,%ecx
4003a836:	55                   	push   %ebp
4003a837:	c1 f9 14             	sar    $0x14,%ecx
4003a83a:	57                   	push   %edi
4003a83b:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
4003a841:	56                   	push   %esi
4003a842:	53                   	push   %ebx
4003a843:	89 c6                	mov    %eax,%esi
4003a845:	83 ec 08             	sub    $0x8,%esp
4003a848:	8d b9 01 fc ff ff    	lea    -0x3ff(%ecx),%edi
4003a84e:	89 d3                	mov    %edx,%ebx
4003a850:	83 ff 13             	cmp    $0x13,%edi
4003a853:	89 04 24             	mov    %eax,(%esp)
4003a856:	0f 8f a1 00 00 00    	jg     4003a8fd <ceil+0xc9>
4003a85c:	85 ff                	test   %edi,%edi
4003a85e:	79 42                	jns    4003a8a2 <ceil+0x6e>
4003a860:	68 3c e4 37 7e       	push   $0x7e37e43c
4003a865:	68 9c 75 00 88       	push   $0x8800759c
4003a86a:	e8 22 59 ff ff       	call   40030191 <__adddf3>
4003a86f:	59                   	pop    %ecx
4003a870:	5f                   	pop    %edi
4003a871:	6a 00                	push   $0x0
4003a873:	6a 00                	push   $0x0
4003a875:	e8 b4 66 ff ff       	call   40030f2e <__gedf2>
4003a87a:	5d                   	pop    %ebp
4003a87b:	85 c0                	test   %eax,%eax
4003a87d:	5a                   	pop    %edx
4003a87e:	0f 8e ef 00 00 00    	jle    4003a973 <ceil+0x13f>
4003a884:	85 db                	test   %ebx,%ebx
4003a886:	0f 88 e0 00 00 00    	js     4003a96c <ceil+0x138>
4003a88c:	09 f3                	or     %esi,%ebx
4003a88e:	31 f6                	xor    %esi,%esi
4003a890:	85 db                	test   %ebx,%ebx
4003a892:	0f 84 db 00 00 00    	je     4003a973 <ceil+0x13f>
4003a898:	bb 00 00 f0 3f       	mov    $0x3ff00000,%ebx
4003a89d:	e9 d1 00 00 00       	jmp    4003a973 <ceil+0x13f>
4003a8a2:	89 f9                	mov    %edi,%ecx
4003a8a4:	bd ff ff 0f 00       	mov    $0xfffff,%ebp
4003a8a9:	d3 fd                	sar    %cl,%ebp
4003a8ab:	89 d1                	mov    %edx,%ecx
4003a8ad:	89 6c 24 04          	mov    %ebp,0x4(%esp)
4003a8b1:	21 e9                	and    %ebp,%ecx
4003a8b3:	8b 2c 24             	mov    (%esp),%ebp
4003a8b6:	09 cd                	or     %ecx,%ebp
4003a8b8:	0f 84 b9 00 00 00    	je     4003a977 <ceil+0x143>
4003a8be:	68 3c e4 37 7e       	push   $0x7e37e43c
4003a8c3:	68 9c 75 00 88       	push   $0x8800759c
4003a8c8:	e8 c4 58 ff ff       	call   40030191 <__adddf3>
4003a8cd:	5d                   	pop    %ebp
4003a8ce:	59                   	pop    %ecx
4003a8cf:	6a 00                	push   $0x0
4003a8d1:	6a 00                	push   $0x0
4003a8d3:	e8 56 66 ff ff       	call   40030f2e <__gedf2>
4003a8d8:	5d                   	pop    %ebp
4003a8d9:	85 c0                	test   %eax,%eax
4003a8db:	5a                   	pop    %edx
4003a8dc:	0f 8e 91 00 00 00    	jle    4003a973 <ceil+0x13f>
4003a8e2:	85 db                	test   %ebx,%ebx
4003a8e4:	7e 0b                	jle    4003a8f1 <ceil+0xbd>
4003a8e6:	b8 00 00 10 00       	mov    $0x100000,%eax
4003a8eb:	89 f9                	mov    %edi,%ecx
4003a8ed:	d3 f8                	sar    %cl,%eax
4003a8ef:	01 c3                	add    %eax,%ebx
4003a8f1:	8b 6c 24 04          	mov    0x4(%esp),%ebp
4003a8f5:	31 f6                	xor    %esi,%esi
4003a8f7:	f7 d5                	not    %ebp
4003a8f9:	21 eb                	and    %ebp,%ebx
4003a8fb:	eb 76                	jmp    4003a973 <ceil+0x13f>
4003a8fd:	83 ff 33             	cmp    $0x33,%edi
4003a900:	7e 13                	jle    4003a915 <ceil+0xe1>
4003a902:	81 ff 00 04 00 00    	cmp    $0x400,%edi
4003a908:	75 6d                	jne    4003a977 <ceil+0x143>
4003a90a:	52                   	push   %edx
4003a90b:	50                   	push   %eax
4003a90c:	e8 80 58 ff ff       	call   40030191 <__adddf3>
4003a911:	5b                   	pop    %ebx
4003a912:	5e                   	pop    %esi
4003a913:	eb 62                	jmp    4003a977 <ceil+0x143>
4003a915:	81 e9 13 04 00 00    	sub    $0x413,%ecx
4003a91b:	83 cd ff             	or     $0xffffffff,%ebp
4003a91e:	d3 ed                	shr    %cl,%ebp
4003a920:	85 e8                	test   %ebp,%eax
4003a922:	74 53                	je     4003a977 <ceil+0x143>
4003a924:	68 3c e4 37 7e       	push   $0x7e37e43c
4003a929:	68 9c 75 00 88       	push   $0x8800759c
4003a92e:	e8 5e 58 ff ff       	call   40030191 <__adddf3>
4003a933:	59                   	pop    %ecx
4003a934:	59                   	pop    %ecx
4003a935:	6a 00                	push   $0x0
4003a937:	6a 00                	push   $0x0
4003a939:	e8 f0 65 ff ff       	call   40030f2e <__gedf2>
4003a93e:	5a                   	pop    %edx
4003a93f:	85 c0                	test   %eax,%eax
4003a941:	59                   	pop    %ecx
4003a942:	7e 2f                	jle    4003a973 <ceil+0x13f>
4003a944:	85 db                	test   %ebx,%ebx
4003a946:	7e 1e                	jle    4003a966 <ceil+0x132>
4003a948:	83 ff 14             	cmp    $0x14,%edi
4003a94b:	75 03                	jne    4003a950 <ceil+0x11c>
4003a94d:	43                   	inc    %ebx
4003a94e:	eb 16                	jmp    4003a966 <ceil+0x132>
4003a950:	b9 34 00 00 00       	mov    $0x34,%ecx
4003a955:	b8 01 00 00 00       	mov    $0x1,%eax
4003a95a:	29 f9                	sub    %edi,%ecx
4003a95c:	d3 e0                	shl    %cl,%eax
4003a95e:	01 c6                	add    %eax,%esi
4003a960:	3b 34 24             	cmp    (%esp),%esi
4003a963:	83 d3 00             	adc    $0x0,%ebx
4003a966:	f7 d5                	not    %ebp
4003a968:	21 ee                	and    %ebp,%esi
4003a96a:	eb 07                	jmp    4003a973 <ceil+0x13f>
4003a96c:	31 f6                	xor    %esi,%esi
4003a96e:	bb 00 00 00 80       	mov    $0x80000000,%ebx
4003a973:	89 da                	mov    %ebx,%edx
4003a975:	89 f0                	mov    %esi,%eax
4003a977:	83 c4 08             	add    $0x8,%esp
4003a97a:	5b                   	pop    %ebx
4003a97b:	5e                   	pop    %esi
4003a97c:	5f                   	pop    %edi
4003a97d:	5d                   	pop    %ebp
4003a97e:	c3                   	ret    

4003a97f <floor>:
4003a97f:	89 d1                	mov    %edx,%ecx
4003a981:	55                   	push   %ebp
4003a982:	c1 f9 14             	sar    $0x14,%ecx
4003a985:	57                   	push   %edi
4003a986:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
4003a98c:	56                   	push   %esi
4003a98d:	53                   	push   %ebx
4003a98e:	89 c6                	mov    %eax,%esi
4003a990:	83 ec 08             	sub    $0x8,%esp
4003a993:	8d b9 01 fc ff ff    	lea    -0x3ff(%ecx),%edi
4003a999:	89 d3                	mov    %edx,%ebx
4003a99b:	83 ff 13             	cmp    $0x13,%edi
4003a99e:	89 04 24             	mov    %eax,(%esp)
4003a9a1:	0f 8f a6 00 00 00    	jg     4003aa4d <floor+0xce>
4003a9a7:	85 ff                	test   %edi,%edi
4003a9a9:	79 47                	jns    4003a9f2 <floor+0x73>
4003a9ab:	68 3c e4 37 7e       	push   $0x7e37e43c
4003a9b0:	68 9c 75 00 88       	push   $0x8800759c
4003a9b5:	e8 d7 57 ff ff       	call   40030191 <__adddf3>
4003a9ba:	59                   	pop    %ecx
4003a9bb:	5f                   	pop    %edi
4003a9bc:	6a 00                	push   $0x0
4003a9be:	6a 00                	push   $0x0
4003a9c0:	e8 69 65 ff ff       	call   40030f2e <__gedf2>
4003a9c5:	5d                   	pop    %ebp
4003a9c6:	85 c0                	test   %eax,%eax
4003a9c8:	5a                   	pop    %edx
4003a9c9:	0f 8e f1 00 00 00    	jle    4003aac0 <floor+0x141>
4003a9cf:	85 db                	test   %ebx,%ebx
4003a9d1:	0f 89 e5 00 00 00    	jns    4003aabc <floor+0x13d>
4003a9d7:	89 d8                	mov    %ebx,%eax
4003a9d9:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
4003a9de:	09 c6                	or     %eax,%esi
4003a9e0:	0f 84 da 00 00 00    	je     4003aac0 <floor+0x141>
4003a9e6:	31 f6                	xor    %esi,%esi
4003a9e8:	bb 00 00 f0 bf       	mov    $0xbff00000,%ebx
4003a9ed:	e9 ce 00 00 00       	jmp    4003aac0 <floor+0x141>
4003a9f2:	89 f9                	mov    %edi,%ecx
4003a9f4:	bd ff ff 0f 00       	mov    $0xfffff,%ebp
4003a9f9:	d3 fd                	sar    %cl,%ebp
4003a9fb:	89 d1                	mov    %edx,%ecx
4003a9fd:	89 6c 24 04          	mov    %ebp,0x4(%esp)
4003aa01:	21 e9                	and    %ebp,%ecx
4003aa03:	8b 2c 24             	mov    (%esp),%ebp
4003aa06:	09 cd                	or     %ecx,%ebp
4003aa08:	0f 84 b6 00 00 00    	je     4003aac4 <floor+0x145>
4003aa0e:	68 3c e4 37 7e       	push   $0x7e37e43c
4003aa13:	68 9c 75 00 88       	push   $0x8800759c
4003aa18:	e8 74 57 ff ff       	call   40030191 <__adddf3>
4003aa1d:	5d                   	pop    %ebp
4003aa1e:	59                   	pop    %ecx
4003aa1f:	6a 00                	push   $0x0
4003aa21:	6a 00                	push   $0x0
4003aa23:	e8 06 65 ff ff       	call   40030f2e <__gedf2>
4003aa28:	5d                   	pop    %ebp
4003aa29:	85 c0                	test   %eax,%eax
4003aa2b:	5a                   	pop    %edx
4003aa2c:	0f 8e 8e 00 00 00    	jle    4003aac0 <floor+0x141>
4003aa32:	85 db                	test   %ebx,%ebx
4003aa34:	79 0b                	jns    4003aa41 <floor+0xc2>
4003aa36:	b8 00 00 10 00       	mov    $0x100000,%eax
4003aa3b:	89 f9                	mov    %edi,%ecx
4003aa3d:	d3 f8                	sar    %cl,%eax
4003aa3f:	01 c3                	add    %eax,%ebx
4003aa41:	8b 6c 24 04          	mov    0x4(%esp),%ebp
4003aa45:	31 f6                	xor    %esi,%esi
4003aa47:	f7 d5                	not    %ebp
4003aa49:	21 eb                	and    %ebp,%ebx
4003aa4b:	eb 73                	jmp    4003aac0 <floor+0x141>
4003aa4d:	83 ff 33             	cmp    $0x33,%edi
4003aa50:	7e 13                	jle    4003aa65 <floor+0xe6>
4003aa52:	81 ff 00 04 00 00    	cmp    $0x400,%edi
4003aa58:	75 6a                	jne    4003aac4 <floor+0x145>
4003aa5a:	52                   	push   %edx
4003aa5b:	50                   	push   %eax
4003aa5c:	e8 30 57 ff ff       	call   40030191 <__adddf3>
4003aa61:	5b                   	pop    %ebx
4003aa62:	5e                   	pop    %esi
4003aa63:	eb 5f                	jmp    4003aac4 <floor+0x145>
4003aa65:	81 e9 13 04 00 00    	sub    $0x413,%ecx
4003aa6b:	83 cd ff             	or     $0xffffffff,%ebp
4003aa6e:	d3 ed                	shr    %cl,%ebp
4003aa70:	85 e8                	test   %ebp,%eax
4003aa72:	74 50                	je     4003aac4 <floor+0x145>
4003aa74:	68 3c e4 37 7e       	push   $0x7e37e43c
4003aa79:	68 9c 75 00 88       	push   $0x8800759c
4003aa7e:	e8 0e 57 ff ff       	call   40030191 <__adddf3>
4003aa83:	59                   	pop    %ecx
4003aa84:	59                   	pop    %ecx
4003aa85:	6a 00                	push   $0x0
4003aa87:	6a 00                	push   $0x0
4003aa89:	e8 a0 64 ff ff       	call   40030f2e <__gedf2>
4003aa8e:	5a                   	pop    %edx
4003aa8f:	85 c0                	test   %eax,%eax
4003aa91:	59                   	pop    %ecx
4003aa92:	7e 2c                	jle    4003aac0 <floor+0x141>
4003aa94:	85 db                	test   %ebx,%ebx
4003aa96:	79 1e                	jns    4003aab6 <floor+0x137>
4003aa98:	83 ff 14             	cmp    $0x14,%edi
4003aa9b:	75 03                	jne    4003aaa0 <floor+0x121>
4003aa9d:	43                   	inc    %ebx
4003aa9e:	eb 16                	jmp    4003aab6 <floor+0x137>
4003aaa0:	b9 34 00 00 00       	mov    $0x34,%ecx
4003aaa5:	b8 01 00 00 00       	mov    $0x1,%eax
4003aaaa:	29 f9                	sub    %edi,%ecx
4003aaac:	d3 e0                	shl    %cl,%eax
4003aaae:	01 c6                	add    %eax,%esi
4003aab0:	3b 34 24             	cmp    (%esp),%esi
4003aab3:	83 d3 00             	adc    $0x0,%ebx
4003aab6:	f7 d5                	not    %ebp
4003aab8:	21 ee                	and    %ebp,%esi
4003aaba:	eb 04                	jmp    4003aac0 <floor+0x141>
4003aabc:	31 f6                	xor    %esi,%esi
4003aabe:	31 db                	xor    %ebx,%ebx
4003aac0:	89 da                	mov    %ebx,%edx
4003aac2:	89 f0                	mov    %esi,%eax
4003aac4:	83 c4 08             	add    $0x8,%esp
4003aac7:	5b                   	pop    %ebx
4003aac8:	5e                   	pop    %esi
4003aac9:	5f                   	pop    %edi
4003aaca:	5d                   	pop    %ebp
4003aacb:	c3                   	ret    

4003aacc <malloc>:
4003aacc:	53                   	push   %ebx
4003aacd:	89 c3                	mov    %eax,%ebx
4003aacf:	e8 64 02 00 00       	call   4003ad38 <__getreent>
4003aad4:	89 da                	mov    %ebx,%edx
4003aad6:	5b                   	pop    %ebx
4003aad7:	e9 c9 00 00 00       	jmp    4003aba5 <_malloc_r>

4003aadc <free>:
4003aadc:	53                   	push   %ebx
4003aadd:	89 c3                	mov    %eax,%ebx
4003aadf:	e8 54 02 00 00       	call   4003ad38 <__getreent>
4003aae4:	89 da                	mov    %ebx,%edx
4003aae6:	5b                   	pop    %ebx
4003aae7:	e9 00 00 00 00       	jmp    4003aaec <_free_r>

4003aaec <_free_r>:
4003aaec:	85 d2                	test   %edx,%edx
4003aaee:	0f 84 b0 00 00 00    	je     4003aba4 <_free_r+0xb8>
4003aaf4:	8d 4a fc             	lea    -0x4(%edx),%ecx
4003aaf7:	8b 52 fc             	mov    -0x4(%edx),%edx
4003aafa:	85 d2                	test   %edx,%edx
4003aafc:	79 02                	jns    4003ab00 <_free_r+0x14>
4003aafe:	01 d1                	add    %edx,%ecx
4003ab00:	8b 15 04 68 00 a8    	mov    0xa8006804,%edx
4003ab06:	85 d2                	test   %edx,%edx
4003ab08:	75 0e                	jne    4003ab18 <_free_r+0x2c>
4003ab0a:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
4003ab11:	89 0d 04 68 00 a8    	mov    %ecx,0xa8006804
4003ab17:	c3                   	ret    
4003ab18:	57                   	push   %edi
4003ab19:	39 ca                	cmp    %ecx,%edx
4003ab1b:	56                   	push   %esi
4003ab1c:	53                   	push   %ebx
4003ab1d:	53                   	push   %ebx
4003ab1e:	76 20                	jbe    4003ab40 <_free_r+0x54>
4003ab20:	8b 01                	mov    (%ecx),%eax
4003ab22:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
4003ab25:	39 da                	cmp    %ebx,%edx
4003ab27:	75 0c                	jne    4003ab35 <_free_r+0x49>
4003ab29:	03 02                	add    (%edx),%eax
4003ab2b:	89 01                	mov    %eax,(%ecx)
4003ab2d:	8b 42 04             	mov    0x4(%edx),%eax
4003ab30:	89 41 04             	mov    %eax,0x4(%ecx)
4003ab33:	eb 03                	jmp    4003ab38 <_free_r+0x4c>
4003ab35:	89 51 04             	mov    %edx,0x4(%ecx)
4003ab38:	89 0d 04 68 00 a8    	mov    %ecx,0xa8006804
4003ab3e:	eb 60                	jmp    4003aba0 <_free_r+0xb4>
4003ab40:	8b 72 04             	mov    0x4(%edx),%esi
4003ab43:	85 f6                	test   %esi,%esi
4003ab45:	0f 95 44 24 03       	setne  0x3(%esp)
4003ab4a:	39 ce                	cmp    %ecx,%esi
4003ab4c:	0f 96 c3             	setbe  %bl
4003ab4f:	84 5c 24 03          	test   %bl,0x3(%esp)
4003ab53:	74 04                	je     4003ab59 <_free_r+0x6d>
4003ab55:	89 f2                	mov    %esi,%edx
4003ab57:	eb e7                	jmp    4003ab40 <_free_r+0x54>
4003ab59:	8b 1a                	mov    (%edx),%ebx
4003ab5b:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
4003ab5e:	39 cf                	cmp    %ecx,%edi
4003ab60:	75 19                	jne    4003ab7b <_free_r+0x8f>
4003ab62:	8b 01                	mov    (%ecx),%eax
4003ab64:	01 d8                	add    %ebx,%eax
4003ab66:	89 02                	mov    %eax,(%edx)
4003ab68:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
4003ab6b:	39 ce                	cmp    %ecx,%esi
4003ab6d:	75 31                	jne    4003aba0 <_free_r+0xb4>
4003ab6f:	03 06                	add    (%esi),%eax
4003ab71:	89 02                	mov    %eax,(%edx)
4003ab73:	8b 46 04             	mov    0x4(%esi),%eax
4003ab76:	89 42 04             	mov    %eax,0x4(%edx)
4003ab79:	eb 25                	jmp    4003aba0 <_free_r+0xb4>
4003ab7b:	76 08                	jbe    4003ab85 <_free_r+0x99>
4003ab7d:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
4003ab83:	eb 1b                	jmp    4003aba0 <_free_r+0xb4>
4003ab85:	8b 01                	mov    (%ecx),%eax
4003ab87:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
4003ab8a:	39 de                	cmp    %ebx,%esi
4003ab8c:	75 0c                	jne    4003ab9a <_free_r+0xae>
4003ab8e:	03 06                	add    (%esi),%eax
4003ab90:	89 01                	mov    %eax,(%ecx)
4003ab92:	8b 46 04             	mov    0x4(%esi),%eax
4003ab95:	89 41 04             	mov    %eax,0x4(%ecx)
4003ab98:	eb 03                	jmp    4003ab9d <_free_r+0xb1>
4003ab9a:	89 71 04             	mov    %esi,0x4(%ecx)
4003ab9d:	89 4a 04             	mov    %ecx,0x4(%edx)
4003aba0:	58                   	pop    %eax
4003aba1:	5b                   	pop    %ebx
4003aba2:	5e                   	pop    %esi
4003aba3:	5f                   	pop    %edi
4003aba4:	c3                   	ret    

4003aba5 <_malloc_r>:
4003aba5:	57                   	push   %edi
4003aba6:	8d 7a 03             	lea    0x3(%edx),%edi
4003aba9:	83 e7 fc             	and    $0xfffffffc,%edi
4003abac:	56                   	push   %esi
4003abad:	83 c7 08             	add    $0x8,%edi
4003abb0:	53                   	push   %ebx
4003abb1:	89 c6                	mov    %eax,%esi
4003abb3:	83 ff 0c             	cmp    $0xc,%edi
4003abb6:	73 05                	jae    4003abbd <_malloc_r+0x18>
4003abb8:	bf 0c 00 00 00       	mov    $0xc,%edi
4003abbd:	89 f8                	mov    %edi,%eax
4003abbf:	c1 e8 1f             	shr    $0x1f,%eax
4003abc2:	75 0c                	jne    4003abd0 <_malloc_r+0x2b>
4003abc4:	8b 0d 04 68 00 a8    	mov    0xa8006804,%ecx
4003abca:	39 fa                	cmp    %edi,%edx
4003abcc:	89 c8                	mov    %ecx,%eax
4003abce:	76 18                	jbe    4003abe8 <_malloc_r+0x43>
4003abd0:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
4003abd6:	31 c0                	xor    %eax,%eax
4003abd8:	e9 97 00 00 00       	jmp    4003ac74 <_malloc_r+0xcf>
4003abdd:	8b 10                	mov    (%eax),%edx
4003abdf:	29 fa                	sub    %edi,%edx
4003abe1:	79 0b                	jns    4003abee <_malloc_r+0x49>
4003abe3:	89 c1                	mov    %eax,%ecx
4003abe5:	8b 40 04             	mov    0x4(%eax),%eax
4003abe8:	85 c0                	test   %eax,%eax
4003abea:	75 f1                	jne    4003abdd <_malloc_r+0x38>
4003abec:	eb 26                	jmp    4003ac14 <_malloc_r+0x6f>
4003abee:	83 fa 0b             	cmp    $0xb,%edx
4003abf1:	76 09                	jbe    4003abfc <_malloc_r+0x57>
4003abf3:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
4003abf6:	89 10                	mov    %edx,(%eax)
4003abf8:	89 39                	mov    %edi,(%ecx)
4003abfa:	eb 4d                	jmp    4003ac49 <_malloc_r+0xa4>
4003abfc:	39 c1                	cmp    %eax,%ecx
4003abfe:	75 0a                	jne    4003ac0a <_malloc_r+0x65>
4003ac00:	8b 41 04             	mov    0x4(%ecx),%eax
4003ac03:	a3 04 68 00 a8       	mov    %eax,0xa8006804
4003ac08:	eb 3f                	jmp    4003ac49 <_malloc_r+0xa4>
4003ac0a:	8b 50 04             	mov    0x4(%eax),%edx
4003ac0d:	89 51 04             	mov    %edx,0x4(%ecx)
4003ac10:	89 c1                	mov    %eax,%ecx
4003ac12:	eb 35                	jmp    4003ac49 <_malloc_r+0xa4>
4003ac14:	83 3d 00 68 00 a8 00 	cmpl   $0x0,0xa8006800
4003ac1b:	75 0e                	jne    4003ac2b <_malloc_r+0x86>
4003ac1d:	31 d2                	xor    %edx,%edx
4003ac1f:	89 f0                	mov    %esi,%eax
4003ac21:	e8 d4 00 00 00       	call   4003acfa <_sbrk_r>
4003ac26:	a3 00 68 00 a8       	mov    %eax,0xa8006800
4003ac2b:	89 fa                	mov    %edi,%edx
4003ac2d:	89 f0                	mov    %esi,%eax
4003ac2f:	e8 c6 00 00 00       	call   4003acfa <_sbrk_r>
4003ac34:	83 f8 ff             	cmp    $0xffffffff,%eax
4003ac37:	74 97                	je     4003abd0 <_malloc_r+0x2b>
4003ac39:	8d 48 03             	lea    0x3(%eax),%ecx
4003ac3c:	89 cb                	mov    %ecx,%ebx
4003ac3e:	83 e3 fc             	and    $0xfffffffc,%ebx
4003ac41:	39 d8                	cmp    %ebx,%eax
4003ac43:	75 1c                	jne    4003ac61 <_malloc_r+0xbc>
4003ac45:	89 3b                	mov    %edi,(%ebx)
4003ac47:	89 d9                	mov    %ebx,%ecx
4003ac49:	8d 41 0b             	lea    0xb(%ecx),%eax
4003ac4c:	8d 51 04             	lea    0x4(%ecx),%edx
4003ac4f:	83 e0 f8             	and    $0xfffffff8,%eax
4003ac52:	89 c6                	mov    %eax,%esi
4003ac54:	29 d6                	sub    %edx,%esi
4003ac56:	74 1c                	je     4003ac74 <_malloc_r+0xcf>
4003ac58:	89 f3                	mov    %esi,%ebx
4003ac5a:	f7 db                	neg    %ebx
4003ac5c:	89 1c 31             	mov    %ebx,(%ecx,%esi,1)
4003ac5f:	eb 13                	jmp    4003ac74 <_malloc_r+0xcf>
4003ac61:	89 da                	mov    %ebx,%edx
4003ac63:	29 c2                	sub    %eax,%edx
4003ac65:	89 f0                	mov    %esi,%eax
4003ac67:	e8 8e 00 00 00       	call   4003acfa <_sbrk_r>
4003ac6c:	40                   	inc    %eax
4003ac6d:	75 d6                	jne    4003ac45 <_malloc_r+0xa0>
4003ac6f:	e9 5c ff ff ff       	jmp    4003abd0 <_malloc_r+0x2b>
4003ac74:	5b                   	pop    %ebx
4003ac75:	5e                   	pop    %esi
4003ac76:	5f                   	pop    %edi
4003ac77:	c3                   	ret    

4003ac78 <iprintf>:
4003ac78:	e8 bb 00 00 00       	call   4003ad38 <__getreent>
4003ac7d:	8d 4c 24 08          	lea    0x8(%esp),%ecx
4003ac81:	8b 50 08             	mov    0x8(%eax),%edx
4003ac84:	51                   	push   %ecx
4003ac85:	8b 4c 24 08          	mov    0x8(%esp),%ecx
4003ac89:	e8 09 01 00 00       	call   4003ad97 <_vfiprintf_r>
4003ac8e:	5a                   	pop    %edx
4003ac8f:	c3                   	ret    

4003ac90 <srand>:
4003ac90:	53                   	push   %ebx
4003ac91:	89 c3                	mov    %eax,%ebx
4003ac93:	e8 a0 00 00 00       	call   4003ad38 <__getreent>
4003ac98:	89 98 a4 00 00 00    	mov    %ebx,0xa4(%eax)
4003ac9e:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
4003aca5:	00 00 00 
4003aca8:	5b                   	pop    %ebx
4003aca9:	c3                   	ret    

4003acaa <rand>:
4003acaa:	57                   	push   %edi
4003acab:	56                   	push   %esi
4003acac:	53                   	push   %ebx
4003acad:	e8 86 00 00 00       	call   4003ad38 <__getreent>
4003acb2:	89 c6                	mov    %eax,%esi
4003acb4:	b9 2d 7f 95 4c       	mov    $0x4c957f2d,%ecx
4003acb9:	69 b8 a8 00 00 00 2d 	imul   $0x4c957f2d,0xa8(%eax),%edi
4003acc0:	7f 95 4c 
4003acc3:	69 80 a4 00 00 00 2d 	imul   $0x5851f42d,0xa4(%eax),%eax
4003acca:	f4 51 58 
4003accd:	01 c7                	add    %eax,%edi
4003accf:	89 c8                	mov    %ecx,%eax
4003acd1:	f7 a6 a4 00 00 00    	mull   0xa4(%esi)
4003acd7:	89 c1                	mov    %eax,%ecx
4003acd9:	89 d3                	mov    %edx,%ebx
4003acdb:	01 fb                	add    %edi,%ebx
4003acdd:	83 c1 01             	add    $0x1,%ecx
4003ace0:	83 d3 00             	adc    $0x0,%ebx
4003ace3:	89 8e a4 00 00 00    	mov    %ecx,0xa4(%esi)
4003ace9:	89 9e a8 00 00 00    	mov    %ebx,0xa8(%esi)
4003acef:	89 d8                	mov    %ebx,%eax
4003acf1:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
4003acf6:	5b                   	pop    %ebx
4003acf7:	5e                   	pop    %esi
4003acf8:	5f                   	pop    %edi
4003acf9:	c3                   	ret    

4003acfa <_sbrk_r>:
4003acfa:	53                   	push   %ebx
4003acfb:	89 c3                	mov    %eax,%ebx
4003acfd:	89 d0                	mov    %edx,%eax
4003acff:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003ad06:	00 00 00 
4003ad09:	e8 a9 7b ff ff       	call   400328b7 <_sbrk>
4003ad0e:	83 f8 ff             	cmp    $0xffffffff,%eax
4003ad11:	75 0c                	jne    4003ad1f <_sbrk_r+0x25>
4003ad13:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003ad19:	85 d2                	test   %edx,%edx
4003ad1b:	74 02                	je     4003ad1f <_sbrk_r+0x25>
4003ad1d:	89 13                	mov    %edx,(%ebx)
4003ad1f:	5b                   	pop    %ebx
4003ad20:	c3                   	ret    

4003ad21 <strcmp>:
4003ad21:	8a 08                	mov    (%eax),%cl
4003ad23:	84 c9                	test   %cl,%cl
4003ad25:	74 08                	je     4003ad2f <strcmp+0xe>
4003ad27:	3a 0a                	cmp    (%edx),%cl
4003ad29:	75 04                	jne    4003ad2f <strcmp+0xe>
4003ad2b:	40                   	inc    %eax
4003ad2c:	42                   	inc    %edx
4003ad2d:	eb f2                	jmp    4003ad21 <strcmp>
4003ad2f:	0f b6 12             	movzbl (%edx),%edx
4003ad32:	0f b6 c1             	movzbl %cl,%eax
4003ad35:	29 d0                	sub    %edx,%eax
4003ad37:	c3                   	ret    

4003ad38 <__getreent>:
4003ad38:	a1 00 64 00 a8       	mov    0xa8006400,%eax
4003ad3d:	c3                   	ret    

4003ad3e <__sfputc_r>:
4003ad3e:	53                   	push   %ebx
4003ad3f:	8b 59 08             	mov    0x8(%ecx),%ebx
4003ad42:	4b                   	dec    %ebx
4003ad43:	89 59 08             	mov    %ebx,0x8(%ecx)
4003ad46:	85 db                	test   %ebx,%ebx
4003ad48:	79 10                	jns    4003ad5a <__sfputc_r+0x1c>
4003ad4a:	3b 59 18             	cmp    0x18(%ecx),%ebx
4003ad4d:	7c 05                	jl     4003ad54 <__sfputc_r+0x16>
4003ad4f:	80 fa 0a             	cmp    $0xa,%dl
4003ad52:	75 06                	jne    4003ad5a <__sfputc_r+0x1c>
4003ad54:	5b                   	pop    %ebx
4003ad55:	e9 cf 02 00 00       	jmp    4003b029 <__swbuf_r>
4003ad5a:	8b 01                	mov    (%ecx),%eax
4003ad5c:	8d 58 01             	lea    0x1(%eax),%ebx
4003ad5f:	89 19                	mov    %ebx,(%ecx)
4003ad61:	88 10                	mov    %dl,(%eax)
4003ad63:	5b                   	pop    %ebx
4003ad64:	0f b6 c2             	movzbl %dl,%eax
4003ad67:	c3                   	ret    

4003ad68 <__sfputs_r>:
4003ad68:	55                   	push   %ebp
4003ad69:	57                   	push   %edi
4003ad6a:	56                   	push   %esi
4003ad6b:	53                   	push   %ebx
4003ad6c:	8b 74 24 14          	mov    0x14(%esp),%esi
4003ad70:	89 c7                	mov    %eax,%edi
4003ad72:	89 d5                	mov    %edx,%ebp
4003ad74:	89 cb                	mov    %ecx,%ebx
4003ad76:	01 ce                	add    %ecx,%esi
4003ad78:	39 f3                	cmp    %esi,%ebx
4003ad7a:	74 14                	je     4003ad90 <__sfputs_r+0x28>
4003ad7c:	0f be 13             	movsbl (%ebx),%edx
4003ad7f:	89 e9                	mov    %ebp,%ecx
4003ad81:	89 f8                	mov    %edi,%eax
4003ad83:	e8 b6 ff ff ff       	call   4003ad3e <__sfputc_r>
4003ad88:	43                   	inc    %ebx
4003ad89:	83 f8 ff             	cmp    $0xffffffff,%eax
4003ad8c:	75 ea                	jne    4003ad78 <__sfputs_r+0x10>
4003ad8e:	eb 02                	jmp    4003ad92 <__sfputs_r+0x2a>
4003ad90:	31 c0                	xor    %eax,%eax
4003ad92:	5b                   	pop    %ebx
4003ad93:	5e                   	pop    %esi
4003ad94:	5f                   	pop    %edi
4003ad95:	5d                   	pop    %ebp
4003ad96:	c3                   	ret    

4003ad97 <_vfiprintf_r>:
4003ad97:	55                   	push   %ebp
4003ad98:	57                   	push   %edi
4003ad99:	56                   	push   %esi
4003ad9a:	53                   	push   %ebx
4003ad9b:	83 ec 68             	sub    $0x68,%esp
4003ad9e:	89 c5                	mov    %eax,%ebp
4003ada0:	89 d6                	mov    %edx,%esi
4003ada2:	89 cf                	mov    %ecx,%edi
4003ada4:	85 c0                	test   %eax,%eax
4003ada6:	74 0b                	je     4003adb3 <_vfiprintf_r+0x1c>
4003ada8:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003adac:	75 05                	jne    4003adb3 <_vfiprintf_r+0x1c>
4003adae:	e8 93 05 00 00       	call   4003b346 <__sinit>
4003adb3:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
4003adb7:	74 1d                	je     4003add6 <_vfiprintf_r+0x3f>
4003adb9:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
4003adbd:	74 17                	je     4003add6 <_vfiprintf_r+0x3f>
4003adbf:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
4003adc6:	00 
4003adc7:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
4003adcc:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
4003add1:	e9 9b 00 00 00       	jmp    4003ae71 <_vfiprintf_r+0xda>
4003add6:	89 f2                	mov    %esi,%edx
4003add8:	89 e8                	mov    %ebp,%eax
4003adda:	e8 d8 02 00 00       	call   4003b0b7 <__swsetup_r>
4003addf:	85 c0                	test   %eax,%eax
4003ade1:	74 dc                	je     4003adbf <_vfiprintf_r+0x28>
4003ade3:	83 c8 ff             	or     $0xffffffff,%eax
4003ade6:	e9 36 02 00 00       	jmp    4003b021 <_vfiprintf_r+0x28a>
4003adeb:	8b 54 24 7c          	mov    0x7c(%esp),%edx
4003adef:	8d 4a 04             	lea    0x4(%edx),%ecx
4003adf2:	8b 12                	mov    (%edx),%edx
4003adf4:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
4003adf8:	85 d2                	test   %edx,%edx
4003adfa:	0f 88 39 01 00 00    	js     4003af39 <_vfiprintf_r+0x1a2>
4003ae00:	89 54 24 18          	mov    %edx,0x18(%esp)
4003ae04:	43                   	inc    %ebx
4003ae05:	80 3b 2e             	cmpb   $0x2e,(%ebx)
4003ae08:	0f 84 63 01 00 00    	je     4003af71 <_vfiprintf_r+0x1da>
4003ae0e:	0f be 13             	movsbl (%ebx),%edx
4003ae11:	b9 03 00 00 00       	mov    $0x3,%ecx
4003ae16:	b8 78 d2 03 40       	mov    $0x4003d278,%eax
4003ae1b:	e8 63 52 ff ff       	call   40030083 <memchr>
4003ae20:	85 c0                	test   %eax,%eax
4003ae22:	74 13                	je     4003ae37 <_vfiprintf_r+0xa0>
4003ae24:	2d 78 d2 03 40       	sub    $0x4003d278,%eax
4003ae29:	ba 40 00 00 00       	mov    $0x40,%edx
4003ae2e:	88 c1                	mov    %al,%cl
4003ae30:	43                   	inc    %ebx
4003ae31:	d3 e2                	shl    %cl,%edx
4003ae33:	09 54 24 0c          	or     %edx,0xc(%esp)
4003ae37:	0f be 13             	movsbl (%ebx),%edx
4003ae3a:	b9 06 00 00 00       	mov    $0x6,%ecx
4003ae3f:	b8 7c d2 03 40       	mov    $0x4003d27c,%eax
4003ae44:	88 54 24 24          	mov    %dl,0x24(%esp)
4003ae48:	e8 36 52 ff ff       	call   40030083 <memchr>
4003ae4d:	8d 7b 01             	lea    0x1(%ebx),%edi
4003ae50:	85 c0                	test   %eax,%eax
4003ae52:	0f 84 94 01 00 00    	je     4003afec <_vfiprintf_r+0x255>
4003ae58:	b8 00 00 00 00       	mov    $0x0,%eax
4003ae5d:	85 c0                	test   %eax,%eax
4003ae5f:	0f 85 6e 01 00 00    	jne    4003afd3 <_vfiprintf_r+0x23c>
4003ae65:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
4003ae6a:	8b 04 24             	mov    (%esp),%eax
4003ae6d:	01 44 24 20          	add    %eax,0x20(%esp)
4003ae71:	89 fb                	mov    %edi,%ebx
4003ae73:	8a 03                	mov    (%ebx),%al
4003ae75:	84 c0                	test   %al,%al
4003ae77:	0f 95 c2             	setne  %dl
4003ae7a:	3c 25                	cmp    $0x25,%al
4003ae7c:	0f 95 c0             	setne  %al
4003ae7f:	20 c2                	and    %al,%dl
4003ae81:	88 54 24 07          	mov    %dl,0x7(%esp)
4003ae85:	74 03                	je     4003ae8a <_vfiprintf_r+0xf3>
4003ae87:	43                   	inc    %ebx
4003ae88:	eb e9                	jmp    4003ae73 <_vfiprintf_r+0xdc>
4003ae8a:	89 d8                	mov    %ebx,%eax
4003ae8c:	29 f8                	sub    %edi,%eax
4003ae8e:	89 44 24 08          	mov    %eax,0x8(%esp)
4003ae92:	74 1c                	je     4003aeb0 <_vfiprintf_r+0x119>
4003ae94:	50                   	push   %eax
4003ae95:	89 f9                	mov    %edi,%ecx
4003ae97:	89 f2                	mov    %esi,%edx
4003ae99:	89 e8                	mov    %ebp,%eax
4003ae9b:	e8 c8 fe ff ff       	call   4003ad68 <__sfputs_r>
4003aea0:	59                   	pop    %ecx
4003aea1:	40                   	inc    %eax
4003aea2:	0f 84 6b 01 00 00    	je     4003b013 <_vfiprintf_r+0x27c>
4003aea8:	8b 44 24 08          	mov    0x8(%esp),%eax
4003aeac:	01 44 24 20          	add    %eax,0x20(%esp)
4003aeb0:	80 3b 00             	cmpb   $0x0,(%ebx)
4003aeb3:	0f 84 5a 01 00 00    	je     4003b013 <_vfiprintf_r+0x27c>
4003aeb9:	43                   	inc    %ebx
4003aeba:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
4003aec1:	00 
4003aec2:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
4003aec9:	00 
4003aeca:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
4003aed1:	ff 
4003aed2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
4003aed9:	00 
4003aeda:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
4003aedf:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
4003aee6:	00 
4003aee7:	0f be 13             	movsbl (%ebx),%edx
4003aeea:	b9 05 00 00 00       	mov    $0x5,%ecx
4003aeef:	b8 72 d2 03 40       	mov    $0x4003d272,%eax
4003aef4:	e8 8a 51 ff ff       	call   40030083 <memchr>
4003aef9:	85 c0                	test   %eax,%eax
4003aefb:	74 15                	je     4003af12 <_vfiprintf_r+0x17b>
4003aefd:	2d 72 d2 03 40       	sub    $0x4003d272,%eax
4003af02:	ba 01 00 00 00       	mov    $0x1,%edx
4003af07:	88 c1                	mov    %al,%cl
4003af09:	43                   	inc    %ebx
4003af0a:	d3 e2                	shl    %cl,%edx
4003af0c:	09 54 24 0c          	or     %edx,0xc(%esp)
4003af10:	eb d5                	jmp    4003aee7 <_vfiprintf_r+0x150>
4003af12:	8b 44 24 0c          	mov    0xc(%esp),%eax
4003af16:	a8 10                	test   $0x10,%al
4003af18:	74 05                	je     4003af1f <_vfiprintf_r+0x188>
4003af1a:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
4003af1f:	a8 08                	test   $0x8,%al
4003af21:	74 05                	je     4003af28 <_vfiprintf_r+0x191>
4003af23:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
4003af28:	80 3b 2a             	cmpb   $0x2a,(%ebx)
4003af2b:	0f 84 ba fe ff ff    	je     4003adeb <_vfiprintf_r+0x54>
4003af31:	8b 44 24 18          	mov    0x18(%esp),%eax
4003af35:	31 c9                	xor    %ecx,%ecx
4003af37:	eb 12                	jmp    4003af4b <_vfiprintf_r+0x1b4>
4003af39:	f7 da                	neg    %edx
4003af3b:	83 c8 02             	or     $0x2,%eax
4003af3e:	89 54 24 18          	mov    %edx,0x18(%esp)
4003af42:	89 44 24 0c          	mov    %eax,0xc(%esp)
4003af46:	e9 b9 fe ff ff       	jmp    4003ae04 <_vfiprintf_r+0x6d>
4003af4b:	0f be 13             	movsbl (%ebx),%edx
4003af4e:	83 ea 30             	sub    $0x30,%edx
4003af51:	83 fa 09             	cmp    $0x9,%edx
4003af54:	77 0a                	ja     4003af60 <_vfiprintf_r+0x1c9>
4003af56:	6b c0 0a             	imul   $0xa,%eax,%eax
4003af59:	43                   	inc    %ebx
4003af5a:	01 d0                	add    %edx,%eax
4003af5c:	b1 01                	mov    $0x1,%cl
4003af5e:	eb eb                	jmp    4003af4b <_vfiprintf_r+0x1b4>
4003af60:	84 c9                	test   %cl,%cl
4003af62:	0f 84 9d fe ff ff    	je     4003ae05 <_vfiprintf_r+0x6e>
4003af68:	89 44 24 18          	mov    %eax,0x18(%esp)
4003af6c:	e9 94 fe ff ff       	jmp    4003ae05 <_vfiprintf_r+0x6e>
4003af71:	8d 43 01             	lea    0x1(%ebx),%eax
4003af74:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
4003af78:	75 21                	jne    4003af9b <_vfiprintf_r+0x204>
4003af7a:	8b 44 24 7c          	mov    0x7c(%esp),%eax
4003af7e:	83 c3 02             	add    $0x2,%ebx
4003af81:	8d 50 04             	lea    0x4(%eax),%edx
4003af84:	8b 00                	mov    (%eax),%eax
4003af86:	89 54 24 7c          	mov    %edx,0x7c(%esp)
4003af8a:	85 c0                	test   %eax,%eax
4003af8c:	79 3c                	jns    4003afca <_vfiprintf_r+0x233>
4003af8e:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
4003af95:	ff 
4003af96:	e9 73 fe ff ff       	jmp    4003ae0e <_vfiprintf_r+0x77>
4003af9b:	89 c3                	mov    %eax,%ebx
4003af9d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
4003afa4:	00 
4003afa5:	31 c0                	xor    %eax,%eax
4003afa7:	0f be 13             	movsbl (%ebx),%edx
4003afaa:	83 ea 30             	sub    $0x30,%edx
4003afad:	83 fa 09             	cmp    $0x9,%edx
4003afb0:	77 0d                	ja     4003afbf <_vfiprintf_r+0x228>
4003afb2:	6b c0 0a             	imul   $0xa,%eax,%eax
4003afb5:	43                   	inc    %ebx
4003afb6:	01 d0                	add    %edx,%eax
4003afb8:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
4003afbd:	eb e8                	jmp    4003afa7 <_vfiprintf_r+0x210>
4003afbf:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
4003afc4:	0f 84 44 fe ff ff    	je     4003ae0e <_vfiprintf_r+0x77>
4003afca:	89 44 24 10          	mov    %eax,0x10(%esp)
4003afce:	e9 3b fe ff ff       	jmp    4003ae0e <_vfiprintf_r+0x77>
4003afd3:	8d 44 24 7c          	lea    0x7c(%esp),%eax
4003afd7:	89 f1                	mov    %esi,%ecx
4003afd9:	50                   	push   %eax
4003afda:	68 68 ad 03 40       	push   $0x4003ad68
4003afdf:	8d 54 24 14          	lea    0x14(%esp),%edx
4003afe3:	89 e8                	mov    %ebp,%eax
4003afe5:	e8 16 50 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
4003afea:	eb 17                	jmp    4003b003 <_vfiprintf_r+0x26c>
4003afec:	8d 44 24 7c          	lea    0x7c(%esp),%eax
4003aff0:	89 f1                	mov    %esi,%ecx
4003aff2:	50                   	push   %eax
4003aff3:	68 68 ad 03 40       	push   $0x4003ad68
4003aff8:	8d 54 24 14          	lea    0x14(%esp),%edx
4003affc:	89 e8                	mov    %ebp,%eax
4003affe:	e8 e7 05 00 00       	call   4003b5ea <_printf_i>
4003b003:	89 44 24 08          	mov    %eax,0x8(%esp)
4003b007:	58                   	pop    %eax
4003b008:	5a                   	pop    %edx
4003b009:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
4003b00d:	0f 85 57 fe ff ff    	jne    4003ae6a <_vfiprintf_r+0xd3>
4003b013:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
4003b017:	0f 85 c6 fd ff ff    	jne    4003ade3 <_vfiprintf_r+0x4c>
4003b01d:	8b 44 24 20          	mov    0x20(%esp),%eax
4003b021:	83 c4 68             	add    $0x68,%esp
4003b024:	5b                   	pop    %ebx
4003b025:	5e                   	pop    %esi
4003b026:	5f                   	pop    %edi
4003b027:	5d                   	pop    %ebp
4003b028:	c3                   	ret    

4003b029 <__swbuf_r>:
4003b029:	55                   	push   %ebp
4003b02a:	85 c0                	test   %eax,%eax
4003b02c:	57                   	push   %edi
4003b02d:	89 d5                	mov    %edx,%ebp
4003b02f:	56                   	push   %esi
4003b030:	89 c6                	mov    %eax,%esi
4003b032:	53                   	push   %ebx
4003b033:	89 cb                	mov    %ecx,%ebx
4003b035:	74 0b                	je     4003b042 <__swbuf_r+0x19>
4003b037:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003b03b:	75 05                	jne    4003b042 <__swbuf_r+0x19>
4003b03d:	e8 04 03 00 00       	call   4003b346 <__sinit>
4003b042:	8b 43 18             	mov    0x18(%ebx),%eax
4003b045:	f6 43 0c 08          	testb  $0x8,0xc(%ebx)
4003b049:	89 43 08             	mov    %eax,0x8(%ebx)
4003b04c:	74 17                	je     4003b065 <__swbuf_r+0x3c>
4003b04e:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003b052:	74 11                	je     4003b065 <__swbuf_r+0x3c>
4003b054:	89 e8                	mov    %ebp,%eax
4003b056:	0f b6 f8             	movzbl %al,%edi
4003b059:	8b 03                	mov    (%ebx),%eax
4003b05b:	2b 43 10             	sub    0x10(%ebx),%eax
4003b05e:	3b 43 14             	cmp    0x14(%ebx),%eax
4003b061:	7c 21                	jl     4003b084 <__swbuf_r+0x5b>
4003b063:	eb 12                	jmp    4003b077 <__swbuf_r+0x4e>
4003b065:	89 da                	mov    %ebx,%edx
4003b067:	89 f0                	mov    %esi,%eax
4003b069:	e8 49 00 00 00       	call   4003b0b7 <__swsetup_r>
4003b06e:	85 c0                	test   %eax,%eax
4003b070:	74 e2                	je     4003b054 <__swbuf_r+0x2b>
4003b072:	83 cf ff             	or     $0xffffffff,%edi
4003b075:	eb 39                	jmp    4003b0b0 <__swbuf_r+0x87>
4003b077:	89 da                	mov    %ebx,%edx
4003b079:	89 f0                	mov    %esi,%eax
4003b07b:	e8 23 02 00 00       	call   4003b2a3 <_fflush_r>
4003b080:	85 c0                	test   %eax,%eax
4003b082:	75 ee                	jne    4003b072 <__swbuf_r+0x49>
4003b084:	8b 13                	mov    (%ebx),%edx
4003b086:	ff 4b 08             	decl   0x8(%ebx)
4003b089:	8d 4a 01             	lea    0x1(%edx),%ecx
4003b08c:	40                   	inc    %eax
4003b08d:	89 0b                	mov    %ecx,(%ebx)
4003b08f:	89 e9                	mov    %ebp,%ecx
4003b091:	88 0a                	mov    %cl,(%edx)
4003b093:	3b 43 14             	cmp    0x14(%ebx),%eax
4003b096:	74 0b                	je     4003b0a3 <__swbuf_r+0x7a>
4003b098:	83 ff 0a             	cmp    $0xa,%edi
4003b09b:	75 13                	jne    4003b0b0 <__swbuf_r+0x87>
4003b09d:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
4003b0a1:	74 0d                	je     4003b0b0 <__swbuf_r+0x87>
4003b0a3:	89 da                	mov    %ebx,%edx
4003b0a5:	89 f0                	mov    %esi,%eax
4003b0a7:	e8 f7 01 00 00       	call   4003b2a3 <_fflush_r>
4003b0ac:	85 c0                	test   %eax,%eax
4003b0ae:	75 c2                	jne    4003b072 <__swbuf_r+0x49>
4003b0b0:	5b                   	pop    %ebx
4003b0b1:	89 f8                	mov    %edi,%eax
4003b0b3:	5e                   	pop    %esi
4003b0b4:	5f                   	pop    %edi
4003b0b5:	5d                   	pop    %ebp
4003b0b6:	c3                   	ret    

4003b0b7 <__swsetup_r>:
4003b0b7:	56                   	push   %esi
4003b0b8:	89 c6                	mov    %eax,%esi
4003b0ba:	53                   	push   %ebx
4003b0bb:	89 d3                	mov    %edx,%ebx
4003b0bd:	e8 76 fc ff ff       	call   4003ad38 <__getreent>
4003b0c2:	85 c0                	test   %eax,%eax
4003b0c4:	74 0b                	je     4003b0d1 <__swsetup_r+0x1a>
4003b0c6:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003b0ca:	75 05                	jne    4003b0d1 <__swsetup_r+0x1a>
4003b0cc:	e8 75 02 00 00       	call   4003b346 <__sinit>
4003b0d1:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b0d4:	a8 08                	test   $0x8,%al
4003b0d6:	75 4c                	jne    4003b124 <__swsetup_r+0x6d>
4003b0d8:	a8 10                	test   $0x10,%al
4003b0da:	75 12                	jne    4003b0ee <__swsetup_r+0x37>
4003b0dc:	83 c8 40             	or     $0x40,%eax
4003b0df:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
4003b0e5:	66 89 43 0c          	mov    %ax,0xc(%ebx)
4003b0e9:	e9 8c 00 00 00       	jmp    4003b17a <__swsetup_r+0xc3>
4003b0ee:	a8 04                	test   $0x4,%al
4003b0f0:	74 2d                	je     4003b11f <__swsetup_r+0x68>
4003b0f2:	8b 53 30             	mov    0x30(%ebx),%edx
4003b0f5:	85 d2                	test   %edx,%edx
4003b0f7:	74 15                	je     4003b10e <__swsetup_r+0x57>
4003b0f9:	8d 43 40             	lea    0x40(%ebx),%eax
4003b0fc:	39 c2                	cmp    %eax,%edx
4003b0fe:	74 07                	je     4003b107 <__swsetup_r+0x50>
4003b100:	89 f0                	mov    %esi,%eax
4003b102:	e8 e5 f9 ff ff       	call   4003aaec <_free_r>
4003b107:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
4003b10e:	66 83 63 0c db       	andw   $0xffdb,0xc(%ebx)
4003b113:	8b 43 10             	mov    0x10(%ebx),%eax
4003b116:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003b11d:	89 03                	mov    %eax,(%ebx)
4003b11f:	66 83 4b 0c 08       	orw    $0x8,0xc(%ebx)
4003b124:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003b128:	75 16                	jne    4003b140 <__swsetup_r+0x89>
4003b12a:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b12d:	66 25 80 02          	and    $0x280,%ax
4003b131:	66 3d 00 02          	cmp    $0x200,%ax
4003b135:	74 09                	je     4003b140 <__swsetup_r+0x89>
4003b137:	89 da                	mov    %ebx,%edx
4003b139:	89 f0                	mov    %esi,%eax
4003b13b:	e8 2e 03 00 00       	call   4003b46e <__smakebuf_r>
4003b140:	8b 53 0c             	mov    0xc(%ebx),%edx
4003b143:	f6 c2 01             	test   $0x1,%dl
4003b146:	74 11                	je     4003b159 <__swsetup_r+0xa2>
4003b148:	8b 43 14             	mov    0x14(%ebx),%eax
4003b14b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
4003b152:	f7 d8                	neg    %eax
4003b154:	89 43 18             	mov    %eax,0x18(%ebx)
4003b157:	eb 0d                	jmp    4003b166 <__swsetup_r+0xaf>
4003b159:	31 c0                	xor    %eax,%eax
4003b15b:	f6 c2 02             	test   $0x2,%dl
4003b15e:	75 03                	jne    4003b163 <__swsetup_r+0xac>
4003b160:	8b 43 14             	mov    0x14(%ebx),%eax
4003b163:	89 43 08             	mov    %eax,0x8(%ebx)
4003b166:	31 c0                	xor    %eax,%eax
4003b168:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003b16c:	75 0f                	jne    4003b17d <__swsetup_r+0xc6>
4003b16e:	f6 c2 80             	test   $0x80,%dl
4003b171:	74 0a                	je     4003b17d <__swsetup_r+0xc6>
4003b173:	83 ca 40             	or     $0x40,%edx
4003b176:	66 89 53 0c          	mov    %dx,0xc(%ebx)
4003b17a:	83 c8 ff             	or     $0xffffffff,%eax
4003b17d:	5b                   	pop    %ebx
4003b17e:	5e                   	pop    %esi
4003b17f:	c3                   	ret    

4003b180 <__sflush_r>:
4003b180:	55                   	push   %ebp
4003b181:	57                   	push   %edi
4003b182:	56                   	push   %esi
4003b183:	53                   	push   %ebx
4003b184:	89 c6                	mov    %eax,%esi
4003b186:	8b 42 0c             	mov    0xc(%edx),%eax
4003b189:	89 d3                	mov    %edx,%ebx
4003b18b:	a8 08                	test   $0x8,%al
4003b18d:	0f 85 cc 00 00 00    	jne    4003b25f <__sflush_r+0xdf>
4003b193:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
4003b197:	7f 0a                	jg     4003b1a3 <__sflush_r+0x23>
4003b199:	83 7a 3c 00          	cmpl   $0x0,0x3c(%edx)
4003b19d:	0f 8e b8 00 00 00    	jle    4003b25b <__sflush_r+0xdb>
4003b1a3:	8b 6b 28             	mov    0x28(%ebx),%ebp
4003b1a6:	85 ed                	test   %ebp,%ebp
4003b1a8:	0f 84 ad 00 00 00    	je     4003b25b <__sflush_r+0xdb>
4003b1ae:	8b 3e                	mov    (%esi),%edi
4003b1b0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
4003b1b6:	f6 c4 10             	test   $0x10,%ah
4003b1b9:	74 05                	je     4003b1c0 <__sflush_r+0x40>
4003b1bb:	8b 43 50             	mov    0x50(%ebx),%eax
4003b1be:	eb 29                	jmp    4003b1e9 <__sflush_r+0x69>
4003b1c0:	31 c9                	xor    %ecx,%ecx
4003b1c2:	8b 53 1c             	mov    0x1c(%ebx),%edx
4003b1c5:	89 f0                	mov    %esi,%eax
4003b1c7:	6a 01                	push   $0x1
4003b1c9:	ff d5                	call   *%ebp
4003b1cb:	5d                   	pop    %ebp
4003b1cc:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b1cf:	75 18                	jne    4003b1e9 <__sflush_r+0x69>
4003b1d1:	8b 16                	mov    (%esi),%edx
4003b1d3:	85 d2                	test   %edx,%edx
4003b1d5:	74 12                	je     4003b1e9 <__sflush_r+0x69>
4003b1d7:	83 fa 1d             	cmp    $0x1d,%edx
4003b1da:	74 09                	je     4003b1e5 <__sflush_r+0x65>
4003b1dc:	83 fa 16             	cmp    $0x16,%edx
4003b1df:	0f 85 95 00 00 00    	jne    4003b27a <__sflush_r+0xfa>
4003b1e5:	89 3e                	mov    %edi,(%esi)
4003b1e7:	eb 72                	jmp    4003b25b <__sflush_r+0xdb>
4003b1e9:	f6 43 0c 04          	testb  $0x4,0xc(%ebx)
4003b1ed:	74 0c                	je     4003b1fb <__sflush_r+0x7b>
4003b1ef:	2b 43 04             	sub    0x4(%ebx),%eax
4003b1f2:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
4003b1f6:	74 03                	je     4003b1fb <__sflush_r+0x7b>
4003b1f8:	2b 43 3c             	sub    0x3c(%ebx),%eax
4003b1fb:	89 c1                	mov    %eax,%ecx
4003b1fd:	8b 53 1c             	mov    0x1c(%ebx),%edx
4003b200:	89 f0                	mov    %esi,%eax
4003b202:	6a 00                	push   $0x0
4003b204:	ff 53 28             	call   *0x28(%ebx)
4003b207:	59                   	pop    %ecx
4003b208:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b20b:	75 11                	jne    4003b21e <__sflush_r+0x9e>
4003b20d:	8b 16                	mov    (%esi),%edx
4003b20f:	83 fa 1d             	cmp    $0x1d,%edx
4003b212:	77 66                	ja     4003b27a <__sflush_r+0xfa>
4003b214:	b9 01 00 40 20       	mov    $0x20400001,%ecx
4003b219:	0f a3 d1             	bt     %edx,%ecx
4003b21c:	73 5c                	jae    4003b27a <__sflush_r+0xfa>
4003b21e:	8b 53 10             	mov    0x10(%ebx),%edx
4003b221:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003b228:	89 13                	mov    %edx,(%ebx)
4003b22a:	f6 43 0d 10          	testb  $0x10,0xd(%ebx)
4003b22e:	74 0d                	je     4003b23d <__sflush_r+0xbd>
4003b230:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b233:	75 05                	jne    4003b23a <__sflush_r+0xba>
4003b235:	83 3e 00             	cmpl   $0x0,(%esi)
4003b238:	75 03                	jne    4003b23d <__sflush_r+0xbd>
4003b23a:	89 43 50             	mov    %eax,0x50(%ebx)
4003b23d:	8b 53 30             	mov    0x30(%ebx),%edx
4003b240:	89 3e                	mov    %edi,(%esi)
4003b242:	85 d2                	test   %edx,%edx
4003b244:	74 15                	je     4003b25b <__sflush_r+0xdb>
4003b246:	8d 43 40             	lea    0x40(%ebx),%eax
4003b249:	39 c2                	cmp    %eax,%edx
4003b24b:	74 07                	je     4003b254 <__sflush_r+0xd4>
4003b24d:	89 f0                	mov    %esi,%eax
4003b24f:	e8 98 f8 ff ff       	call   4003aaec <_free_r>
4003b254:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
4003b25b:	31 c0                	xor    %eax,%eax
4003b25d:	eb 3f                	jmp    4003b29e <__sflush_r+0x11e>
4003b25f:	8b 6a 10             	mov    0x10(%edx),%ebp
4003b262:	85 ed                	test   %ebp,%ebp
4003b264:	74 f5                	je     4003b25b <__sflush_r+0xdb>
4003b266:	8b 3a                	mov    (%edx),%edi
4003b268:	89 2a                	mov    %ebp,(%edx)
4003b26a:	29 ef                	sub    %ebp,%edi
4003b26c:	31 d2                	xor    %edx,%edx
4003b26e:	a8 03                	test   $0x3,%al
4003b270:	75 03                	jne    4003b275 <__sflush_r+0xf5>
4003b272:	8b 53 14             	mov    0x14(%ebx),%edx
4003b275:	89 53 08             	mov    %edx,0x8(%ebx)
4003b278:	eb 1e                	jmp    4003b298 <__sflush_r+0x118>
4003b27a:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
4003b27f:	83 c8 ff             	or     $0xffffffff,%eax
4003b282:	eb 1a                	jmp    4003b29e <__sflush_r+0x11e>
4003b284:	8b 53 1c             	mov    0x1c(%ebx),%edx
4003b287:	89 e9                	mov    %ebp,%ecx
4003b289:	89 f0                	mov    %esi,%eax
4003b28b:	57                   	push   %edi
4003b28c:	ff 53 24             	call   *0x24(%ebx)
4003b28f:	5a                   	pop    %edx
4003b290:	85 c0                	test   %eax,%eax
4003b292:	7e e6                	jle    4003b27a <__sflush_r+0xfa>
4003b294:	01 c5                	add    %eax,%ebp
4003b296:	29 c7                	sub    %eax,%edi
4003b298:	85 ff                	test   %edi,%edi
4003b29a:	7f e8                	jg     4003b284 <__sflush_r+0x104>
4003b29c:	eb bd                	jmp    4003b25b <__sflush_r+0xdb>
4003b29e:	5b                   	pop    %ebx
4003b29f:	5e                   	pop    %esi
4003b2a0:	5f                   	pop    %edi
4003b2a1:	5d                   	pop    %ebp
4003b2a2:	c3                   	ret    

4003b2a3 <_fflush_r>:
4003b2a3:	53                   	push   %ebx
4003b2a4:	85 c0                	test   %eax,%eax
4003b2a6:	53                   	push   %ebx
4003b2a7:	89 c3                	mov    %eax,%ebx
4003b2a9:	74 11                	je     4003b2bc <_fflush_r+0x19>
4003b2ab:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003b2af:	75 0b                	jne    4003b2bc <_fflush_r+0x19>
4003b2b1:	89 14 24             	mov    %edx,(%esp)
4003b2b4:	e8 8d 00 00 00       	call   4003b346 <__sinit>
4003b2b9:	8b 14 24             	mov    (%esp),%edx
4003b2bc:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
4003b2c1:	74 09                	je     4003b2cc <_fflush_r+0x29>
4003b2c3:	89 d8                	mov    %ebx,%eax
4003b2c5:	59                   	pop    %ecx
4003b2c6:	5b                   	pop    %ebx
4003b2c7:	e9 b4 fe ff ff       	jmp    4003b180 <__sflush_r>
4003b2cc:	31 c0                	xor    %eax,%eax
4003b2ce:	5a                   	pop    %edx
4003b2cf:	5b                   	pop    %ebx
4003b2d0:	c3                   	ret    

4003b2d1 <_cleanup_r>:
4003b2d1:	ba a3 b2 03 40       	mov    $0x4003b2a3,%edx
4003b2d6:	e9 d7 00 00 00       	jmp    4003b3b2 <_fwalk_reent>

4003b2db <std.isra.0>:
4003b2db:	53                   	push   %ebx
4003b2dc:	89 c3                	mov    %eax,%ebx
4003b2de:	66 89 50 0c          	mov    %dx,0xc(%eax)
4003b2e2:	66 89 48 0e          	mov    %cx,0xe(%eax)
4003b2e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
4003b2ec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
4003b2f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
4003b2fa:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
4003b301:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
4003b308:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
4003b30f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
4003b316:	b9 08 00 00 00       	mov    $0x8,%ecx
4003b31b:	8d 40 5c             	lea    0x5c(%eax),%eax
4003b31e:	31 d2                	xor    %edx,%edx
4003b320:	e8 50 4d ff ff       	call   40030075 <memset>
4003b325:	89 5b 1c             	mov    %ebx,0x1c(%ebx)
4003b328:	c7 43 20 83 b8 03 40 	movl   $0x4003b883,0x20(%ebx)
4003b32f:	c7 43 24 a5 b8 03 40 	movl   $0x4003b8a5,0x24(%ebx)
4003b336:	c7 43 28 e2 b8 03 40 	movl   $0x4003b8e2,0x28(%ebx)
4003b33d:	c7 43 2c 0b b9 03 40 	movl   $0x4003b90b,0x2c(%ebx)
4003b344:	5b                   	pop    %ebx
4003b345:	c3                   	ret    

4003b346 <__sinit>:
4003b346:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003b34a:	75 65                	jne    4003b3b1 <__sinit+0x6b>
4003b34c:	53                   	push   %ebx
4003b34d:	89 c3                	mov    %eax,%ebx
4003b34f:	c7 40 3c d1 b2 03 40 	movl   $0x4003b2d1,0x3c(%eax)
4003b356:	c7 80 4c 01 00 00 00 	movl   $0x0,0x14c(%eax)
4003b35d:	00 00 00 
4003b360:	c7 80 50 01 00 00 03 	movl   $0x3,0x150(%eax)
4003b367:	00 00 00 
4003b36a:	8d 80 58 01 00 00    	lea    0x158(%eax),%eax
4003b370:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
4003b376:	31 c9                	xor    %ecx,%ecx
4003b378:	8b 43 04             	mov    0x4(%ebx),%eax
4003b37b:	ba 04 00 00 00       	mov    $0x4,%edx
4003b380:	e8 56 ff ff ff       	call   4003b2db <std.isra.0>
4003b385:	8b 43 08             	mov    0x8(%ebx),%eax
4003b388:	b9 01 00 00 00       	mov    $0x1,%ecx
4003b38d:	ba 09 00 00 00       	mov    $0x9,%edx
4003b392:	e8 44 ff ff ff       	call   4003b2db <std.isra.0>
4003b397:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b39a:	b9 02 00 00 00       	mov    $0x2,%ecx
4003b39f:	ba 12 00 00 00       	mov    $0x12,%edx
4003b3a4:	e8 32 ff ff ff       	call   4003b2db <std.isra.0>
4003b3a9:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
4003b3b0:	5b                   	pop    %ebx
4003b3b1:	c3                   	ret    

4003b3b2 <_fwalk_reent>:
4003b3b2:	55                   	push   %ebp
4003b3b3:	57                   	push   %edi
4003b3b4:	56                   	push   %esi
4003b3b5:	53                   	push   %ebx
4003b3b6:	83 ec 08             	sub    $0x8,%esp
4003b3b9:	89 c5                	mov    %eax,%ebp
4003b3bb:	89 d1                	mov    %edx,%ecx
4003b3bd:	8d 98 4c 01 00 00    	lea    0x14c(%eax),%ebx
4003b3c3:	31 ff                	xor    %edi,%edi
4003b3c5:	85 db                	test   %ebx,%ebx
4003b3c7:	74 35                	je     4003b3fe <_fwalk_reent+0x4c>
4003b3c9:	8b 43 04             	mov    0x4(%ebx),%eax
4003b3cc:	8b 73 08             	mov    0x8(%ebx),%esi
4003b3cf:	89 04 24             	mov    %eax,(%esp)
4003b3d2:	ff 0c 24             	decl   (%esp)
4003b3d5:	78 23                	js     4003b3fa <_fwalk_reent+0x48>
4003b3d7:	66 83 7e 0c 01       	cmpw   $0x1,0xc(%esi)
4003b3dc:	76 17                	jbe    4003b3f5 <_fwalk_reent+0x43>
4003b3de:	66 83 7e 0e ff       	cmpw   $0xffff,0xe(%esi)
4003b3e3:	74 10                	je     4003b3f5 <_fwalk_reent+0x43>
4003b3e5:	89 f2                	mov    %esi,%edx
4003b3e7:	89 e8                	mov    %ebp,%eax
4003b3e9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4003b3ed:	ff d1                	call   *%ecx
4003b3ef:	8b 4c 24 04          	mov    0x4(%esp),%ecx
4003b3f3:	09 c7                	or     %eax,%edi
4003b3f5:	83 c6 68             	add    $0x68,%esi
4003b3f8:	eb d8                	jmp    4003b3d2 <_fwalk_reent+0x20>
4003b3fa:	8b 1b                	mov    (%ebx),%ebx
4003b3fc:	eb c7                	jmp    4003b3c5 <_fwalk_reent+0x13>
4003b3fe:	83 c4 08             	add    $0x8,%esp
4003b401:	89 f8                	mov    %edi,%eax
4003b403:	5b                   	pop    %ebx
4003b404:	5e                   	pop    %esi
4003b405:	5f                   	pop    %edi
4003b406:	5d                   	pop    %ebp
4003b407:	c3                   	ret    

4003b408 <__swhatbuf_r>:
4003b408:	57                   	push   %edi
4003b409:	56                   	push   %esi
4003b40a:	53                   	push   %ebx
4003b40b:	89 d7                	mov    %edx,%edi
4003b40d:	83 ec 3c             	sub    $0x3c,%esp
4003b410:	89 cb                	mov    %ecx,%ebx
4003b412:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003b416:	66 85 d2             	test   %dx,%dx
4003b419:	8b 74 24 4c          	mov    0x4c(%esp),%esi
4003b41d:	79 1f                	jns    4003b43e <__swhatbuf_r+0x36>
4003b41f:	8b 47 0c             	mov    0xc(%edi),%eax
4003b422:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
4003b428:	66 25 80 00          	and    $0x80,%ax
4003b42c:	66 83 f8 01          	cmp    $0x1,%ax
4003b430:	19 c0                	sbb    %eax,%eax
4003b432:	25 c0 03 00 00       	and    $0x3c0,%eax
4003b437:	83 c0 40             	add    $0x40,%eax
4003b43a:	89 03                	mov    %eax,(%ebx)
4003b43c:	eb 27                	jmp    4003b465 <__swhatbuf_r+0x5d>
4003b43e:	89 e1                	mov    %esp,%ecx
4003b440:	e8 23 05 00 00       	call   4003b968 <_fstat_r>
4003b445:	85 c0                	test   %eax,%eax
4003b447:	78 d6                	js     4003b41f <__swhatbuf_r+0x17>
4003b449:	8b 44 24 04          	mov    0x4(%esp),%eax
4003b44d:	25 00 f0 00 00       	and    $0xf000,%eax
4003b452:	3d 00 20 00 00       	cmp    $0x2000,%eax
4003b457:	0f 94 c0             	sete   %al
4003b45a:	0f b6 c0             	movzbl %al,%eax
4003b45d:	89 06                	mov    %eax,(%esi)
4003b45f:	c7 03 00 04 00 00    	movl   $0x400,(%ebx)
4003b465:	83 c4 3c             	add    $0x3c,%esp
4003b468:	31 c0                	xor    %eax,%eax
4003b46a:	5b                   	pop    %ebx
4003b46b:	5e                   	pop    %esi
4003b46c:	5f                   	pop    %edi
4003b46d:	c3                   	ret    

4003b46e <__smakebuf_r>:
4003b46e:	f6 42 0c 02          	testb  $0x2,0xc(%edx)
4003b472:	74 10                	je     4003b484 <__smakebuf_r+0x16>
4003b474:	8d 42 43             	lea    0x43(%edx),%eax
4003b477:	c7 42 14 01 00 00 00 	movl   $0x1,0x14(%edx)
4003b47e:	89 02                	mov    %eax,(%edx)
4003b480:	89 42 10             	mov    %eax,0x10(%edx)
4003b483:	c3                   	ret    
4003b484:	57                   	push   %edi
4003b485:	56                   	push   %esi
4003b486:	53                   	push   %ebx
4003b487:	89 c6                	mov    %eax,%esi
4003b489:	83 ec 08             	sub    $0x8,%esp
4003b48c:	89 d3                	mov    %edx,%ebx
4003b48e:	8d 44 24 04          	lea    0x4(%esp),%eax
4003b492:	50                   	push   %eax
4003b493:	89 f0                	mov    %esi,%eax
4003b495:	8d 4c 24 04          	lea    0x4(%esp),%ecx
4003b499:	e8 6a ff ff ff       	call   4003b408 <__swhatbuf_r>
4003b49e:	8b 54 24 04          	mov    0x4(%esp),%edx
4003b4a2:	89 c7                	mov    %eax,%edi
4003b4a4:	89 f0                	mov    %esi,%eax
4003b4a6:	e8 fa f6 ff ff       	call   4003aba5 <_malloc_r>
4003b4ab:	5a                   	pop    %edx
4003b4ac:	85 c0                	test   %eax,%eax
4003b4ae:	75 20                	jne    4003b4d0 <__smakebuf_r+0x62>
4003b4b0:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b4b3:	f6 c4 02             	test   $0x2,%ah
4003b4b6:	75 4f                	jne    4003b507 <__smakebuf_r+0x99>
4003b4b8:	83 c8 02             	or     $0x2,%eax
4003b4bb:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
4003b4c2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
4003b4c6:	8d 43 43             	lea    0x43(%ebx),%eax
4003b4c9:	89 03                	mov    %eax,(%ebx)
4003b4cb:	89 43 10             	mov    %eax,0x10(%ebx)
4003b4ce:	eb 37                	jmp    4003b507 <__smakebuf_r+0x99>
4003b4d0:	c7 46 3c d1 b2 03 40 	movl   $0x4003b2d1,0x3c(%esi)
4003b4d7:	89 03                	mov    %eax,(%ebx)
4003b4d9:	89 43 10             	mov    %eax,0x10(%ebx)
4003b4dc:	8b 04 24             	mov    (%esp),%eax
4003b4df:	66 81 4b 0c 80 00    	orw    $0x80,0xc(%ebx)
4003b4e5:	89 43 14             	mov    %eax,0x14(%ebx)
4003b4e8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
4003b4ed:	74 14                	je     4003b503 <__smakebuf_r+0x95>
4003b4ef:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
4003b4f3:	89 f0                	mov    %esi,%eax
4003b4f5:	e8 97 04 00 00       	call   4003b991 <_isatty_r>
4003b4fa:	85 c0                	test   %eax,%eax
4003b4fc:	74 05                	je     4003b503 <__smakebuf_r+0x95>
4003b4fe:	66 83 4b 0c 01       	orw    $0x1,0xc(%ebx)
4003b503:	66 09 7b 0c          	or     %di,0xc(%ebx)
4003b507:	83 c4 08             	add    $0x8,%esp
4003b50a:	5b                   	pop    %ebx
4003b50b:	5e                   	pop    %esi
4003b50c:	5f                   	pop    %edi
4003b50d:	c3                   	ret    

4003b50e <_printf_common>:
4003b50e:	55                   	push   %ebp
4003b50f:	57                   	push   %edi
4003b510:	56                   	push   %esi
4003b511:	53                   	push   %ebx
4003b512:	53                   	push   %ebx
4003b513:	89 d3                	mov    %edx,%ebx
4003b515:	89 c5                	mov    %eax,%ebp
4003b517:	8b 52 08             	mov    0x8(%edx),%edx
4003b51a:	8b 43 10             	mov    0x10(%ebx),%eax
4003b51d:	89 ce                	mov    %ecx,%esi
4003b51f:	39 d0                	cmp    %edx,%eax
4003b521:	7d 02                	jge    4003b525 <_printf_common+0x17>
4003b523:	89 d0                	mov    %edx,%eax
4003b525:	89 06                	mov    %eax,(%esi)
4003b527:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
4003b52b:	74 03                	je     4003b530 <_printf_common+0x22>
4003b52d:	40                   	inc    %eax
4003b52e:	89 06                	mov    %eax,(%esi)
4003b530:	f6 03 20             	testb  $0x20,(%ebx)
4003b533:	74 03                	je     4003b538 <_printf_common+0x2a>
4003b535:	83 06 02             	addl   $0x2,(%esi)
4003b538:	8b 3b                	mov    (%ebx),%edi
4003b53a:	83 e7 06             	and    $0x6,%edi
4003b53d:	75 26                	jne    4003b565 <_printf_common+0x57>
4003b53f:	8d 43 19             	lea    0x19(%ebx),%eax
4003b542:	89 04 24             	mov    %eax,(%esp)
4003b545:	eb 15                	jmp    4003b55c <_printf_common+0x4e>
4003b547:	6a 01                	push   $0x1
4003b549:	89 e8                	mov    %ebp,%eax
4003b54b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
4003b54f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
4003b553:	ff 54 24 20          	call   *0x20(%esp)
4003b557:	5a                   	pop    %edx
4003b558:	40                   	inc    %eax
4003b559:	74 3c                	je     4003b597 <_printf_common+0x89>
4003b55b:	47                   	inc    %edi
4003b55c:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b55f:	2b 06                	sub    (%esi),%eax
4003b561:	39 c7                	cmp    %eax,%edi
4003b563:	7c e2                	jl     4003b547 <_printf_common+0x39>
4003b565:	31 c0                	xor    %eax,%eax
4003b567:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
4003b56b:	0f 95 c0             	setne  %al
4003b56e:	f6 03 20             	testb  $0x20,(%ebx)
4003b571:	74 12                	je     4003b585 <_printf_common+0x77>
4003b573:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
4003b578:	8d 50 01             	lea    0x1(%eax),%edx
4003b57b:	8a 4b 45             	mov    0x45(%ebx),%cl
4003b57e:	83 c0 02             	add    $0x2,%eax
4003b581:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
4003b585:	50                   	push   %eax
4003b586:	8d 4b 43             	lea    0x43(%ebx),%ecx
4003b589:	8b 54 24 1c          	mov    0x1c(%esp),%edx
4003b58d:	89 e8                	mov    %ebp,%eax
4003b58f:	ff 54 24 20          	call   *0x20(%esp)
4003b593:	5f                   	pop    %edi
4003b594:	40                   	inc    %eax
4003b595:	75 05                	jne    4003b59c <_printf_common+0x8e>
4003b597:	83 c8 ff             	or     $0xffffffff,%eax
4003b59a:	eb 48                	jmp    4003b5e4 <_printf_common+0xd6>
4003b59c:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b59f:	2b 06                	sub    (%esi),%eax
4003b5a1:	89 c6                	mov    %eax,%esi
4003b5a3:	8b 03                	mov    (%ebx),%eax
4003b5a5:	83 e0 06             	and    $0x6,%eax
4003b5a8:	83 f8 04             	cmp    $0x4,%eax
4003b5ab:	75 07                	jne    4003b5b4 <_printf_common+0xa6>
4003b5ad:	89 f0                	mov    %esi,%eax
4003b5af:	c1 e8 1f             	shr    $0x1f,%eax
4003b5b2:	74 02                	je     4003b5b6 <_printf_common+0xa8>
4003b5b4:	31 f6                	xor    %esi,%esi
4003b5b6:	8b 43 08             	mov    0x8(%ebx),%eax
4003b5b9:	8b 53 10             	mov    0x10(%ebx),%edx
4003b5bc:	39 d0                	cmp    %edx,%eax
4003b5be:	7e 04                	jle    4003b5c4 <_printf_common+0xb6>
4003b5c0:	29 d0                	sub    %edx,%eax
4003b5c2:	01 c6                	add    %eax,%esi
4003b5c4:	31 ff                	xor    %edi,%edi
4003b5c6:	83 c3 1a             	add    $0x1a,%ebx
4003b5c9:	39 fe                	cmp    %edi,%esi
4003b5cb:	74 15                	je     4003b5e2 <_printf_common+0xd4>
4003b5cd:	6a 01                	push   $0x1
4003b5cf:	89 d9                	mov    %ebx,%ecx
4003b5d1:	8b 54 24 1c          	mov    0x1c(%esp),%edx
4003b5d5:	89 e8                	mov    %ebp,%eax
4003b5d7:	ff 54 24 20          	call   *0x20(%esp)
4003b5db:	59                   	pop    %ecx
4003b5dc:	40                   	inc    %eax
4003b5dd:	74 b8                	je     4003b597 <_printf_common+0x89>
4003b5df:	47                   	inc    %edi
4003b5e0:	eb e7                	jmp    4003b5c9 <_printf_common+0xbb>
4003b5e2:	31 c0                	xor    %eax,%eax
4003b5e4:	5a                   	pop    %edx
4003b5e5:	5b                   	pop    %ebx
4003b5e6:	5e                   	pop    %esi
4003b5e7:	5f                   	pop    %edi
4003b5e8:	5d                   	pop    %ebp
4003b5e9:	c3                   	ret    

4003b5ea <_printf_i>:
4003b5ea:	55                   	push   %ebp
4003b5eb:	57                   	push   %edi
4003b5ec:	56                   	push   %esi
4003b5ed:	53                   	push   %ebx
4003b5ee:	83 ec 0c             	sub    $0xc,%esp
4003b5f1:	89 d3                	mov    %edx,%ebx
4003b5f3:	8d 6a 43             	lea    0x43(%edx),%ebp
4003b5f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4003b5fa:	8a 4a 18             	mov    0x18(%edx),%cl
4003b5fd:	89 04 24             	mov    %eax,(%esp)
4003b600:	80 f9 6e             	cmp    $0x6e,%cl
4003b603:	8b 44 24 24          	mov    0x24(%esp),%eax
4003b607:	0f 84 83 01 00 00    	je     4003b790 <_printf_i+0x1a6>
4003b60d:	7f 35                	jg     4003b644 <_printf_i+0x5a>
4003b60f:	80 f9 63             	cmp    $0x63,%cl
4003b612:	74 60                	je     4003b674 <_printf_i+0x8a>
4003b614:	7f 1f                	jg     4003b635 <_printf_i+0x4b>
4003b616:	84 c9                	test   %cl,%cl
4003b618:	0f 84 9d 01 00 00    	je     4003b7bb <_printf_i+0x1d1>
4003b61e:	80 f9 58             	cmp    $0x58,%cl
4003b621:	0f 85 c5 01 00 00    	jne    4003b7ec <_printf_i+0x202>
4003b627:	c6 42 45 58          	movb   $0x58,0x45(%edx)
4003b62b:	bf 83 d2 03 40       	mov    $0x4003d283,%edi
4003b630:	e9 c2 00 00 00       	jmp    4003b6f7 <_printf_i+0x10d>
4003b635:	80 f9 64             	cmp    $0x64,%cl
4003b638:	74 4e                	je     4003b688 <_printf_i+0x9e>
4003b63a:	80 f9 69             	cmp    $0x69,%cl
4003b63d:	74 49                	je     4003b688 <_printf_i+0x9e>
4003b63f:	e9 a8 01 00 00       	jmp    4003b7ec <_printf_i+0x202>
4003b644:	80 f9 73             	cmp    $0x73,%cl
4003b647:	0f 84 79 01 00 00    	je     4003b7c6 <_printf_i+0x1dc>
4003b64d:	7f 16                	jg     4003b665 <_printf_i+0x7b>
4003b64f:	80 f9 6f             	cmp    $0x6f,%cl
4003b652:	74 65                	je     4003b6b9 <_printf_i+0xcf>
4003b654:	80 f9 70             	cmp    $0x70,%cl
4003b657:	0f 85 8f 01 00 00    	jne    4003b7ec <_printf_i+0x202>
4003b65d:	83 0a 20             	orl    $0x20,(%edx)
4003b660:	e9 89 00 00 00       	jmp    4003b6ee <_printf_i+0x104>
4003b665:	80 f9 75             	cmp    $0x75,%cl
4003b668:	74 4f                	je     4003b6b9 <_printf_i+0xcf>
4003b66a:	80 f9 78             	cmp    $0x78,%cl
4003b66d:	74 7f                	je     4003b6ee <_printf_i+0x104>
4003b66f:	e9 78 01 00 00       	jmp    4003b7ec <_printf_i+0x202>
4003b674:	8d 72 42             	lea    0x42(%edx),%esi
4003b677:	8b 10                	mov    (%eax),%edx
4003b679:	8d 4a 04             	lea    0x4(%edx),%ecx
4003b67c:	89 08                	mov    %ecx,(%eax)
4003b67e:	8b 02                	mov    (%edx),%eax
4003b680:	88 43 42             	mov    %al,0x42(%ebx)
4003b683:	e9 6a 01 00 00       	jmp    4003b7f2 <_printf_i+0x208>
4003b688:	8b 0b                	mov    (%ebx),%ecx
4003b68a:	8b 10                	mov    (%eax),%edx
4003b68c:	f6 c1 80             	test   $0x80,%cl
4003b68f:	74 07                	je     4003b698 <_printf_i+0xae>
4003b691:	8d 4a 04             	lea    0x4(%edx),%ecx
4003b694:	89 08                	mov    %ecx,(%eax)
4003b696:	eb 0f                	jmp    4003b6a7 <_printf_i+0xbd>
4003b698:	80 e1 40             	and    $0x40,%cl
4003b69b:	8d 4a 04             	lea    0x4(%edx),%ecx
4003b69e:	89 08                	mov    %ecx,(%eax)
4003b6a0:	74 05                	je     4003b6a7 <_printf_i+0xbd>
4003b6a2:	0f bf 02             	movswl (%edx),%eax
4003b6a5:	eb 02                	jmp    4003b6a9 <_printf_i+0xbf>
4003b6a7:	8b 02                	mov    (%edx),%eax
4003b6a9:	85 c0                	test   %eax,%eax
4003b6ab:	0f 89 83 00 00 00    	jns    4003b734 <_printf_i+0x14a>
4003b6b1:	f7 d8                	neg    %eax
4003b6b3:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
4003b6b7:	eb 7b                	jmp    4003b734 <_printf_i+0x14a>
4003b6b9:	8b 33                	mov    (%ebx),%esi
4003b6bb:	8b 10                	mov    (%eax),%edx
4003b6bd:	f7 c6 80 00 00 00    	test   $0x80,%esi
4003b6c3:	74 07                	je     4003b6cc <_printf_i+0xe2>
4003b6c5:	8d 72 04             	lea    0x4(%edx),%esi
4003b6c8:	89 30                	mov    %esi,(%eax)
4003b6ca:	eb 0f                	jmp    4003b6db <_printf_i+0xf1>
4003b6cc:	83 e6 40             	and    $0x40,%esi
4003b6cf:	8d 72 04             	lea    0x4(%edx),%esi
4003b6d2:	89 30                	mov    %esi,(%eax)
4003b6d4:	74 05                	je     4003b6db <_printf_i+0xf1>
4003b6d6:	0f b7 02             	movzwl (%edx),%eax
4003b6d9:	eb 02                	jmp    4003b6dd <_printf_i+0xf3>
4003b6db:	8b 02                	mov    (%edx),%eax
4003b6dd:	bf 83 d2 03 40       	mov    $0x4003d283,%edi
4003b6e2:	80 f9 6f             	cmp    $0x6f,%cl
4003b6e5:	74 42                	je     4003b729 <_printf_i+0x13f>
4003b6e7:	b9 0a 00 00 00       	mov    $0xa,%ecx
4003b6ec:	eb 40                	jmp    4003b72e <_printf_i+0x144>
4003b6ee:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
4003b6f2:	bf 94 d2 03 40       	mov    $0x4003d294,%edi
4003b6f7:	8b 08                	mov    (%eax),%ecx
4003b6f9:	8b 13                	mov    (%ebx),%edx
4003b6fb:	f6 c2 80             	test   $0x80,%dl
4003b6fe:	8d 71 04             	lea    0x4(%ecx),%esi
4003b701:	89 30                	mov    %esi,(%eax)
4003b703:	75 0a                	jne    4003b70f <_printf_i+0x125>
4003b705:	f6 c2 40             	test   $0x40,%dl
4003b708:	74 05                	je     4003b70f <_printf_i+0x125>
4003b70a:	0f b7 01             	movzwl (%ecx),%eax
4003b70d:	eb 02                	jmp    4003b711 <_printf_i+0x127>
4003b70f:	8b 01                	mov    (%ecx),%eax
4003b711:	f6 c2 01             	test   $0x1,%dl
4003b714:	74 05                	je     4003b71b <_printf_i+0x131>
4003b716:	83 ca 20             	or     $0x20,%edx
4003b719:	89 13                	mov    %edx,(%ebx)
4003b71b:	b9 10 00 00 00       	mov    $0x10,%ecx
4003b720:	85 c0                	test   %eax,%eax
4003b722:	75 0a                	jne    4003b72e <_printf_i+0x144>
4003b724:	83 23 df             	andl   $0xffffffdf,(%ebx)
4003b727:	eb 05                	jmp    4003b72e <_printf_i+0x144>
4003b729:	b9 08 00 00 00       	mov    $0x8,%ecx
4003b72e:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
4003b732:	eb 0a                	jmp    4003b73e <_printf_i+0x154>
4003b734:	bf 83 d2 03 40       	mov    $0x4003d283,%edi
4003b739:	b9 0a 00 00 00       	mov    $0xa,%ecx
4003b73e:	8b 53 04             	mov    0x4(%ebx),%edx
4003b741:	89 53 08             	mov    %edx,0x8(%ebx)
4003b744:	85 d2                	test   %edx,%edx
4003b746:	78 12                	js     4003b75a <_printf_i+0x170>
4003b748:	83 23 fb             	andl   $0xfffffffb,(%ebx)
4003b74b:	85 c0                	test   %eax,%eax
4003b74d:	75 13                	jne    4003b762 <_printf_i+0x178>
4003b74f:	89 ee                	mov    %ebp,%esi
4003b751:	85 d2                	test   %edx,%edx
4003b753:	74 1d                	je     4003b772 <_printf_i+0x188>
4003b755:	e9 14 01 00 00       	jmp    4003b86e <_printf_i+0x284>
4003b75a:	85 c0                	test   %eax,%eax
4003b75c:	0f 84 0c 01 00 00    	je     4003b86e <_printf_i+0x284>
4003b762:	89 ee                	mov    %ebp,%esi
4003b764:	31 d2                	xor    %edx,%edx
4003b766:	4e                   	dec    %esi
4003b767:	f7 f1                	div    %ecx
4003b769:	85 c0                	test   %eax,%eax
4003b76b:	8a 14 17             	mov    (%edi,%edx,1),%dl
4003b76e:	88 16                	mov    %dl,(%esi)
4003b770:	75 f2                	jne    4003b764 <_printf_i+0x17a>
4003b772:	83 f9 08             	cmp    $0x8,%ecx
4003b775:	75 12                	jne    4003b789 <_printf_i+0x19f>
4003b777:	f6 03 01             	testb  $0x1,(%ebx)
4003b77a:	74 0d                	je     4003b789 <_printf_i+0x19f>
4003b77c:	8b 43 10             	mov    0x10(%ebx),%eax
4003b77f:	39 43 04             	cmp    %eax,0x4(%ebx)
4003b782:	7f 05                	jg     4003b789 <_printf_i+0x19f>
4003b784:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
4003b788:	4e                   	dec    %esi
4003b789:	29 f5                	sub    %esi,%ebp
4003b78b:	89 6b 10             	mov    %ebp,0x10(%ebx)
4003b78e:	eb 6d                	jmp    4003b7fd <_printf_i+0x213>
4003b790:	8b 32                	mov    (%edx),%esi
4003b792:	8b 4b 14             	mov    0x14(%ebx),%ecx
4003b795:	f7 c6 80 00 00 00    	test   $0x80,%esi
4003b79b:	8b 10                	mov    (%eax),%edx
4003b79d:	74 09                	je     4003b7a8 <_printf_i+0x1be>
4003b79f:	8d 72 04             	lea    0x4(%edx),%esi
4003b7a2:	89 30                	mov    %esi,(%eax)
4003b7a4:	8b 02                	mov    (%edx),%eax
4003b7a6:	eb 11                	jmp    4003b7b9 <_printf_i+0x1cf>
4003b7a8:	83 e6 40             	and    $0x40,%esi
4003b7ab:	8d 72 04             	lea    0x4(%edx),%esi
4003b7ae:	89 30                	mov    %esi,(%eax)
4003b7b0:	8b 02                	mov    (%edx),%eax
4003b7b2:	74 05                	je     4003b7b9 <_printf_i+0x1cf>
4003b7b4:	66 89 08             	mov    %cx,(%eax)
4003b7b7:	eb 02                	jmp    4003b7bb <_printf_i+0x1d1>
4003b7b9:	89 08                	mov    %ecx,(%eax)
4003b7bb:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
4003b7c2:	89 ee                	mov    %ebp,%esi
4003b7c4:	eb 37                	jmp    4003b7fd <_printf_i+0x213>
4003b7c6:	8b 10                	mov    (%eax),%edx
4003b7c8:	8d 4a 04             	lea    0x4(%edx),%ecx
4003b7cb:	89 08                	mov    %ecx,(%eax)
4003b7cd:	8b 4b 04             	mov    0x4(%ebx),%ecx
4003b7d0:	8b 32                	mov    (%edx),%esi
4003b7d2:	31 d2                	xor    %edx,%edx
4003b7d4:	89 f0                	mov    %esi,%eax
4003b7d6:	e8 a8 48 ff ff       	call   40030083 <memchr>
4003b7db:	85 c0                	test   %eax,%eax
4003b7dd:	74 05                	je     4003b7e4 <_printf_i+0x1fa>
4003b7df:	29 f0                	sub    %esi,%eax
4003b7e1:	89 43 04             	mov    %eax,0x4(%ebx)
4003b7e4:	8b 43 04             	mov    0x4(%ebx),%eax
4003b7e7:	89 43 10             	mov    %eax,0x10(%ebx)
4003b7ea:	eb 0d                	jmp    4003b7f9 <_printf_i+0x20f>
4003b7ec:	8d 73 42             	lea    0x42(%ebx),%esi
4003b7ef:	88 4b 42             	mov    %cl,0x42(%ebx)
4003b7f2:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
4003b7f9:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
4003b7fd:	ff 74 24 20          	pushl  0x20(%esp)
4003b801:	ff 74 24 08          	pushl  0x8(%esp)
4003b805:	89 da                	mov    %ebx,%edx
4003b807:	8d 4c 24 10          	lea    0x10(%esp),%ecx
4003b80b:	8b 44 24 08          	mov    0x8(%esp),%eax
4003b80f:	e8 fa fc ff ff       	call   4003b50e <_printf_common>
4003b814:	5f                   	pop    %edi
4003b815:	40                   	inc    %eax
4003b816:	5d                   	pop    %ebp
4003b817:	75 05                	jne    4003b81e <_printf_i+0x234>
4003b819:	83 c8 ff             	or     $0xffffffff,%eax
4003b81c:	eb 5d                	jmp    4003b87b <_printf_i+0x291>
4003b81e:	ff 73 10             	pushl  0x10(%ebx)
4003b821:	89 f1                	mov    %esi,%ecx
4003b823:	8b 54 24 08          	mov    0x8(%esp),%edx
4003b827:	8b 44 24 04          	mov    0x4(%esp),%eax
4003b82b:	ff 54 24 24          	call   *0x24(%esp)
4003b82f:	59                   	pop    %ecx
4003b830:	40                   	inc    %eax
4003b831:	74 e6                	je     4003b819 <_printf_i+0x22f>
4003b833:	f6 03 02             	testb  $0x2,(%ebx)
4003b836:	74 27                	je     4003b85f <_printf_i+0x275>
4003b838:	31 f6                	xor    %esi,%esi
4003b83a:	8d 7b 19             	lea    0x19(%ebx),%edi
4003b83d:	eb 15                	jmp    4003b854 <_printf_i+0x26a>
4003b83f:	6a 01                	push   $0x1
4003b841:	89 f9                	mov    %edi,%ecx
4003b843:	8b 54 24 08          	mov    0x8(%esp),%edx
4003b847:	8b 44 24 04          	mov    0x4(%esp),%eax
4003b84b:	ff 54 24 24          	call   *0x24(%esp)
4003b84f:	5a                   	pop    %edx
4003b850:	40                   	inc    %eax
4003b851:	74 c6                	je     4003b819 <_printf_i+0x22f>
4003b853:	46                   	inc    %esi
4003b854:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b857:	2b 44 24 08          	sub    0x8(%esp),%eax
4003b85b:	39 c6                	cmp    %eax,%esi
4003b85d:	7c e0                	jl     4003b83f <_printf_i+0x255>
4003b85f:	8b 54 24 08          	mov    0x8(%esp),%edx
4003b863:	8b 43 0c             	mov    0xc(%ebx),%eax
4003b866:	39 d0                	cmp    %edx,%eax
4003b868:	7d 11                	jge    4003b87b <_printf_i+0x291>
4003b86a:	89 d0                	mov    %edx,%eax
4003b86c:	eb 0d                	jmp    4003b87b <_printf_i+0x291>
4003b86e:	8a 07                	mov    (%edi),%al
4003b870:	8d 73 42             	lea    0x42(%ebx),%esi
4003b873:	88 43 42             	mov    %al,0x42(%ebx)
4003b876:	e9 f7 fe ff ff       	jmp    4003b772 <_printf_i+0x188>
4003b87b:	83 c4 0c             	add    $0xc,%esp
4003b87e:	5b                   	pop    %ebx
4003b87f:	5e                   	pop    %esi
4003b880:	5f                   	pop    %edi
4003b881:	5d                   	pop    %ebp
4003b882:	c3                   	ret    

4003b883 <__sread>:
4003b883:	53                   	push   %ebx
4003b884:	89 d3                	mov    %edx,%ebx
4003b886:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003b88a:	ff 74 24 08          	pushl  0x8(%esp)
4003b88e:	e8 52 01 00 00       	call   4003b9e5 <_read_r>
4003b893:	5a                   	pop    %edx
4003b894:	85 c0                	test   %eax,%eax
4003b896:	78 05                	js     4003b89d <__sread+0x1a>
4003b898:	01 43 50             	add    %eax,0x50(%ebx)
4003b89b:	eb 06                	jmp    4003b8a3 <__sread+0x20>
4003b89d:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
4003b8a3:	5b                   	pop    %ebx
4003b8a4:	c3                   	ret    

4003b8a5 <__swrite>:
4003b8a5:	55                   	push   %ebp
4003b8a6:	57                   	push   %edi
4003b8a7:	56                   	push   %esi
4003b8a8:	53                   	push   %ebx
4003b8a9:	89 c6                	mov    %eax,%esi
4003b8ab:	89 d3                	mov    %edx,%ebx
4003b8ad:	89 cf                	mov    %ecx,%edi
4003b8af:	8b 6c 24 14          	mov    0x14(%esp),%ebp
4003b8b3:	f6 42 0d 01          	testb  $0x1,0xd(%edx)
4003b8b7:	74 0e                	je     4003b8c7 <__swrite+0x22>
4003b8b9:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003b8bd:	31 c9                	xor    %ecx,%ecx
4003b8bf:	6a 02                	push   $0x2
4003b8c1:	e8 f2 00 00 00       	call   4003b9b8 <_lseek_r>
4003b8c6:	58                   	pop    %eax
4003b8c7:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
4003b8cd:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
4003b8d1:	89 f9                	mov    %edi,%ecx
4003b8d3:	89 f0                	mov    %esi,%eax
4003b8d5:	89 6c 24 14          	mov    %ebp,0x14(%esp)
4003b8d9:	5b                   	pop    %ebx
4003b8da:	5e                   	pop    %esi
4003b8db:	5f                   	pop    %edi
4003b8dc:	5d                   	pop    %ebp
4003b8dd:	e9 32 00 00 00       	jmp    4003b914 <_write_r>

4003b8e2 <__sseek>:
4003b8e2:	53                   	push   %ebx
4003b8e3:	89 d3                	mov    %edx,%ebx
4003b8e5:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003b8e9:	ff 74 24 08          	pushl  0x8(%esp)
4003b8ed:	e8 c6 00 00 00       	call   4003b9b8 <_lseek_r>
4003b8f2:	5a                   	pop    %edx
4003b8f3:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b8f6:	75 08                	jne    4003b900 <__sseek+0x1e>
4003b8f8:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
4003b8fe:	eb 09                	jmp    4003b909 <__sseek+0x27>
4003b900:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
4003b906:	89 43 50             	mov    %eax,0x50(%ebx)
4003b909:	5b                   	pop    %ebx
4003b90a:	c3                   	ret    

4003b90b <__sclose>:
4003b90b:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003b90f:	e9 2d 00 00 00       	jmp    4003b941 <_close_r>

4003b914 <_write_r>:
4003b914:	53                   	push   %ebx
4003b915:	89 c3                	mov    %eax,%ebx
4003b917:	89 d0                	mov    %edx,%eax
4003b919:	89 ca                	mov    %ecx,%edx
4003b91b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
4003b91f:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b926:	00 00 00 
4003b929:	e8 2d 6f ff ff       	call   4003285b <_write>
4003b92e:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b931:	75 0c                	jne    4003b93f <_write_r+0x2b>
4003b933:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003b939:	85 d2                	test   %edx,%edx
4003b93b:	74 02                	je     4003b93f <_write_r+0x2b>
4003b93d:	89 13                	mov    %edx,(%ebx)
4003b93f:	5b                   	pop    %ebx
4003b940:	c3                   	ret    

4003b941 <_close_r>:
4003b941:	53                   	push   %ebx
4003b942:	89 c3                	mov    %eax,%ebx
4003b944:	89 d0                	mov    %edx,%eax
4003b946:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b94d:	00 00 00 
4003b950:	e8 53 6f ff ff       	call   400328a8 <_close>
4003b955:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b958:	75 0c                	jne    4003b966 <_close_r+0x25>
4003b95a:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003b960:	85 d2                	test   %edx,%edx
4003b962:	74 02                	je     4003b966 <_close_r+0x25>
4003b964:	89 13                	mov    %edx,(%ebx)
4003b966:	5b                   	pop    %ebx
4003b967:	c3                   	ret    

4003b968 <_fstat_r>:
4003b968:	53                   	push   %ebx
4003b969:	89 c3                	mov    %eax,%ebx
4003b96b:	89 d0                	mov    %edx,%eax
4003b96d:	89 ca                	mov    %ecx,%edx
4003b96f:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b976:	00 00 00 
4003b979:	e8 1c 6f ff ff       	call   4003289a <_fstat>
4003b97e:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b981:	75 0c                	jne    4003b98f <_fstat_r+0x27>
4003b983:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003b989:	85 d2                	test   %edx,%edx
4003b98b:	74 02                	je     4003b98f <_fstat_r+0x27>
4003b98d:	89 13                	mov    %edx,(%ebx)
4003b98f:	5b                   	pop    %ebx
4003b990:	c3                   	ret    

4003b991 <_isatty_r>:
4003b991:	53                   	push   %ebx
4003b992:	89 c3                	mov    %eax,%ebx
4003b994:	89 d0                	mov    %edx,%eax
4003b996:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b99d:	00 00 00 
4003b9a0:	e8 eb 6e ff ff       	call   40032890 <_isatty>
4003b9a5:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b9a8:	75 0c                	jne    4003b9b6 <_isatty_r+0x25>
4003b9aa:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003b9b0:	85 d2                	test   %edx,%edx
4003b9b2:	74 02                	je     4003b9b6 <_isatty_r+0x25>
4003b9b4:	89 13                	mov    %edx,(%ebx)
4003b9b6:	5b                   	pop    %ebx
4003b9b7:	c3                   	ret    

4003b9b8 <_lseek_r>:
4003b9b8:	53                   	push   %ebx
4003b9b9:	89 c3                	mov    %eax,%ebx
4003b9bb:	89 d0                	mov    %edx,%eax
4003b9bd:	89 ca                	mov    %ecx,%edx
4003b9bf:	8b 4c 24 08          	mov    0x8(%esp),%ecx
4003b9c3:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b9ca:	00 00 00 
4003b9cd:	e8 de 6e ff ff       	call   400328b0 <_lseek>
4003b9d2:	83 f8 ff             	cmp    $0xffffffff,%eax
4003b9d5:	75 0c                	jne    4003b9e3 <_lseek_r+0x2b>
4003b9d7:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003b9dd:	85 d2                	test   %edx,%edx
4003b9df:	74 02                	je     4003b9e3 <_lseek_r+0x2b>
4003b9e1:	89 13                	mov    %edx,(%ebx)
4003b9e3:	5b                   	pop    %ebx
4003b9e4:	c3                   	ret    

4003b9e5 <_read_r>:
4003b9e5:	53                   	push   %ebx
4003b9e6:	89 c3                	mov    %eax,%ebx
4003b9e8:	89 d0                	mov    %edx,%eax
4003b9ea:	89 ca                	mov    %ecx,%edx
4003b9ec:	8b 4c 24 08          	mov    0x8(%esp),%ecx
4003b9f0:	c7 05 44 85 00 a8 00 	movl   $0x0,0xa8008544
4003b9f7:	00 00 00 
4003b9fa:	e8 31 6e ff ff       	call   40032830 <_read>
4003b9ff:	83 f8 ff             	cmp    $0xffffffff,%eax
4003ba02:	75 0c                	jne    4003ba10 <_read_r+0x2b>
4003ba04:	8b 15 44 85 00 a8    	mov    0xa8008544,%edx
4003ba0a:	85 d2                	test   %edx,%edx
4003ba0c:	74 02                	je     4003ba10 <_read_r+0x2b>
4003ba0e:	89 13                	mov    %edx,(%ebx)
4003ba10:	5b                   	pop    %ebx
4003ba11:	c3                   	ret    

4003ba12 <_handle_exc_0_vector_0_stub>:
4003ba12:	6a 00                	push   $0x0
4003ba14:	68 00 9a 03 40       	push   $0x40039a00
4003ba19:	e9 81 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba1e <_handle_exc_2_vector_2_stub>:
4003ba1e:	6a 00                	push   $0x0
4003ba20:	68 0c 9a 03 40       	push   $0x40039a0c
4003ba25:	e9 75 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba2a <_handle_exc_4_vector_4_stub>:
4003ba2a:	6a 00                	push   $0x0
4003ba2c:	68 1b 9a 03 40       	push   $0x40039a1b
4003ba31:	e9 69 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba36 <_handle_exc_5_vector_5_stub>:
4003ba36:	6a 00                	push   $0x0
4003ba38:	68 2a 9a 03 40       	push   $0x40039a2a
4003ba3d:	e9 5d dd ff ff       	jmp    4003979f <_exception_enter>

4003ba42 <_handle_exc_6_vector_6_stub>:
4003ba42:	6a 00                	push   $0x0
4003ba44:	68 39 9a 03 40       	push   $0x40039a39
4003ba49:	e9 51 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba4e <_handle_exc_7_vector_7_stub>:
4003ba4e:	6a 00                	push   $0x0
4003ba50:	68 48 9a 03 40       	push   $0x40039a48
4003ba55:	e9 45 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba5a <_handle_exc_8_vector_8_stub>:
4003ba5a:	68 57 9a 03 40       	push   $0x40039a57
4003ba5f:	e9 3b dd ff ff       	jmp    4003979f <_exception_enter>

4003ba64 <_handle_exc_10_vector_10_stub>:
4003ba64:	68 66 9a 03 40       	push   $0x40039a66
4003ba69:	e9 31 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba6e <_handle_exc_11_vector_11_stub>:
4003ba6e:	68 75 9a 03 40       	push   $0x40039a75
4003ba73:	e9 27 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba78 <_handle_exc_12_vector_12_stub>:
4003ba78:	68 84 9a 03 40       	push   $0x40039a84
4003ba7d:	e9 1d dd ff ff       	jmp    4003979f <_exception_enter>

4003ba82 <_handle_exc_13_vector_13_stub>:
4003ba82:	68 93 9a 03 40       	push   $0x40039a93
4003ba87:	e9 13 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba8c <_handle_exc_14_vector_14_stub>:
4003ba8c:	68 a2 9a 03 40       	push   $0x40039aa2
4003ba91:	e9 09 dd ff ff       	jmp    4003979f <_exception_enter>

4003ba96 <_handle_exc_16_vector_16_stub>:
4003ba96:	6a 00                	push   $0x0
4003ba98:	68 b1 9a 03 40       	push   $0x40039ab1
4003ba9d:	e9 fd dc ff ff       	jmp    4003979f <_exception_enter>

4003baa2 <_handle_exc_17_vector_17_stub>:
4003baa2:	68 c0 9a 03 40       	push   $0x40039ac0
4003baa7:	e9 f3 dc ff ff       	jmp    4003979f <_exception_enter>

4003baac <_handle_exc_18_vector_18_stub>:
4003baac:	6a 00                	push   $0x0
4003baae:	68 cf 9a 03 40       	push   $0x40039acf
4003bab3:	e9 e7 dc ff ff       	jmp    4003979f <_exception_enter>
