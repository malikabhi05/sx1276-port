
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
4003000c:	0f 01 1d 4c 00 03 40 	lidtl  0x4003004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
40030013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
4003001c:	bc dc 78 00 a8       	mov    $0xa80078dc,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
40030021:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030027:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003002c:	be a8 6d 03 40       	mov    $0x40036da8,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030031:	b9 f5 00 00 00       	mov    $0xf5,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
40030038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003003a:	bf e0 67 00 a8       	mov    $0xa80067e0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
4003003f:	b9 3e 04 00 00       	mov    $0x43e,%ecx
	cld
40030044:	fc                   	cld    
	rep
40030045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030047:	e9 48 36 00 00       	jmp    40033694 <_Cstart>

4003004c <_Idt>:
4003004c:	ff 07 28 65 03 40 66 90 66 90 66 90 66 90 66 90     ..(e.@f.f.f.f.f.
4003005c:	66 90 66 90                                         f.f.

40030060 <_thread_entry_wrapper>:
40030060:	58                   	pop    %eax
40030061:	5a                   	pop    %edx
40030062:	59                   	pop    %ecx
40030063:	6a 00                	push   $0x0
40030065:	e9 49 3e 00 00       	jmp    40033eb3 <_thread_entry>

4003006a <memcpy>:
4003006a:	56                   	push   %esi
4003006b:	57                   	push   %edi
4003006c:	89 c7                	mov    %eax,%edi
4003006e:	89 d6                	mov    %edx,%esi
40030070:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40030072:	5f                   	pop    %edi
40030073:	5e                   	pop    %esi
40030074:	c3                   	ret    

40030075 <memset>:
40030075:	57                   	push   %edi
40030076:	89 c7                	mov    %eax,%edi
40030078:	0f b6 c2             	movzbl %dl,%eax
4003007b:	89 fa                	mov    %edi,%edx
4003007d:	f3 aa                	rep stos %al,%es:(%edi)
4003007f:	89 d0                	mov    %edx,%eax
40030081:	5f                   	pop    %edi
40030082:	c3                   	ret    

40030083 <memchr>:
40030083:	57                   	push   %edi
40030084:	89 c7                	mov    %eax,%edi
40030086:	89 d0                	mov    %edx,%eax
40030088:	31 d2                	xor    %edx,%edx
4003008a:	85 c9                	test   %ecx,%ecx
4003008c:	74 09                	je     40030097 <L20>
4003008e:	f2 ae                	repnz scas %es:(%edi),%al
40030090:	0f 95 c2             	setne  %dl
40030093:	4f                   	dec    %edi
40030094:	4a                   	dec    %edx
40030095:	21 fa                	and    %edi,%edx

40030097 <L20>:
40030097:	89 d0                	mov    %edx,%eax
40030099:	5f                   	pop    %edi
4003009a:	c3                   	ret    

4003009b <memmove>:
4003009b:	56                   	push   %esi
4003009c:	57                   	push   %edi
4003009d:	89 c7                	mov    %eax,%edi
4003009f:	89 d6                	mov    %edx,%esi
400300a1:	39 f7                	cmp    %esi,%edi
400300a3:	77 07                	ja     400300ac <memmove+0x11>
400300a5:	74 11                	je     400300b8 <memmove+0x1d>
400300a7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
400300a9:	5f                   	pop    %edi
400300aa:	5e                   	pop    %esi
400300ab:	c3                   	ret    
400300ac:	8d 7c 0f ff          	lea    -0x1(%edi,%ecx,1),%edi
400300b0:	8d 74 0e ff          	lea    -0x1(%esi,%ecx,1),%esi
400300b4:	fd                   	std    
400300b5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
400300b7:	fc                   	cld    
400300b8:	5f                   	pop    %edi
400300b9:	5e                   	pop    %esi
400300ba:	c3                   	ret    

400300bb <__udivdi3>:
400300bb:	55                   	push   %ebp
400300bc:	89 e5                	mov    %esp,%ebp
400300be:	57                   	push   %edi
400300bf:	56                   	push   %esi
400300c0:	53                   	push   %ebx
400300c1:	83 ec 10             	sub    $0x10,%esp
400300c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
400300c7:	8b 45 08             	mov    0x8(%ebp),%eax
400300ca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400300cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
400300d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300d3:	89 d6                	mov    %edx,%esi
400300d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
400300d8:	89 d9                	mov    %ebx,%ecx
400300da:	89 d0                	mov    %edx,%eax
400300dc:	85 db                	test   %ebx,%ebx
400300de:	8b 55 e8             	mov    -0x18(%ebp),%edx
400300e1:	75 30                	jne    40030113 <__udivdi3+0x58>
400300e3:	89 d7                	mov    %edx,%edi
400300e5:	39 f2                	cmp    %esi,%edx
400300e7:	76 07                	jbe    400300f0 <__udivdi3+0x35>
400300e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300ec:	89 f2                	mov    %esi,%edx
400300ee:	eb 1a                	jmp    4003010a <__udivdi3+0x4f>
400300f0:	85 d2                	test   %edx,%edx
400300f2:	75 0b                	jne    400300ff <__udivdi3+0x44>
400300f4:	b8 01 00 00 00       	mov    $0x1,%eax
400300f9:	31 d2                	xor    %edx,%edx
400300fb:	f7 f7                	div    %edi
400300fd:	89 c7                	mov    %eax,%edi
400300ff:	31 d2                	xor    %edx,%edx
40030101:	89 f0                	mov    %esi,%eax
40030103:	f7 f7                	div    %edi
40030105:	89 c1                	mov    %eax,%ecx
40030107:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003010a:	f7 f7                	div    %edi
4003010c:	89 c3                	mov    %eax,%ebx
4003010e:	e9 92 00 00 00       	jmp    400301a5 <__udivdi3+0xea>
40030113:	39 f3                	cmp    %esi,%ebx
40030115:	0f 87 82 00 00 00    	ja     4003019d <__udivdi3+0xe2>
4003011b:	0f bd f3             	bsr    %ebx,%esi
4003011e:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030121:	83 75 f0 1f          	xorl   $0x1f,-0x10(%ebp)
40030125:	75 15                	jne    4003013c <__udivdi3+0x81>
40030127:	39 c3                	cmp    %eax,%ebx
40030129:	b9 00 00 00 00       	mov    $0x0,%ecx
4003012e:	72 05                	jb     40030135 <__udivdi3+0x7a>
40030130:	3b 55 ec             	cmp    -0x14(%ebp),%edx
40030133:	77 6a                	ja     4003019f <__udivdi3+0xe4>
40030135:	bb 01 00 00 00       	mov    $0x1,%ebx
4003013a:	eb 69                	jmp    400301a5 <__udivdi3+0xea>
4003013c:	be 20 00 00 00       	mov    $0x20,%esi
40030141:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030144:	2b 75 f0             	sub    -0x10(%ebp),%esi
40030147:	89 d7                	mov    %edx,%edi
40030149:	d3 e3                	shl    %cl,%ebx
4003014b:	89 f1                	mov    %esi,%ecx
4003014d:	d3 ef                	shr    %cl,%edi
4003014f:	89 f9                	mov    %edi,%ecx
40030151:	09 d9                	or     %ebx,%ecx
40030153:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030156:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40030159:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003015c:	d3 e2                	shl    %cl,%edx
4003015e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030161:	89 f1                	mov    %esi,%ecx
40030163:	89 c2                	mov    %eax,%edx
40030165:	d3 ea                	shr    %cl,%edx
40030167:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003016a:	d3 e0                	shl    %cl,%eax
4003016c:	89 f1                	mov    %esi,%ecx
4003016e:	d3 eb                	shr    %cl,%ebx
40030170:	09 c3                	or     %eax,%ebx
40030172:	89 d8                	mov    %ebx,%eax
40030174:	f7 75 e8             	divl   -0x18(%ebp)
40030177:	89 d6                	mov    %edx,%esi
40030179:	89 c7                	mov    %eax,%edi
4003017b:	89 c3                	mov    %eax,%ebx
4003017d:	f7 65 e4             	mull   -0x1c(%ebp)
40030180:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030183:	39 d6                	cmp    %edx,%esi
40030185:	72 11                	jb     40030198 <__udivdi3+0xdd>
40030187:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003018a:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003018d:	d3 e0                	shl    %cl,%eax
4003018f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
40030192:	73 0f                	jae    400301a3 <__udivdi3+0xe8>
40030194:	39 d6                	cmp    %edx,%esi
40030196:	75 0b                	jne    400301a3 <__udivdi3+0xe8>
40030198:	8d 5f ff             	lea    -0x1(%edi),%ebx
4003019b:	eb 06                	jmp    400301a3 <__udivdi3+0xe8>
4003019d:	31 c9                	xor    %ecx,%ecx
4003019f:	31 db                	xor    %ebx,%ebx
400301a1:	eb 02                	jmp    400301a5 <__udivdi3+0xea>
400301a3:	31 c9                	xor    %ecx,%ecx
400301a5:	89 d8                	mov    %ebx,%eax
400301a7:	89 ca                	mov    %ecx,%edx
400301a9:	83 c4 10             	add    $0x10,%esp
400301ac:	5b                   	pop    %ebx
400301ad:	5e                   	pop    %esi
400301ae:	5f                   	pop    %edi
400301af:	5d                   	pop    %ebp
400301b0:	c3                   	ret    

400301b1 <main>:

int counter = 0;

uint8_t buffer[10] = {0};

void main() {
400301b1:	55                   	push   %ebp
400301b2:	89 e5                	mov    %esp,%ebp
    printf("LoRa Sender\n");
400301b4:	68 98 55 03 40       	push   $0x40035598
400301b9:	e8 fc 40 00 00       	call   400342ba <iprintf>
400301be:	58                   	pop    %eax

    // start initialization
    LoRaClass();
400301bf:	e8 e9 27 00 00       	call   400329ad <LoRaClass>
    // call pinset
    // ss, reset, dio0
    // 101
    //setPins(10, 3, 2);
    // c1000
    setPins(60, 82, 72);
400301c4:	b9 48 00 00 00       	mov    $0x48,%ecx
400301c9:	ba 52 00 00 00       	mov    $0x52,%edx
400301ce:	b8 3c 00 00 00       	mov    $0x3c,%eax
400301d3:	e8 62 28 00 00       	call   40032a3a <setPins>

    // complete initialization by finishing pin setup and
    // setting frequency
    //begin(915e6);
    begin(914984144);
400301d8:	b8 d0 8c 89 36       	mov    $0x36898cd0,%eax
400301dd:	e8 94 2c 00 00       	call   40032e76 <begin>

    dumpRegisters();
400301e2:	e8 d8 28 00 00       	call   40032abf <dumpRegisters>

#if 1
    while(1) {
        printf("sending packet: %d\n", counter);
400301e7:	ff 35 f4 67 00 a8    	pushl  0xa80067f4
400301ed:	68 a5 55 03 40       	push   $0x400355a5
400301f2:	e8 c3 40 00 00       	call   400342ba <iprintf>
400301f7:	58                   	pop    %eax

        // send packet actually
        beginPacket(false);
400301f8:	31 c0                	xor    %eax,%eax
        printf("sending packet: %d\n", counter);
400301fa:	5a                   	pop    %edx
        beginPacket(false);
400301fb:	e8 00 2f 00 00       	call   40033100 <beginPacket>
        //printf("packet sent: ")
        snprintf(buffer, 10, "Ping %d", counter++);
40030200:	a1 f4 67 00 a8       	mov    0xa80067f4,%eax
40030205:	50                   	push   %eax
40030206:	68 b9 55 03 40       	push   $0x400355b9
4003020b:	8d 50 01             	lea    0x1(%eax),%edx
4003020e:	6a 0a                	push   $0xa
40030210:	68 e8 67 00 a8       	push   $0xa80067e8
40030215:	89 15 f4 67 00 a8    	mov    %edx,0xa80067f4
4003021b:	e8 d9 40 00 00       	call   400342f9 <sniprintf>
40030220:	83 c4 10             	add    $0x10,%esp
        printf("buffer: %s\n", buffer);
40030223:	68 e8 67 00 a8       	push   $0xa80067e8
40030228:	68 c1 55 03 40       	push   $0x400355c1
4003022d:	e8 88 40 00 00       	call   400342ba <iprintf>
40030232:	59                   	pop    %ecx
        write_buf(buffer, 10);
40030233:	ba 0a 00 00 00       	mov    $0xa,%edx
        printf("buffer: %s\n", buffer);
40030238:	58                   	pop    %eax
        write_buf(buffer, 10);
40030239:	b8 e8 67 00 a8       	mov    $0xa80067e8,%eax
4003023e:	e8 f7 29 00 00       	call   40032c3a <write_buf>
        endPacket();
40030243:	e8 0a 29 00 00       	call   40032b52 <endPacket>

        counter++;

        upm_delay_us(10000000);
40030248:	b8 80 96 98 00       	mov    $0x989680,%eax
        counter++;
4003024d:	ff 05 f4 67 00 a8    	incl   0xa80067f4
        upm_delay_us(10000000);
40030253:	e8 2d 27 00 00       	call   40032985 <upm_delay_us>
40030258:	eb 8d                	jmp    400301e7 <main+0x36>

4003025a <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
4003025a:	55                   	push   %ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
4003025b:	83 f8 0a             	cmp    $0xa,%eax
{
4003025e:	89 e5                	mov    %esp,%ebp
40030260:	53                   	push   %ebx
40030261:	89 c3                	mov    %eax,%ebx
	if ('\n' == c) {
40030263:	75 10                	jne    40030275 <console_out+0x1b>
		uart_poll_out(uart_console_dev, '\r');
40030265:	a1 f8 67 00 a8       	mov    0xa80067f8,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
4003026a:	ba 0d 00 00 00       	mov    $0xd,%edx
4003026f:	8b 48 04             	mov    0x4(%eax),%ecx
40030272:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
40030275:	a1 f8 67 00 a8       	mov    0xa80067f8,%eax
4003027a:	0f b6 d3             	movzbl %bl,%edx
4003027d:	8b 48 04             	mov    0x4(%eax),%ecx
40030280:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
40030283:	89 d8                	mov    %ebx,%eax
40030285:	5b                   	pop    %ebx
40030286:	5d                   	pop    %ebp
40030287:	c3                   	ret    

40030288 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
40030288:	55                   	push   %ebp
	__stdout_hook_install(console_out);
40030289:	b8 5a 02 03 40       	mov    $0x4003025a,%eax
{
4003028e:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
40030290:	e8 ad 0a 00 00       	call   40030d42 <__stdout_hook_install>
	__printk_hook_install(console_out);
40030295:	b8 5a 02 03 40       	mov    $0x4003025a,%eax
}
4003029a:	5d                   	pop    %ebp
	__printk_hook_install(console_out);
4003029b:	e9 23 0c 00 00       	jmp    40030ec3 <__printk_hook_install>

400302a0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
400302a0:	55                   	push   %ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400302a1:	b8 cd 55 03 40       	mov    $0x400355cd,%eax
{
400302a6:	89 e5                	mov    %esp,%ebp
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400302a8:	e8 5d 33 00 00       	call   4003360a <device_get_binding>
400302ad:	a3 f8 67 00 a8       	mov    %eax,0xa80067f8
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
400302b2:	e8 d1 ff ff ff       	call   40030288 <uart_console_hook_install>

	return 0;
}
400302b7:	31 c0                	xor    %eax,%eax
400302b9:	5d                   	pop    %ebp
400302ba:	c3                   	ret    

400302bb <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
400302bb:	55                   	push   %ebp
400302bc:	89 e5                	mov    %esp,%ebp
400302be:	56                   	push   %esi
400302bf:	53                   	push   %ebx
400302c0:	89 c6                	mov    %eax,%esi
400302c2:	83 ec 0c             	sub    $0xc,%esp
	const struct uart_qmsi_config_info *config = dev->config->config_info;
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
400302c5:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
	const struct uart_qmsi_config_info *config = dev->config->config_info;
400302cc:	8b 00                	mov    (%eax),%eax
400302ce:	8b 58 08             	mov    0x8(%eax),%ebx
	cfg.baud_divisor = config->baud_divisor;
400302d1:	8b 43 08             	mov    0x8(%ebx),%eax
400302d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cfg.hw_fc = config->hw_fc;
400302d7:	8a 43 0c             	mov    0xc(%ebx),%al
400302da:	88 45 f4             	mov    %al,-0xc(%ebp)

	clk_periph_enable(config->clock_gate);
400302dd:	8b 43 04             	mov    0x4(%ebx),%eax
400302e0:	e8 9e 0e 00 00       	call   40031183 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
400302e5:	8d 55 ec             	lea    -0x14(%ebp),%edx
400302e8:	8b 03                	mov    (%ebx),%eax
400302ea:	e8 db 0f 00 00       	call   400312ca <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
400302ef:	c7 46 04 08 56 03 40 	movl   $0x40035608,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
400302f6:	83 c4 0c             	add    $0xc,%esp
400302f9:	31 c0                	xor    %eax,%eax
400302fb:	5b                   	pop    %ebx
400302fc:	5e                   	pop    %esi
400302fd:	5d                   	pop    %ebp
400302fe:	c3                   	ret    

400302ff <uart_qmsi_err_check>:
{
400302ff:	55                   	push   %ebp
40030300:	89 e5                	mov    %esp,%ebp
40030302:	52                   	push   %edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030303:	8b 00                	mov    (%eax),%eax
	qm_uart_get_status(instance, &status);
40030305:	8d 55 fc             	lea    -0x4(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030308:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_get_status(instance, &status);
4003030b:	8b 00                	mov    (%eax),%eax
4003030d:	e8 25 10 00 00       	call   40031337 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
40030312:	8b 45 fc             	mov    -0x4(%ebp),%eax
40030315:	83 e0 1e             	and    $0x1e,%eax
}
40030318:	c9                   	leave  
40030319:	c3                   	ret    

4003031a <uart_qmsi_poll_out>:
{
4003031a:	55                   	push   %ebp
4003031b:	89 e5                	mov    %esp,%ebp
4003031d:	53                   	push   %ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003031e:	8b 00                	mov    (%eax),%eax
{
40030320:	89 d3                	mov    %edx,%ebx
	qm_uart_write(instance, data);
40030322:	0f b6 d2             	movzbl %dl,%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030325:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_write(instance, data);
40030328:	8b 00                	mov    (%eax),%eax
4003032a:	e8 49 10 00 00       	call   40031378 <qm_uart_write>
}
4003032f:	88 d8                	mov    %bl,%al
40030331:	5b                   	pop    %ebx
40030332:	5d                   	pop    %ebp
40030333:	c3                   	ret    

40030334 <uart_qmsi_poll_in>:
{
40030334:	55                   	push   %ebp
40030335:	89 e5                	mov    %esp,%ebp
40030337:	56                   	push   %esi
40030338:	53                   	push   %ebx
40030339:	51                   	push   %ecx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003033a:	8b 00                	mov    (%eax),%eax
{
4003033c:	89 d6                	mov    %edx,%esi
	qm_uart_get_status(instance, &status);
4003033e:	8d 55 f4             	lea    -0xc(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030341:	8b 40 08             	mov    0x8(%eax),%eax
40030344:	8b 18                	mov    (%eax),%ebx
	qm_uart_get_status(instance, &status);
40030346:	89 d8                	mov    %ebx,%eax
40030348:	e8 ea 0f 00 00       	call   40031337 <qm_uart_get_status>
		return -1;
4003034d:	83 c8 ff             	or     $0xffffffff,%eax
	if (!(status & QM_UART_RX_BUSY))
40030350:	f6 45 f4 40          	testb  $0x40,-0xc(%ebp)
40030354:	74 0d                	je     40030363 <uart_qmsi_poll_in+0x2f>
	qm_uart_read(instance, data, NULL);
40030356:	31 c9                	xor    %ecx,%ecx
40030358:	89 f2                	mov    %esi,%edx
4003035a:	89 d8                	mov    %ebx,%eax
4003035c:	e8 3a 10 00 00       	call   4003139b <qm_uart_read>
	return 0;
40030361:	31 c0                	xor    %eax,%eax
}
40030363:	5a                   	pop    %edx
40030364:	5b                   	pop    %ebx
40030365:	5e                   	pop    %esi
40030366:	5d                   	pop    %ebp
40030367:	c3                   	ret    

40030368 <_timer_int_handler>:

	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick * _sys_idle_elapsed_ticks;
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
40030368:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
{
4003036d:	55                   	push   %ebp
	accumulated_cycle_count += cycles_per_tick;
4003036e:	01 05 0c 68 00 a8    	add    %eax,0xa800680c

	_sys_clock_tick_announce();
40030374:	a1 e8 66 00 a8       	mov    0xa80066e8,%eax
{
40030379:	89 e5                	mov    %esp,%ebp
#endif /*CONFIG_TICKLESS_IDLE*/

}
4003037b:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
4003037c:	e9 2e 38 00 00       	jmp    40033baf <_nano_sys_clock_tick_announce>

40030381 <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40030381:	a1 ec 66 00 a8       	mov    0xa80066ec,%eax
{
40030386:	55                   	push   %ebp
	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40030387:	a3 d8 78 00 a8       	mov    %eax,0xa80078d8
{
4003038c:	89 e5                	mov    %esp,%ebp
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
4003038e:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
40030393:	83 e0 f0             	and    $0xfffffff0,%eax
40030396:	83 c8 0b             	or     $0xb,%eax
40030399:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
4003039e:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
400303a3:	48                   	dec    %eax
	*_REG_TIMER_ICR = count;
400303a4:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
400303a9:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
400303ae:	0d 00 00 02 00       	or     $0x20000,%eax
400303b3:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
400303b8:	0f b6 05 68 6d 03 40 	movzbl 0x40036d68,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
400303bf:	31 c9                	xor    %ecx,%ecx
400303c1:	ba 40 00 00 00       	mov    $0x40,%edx
400303c6:	e8 7b 01 00 00       	call   40030546 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
400303cb:	b8 40 00 00 00       	mov    $0x40,%eax
400303d0:	e8 93 01 00 00       	call   40030568 <_arch_irq_enable>

	return 0;
}
400303d5:	31 c0                	xor    %eax,%eax
400303d7:	5d                   	pop    %ebp
400303d8:	c3                   	ret    

400303d9 <_timer_int_handler_irq64_stub>:
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
400303d9:	6a 00                	push   $0x0
400303db:	68 68 03 03 40       	push   $0x40030368
400303e0:	e9 e8 2e 00 00       	jmp    400332cd <_interrupt_enter>

400303e5 <qm_spi_master_1_isr_irq3_stub>:
400303e5:	6a 00                	push   $0x0
400303e7:	68 6e 18 03 40       	push   $0x4003186e
400303ec:	e9 dc 2e 00 00       	jmp    400332cd <_interrupt_enter>

400303f1 <qm_spi_master_0_isr_irq2_stub>:
400303f1:	6a 00                	push   $0x0
400303f3:	68 63 18 03 40       	push   $0x40031863
400303f8:	e9 d0 2e 00 00       	jmp    400332cd <_interrupt_enter>

400303fd <qm_aon_gpio_0_isr_irq31_stub>:
400303fd:	6a 00                	push   $0x0
400303ff:	68 da 11 03 40       	push   $0x400311da
40030404:	e9 c4 2e 00 00       	jmp    400332cd <_interrupt_enter>

40030409 <qm_gpio_0_isr_irq8_stub>:
40030409:	6a 00                	push   $0x0
4003040b:	68 cf 11 03 40       	push   $0x400311cf
40030410:	e9 b8 2e 00 00       	jmp    400332cd <_interrupt_enter>

40030415 <_timer_cycle_get_32>:
	 * in the Initial Count Register (ICR).
	 */

#if !defined(CONFIG_TICKLESS_IDLE)
	/* The value in the ICR always matches cycles_per_tick. */
	val = accumulated_cycle_count - current_count_register_get() +
40030415:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
{
4003041a:	55                   	push   %ebp
	val = accumulated_cycle_count - current_count_register_get() +
4003041b:	03 05 0c 68 00 a8    	add    0xa800680c,%eax
	return *_REG_TIMER_CCR;
40030421:	8b 15 90 03 e0 fe    	mov    0xfee00390,%edx
{
40030427:	89 e5                	mov    %esp,%ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030429:	29 d0                	sub    %edx,%eax
	val = accumulated_cycle_count - current_count_register_get() +
	      initial_count_register_get();
#endif

	return val;
}
4003042b:	5d                   	pop    %ebp
4003042c:	c3                   	ret    

4003042d <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
4003042d:	55                   	push   %ebp
4003042e:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
40030430:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
40030435:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
40030438:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
4003043d:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
40030442:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
40030449:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
4003044c:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
4003044f:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
40030456:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
40030459:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
40030460:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
40030463:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
4003046a:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
4003046d:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
40030473:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030479:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
4003047c:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
40030482:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
40030488:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
4003048e:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40030491:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
40030494:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
4003049a:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
4003049d:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
400304a4:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
400304a7:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
400304ae:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
400304b1:	7e 19                	jle    400304cc <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
400304b3:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
400304ba:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
400304bd:	83 f8 04             	cmp    $0x4,%eax
400304c0:	74 0a                	je     400304cc <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
400304c2:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
400304c9:	00 01 00 
		| (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF);
#endif

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
400304cc:	e8 42 2d 00 00       	call   40033213 <_lakemont_eoi>
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
#endif

	return 0;
}
400304d1:	31 c0                	xor    %eax,%eax
400304d3:	5d                   	pop    %ebp
400304d4:	c3                   	ret    

400304d5 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
400304d5:	55                   	push   %ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
400304d6:	05 32 00 ee 0f       	add    $0xfee0032,%eax
400304db:	c1 e0 04             	shl    $0x4,%eax
{
400304de:	89 e5                	mov    %esp,%ebp
400304e0:	53                   	push   %ebx
	__asm__ volatile (
400304e1:	9c                   	pushf  
400304e2:	fa                   	cli    
400304e3:	5b                   	pop    %ebx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
400304e4:	8b 08                	mov    (%eax),%ecx
400304e6:	30 c9                	xor    %cl,%cl
400304e8:	09 ca                	or     %ecx,%edx
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
400304ea:	0f ba e3 09          	bt     $0x9,%ebx
400304ee:	89 10                	mov    %edx,(%eax)
400304f0:	73 01                	jae    400304f3 <_loapic_int_vec_set+0x1e>
	__asm__ volatile (
400304f2:	fb                   	sti    
	irq_unlock(oldLevel);
}
400304f3:	5b                   	pop    %ebx
400304f4:	5d                   	pop    %ebp
400304f5:	c3                   	ret    

400304f6 <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
400304f6:	55                   	push   %ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
400304f7:	05 32 00 ee 0f       	add    $0xfee0032,%eax
400304fc:	c1 e0 04             	shl    $0x4,%eax
{
400304ff:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030501:	9c                   	pushf  
40030502:	fa                   	cli    
40030503:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
40030504:	8b 10                	mov    (%eax),%edx
40030506:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
4003050c:	0f ba e1 09          	bt     $0x9,%ecx
40030510:	89 10                	mov    %edx,(%eax)
40030512:	73 01                	jae    40030515 <_loapic_irq_enable+0x1f>
	__asm__ volatile (
40030514:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030515:	5d                   	pop    %ebp
40030516:	c3                   	ret    

40030517 <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
40030517:	55                   	push   %ebp
40030518:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
4003051d:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
4003051f:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
40030524:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
40030526:	85 d2                	test   %edx,%edx
40030528:	74 11                	je     4003053b <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
4003052a:	0f bd d2             	bsr    %edx,%edx
4003052d:	75 05                	jne    40030534 <__irq_controller_isr_vector_get+0x1d>
4003052f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
40030534:	c1 e0 05             	shl    $0x5,%eax
40030537:	01 d0                	add    %edx,%eax
40030539:	eb 09                	jmp    40030544 <__irq_controller_isr_vector_get+0x2d>
4003053b:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
4003053e:	48                   	dec    %eax
4003053f:	75 e3                	jne    40030524 <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
40030541:	83 c8 ff             	or     $0xffffffff,%eax
}
40030544:	5d                   	pop    %ebp
40030545:	c3                   	ret    

40030546 <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
40030546:	55                   	push   %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
40030547:	83 fa 3f             	cmp    $0x3f,%edx
{
4003054a:	89 e5                	mov    %esp,%ebp
4003054c:	53                   	push   %ebx
4003054d:	89 c3                	mov    %eax,%ebx
4003054f:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
40030551:	77 09                	ja     4003055c <__irq_controller_irq_config+0x16>
		_ioapic_irq_set(irq, vector, flags);
40030553:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
40030555:	5b                   	pop    %ebx
40030556:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
40030557:	e9 a9 00 00 00       	jmp    40030605 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
4003055c:	89 da                	mov    %ebx,%edx
4003055e:	83 e8 40             	sub    $0x40,%eax
}
40030561:	5b                   	pop    %ebx
40030562:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030563:	e9 6d ff ff ff       	jmp    400304d5 <_loapic_int_vec_set>

40030568 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
40030568:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030569:	83 f8 3f             	cmp    $0x3f,%eax
{
4003056c:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
4003056e:	77 06                	ja     40030576 <_arch_irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
40030570:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
40030571:	e9 7f 00 00 00       	jmp    400305f5 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
40030576:	83 e8 40             	sub    $0x40,%eax
}
40030579:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
4003057a:	e9 77 ff ff ff       	jmp    400304f6 <_loapic_irq_enable>

4003057f <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
4003057f:	55                   	push   %ebp
40030580:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030582:	9c                   	pushf  
40030583:	fa                   	cli    
40030584:	59                   	pop    %ecx
40030585:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
40030589:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
4003058e:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
40030594:	73 01                	jae    40030597 <__IoApicSet+0x18>
	__asm__ volatile (
40030596:	fb                   	sti    

	irq_unlock(key);
}
40030597:	5d                   	pop    %ebp
40030598:	c3                   	ret    

40030599 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
40030599:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
4003059a:	01 c0                	add    %eax,%eax
{
4003059c:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
4003059e:	83 c0 10             	add    $0x10,%eax
{
400305a1:	56                   	push   %esi
400305a2:	53                   	push   %ebx
	__asm__ volatile (
400305a3:	9c                   	pushf  
400305a4:	fa                   	cli    
400305a5:	5e                   	pop    %esi
400305a6:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
400305aa:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
400305af:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
400305b5:	73 01                	jae    400305b8 <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
400305b7:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
400305b8:	31 da                	xor    %ebx,%edx
400305ba:	21 ca                	and    %ecx,%edx
400305bc:	31 da                	xor    %ebx,%edx
}
400305be:	5b                   	pop    %ebx
400305bf:	5e                   	pop    %esi
400305c0:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
400305c1:	e9 b9 ff ff ff       	jmp    4003057f <__IoApicSet>

400305c6 <_ioapic_init>:
{
400305c6:	55                   	push   %ebp
400305c7:	89 e5                	mov    %esp,%ebp
400305c9:	53                   	push   %ebx
400305ca:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
400305cf:	31 d2                	xor    %edx,%edx
400305d1:	89 d8                	mov    %ebx,%eax
400305d3:	e8 a7 ff ff ff       	call   4003057f <__IoApicSet>
	__IoApicSet(offset, lower32);
400305d8:	8d 43 ff             	lea    -0x1(%ebx),%eax
400305db:	ba 00 00 01 00       	mov    $0x10000,%edx
400305e0:	83 c3 02             	add    $0x2,%ebx
400305e3:	e8 97 ff ff ff       	call   4003057f <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
400305e8:	81 fb 91 00 00 00    	cmp    $0x91,%ebx
400305ee:	75 df                	jne    400305cf <_ioapic_init+0x9>
}
400305f0:	31 c0                	xor    %eax,%eax
400305f2:	5b                   	pop    %ebx
400305f3:	5d                   	pop    %ebp
400305f4:	c3                   	ret    

400305f5 <_ioapic_irq_enable>:
{
400305f5:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
400305f6:	b9 00 00 01 00       	mov    $0x10000,%ecx
400305fb:	31 d2                	xor    %edx,%edx
{
400305fd:	89 e5                	mov    %esp,%ebp
}
400305ff:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030600:	e9 94 ff ff ff       	jmp    40030599 <_IoApicRedUpdateLo>

40030605 <_ioapic_irq_set>:
{
40030605:	55                   	push   %ebp
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030606:	81 c9 00 00 01 00    	or     $0x10000,%ecx
{
4003060c:	89 e5                	mov    %esp,%ebp
4003060e:	56                   	push   %esi
4003060f:	53                   	push   %ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030610:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
40030613:	0f b6 f2             	movzbl %dl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030616:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
40030619:	31 d2                	xor    %edx,%edx
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
4003061b:	09 ce                	or     %ecx,%esi
	__IoApicSet(offset, upper32);
4003061d:	e8 5d ff ff ff       	call   4003057f <__IoApicSet>
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030622:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
40030625:	89 f2                	mov    %esi,%edx
}
40030627:	5b                   	pop    %ebx
40030628:	5e                   	pop    %esi
40030629:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
4003062a:	e9 50 ff ff ff       	jmp    4003057f <__IoApicSet>

4003062f <spi_qmsi_configure>:
	gpio_pin_write(gpio, config->cs_pin, !active);
}

static int spi_qmsi_configure(struct device *dev,
				struct spi_config *config)
{
4003062f:	55                   	push   %ebp
40030630:	89 e5                	mov    %esp,%ebp
40030632:	56                   	push   %esi
40030633:	53                   	push   %ebx
40030634:	51                   	push   %ecx
	struct spi_qmsi_runtime *context = dev->driver_data;
40030635:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_spi_config_t *cfg = &context->cfg;

	cfg->frame_size = SPI_WORD_SIZE_GET(config->config) - 1;
40030638:	8b 02                	mov    (%edx),%eax
4003063a:	89 c1                	mov    %eax,%ecx
4003063c:	c1 e9 04             	shr    $0x4,%ecx
4003063f:	0f b6 c9             	movzbl %cl,%ecx
40030642:	49                   	dec    %ecx
40030643:	89 4b 14             	mov    %ecx,0x14(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030646:	89 c1                	mov    %eax,%ecx
40030648:	83 e1 07             	and    $0x7,%ecx
4003064b:	49                   	dec    %ecx
4003064c:	88 4d f7             	mov    %cl,-0x9(%ebp)
4003064f:	31 c9                	xor    %ecx,%ecx
40030651:	80 7d f7 02          	cmpb   $0x2,-0x9(%ebp)
40030655:	77 0a                	ja     40030661 <spi_qmsi_configure+0x32>
40030657:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
4003065b:	8a 89 34 56 03 40    	mov    0x40035634(%ecx),%cl
	/* As loopback is implemented inside the controller,
	 * the bus mode doesn't matter.
	 */
	context->loopback = SPI_MODE(config->config) & SPI_MODE_LOOP;
40030661:	c1 e8 02             	shr    $0x2,%eax
40030664:	83 e0 01             	and    $0x1,%eax
40030667:	88 43 2c             	mov    %al,0x2c(%ebx)
	cfg->clk_divider = config->max_sys_freq;
4003066a:	8b 42 04             	mov    0x4(%edx),%eax
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
4003066d:	0f b6 f1             	movzbl %cl,%esi
	cfg->clk_divider = config->max_sys_freq;
40030670:	66 89 43 24          	mov    %ax,0x24(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030674:	89 73 1c             	mov    %esi,0x1c(%ebx)

	/* Will set the configuration before the transfer starts */
	return 0;
}
40030677:	5a                   	pop    %edx
40030678:	31 c0                	xor    %eax,%eax
4003067a:	5b                   	pop    %ebx
4003067b:	5e                   	pop    %esi
4003067c:	5d                   	pop    %ebp
4003067d:	c3                   	ret    

4003067e <spi_qmsi_slave_select>:
	context->rc = error;
	k_sem_give(&context->device_sync_sem);
}

static int spi_qmsi_slave_select(struct device *dev, uint32_t slave)
{
4003067e:	55                   	push   %ebp
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
	qm_spi_t spi = spi_config->spi;

	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
4003067f:	8d 4a ff             	lea    -0x1(%edx),%ecx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030682:	8b 00                	mov    (%eax),%eax
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030684:	ba 01 00 00 00       	mov    $0x1,%edx
40030689:	d3 e2                	shl    %cl,%edx
	qm_spi_t spi = spi_config->spi;
4003068b:	8b 40 08             	mov    0x8(%eax),%eax
{
4003068e:	89 e5                	mov    %esp,%ebp
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030690:	8b 00                	mov    (%eax),%eax
40030692:	e8 4e 10 00 00       	call   400316e5 <qm_spi_slave_select>
40030697:	85 c0                	test   %eax,%eax
40030699:	74 05                	je     400306a0 <spi_qmsi_slave_select+0x22>
4003069b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400306a0:	5d                   	pop    %ebp
400306a1:	c3                   	ret    

400306a2 <spi_qmsi_init>:
#else
#define spi_master_set_power_state(...)
#endif

static int spi_qmsi_init(struct device *dev)
{
400306a2:	55                   	push   %ebp
400306a3:	89 e5                	mov    %esp,%ebp
400306a5:	57                   	push   %edi
400306a6:	56                   	push   %esi
400306a7:	53                   	push   %ebx
400306a8:	83 ec 08             	sub    $0x8,%esp
400306ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
400306ae:	8b 00                	mov    (%eax),%eax
400306b0:	8b 70 08             	mov    0x8(%eax),%esi
	struct spi_qmsi_runtime *context = dev->driver_data;
400306b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400306b6:	8b 40 08             	mov    0x8(%eax),%eax
400306b9:	89 45 f0             	mov    %eax,-0x10(%ebp)

	switch (spi_config->spi) {
400306bc:	8b 06                	mov    (%esi),%eax
400306be:	85 c0                	test   %eax,%eax
400306c0:	74 40                	je     40030702 <spi_qmsi_init+0x60>
400306c2:	48                   	dec    %eax
400306c3:	0f 85 ea 00 00 00    	jne    400307b3 <spi_qmsi_init+0x111>
400306c9:	0f b6 05 2b 6d 03 40 	movzbl 0x40036d2b,%eax
400306d0:	b9 00 80 00 00       	mov    $0x8000,%ecx
400306d5:	ba 03 00 00 00       	mov    $0x3,%edx
400306da:	e8 67 fe ff ff       	call   40030546 <__irq_controller_irq_config>
#ifdef CONFIG_SPI_1
	case QM_SPI_MST_1:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT),
			    CONFIG_SPI_1_IRQ_PRI, qm_spi_master_1_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT));
400306df:	b8 03 00 00 00       	mov    $0x3,%eax
400306e4:	e8 7f fe ff ff       	call   40030568 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M1_REGISTER);
400306e9:	b8 02 80 00 00       	mov    $0x8002,%eax
400306ee:	e8 90 0a 00 00       	call   40031183 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
400306f3:	a1 58 04 80 b0       	mov    0xb0800458,%eax
400306f8:	83 e0 fe             	and    $0xfffffffe,%eax
400306fb:	a3 58 04 80 b0       	mov    %eax,0xb0800458
				QM_INTERRUPT_ROUTER->spi_master_1_int_mask);
		break;
40030700:	eb 37                	jmp    40030739 <spi_qmsi_init+0x97>
40030702:	0f b6 05 2a 6d 03 40 	movzbl 0x40036d2a,%eax
40030709:	b9 00 80 00 00       	mov    $0x8000,%ecx
4003070e:	ba 02 00 00 00       	mov    $0x2,%edx
40030713:	e8 2e fe ff ff       	call   40030546 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_0_INT));
40030718:	b8 02 00 00 00       	mov    $0x2,%eax
4003071d:	e8 46 fe ff ff       	call   40030568 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M0_REGISTER);
40030722:	b8 02 40 00 00       	mov    $0x4002,%eax
40030727:	e8 57 0a 00 00       	call   40031183 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
4003072c:	a1 54 04 80 b0       	mov    0xb0800454,%eax
40030731:	83 e0 fe             	and    $0xfffffffe,%eax
40030734:	a3 54 04 80 b0       	mov    %eax,0xb0800454
	if (!config->cs_port)
40030739:	8b 46 04             	mov    0x4(%esi),%eax
4003073c:	85 c0                	test   %eax,%eax
4003073e:	75 04                	jne    40030744 <spi_qmsi_init+0xa2>
		return NULL;
40030740:	31 db                	xor    %ebx,%ebx
40030742:	eb 35                	jmp    40030779 <spi_qmsi_init+0xd7>
	gpio = device_get_binding(config->cs_port);
40030744:	e8 c1 2e 00 00       	call   4003360a <device_get_binding>
40030749:	89 c3                	mov    %eax,%ebx
	if (!gpio)
4003074b:	85 c0                	test   %eax,%eax
4003074d:	74 f1                	je     40030740 <spi_qmsi_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
4003074f:	8b 40 04             	mov    0x4(%eax),%eax
40030752:	31 d2                	xor    %edx,%edx
40030754:	0f b6 4e 08          	movzbl 0x8(%esi),%ecx
40030758:	89 c7                	mov    %eax,%edi
4003075a:	89 d8                	mov    %ebx,%eax
4003075c:	6a 01                	push   $0x1
4003075e:	ff 17                	call   *(%edi)
40030760:	59                   	pop    %ecx
	if (gpio_pin_configure(gpio, config->cs_pin, GPIO_DIR_OUT) != 0) {
40030761:	85 c0                	test   %eax,%eax
40030763:	75 db                	jne    40030740 <spi_qmsi_init+0x9e>
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40030765:	8b 4e 08             	mov    0x8(%esi),%ecx
40030768:	8b 73 04             	mov    0x4(%ebx),%esi
4003076b:	31 d2                	xor    %edx,%edx
4003076d:	89 d8                	mov    %ebx,%eax
4003076f:	6a 01                	push   $0x1
40030771:	ff 56 04             	call   *0x4(%esi)
40030774:	5a                   	pop    %edx
	if (gpio_pin_write(gpio, config->cs_pin, 1) != 0) {
40030775:	85 c0                	test   %eax,%eax
40030777:	75 c7                	jne    40030740 <spi_qmsi_init+0x9e>

	default:
		return -EIO;
	}

	context->gpio_cs = gpio_cs_init(spi_config);
40030779:	8b 45 f0             	mov    -0x10(%ebp),%eax

	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
4003077c:	83 c9 ff             	or     $0xffffffff,%ecx
4003077f:	83 c0 04             	add    $0x4,%eax
40030782:	31 d2                	xor    %edx,%edx
	context->gpio_cs = gpio_cs_init(spi_config);
40030784:	89 58 fc             	mov    %ebx,-0x4(%eax)
	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40030787:	e8 65 33 00 00       	call   40033af1 <k_sem_init>
	k_sem_init(&context->sem, 0, UINT_MAX);
4003078c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003078f:	8d 58 30             	lea    0x30(%eax),%ebx
40030792:	83 c9 ff             	or     $0xffffffff,%ecx
40030795:	31 d2                	xor    %edx,%edx
40030797:	89 d8                	mov    %ebx,%eax
40030799:	e8 53 33 00 00       	call   40033af1 <k_sem_init>
	k_sem_give(&context->sem);
4003079e:	89 d8                	mov    %ebx,%eax
400307a0:	e8 5c 33 00 00       	call   40033b01 <k_sem_give>

	spi_master_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	dev->driver_api = &spi_qmsi_api;
400307a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
400307a8:	c7 40 04 50 56 03 40 	movl   $0x40035650,0x4(%eax)
	return 0;
400307af:	31 c0                	xor    %eax,%eax
400307b1:	eb 05                	jmp    400307b8 <spi_qmsi_init+0x116>
		return -EIO;
400307b3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400307b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
400307bb:	5b                   	pop    %ebx
400307bc:	5e                   	pop    %esi
400307bd:	5f                   	pop    %edi
400307be:	5d                   	pop    %ebp
400307bf:	c3                   	ret    

400307c0 <spi_control_cs>:
{
400307c0:	55                   	push   %ebp
400307c1:	89 e5                	mov    %esp,%ebp
400307c3:	56                   	push   %esi
400307c4:	53                   	push   %ebx
	struct device *gpio = context->gpio_cs;
400307c5:	8b 48 08             	mov    0x8(%eax),%ecx
400307c8:	8b 31                	mov    (%ecx),%esi
	if (!gpio)
400307ca:	85 f6                	test   %esi,%esi
400307cc:	74 1a                	je     400307e8 <spi_control_cs+0x28>
	const struct spi_qmsi_config *config = dev->config->config_info;
400307ce:	8b 00                	mov    (%eax),%eax
	gpio_pin_write(gpio, config->cs_pin, !active);
400307d0:	83 f2 01             	xor    $0x1,%edx
400307d3:	8b 5e 04             	mov    0x4(%esi),%ebx
400307d6:	8b 40 08             	mov    0x8(%eax),%eax
400307d9:	0f b6 d2             	movzbl %dl,%edx
400307dc:	8b 48 08             	mov    0x8(%eax),%ecx
400307df:	52                   	push   %edx
400307e0:	89 f0                	mov    %esi,%eax
400307e2:	31 d2                	xor    %edx,%edx
400307e4:	ff 53 04             	call   *0x4(%ebx)
400307e7:	58                   	pop    %eax
}
400307e8:	8d 65 f8             	lea    -0x8(%ebp),%esp
400307eb:	5b                   	pop    %ebx
400307ec:	5e                   	pop    %esi
400307ed:	5d                   	pop    %ebp
400307ee:	c3                   	ret    

400307ef <transfer_complete>:
{
400307ef:	55                   	push   %ebp
400307f0:	89 e5                	mov    %esp,%ebp
400307f2:	57                   	push   %edi
400307f3:	56                   	push   %esi
400307f4:	53                   	push   %ebx
	const struct spi_qmsi_config *spi_config =
400307f5:	8b 00                	mov    (%eax),%eax
	qm_spi_t spi = spi_config->spi;
400307f7:	8b 40 08             	mov    0x8(%eax),%eax
	struct device *dev = pending->dev;
400307fa:	6b 38 1c             	imul   $0x1c,(%eax),%edi
400307fd:	8b 87 a0 68 00 a8    	mov    -0x57ff9760(%edi),%eax
	if (!dev)
40030803:	85 c0                	test   %eax,%eax
40030805:	74 25                	je     4003082c <transfer_complete+0x3d>
40030807:	89 d6                	mov    %edx,%esi
	spi_control_cs(dev, false);
40030809:	31 d2                	xor    %edx,%edx
	context = dev->driver_data;
4003080b:	8b 58 08             	mov    0x8(%eax),%ebx
	spi_control_cs(dev, false);
4003080e:	e8 ad ff ff ff       	call   400307c0 <spi_control_cs>
	pending->dev = NULL;
40030813:	c7 87 a0 68 00 a8 00 	movl   $0x0,-0x57ff9760(%edi)
4003081a:	00 00 00 
	k_sem_give(&context->device_sync_sem);
4003081d:	8d 43 04             	lea    0x4(%ebx),%eax
	context->rc = error;
40030820:	89 73 28             	mov    %esi,0x28(%ebx)
}
40030823:	5b                   	pop    %ebx
40030824:	5e                   	pop    %esi
40030825:	5f                   	pop    %edi
40030826:	5d                   	pop    %ebp
	k_sem_give(&context->device_sync_sem);
40030827:	e9 d5 32 00 00       	jmp    40033b01 <k_sem_give>
}
4003082c:	5b                   	pop    %ebx
4003082d:	5e                   	pop    %esi
4003082e:	5f                   	pop    %edi
4003082f:	5d                   	pop    %ebp
40030830:	c3                   	ret    

40030831 <spi_qmsi_transceive>:
{
40030831:	55                   	push   %ebp
40030832:	89 e5                	mov    %esp,%ebp
40030834:	57                   	push   %edi
40030835:	56                   	push   %esi
40030836:	53                   	push   %ebx
40030837:	83 ec 14             	sub    $0x14,%esp
4003083a:	89 c3                	mov    %eax,%ebx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
4003083c:	8b 00                	mov    (%eax),%eax
{
4003083e:	89 55 e0             	mov    %edx,-0x20(%ebp)
	struct spi_qmsi_runtime *context = dev->driver_data;
40030841:	8b 73 08             	mov    0x8(%ebx),%esi
{
40030844:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	qm_spi_t spi = spi_config->spi;
40030847:	8b 40 08             	mov    0x8(%eax),%eax
4003084a:	8b 00                	mov    (%eax),%eax
4003084c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	qm_spi_config_t *cfg = &context->cfg;
4003084f:	8d 46 14             	lea    0x14(%esi),%eax
40030852:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8_t dfs = frame_size_to_dfs(cfg->frame_size);
40030855:	8b 46 14             	mov    0x14(%esi),%eax
		return 1;
40030858:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_8_BIT)
4003085c:	83 f8 07             	cmp    $0x7,%eax
4003085f:	76 15                	jbe    40030876 <spi_qmsi_transceive+0x45>
		return 2;
40030861:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_16_BIT)
40030865:	83 f8 0f             	cmp    $0xf,%eax
40030868:	76 0c                	jbe    40030876 <spi_qmsi_transceive+0x45>
	return 0;
4003086a:	83 f8 20             	cmp    $0x20,%eax
4003086d:	0f 92 c0             	setb   %al
40030870:	c1 e0 02             	shl    $0x2,%eax
40030873:	88 45 ec             	mov    %al,-0x14(%ebp)
	k_sem_take(&context->sem, K_FOREVER);
40030876:	8d 4e 30             	lea    0x30(%esi),%ecx
40030879:	83 ca ff             	or     $0xffffffff,%edx
4003087c:	89 c8                	mov    %ecx,%eax
4003087e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40030881:	e8 f0 32 00 00       	call   40033b76 <k_sem_take>
	if (pending_transfers[spi].dev) {
40030886:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030889:	6b 55 f0 1c          	imul   $0x1c,-0x10(%ebp),%edx
4003088d:	8d ba a0 68 00 a8    	lea    -0x57ff9760(%edx),%edi
40030893:	83 ba a0 68 00 a8 00 	cmpl   $0x0,-0x57ff9760(%edx)
4003089a:	74 11                	je     400308ad <spi_qmsi_transceive+0x7c>
		k_sem_give(&context->sem);
4003089c:	89 c8                	mov    %ecx,%eax
4003089e:	e8 5e 32 00 00       	call   40033b01 <k_sem_give>
		return -EBUSY;
400308a3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
400308a8:	e9 ed 00 00 00       	jmp    4003099a <spi_qmsi_transceive+0x169>
	k_sem_give(&context->sem);
400308ad:	89 c8                	mov    %ecx,%eax
	pending_transfers[spi].dev = dev;
400308af:	89 9a a0 68 00 a8    	mov    %ebx,-0x57ff9760(%edx)
400308b5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_sem_give(&context->sem);
400308b8:	e8 44 32 00 00       	call   40033b01 <k_sem_give>
	device_busy_set(dev);
400308bd:	89 d8                	mov    %ebx,%eax
400308bf:	e8 7e 2d 00 00       	call   40033642 <device_busy_set>
	xfer = &pending_transfers[spi].xfer;
400308c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
400308c7:	8d 82 a4 68 00 a8    	lea    -0x57ff975c(%edx),%eax
	xfer->rx_len = rx_buf_len / dfs;
400308cd:	31 d2                	xor    %edx,%edx
400308cf:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
	xfer = &pending_transfers[spi].xfer;
400308d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	xfer->rx = rx_buf;
400308d6:	8b 45 08             	mov    0x8(%ebp),%eax
400308d9:	89 47 08             	mov    %eax,0x8(%edi)
	xfer->rx_len = rx_buf_len / dfs;
400308dc:	8b 45 0c             	mov    0xc(%ebp),%eax
400308df:	f7 f1                	div    %ecx
400308e1:	66 89 47 0e          	mov    %ax,0xe(%edi)
	xfer->tx = (uint8_t *)tx_buf;
400308e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
	xfer->tx_len = tx_buf_len / dfs;
400308e8:	31 d2                	xor    %edx,%edx
	xfer->tx = (uint8_t *)tx_buf;
400308ea:	89 47 04             	mov    %eax,0x4(%edi)
	xfer->tx_len = tx_buf_len / dfs;
400308ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
	xfer->callback_data = dev;
400308f0:	89 5f 18             	mov    %ebx,0x18(%edi)
	xfer->tx_len = tx_buf_len / dfs;
400308f3:	f7 f1                	div    %ecx
400308f5:	66 89 47 0c          	mov    %ax,0xc(%edi)
	xfer->callback = transfer_complete;
400308f9:	c7 47 14 ef 07 03 40 	movl   $0x400307ef,0x14(%edi)
	if (tx_buf_len == 0)
40030900:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030904:	75 09                	jne    4003090f <spi_qmsi_transceive+0xde>
		cfg->transfer_mode = QM_SPI_TMOD_RX;
40030906:	c7 46 18 02 00 00 00 	movl   $0x2,0x18(%esi)
4003090d:	eb 0c                	jmp    4003091b <spi_qmsi_transceive+0xea>
		cfg->transfer_mode = QM_SPI_TMOD_TX;
4003090f:	31 c0                	xor    %eax,%eax
40030911:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40030915:	0f 94 c0             	sete   %al
40030918:	89 46 18             	mov    %eax,0x18(%esi)
	if (context->loopback)
4003091b:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
4003091f:	74 11                	je     40030932 <spi_qmsi_transceive+0x101>
		QM_SPI[spi]->ctrlr0 |= BIT(11);
40030921:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030924:	8b 14 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edx
4003092b:	8b 02                	mov    (%edx),%eax
4003092d:	80 cc 08             	or     $0x8,%ah
40030930:	89 02                	mov    %eax,(%edx)
	rc = qm_spi_set_config(spi, cfg);
40030932:	8d 56 14             	lea    0x14(%esi),%edx
40030935:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030938:	e8 3b 0d 00 00       	call   40031678 <qm_spi_set_config>
	if (rc != 0) {
4003093d:	85 c0                	test   %eax,%eax
4003093f:	74 0e                	je     4003094f <spi_qmsi_transceive+0x11e>
		device_busy_clear(dev);
40030941:	89 d8                	mov    %ebx,%eax
40030943:	e8 ff 2c 00 00       	call   40033647 <device_busy_clear>
		return -EINVAL;
40030948:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
4003094d:	eb 4b                	jmp    4003099a <spi_qmsi_transceive+0x169>
	spi_control_cs(dev, true);
4003094f:	ba 01 00 00 00       	mov    $0x1,%edx
40030954:	89 d8                	mov    %ebx,%eax
40030956:	e8 65 fe ff ff       	call   400307c0 <spi_control_cs>
	rc = qm_spi_irq_transfer(spi, xfer);
4003095b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4003095e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030961:	e8 01 0e 00 00       	call   40031767 <qm_spi_irq_transfer>
	if (rc != 0) {
40030966:	85 c0                	test   %eax,%eax
40030968:	74 12                	je     4003097c <spi_qmsi_transceive+0x14b>
		spi_control_cs(dev, false);
4003096a:	89 d8                	mov    %ebx,%eax
4003096c:	31 d2                	xor    %edx,%edx
4003096e:	e8 4d fe ff ff       	call   400307c0 <spi_control_cs>
		device_busy_clear(dev);
40030973:	89 d8                	mov    %ebx,%eax
40030975:	e8 cd 2c 00 00       	call   40033647 <device_busy_clear>
4003097a:	eb 19                	jmp    40030995 <spi_qmsi_transceive+0x164>
	k_sem_take(&context->device_sync_sem, K_FOREVER);
4003097c:	83 ca ff             	or     $0xffffffff,%edx
4003097f:	8d 46 04             	lea    0x4(%esi),%eax
40030982:	e8 ef 31 00 00       	call   40033b76 <k_sem_take>
	device_busy_clear(dev);
40030987:	89 d8                	mov    %ebx,%eax
40030989:	e8 b9 2c 00 00       	call   40033647 <device_busy_clear>
	return context->rc ? -EIO : 0;
4003098e:	8b 46 28             	mov    0x28(%esi),%eax
40030991:	85 c0                	test   %eax,%eax
40030993:	74 05                	je     4003099a <spi_qmsi_transceive+0x169>
40030995:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
4003099a:	83 c4 14             	add    $0x14,%esp
4003099d:	5b                   	pop    %ebx
4003099e:	5e                   	pop    %esi
4003099f:	5f                   	pop    %edi
400309a0:	5d                   	pop    %ebp
400309a1:	c3                   	ret    

400309a2 <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
400309a2:	55                   	push   %ebp
400309a3:	89 e5                	mov    %esp,%ebp
400309a5:	57                   	push   %edi
400309a6:	56                   	push   %esi
400309a7:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
400309a8:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
400309ab:	89 d6                	mov    %edx,%esi
400309ad:	23 71 08             	and    0x8(%ecx),%esi
400309b0:	74 1c                	je     400309ce <gpio_qmsi_callback+0x2c>
400309b2:	8b 19                	mov    (%ecx),%ebx
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
400309b4:	85 db                	test   %ebx,%ebx
400309b6:	74 16                	je     400309ce <gpio_qmsi_callback+0x2c>
400309b8:	89 c7                	mov    %eax,%edi
		if (cb->pin_mask & pins) {
400309ba:	85 73 08             	test   %esi,0x8(%ebx)
400309bd:	74 09                	je     400309c8 <gpio_qmsi_callback+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
400309bf:	89 f1                	mov    %esi,%ecx
400309c1:	89 da                	mov    %ebx,%edx
400309c3:	89 f8                	mov    %edi,%eax
400309c5:	ff 53 04             	call   *0x4(%ebx)
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
400309c8:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
400309ca:	85 db                	test   %ebx,%ebx
400309cc:	75 ec                	jne    400309ba <gpio_qmsi_callback+0x18>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
400309ce:	5b                   	pop    %ebx
400309cf:	5e                   	pop    %esi
400309d0:	5f                   	pop    %edi
400309d1:	5d                   	pop    %ebp
400309d2:	c3                   	ret    

400309d3 <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
400309d3:	55                   	push   %ebp
	if (value) {
400309d4:	84 c9                	test   %cl,%cl
{
400309d6:	89 e5                	mov    %esp,%ebp
400309d8:	0f b6 d2             	movzbl %dl,%edx
	if (value) {
400309db:	74 05                	je     400309e2 <qmsi_write_bit+0xf>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
400309dd:	0f ab 10             	bts    %edx,(%eax)
400309e0:	eb 03                	jmp    400309e5 <qmsi_write_bit+0x12>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
400309e2:	0f b3 10             	btr    %edx,(%eax)
		sys_set_bit((uintptr_t) target, bit);
	} else {
		sys_clear_bit((uintptr_t) target, bit);
	}
}
400309e5:	5d                   	pop    %ebp
400309e6:	c3                   	ret    

400309e7 <gpio_qmsi_manage_callback>:

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
400309e7:	8b 40 08             	mov    0x8(%eax),%eax
	if (set) {
400309ea:	84 c9                	test   %cl,%cl
400309ec:	74 11                	je     400309ff <gpio_qmsi_manage_callback+0x18>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
400309ee:	8b 08                	mov    (%eax),%ecx
400309f0:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
400309f2:	89 10                	mov    %edx,(%eax)

	if (!list->tail) {
400309f4:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
400309f8:	75 44                	jne    40030a3e <gpio_qmsi_manage_callback+0x57>
		list->tail = list->head;
400309fa:	89 50 04             	mov    %edx,0x4(%eax)
400309fd:	eb 3f                	jmp    40030a3e <gpio_qmsi_manage_callback+0x57>
{
400309ff:	55                   	push   %ebp
40030a00:	89 e5                	mov    %esp,%ebp
40030a02:	53                   	push   %ebx
40030a03:	8b 08                	mov    (%eax),%ecx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
40030a05:	31 db                	xor    %ebx,%ebx
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
40030a07:	85 c9                	test   %ecx,%ecx
40030a09:	74 2e                	je     40030a39 <gpio_qmsi_manage_callback+0x52>
		if (test == node) {
40030a0b:	39 ca                	cmp    %ecx,%edx
40030a0d:	75 24                	jne    40030a33 <gpio_qmsi_manage_callback+0x4c>
	if (!prev_node) {
40030a0f:	85 db                	test   %ebx,%ebx
40030a11:	8b 0a                	mov    (%edx),%ecx
40030a13:	75 0c                	jne    40030a21 <gpio_qmsi_manage_callback+0x3a>
		list->head = node->next;
40030a15:	89 08                	mov    %ecx,(%eax)
		if (list->tail == node) {
40030a17:	3b 50 04             	cmp    0x4(%eax),%edx
40030a1a:	75 0f                	jne    40030a2b <gpio_qmsi_manage_callback+0x44>
			list->tail = list->head;
40030a1c:	89 48 04             	mov    %ecx,0x4(%eax)
40030a1f:	eb 0a                	jmp    40030a2b <gpio_qmsi_manage_callback+0x44>
		prev_node->next = node->next;
40030a21:	89 0b                	mov    %ecx,(%ebx)
		if (list->tail == node) {
40030a23:	3b 50 04             	cmp    0x4(%eax),%edx
40030a26:	75 03                	jne    40030a2b <gpio_qmsi_manage_callback+0x44>
			list->tail = prev_node;
40030a28:	89 58 04             	mov    %ebx,0x4(%eax)
	node->next = NULL;
40030a2b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
40030a31:	eb 06                	jmp    40030a39 <gpio_qmsi_manage_callback+0x52>
	SYS_SLIST_FOR_EACH_NODE(list, test) {
40030a33:	89 cb                	mov    %ecx,%ebx
40030a35:	8b 09                	mov    (%ecx),%ecx
40030a37:	eb ce                	jmp    40030a07 <gpio_qmsi_manage_callback+0x20>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
40030a39:	31 c0                	xor    %eax,%eax
40030a3b:	5b                   	pop    %ebx
40030a3c:	5d                   	pop    %ebp
40030a3d:	c3                   	ret    
40030a3e:	31 c0                	xor    %eax,%eax
40030a40:	c3                   	ret    

40030a41 <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
40030a41:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40030a42:	85 d2                	test   %edx,%edx
{
40030a44:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40030a46:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030a49:	75 0c                	jne    40030a57 <gpio_qmsi_enable_callback+0x16>
		context->pin_callbacks |= BIT(pin);
40030a4b:	ba 01 00 00 00       	mov    $0x1,%edx
40030a50:	d3 e2                	shl    %cl,%edx
40030a52:	09 50 08             	or     %edx,0x8(%eax)
40030a55:	eb 07                	jmp    40030a5e <gpio_qmsi_enable_callback+0x1d>
	} else {
		context->pin_callbacks = 0xffffffff;
40030a57:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
40030a5e:	31 c0                	xor    %eax,%eax
40030a60:	5d                   	pop    %ebp
40030a61:	c3                   	ret    

40030a62 <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
40030a62:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40030a63:	85 d2                	test   %edx,%edx
{
40030a65:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40030a67:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030a6a:	75 0c                	jne    40030a78 <gpio_qmsi_disable_callback+0x16>
		context->pin_callbacks &= ~BIT(pin);
40030a6c:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
40030a71:	d3 c2                	rol    %cl,%edx
40030a73:	21 50 08             	and    %edx,0x8(%eax)
40030a76:	eb 07                	jmp    40030a7f <gpio_qmsi_disable_callback+0x1d>
	} else {
		context->pin_callbacks = 0;
40030a78:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
40030a7f:	31 c0                	xor    %eax,%eax
40030a81:	5d                   	pop    %ebp
40030a82:	c3                   	ret    

40030a83 <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
40030a83:	55                   	push   %ebp
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
40030a84:	8b 00                	mov    (%eax),%eax
{
40030a86:	89 e5                	mov    %esp,%ebp
	qm_gpio_t gpio = gpio_config->gpio;

	return QM_GPIO[gpio]->gpio_intstatus;
}
40030a88:	5d                   	pop    %ebp
	qm_gpio_t gpio = gpio_config->gpio;
40030a89:	8b 40 08             	mov    0x8(%eax),%eax
	return QM_GPIO[gpio]->gpio_intstatus;
40030a8c:	8b 00                	mov    (%eax),%eax
40030a8e:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40030a95:	8b 40 40             	mov    0x40(%eax),%eax
}
40030a98:	c3                   	ret    

40030a99 <gpio_qmsi_read>:
{
40030a99:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030a9a:	85 d2                	test   %edx,%edx
{
40030a9c:	89 e5                	mov    %esp,%ebp
40030a9e:	53                   	push   %ebx
40030a9f:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030aa0:	8b 00                	mov    (%eax),%eax
{
40030aa2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40030aa5:	8b 40 08             	mov    0x8(%eax),%eax
40030aa8:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030aaa:	75 12                	jne    40030abe <gpio_qmsi_read+0x25>
		qm_gpio_read_pin(gpio, pin, &state);
40030aac:	0f b6 d1             	movzbl %cl,%edx
40030aaf:	8d 4d f8             	lea    -0x8(%ebp),%ecx
40030ab2:	e8 90 07 00 00       	call   40031247 <qm_gpio_read_pin>
		*value = state;
40030ab7:	8b 45 f8             	mov    -0x8(%ebp),%eax
40030aba:	89 03                	mov    %eax,(%ebx)
40030abc:	eb 07                	jmp    40030ac5 <gpio_qmsi_read+0x2c>
		qm_gpio_read_port(gpio, (uint32_t *const) value);
40030abe:	89 da                	mov    %ebx,%edx
40030ac0:	e8 e2 07 00 00       	call   400312a7 <qm_gpio_read_port>
}
40030ac5:	5a                   	pop    %edx
40030ac6:	31 c0                	xor    %eax,%eax
40030ac8:	5b                   	pop    %ebx
40030ac9:	5d                   	pop    %ebp
40030aca:	c3                   	ret    

40030acb <gpio_qmsi_write>:
{
40030acb:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030acc:	85 d2                	test   %edx,%edx
{
40030ace:	89 e5                	mov    %esp,%ebp
40030ad0:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030ad1:	8b 00                	mov    (%eax),%eax
{
40030ad3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40030ad6:	8b 40 08             	mov    0x8(%eax),%eax
40030ad9:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030adb:	75 15                	jne    40030af2 <gpio_qmsi_write+0x27>
		if (value) {
40030add:	85 db                	test   %ebx,%ebx
40030adf:	0f b6 d1             	movzbl %cl,%edx
40030ae2:	74 07                	je     40030aeb <gpio_qmsi_write+0x20>
			qm_gpio_set_pin(gpio, pin);
40030ae4:	e8 7c 07 00 00       	call   40031265 <qm_gpio_set_pin>
40030ae9:	eb 0e                	jmp    40030af9 <gpio_qmsi_write+0x2e>
			qm_gpio_clear_pin(gpio, pin);
40030aeb:	e8 96 07 00 00       	call   40031286 <qm_gpio_clear_pin>
40030af0:	eb 07                	jmp    40030af9 <gpio_qmsi_write+0x2e>
		qm_gpio_write_port(gpio, value);
40030af2:	89 da                	mov    %ebx,%edx
40030af4:	e8 c1 07 00 00       	call   400312ba <qm_gpio_write_port>
}
40030af9:	31 c0                	xor    %eax,%eax
40030afb:	5b                   	pop    %ebx
40030afc:	5d                   	pop    %ebp
40030afd:	c3                   	ret    

40030afe <qmsi_pin_config>:
{
40030afe:	55                   	push   %ebp
40030aff:	89 e5                	mov    %esp,%ebp
40030b01:	57                   	push   %edi
40030b02:	56                   	push   %esi
40030b03:	53                   	push   %ebx
40030b04:	83 ec 24             	sub    $0x24,%esp
40030b07:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030b09:	8b 00                	mov    (%eax),%eax
{
40030b0b:	89 ce                	mov    %ecx,%esi
	qm_gpio_port_config_t cfg = { 0 };
40030b0d:	8d 7d d4             	lea    -0x2c(%ebp),%edi
40030b10:	b9 08 00 00 00       	mov    $0x8,%ecx
	qm_gpio_t gpio = gpio_config->gpio;
40030b15:	8b 40 08             	mov    0x8(%eax),%eax
40030b18:	8b 00                	mov    (%eax),%eax
40030b1a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	qm_gpio_port_config_t cfg = { 0 };
40030b1d:	31 c0                	xor    %eax,%eax
40030b1f:	f3 ab                	rep stos %eax,%es:(%edi)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40030b21:	8b 45 d0             	mov    -0x30(%ebp),%eax
40030b24:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40030b2b:	8b 48 04             	mov    0x4(%eax),%ecx
	cfg.callback_data = port;
40030b2e:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40030b31:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
40030b34:	8b 48 30             	mov    0x30(%eax),%ecx
40030b37:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
40030b3a:	8b 48 38             	mov    0x38(%eax),%ecx
40030b3d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
40030b40:	8b 48 3c             	mov    0x3c(%eax),%ecx
40030b43:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
40030b46:	8b 48 48             	mov    0x48(%eax),%ecx
40030b49:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40030b4c:	8b 40 68             	mov    0x68(%eax),%eax
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030b4f:	0f b6 da             	movzbl %dl,%ebx
40030b52:	89 f1                	mov    %esi,%ecx
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40030b54:	89 45 e8             	mov    %eax,-0x18(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030b57:	83 e1 01             	and    $0x1,%ecx
40030b5a:	89 da                	mov    %ebx,%edx
40030b5c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	cfg.callback = gpio_qmsi_callback;
40030b5f:	c7 45 ec a2 09 03 40 	movl   $0x400309a2,-0x14(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030b66:	e8 68 fe ff ff       	call   400309d3 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 0);
40030b6b:	31 c9                	xor    %ecx,%ecx
	if (flags & GPIO_INT) {
40030b6d:	f7 c6 02 00 00 00    	test   $0x2,%esi
40030b73:	74 41                	je     40030bb6 <qmsi_pin_config+0xb8>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
40030b75:	89 f1                	mov    %esi,%ecx
40030b77:	89 da                	mov    %ebx,%edx
40030b79:	83 e1 20             	and    $0x20,%ecx
40030b7c:	8d 45 dc             	lea    -0x24(%ebp),%eax
40030b7f:	e8 4f fe ff ff       	call   400309d3 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
40030b84:	89 f1                	mov    %esi,%ecx
40030b86:	83 e1 04             	and    $0x4,%ecx
40030b89:	89 da                	mov    %ebx,%edx
40030b8b:	8d 45 e0             	lea    -0x20(%ebp),%eax
40030b8e:	e8 40 fe ff ff       	call   400309d3 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_debounce, pin,
40030b93:	89 f1                	mov    %esi,%ecx
40030b95:	83 e1 10             	and    $0x10,%ecx
40030b98:	89 da                	mov    %ebx,%edx
40030b9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		qmsi_write_bit(&cfg.int_bothedge, pin,
40030b9d:	83 e6 40             	and    $0x40,%esi
		qmsi_write_bit(&cfg.int_debounce, pin,
40030ba0:	e8 2e fe ff ff       	call   400309d3 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_bothedge, pin,
40030ba5:	89 f1                	mov    %esi,%ecx
40030ba7:	89 da                	mov    %ebx,%edx
40030ba9:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030bac:	e8 22 fe ff ff       	call   400309d3 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 1);
40030bb1:	b9 01 00 00 00       	mov    $0x1,%ecx
		qmsi_write_bit(&cfg.int_en, pin, 0);
40030bb6:	89 da                	mov    %ebx,%edx
40030bb8:	8d 45 d8             	lea    -0x28(%ebp),%eax
40030bbb:	e8 13 fe ff ff       	call   400309d3 <qmsi_write_bit>
	qm_gpio_set_config(gpio, &cfg);
40030bc0:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40030bc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
40030bc6:	e8 1d 06 00 00       	call   400311e8 <qm_gpio_set_config>
}
40030bcb:	83 c4 24             	add    $0x24,%esp
40030bce:	5b                   	pop    %ebx
40030bcf:	5e                   	pop    %esi
40030bd0:	5f                   	pop    %edi
40030bd1:	5d                   	pop    %ebp
40030bd2:	c3                   	ret    

40030bd3 <gpio_qmsi_config>:
{
40030bd3:	55                   	push   %ebp
40030bd4:	89 e5                	mov    %esp,%ebp
40030bd6:	57                   	push   %edi
40030bd7:	56                   	push   %esi
40030bd8:	89 c6                	mov    %eax,%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030bda:	8b 45 08             	mov    0x8(%ebp),%eax
{
40030bdd:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030bde:	83 e0 03             	and    $0x3,%eax
		return -EINVAL;
40030be1:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030be6:	83 f8 03             	cmp    $0x3,%eax
40030be9:	74 34                	je     40030c1f <gpio_qmsi_config+0x4c>
40030beb:	89 d3                	mov    %edx,%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030bed:	85 d2                	test   %edx,%edx
40030bef:	75 0e                	jne    40030bff <gpio_qmsi_config+0x2c>
40030bf1:	89 ca                	mov    %ecx,%edx
		qmsi_pin_config(port, pin, flags);
40030bf3:	89 f0                	mov    %esi,%eax
40030bf5:	8b 4d 08             	mov    0x8(%ebp),%ecx
40030bf8:	e8 01 ff ff ff       	call   40030afe <qmsi_pin_config>
40030bfd:	eb 20                	jmp    40030c1f <gpio_qmsi_config+0x4c>
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030bff:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < num_pins; i++) {
40030c01:	31 db                	xor    %ebx,%ebx
	uint8_t num_pins = gpio_config->num_pins;
40030c03:	8b 40 08             	mov    0x8(%eax),%eax
	for (i = 0; i < num_pins; i++) {
40030c06:	0f b6 78 04          	movzbl 0x4(%eax),%edi
40030c0a:	39 fb                	cmp    %edi,%ebx
40030c0c:	7d 0f                	jge    40030c1d <gpio_qmsi_config+0x4a>
		qmsi_pin_config(port, i, flags);
40030c0e:	89 da                	mov    %ebx,%edx
40030c10:	8b 4d 08             	mov    0x8(%ebp),%ecx
40030c13:	89 f0                	mov    %esi,%eax
	for (i = 0; i < num_pins; i++) {
40030c15:	43                   	inc    %ebx
		qmsi_pin_config(port, i, flags);
40030c16:	e8 e3 fe ff ff       	call   40030afe <qmsi_pin_config>
40030c1b:	eb ed                	jmp    40030c0a <gpio_qmsi_config+0x37>
	return 0;
40030c1d:	31 db                	xor    %ebx,%ebx
}
40030c1f:	89 d8                	mov    %ebx,%eax
40030c21:	5b                   	pop    %ebx
40030c22:	5e                   	pop    %esi
40030c23:	5f                   	pop    %edi
40030c24:	5d                   	pop    %ebp
40030c25:	c3                   	ret    

40030c26 <gpio_qmsi_init>:
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
40030c26:	55                   	push   %ebp
40030c27:	89 e5                	mov    %esp,%ebp
40030c29:	53                   	push   %ebx
40030c2a:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030c2c:	8b 00                	mov    (%eax),%eax
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
40030c2e:	8b 40 08             	mov    0x8(%eax),%eax
40030c31:	8b 00                	mov    (%eax),%eax
40030c33:	85 c0                	test   %eax,%eax
40030c35:	74 32                	je     40030c69 <gpio_qmsi_init+0x43>
40030c37:	48                   	dec    %eax
40030c38:	75 71                	jne    40030cab <gpio_qmsi_init+0x85>
40030c3a:	0f b6 05 47 6d 03 40 	movzbl 0x40036d47,%eax
40030c41:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030c46:	ba 1f 00 00 00       	mov    $0x1f,%edx
40030c4b:	e8 f6 f8 ff ff       	call   40030546 <__irq_controller_irq_config>
#ifdef CONFIG_GPIO_QMSI_1
	case QM_AON_GPIO_0:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_1_IRQ_PRI, qm_aon_gpio_0_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT));
40030c50:	b8 1f 00 00 00       	mov    $0x1f,%eax
40030c55:	e8 0e f9 ff ff       	call   40030568 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030c5a:	a1 d4 04 80 b0       	mov    0xb08004d4,%eax
40030c5f:	83 e0 fe             	and    $0xfffffffe,%eax
40030c62:	a3 d4 04 80 b0       	mov    %eax,0xb08004d4
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
40030c67:	eb 37                	jmp    40030ca0 <gpio_qmsi_init+0x7a>
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
40030c69:	b8 82 21 00 00       	mov    $0x2182,%eax
40030c6e:	e8 10 05 00 00       	call   40031183 <clk_periph_enable>
40030c73:	0f b6 05 30 6d 03 40 	movzbl 0x40036d30,%eax
40030c7a:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030c7f:	ba 08 00 00 00       	mov    $0x8,%edx
40030c84:	e8 bd f8 ff ff       	call   40030546 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
40030c89:	b8 08 00 00 00       	mov    $0x8,%eax
40030c8e:	e8 d5 f8 ff ff       	call   40030568 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
40030c93:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
40030c98:	83 e0 fe             	and    $0xfffffffe,%eax
40030c9b:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
40030ca0:	c7 43 04 5c 56 03 40 	movl   $0x4003565c,0x4(%ebx)
	return 0;
40030ca7:	31 c0                	xor    %eax,%eax
40030ca9:	eb 05                	jmp    40030cb0 <gpio_qmsi_init+0x8a>
		return -EIO;
40030cab:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030cb0:	5b                   	pop    %ebx
40030cb1:	5d                   	pop    %ebp
40030cb2:	c3                   	ret    

40030cb3 <pinmux_get>:
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
40030cb3:	89 d0                	mov    %edx,%eax
{
40030cb5:	55                   	push   %ebp
	uint32_t reg_offset = pin >> 4;
40030cb6:	c1 e8 04             	shr    $0x4,%eax
{
40030cb9:	89 e5                	mov    %esp,%ebp
40030cbb:	53                   	push   %ebx
40030cbc:	89 cb                	mov    %ecx,%ebx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
40030cbe:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
	uint32_t mode_mask = *mux_register & pin_mask;
40030cc1:	8b 14 85 30 09 80 b0 	mov    -0x4f7ff6d0(,%eax,4),%edx
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
40030cc8:	83 e1 1e             	and    $0x1e,%ecx
40030ccb:	b8 03 00 00 00       	mov    $0x3,%eax
40030cd0:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
40030cd2:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
40030cd4:	d3 e8                	shr    %cl,%eax
40030cd6:	89 03                	mov    %eax,(%ebx)

	*func = mode;

	return 0;
}
40030cd8:	31 c0                	xor    %eax,%eax
40030cda:	5b                   	pop    %ebx
40030cdb:	5d                   	pop    %ebp
40030cdc:	c3                   	ret    

40030cdd <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(struct device *port)
{
40030cdd:	55                   	push   %ebp
	return 0;
}
40030cde:	31 c0                	xor    %eax,%eax
{
40030ce0:	89 e5                	mov    %esp,%ebp
}
40030ce2:	5d                   	pop    %ebp
40030ce3:	c3                   	ret    

40030ce4 <pinmux_input>:
{
40030ce4:	55                   	push   %ebp
40030ce5:	89 d0                	mov    %edx,%eax
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
40030ce7:	31 d2                	xor    %edx,%edx
{
40030ce9:	89 e5                	mov    %esp,%ebp
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
40030ceb:	84 c9                	test   %cl,%cl
40030ced:	0f 95 c2             	setne  %dl
40030cf0:	e8 be 0b 00 00       	call   400318b3 <qm_pmux_input_en>
40030cf5:	85 c0                	test   %eax,%eax
40030cf7:	74 05                	je     40030cfe <pinmux_input+0x1a>
40030cf9:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030cfe:	5d                   	pop    %ebp
40030cff:	c3                   	ret    

40030d00 <pinmux_pullup>:
{
40030d00:	55                   	push   %ebp
40030d01:	89 d0                	mov    %edx,%eax
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
40030d03:	31 d2                	xor    %edx,%edx
{
40030d05:	89 e5                	mov    %esp,%ebp
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
40030d07:	84 c9                	test   %cl,%cl
40030d09:	0f 95 c2             	setne  %dl
40030d0c:	e8 d2 0b 00 00       	call   400318e3 <qm_pmux_pullup_en>
40030d11:	85 c0                	test   %eax,%eax
40030d13:	74 05                	je     40030d1a <pinmux_pullup+0x1a>
40030d15:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030d1a:	5d                   	pop    %ebp
40030d1b:	c3                   	ret    

40030d1c <pinmux_set>:
{
40030d1c:	55                   	push   %ebp
40030d1d:	89 d0                	mov    %edx,%eax
40030d1f:	89 e5                	mov    %esp,%ebp
40030d21:	89 ca                	mov    %ecx,%edx
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
40030d23:	e8 54 0b 00 00       	call   4003187c <qm_pmux_select>
40030d28:	85 c0                	test   %eax,%eax
40030d2a:	74 05                	je     40030d31 <pinmux_set+0x15>
40030d2c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030d31:	5d                   	pop    %ebp
40030d32:	c3                   	ret    

40030d33 <_stdin_hook_default>:
{
	_stdout_hook = hook;
}

static unsigned char _stdin_hook_default(void)
{
40030d33:	55                   	push   %ebp
	return 0;
}
40030d34:	31 c0                	xor    %eax,%eax
{
40030d36:	89 e5                	mov    %esp,%ebp
}
40030d38:	5d                   	pop    %ebp
40030d39:	c3                   	ret    

40030d3a <_stdout_hook_default>:
40030d3a:	55                   	push   %ebp
40030d3b:	83 c8 ff             	or     $0xffffffff,%eax
40030d3e:	89 e5                	mov    %esp,%ebp
40030d40:	5d                   	pop    %ebp
40030d41:	c3                   	ret    

40030d42 <__stdout_hook_install>:
{
40030d42:	55                   	push   %ebp
	_stdout_hook = hook;
40030d43:	a3 c4 66 00 a8       	mov    %eax,0xa80066c4
{
40030d48:	89 e5                	mov    %esp,%ebp
}
40030d4a:	5d                   	pop    %ebp
40030d4b:	c3                   	ret    

40030d4c <_read>:
{
	_stdin_hook = hook;
}

int _read(int fd, char *buf, int nbytes)
{
40030d4c:	55                   	push   %ebp
40030d4d:	89 e5                	mov    %esp,%ebp
40030d4f:	57                   	push   %edi
40030d50:	89 d7                	mov    %edx,%edi
40030d52:	56                   	push   %esi
40030d53:	89 ce                	mov    %ecx,%esi
40030d55:	53                   	push   %ebx
	int i = 0;

	for (i = 0; i < nbytes; i++) {
40030d56:	31 db                	xor    %ebx,%ebx
40030d58:	39 f3                	cmp    %esi,%ebx
40030d5a:	7d 14                	jge    40030d70 <_read+0x24>
		*(buf + i) = _stdin_hook();
40030d5c:	ff 15 c0 66 00 a8    	call   *0xa80066c0
40030d62:	88 04 1f             	mov    %al,(%edi,%ebx,1)
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
40030d65:	3c 0a                	cmp    $0xa,%al
40030d67:	8d 5b 01             	lea    0x1(%ebx),%ebx
40030d6a:	74 04                	je     40030d70 <_read+0x24>
40030d6c:	3c 0d                	cmp    $0xd,%al
40030d6e:	75 e8                	jne    40030d58 <_read+0xc>
			i++;
			break;
		}
	}
	return i;
}
40030d70:	89 d8                	mov    %ebx,%eax
40030d72:	5b                   	pop    %ebx
40030d73:	5e                   	pop    %esi
40030d74:	5f                   	pop    %edi
40030d75:	5d                   	pop    %ebp
40030d76:	c3                   	ret    

40030d77 <_write>:
FUNC_ALIAS(_read, read, int);

int _write(int fd, char *buf, int nbytes)
{
40030d77:	55                   	push   %ebp
40030d78:	89 e5                	mov    %esp,%ebp
40030d7a:	57                   	push   %edi
40030d7b:	89 d7                	mov    %edx,%edi
40030d7d:	56                   	push   %esi
40030d7e:	89 ce                	mov    %ecx,%esi
40030d80:	53                   	push   %ebx
	int i;

	for (i = 0; i < nbytes; i++) {
40030d81:	31 db                	xor    %ebx,%ebx
40030d83:	39 f3                	cmp    %esi,%ebx
40030d85:	7d 1e                	jge    40030da5 <_write+0x2e>
		if (*(buf + i) == '\n') {
40030d87:	80 3c 1f 0a          	cmpb   $0xa,(%edi,%ebx,1)
40030d8b:	75 0b                	jne    40030d98 <_write+0x21>
			_stdout_hook('\r');
40030d8d:	b8 0d 00 00 00       	mov    $0xd,%eax
40030d92:	ff 15 c4 66 00 a8    	call   *0xa80066c4
		}
		_stdout_hook(*(buf + i));
40030d98:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
	for (i = 0; i < nbytes; i++) {
40030d9c:	43                   	inc    %ebx
		_stdout_hook(*(buf + i));
40030d9d:	ff 15 c4 66 00 a8    	call   *0xa80066c4
40030da3:	eb de                	jmp    40030d83 <_write+0xc>
	}
	return nbytes;
}
40030da5:	5b                   	pop    %ebx
40030da6:	89 f0                	mov    %esi,%eax
40030da8:	5e                   	pop    %esi
40030da9:	5f                   	pop    %edi
40030daa:	5d                   	pop    %ebp
40030dab:	c3                   	ret    

40030dac <_isatty>:
FUNC_ALIAS(_write, write, int);

int _isatty(int file)
{
40030dac:	55                   	push   %ebp
	return 1;
}
40030dad:	b8 01 00 00 00       	mov    $0x1,%eax
{
40030db2:	89 e5                	mov    %esp,%ebp
}
40030db4:	5d                   	pop    %ebp
40030db5:	c3                   	ret    

40030db6 <_fstat>:
	return 0;
}
FUNC_ALIAS(_getpid, getpid, int);

int _fstat(int file, struct stat *st)
{
40030db6:	55                   	push   %ebp
	st->st_mode = S_IFCHR;
	return 0;
}
40030db7:	31 c0                	xor    %eax,%eax
{
40030db9:	89 e5                	mov    %esp,%ebp
	st->st_mode = S_IFCHR;
40030dbb:	c7 42 04 00 20 00 00 	movl   $0x2000,0x4(%edx)
}
40030dc2:	5d                   	pop    %ebp
40030dc3:	c3                   	ret    

40030dc4 <_close>:
	return -1;
}
FUNC_ALIAS(_open, open, int);

int _close(int file)
{
40030dc4:	55                   	push   %ebp
	return -1;
}
40030dc5:	83 c8 ff             	or     $0xffffffff,%eax
{
40030dc8:	89 e5                	mov    %esp,%ebp
}
40030dca:	5d                   	pop    %ebp
40030dcb:	c3                   	ret    

40030dcc <_lseek>:
FUNC_ALIAS(_close, close, int);

int _lseek(int file, int ptr, int dir)
{
40030dcc:	55                   	push   %ebp
	return 0;
}
40030dcd:	31 c0                	xor    %eax,%eax
{
40030dcf:	89 e5                	mov    %esp,%ebp
}
40030dd1:	5d                   	pop    %ebp
40030dd2:	c3                   	ret    

40030dd3 <_sbrk>:
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
	void *ptr = heap_base + heap_sz;
40030dd3:	8b 15 0c 69 00 a8    	mov    0xa800690c,%edx
{
40030dd9:	55                   	push   %ebp
40030dda:	89 e5                	mov    %esp,%ebp

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
40030ddc:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40030ddf:	b8 00 40 01 a8       	mov    $0xa8014000,%eax
40030de4:	2d dc 85 00 a8       	sub    $0xa80085dc,%eax
40030de9:	39 c1                	cmp    %eax,%ecx
40030deb:	73 0e                	jae    40030dfb <_sbrk+0x28>
	void *ptr = heap_base + heap_sz;
40030ded:	8d 82 dc 85 00 a8    	lea    -0x57ff7a24(%edx),%eax
		heap_sz += count;
40030df3:	89 0d 0c 69 00 a8    	mov    %ecx,0xa800690c
		return ptr;
40030df9:	eb 03                	jmp    40030dfe <_sbrk+0x2b>
	} else {
		return (void *)-1;
40030dfb:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
40030dfe:	5d                   	pop    %ebp
40030dff:	c3                   	ret    

40030e00 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
40030e00:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40030e01:	31 c0                	xor    %eax,%eax
{
40030e03:	89 e5                	mov    %esp,%ebp
}
40030e05:	5d                   	pop    %ebp
40030e06:	c3                   	ret    

40030e07 <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
40030e07:	ff 02                	incl   (%edx)
{
40030e09:	55                   	push   %ebp
40030e0a:	89 e5                	mov    %esp,%ebp
	return _char_out(c);
}
40030e0c:	5d                   	pop    %ebp
	return _char_out(c);
40030e0d:	ff 25 c8 66 00 a8    	jmp    *0xa80066c8

40030e13 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
40030e13:	55                   	push   %ebp
40030e14:	89 e5                	mov    %esp,%ebp
40030e16:	57                   	push   %edi
40030e17:	56                   	push   %esi
40030e18:	53                   	push   %ebx
40030e19:	83 ec 14             	sub    $0x14,%esp
40030e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030e1f:	8b 75 0c             	mov    0xc(%ebp),%esi
40030e22:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030e25:	8b 45 08             	mov    0x8(%ebp),%eax
40030e28:	89 75 ec             	mov    %esi,-0x14(%ebp)
40030e2b:	85 f6                	test   %esi,%esi
40030e2d:	7f 07                	jg     40030e36 <_printk_dec_ulong+0x23>
40030e2f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40030e36:	83 f8 01             	cmp    $0x1,%eax
40030e39:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030e3c:	19 f6                	sbb    %esi,%esi
40030e3e:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
40030e45:	83 e6 f0             	and    $0xfffffff0,%esi
40030e48:	31 ff                	xor    %edi,%edi
40030e4a:	83 c6 30             	add    $0x30,%esi
40030e4d:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
40030e52:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
40030e55:	72 04                	jb     40030e5b <_printk_dec_ulong+0x48>
40030e57:	85 ff                	test   %edi,%edi
40030e59:	74 1c                	je     40030e77 <_printk_dec_ulong+0x64>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
40030e5b:	8d 4b 01             	lea    0x1(%ebx),%ecx
40030e5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030e61:	31 d2                	xor    %edx,%edx
40030e63:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40030e66:	f7 f1                	div    %ecx
40030e68:	83 c0 30             	add    $0x30,%eax
40030e6b:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030e6e:	ff d7                	call   *%edi
			found_largest_digit = 1;
40030e70:	bf 01 00 00 00       	mov    $0x1,%edi
40030e75:	eb 14                	jmp    40030e8b <_printk_dec_ulong+0x78>
		} else if (remaining <= min_width) {
40030e77:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030e7a:	31 ff                	xor    %edi,%edi
40030e7c:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40030e7f:	7c 0a                	jl     40030e8b <_printk_dec_ulong+0x78>
			out((int)(pad_zero ? '0' : ' '), ctx);
40030e81:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030e84:	89 f0                	mov    %esi,%eax
40030e86:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030e89:	ff d1                	call   *%ecx
		}
		remaining--;
		remainder %= (pos + 1);
40030e8b:	8d 4b 01             	lea    0x1(%ebx),%ecx
40030e8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030e91:	31 d2                	xor    %edx,%edx
		remaining--;
40030e93:	ff 4d e8             	decl   -0x18(%ebp)
		remainder %= (pos + 1);
40030e96:	f7 f1                	div    %ecx
40030e98:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
40030e9b:	89 d8                	mov    %ebx,%eax
40030e9d:	31 d2                	xor    %edx,%edx
40030e9f:	b9 0a 00 00 00       	mov    $0xa,%ecx
40030ea4:	f7 f1                	div    %ecx
40030ea6:	89 c3                	mov    %eax,%ebx
	while (pos >= 9) {
40030ea8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40030eac:	75 a4                	jne    40030e52 <_printk_dec_ulong+0x3f>
	}
	out((int)(remainder + 48), ctx);
40030eae:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030eb1:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030eb4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}
40030eb7:	83 c4 14             	add    $0x14,%esp
	out((int)(remainder + 48), ctx);
40030eba:	83 c0 30             	add    $0x30,%eax
}
40030ebd:	5b                   	pop    %ebx
40030ebe:	5e                   	pop    %esi
40030ebf:	5f                   	pop    %edi
40030ec0:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
40030ec1:	ff e1                	jmp    *%ecx

40030ec3 <__printk_hook_install>:
{
40030ec3:	55                   	push   %ebp
	_char_out = fn;
40030ec4:	a3 c8 66 00 a8       	mov    %eax,0xa80066c8
{
40030ec9:	89 e5                	mov    %esp,%ebp
}
40030ecb:	5d                   	pop    %ebp
40030ecc:	c3                   	ret    

40030ecd <_vprintk>:
{
40030ecd:	55                   	push   %ebp
40030ece:	89 e5                	mov    %esp,%ebp
40030ed0:	57                   	push   %edi
40030ed1:	56                   	push   %esi
40030ed2:	53                   	push   %ebx
40030ed3:	83 ec 20             	sub    $0x20,%esp
40030ed6:	89 c7                	mov    %eax,%edi
40030ed8:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030edb:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40030ede:	8b 75 08             	mov    0x8(%ebp),%esi
	int min_width = -1;
40030ee1:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	int pad_zero = 0;
40030ee8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
40030eef:	31 db                	xor    %ebx,%ebx
	while (*fmt) {
40030ef1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030ef4:	0f be 00             	movsbl (%eax),%eax
40030ef7:	84 c0                	test   %al,%al
40030ef9:	0f 84 0d 02 00 00    	je     4003110c <_vprintk+0x23f>
		if (!might_format) {
40030eff:	85 db                	test   %ebx,%ebx
40030f01:	75 12                	jne    40030f15 <_vprintk+0x48>
			if (*fmt != '%') {
40030f03:	3c 25                	cmp    $0x25,%al
40030f05:	0f 84 e1 01 00 00    	je     400310ec <_vprintk+0x21f>
				out((int)*fmt, ctx);
40030f0b:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030f0e:	ff d7                	call   *%edi
40030f10:	e9 ef 01 00 00       	jmp    40031104 <_vprintk+0x237>
			switch (*fmt) {
40030f15:	3c 68                	cmp    $0x68,%al
40030f17:	0f 84 e7 01 00 00    	je     40031104 <_vprintk+0x237>
40030f1d:	7f 3a                	jg     40030f59 <_vprintk+0x8c>
40030f1f:	3c 39                	cmp    $0x39,%al
40030f21:	7f 19                	jg     40030f3c <_vprintk+0x6f>
40030f23:	3c 31                	cmp    $0x31,%al
40030f25:	0f 8d 89 00 00 00    	jge    40030fb4 <_vprintk+0xe7>
40030f2b:	3c 25                	cmp    $0x25,%al
40030f2d:	0f 84 96 01 00 00    	je     400310c9 <_vprintk+0x1fc>
40030f33:	3c 30                	cmp    $0x30,%al
40030f35:	74 6b                	je     40030fa2 <_vprintk+0xd5>
40030f37:	e9 97 01 00 00       	jmp    400310d3 <_vprintk+0x206>
40030f3c:	3c 63                	cmp    $0x63,%al
40030f3e:	0f 84 76 01 00 00    	je     400310ba <_vprintk+0x1ed>
40030f44:	3c 64                	cmp    $0x64,%al
40030f46:	0f 84 83 00 00 00    	je     40030fcf <_vprintk+0x102>
40030f4c:	3c 58                	cmp    $0x58,%al
40030f4e:	0f 85 7f 01 00 00    	jne    400310d3 <_vprintk+0x206>
40030f54:	e9 c7 00 00 00       	jmp    40031020 <_vprintk+0x153>
40030f59:	3c 73                	cmp    $0x73,%al
40030f5b:	0f 84 41 01 00 00    	je     400310a2 <_vprintk+0x1d5>
40030f61:	7f 1a                	jg     40030f7d <_vprintk+0xb0>
40030f63:	3c 6c                	cmp    $0x6c,%al
40030f65:	0f 84 99 01 00 00    	je     40031104 <_vprintk+0x237>
40030f6b:	3c 70                	cmp    $0x70,%al
40030f6d:	0f 84 8f 00 00 00    	je     40031002 <_vprintk+0x135>
40030f73:	3c 69                	cmp    $0x69,%al
40030f75:	0f 85 58 01 00 00    	jne    400310d3 <_vprintk+0x206>
40030f7b:	eb 52                	jmp    40030fcf <_vprintk+0x102>
40030f7d:	3c 78                	cmp    $0x78,%al
40030f7f:	0f 84 9b 00 00 00    	je     40031020 <_vprintk+0x153>
40030f85:	3c 7a                	cmp    $0x7a,%al
40030f87:	0f 84 77 01 00 00    	je     40031104 <_vprintk+0x237>
40030f8d:	3c 75                	cmp    $0x75,%al
40030f8f:	0f 85 3e 01 00 00    	jne    400310d3 <_vprintk+0x206>
				_printk_dec_ulong(out, ctx, u, pad_zero,
40030f95:	ff 75 ec             	pushl  -0x14(%ebp)
				unsigned long u = va_arg(
40030f98:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40030f9b:	8b 0e                	mov    (%esi),%ecx
40030f9d:	ff 75 e8             	pushl  -0x18(%ebp)
40030fa0:	eb 4d                	jmp    40030fef <_vprintk+0x122>
				if (min_width < 0 && pad_zero == 0) {
40030fa2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40030fa5:	c1 e9 1f             	shr    $0x1f,%ecx
40030fa8:	74 0a                	je     40030fb4 <_vprintk+0xe7>
40030faa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030fae:	0f 84 4d 01 00 00    	je     40031101 <_vprintk+0x234>
				if (min_width < 0) {
40030fb4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40030fb8:	79 05                	jns    40030fbf <_vprintk+0xf2>
					min_width = *fmt - '0';
40030fba:	83 e8 30             	sub    $0x30,%eax
40030fbd:	eb 08                	jmp    40030fc7 <_vprintk+0xfa>
					min_width = 10 * min_width + *fmt - '0';
40030fbf:	6b 55 ec 0a          	imul   $0xa,-0x14(%ebp),%edx
40030fc3:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
40030fc7:	89 45 ec             	mov    %eax,-0x14(%ebp)
40030fca:	e9 35 01 00 00       	jmp    40031104 <_vprintk+0x237>
				long d = va_arg(ap, long);
40030fcf:	8d 5e 04             	lea    0x4(%esi),%ebx
40030fd2:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
40030fd4:	85 f6                	test   %esi,%esi
40030fd6:	79 0f                	jns    40030fe7 <_vprintk+0x11a>
					out((int)'-', ctx);
40030fd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030fdb:	b8 2d 00 00 00       	mov    $0x2d,%eax
40030fe0:	ff d7                	call   *%edi
					min_width--;
40030fe2:	ff 4d ec             	decl   -0x14(%ebp)
					d = -d;
40030fe5:	f7 de                	neg    %esi
				_printk_dec_ulong(out, ctx, d, pad_zero,
40030fe7:	ff 75 ec             	pushl  -0x14(%ebp)
40030fea:	ff 75 e8             	pushl  -0x18(%ebp)
40030fed:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40030fef:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030ff2:	89 f8                	mov    %edi,%eax
40030ff4:	e8 1a fe ff ff       	call   40030e13 <_printk_dec_ulong>
40030ff9:	58                   	pop    %eax
40030ffa:	5a                   	pop    %edx
				unsigned long u = va_arg(
40030ffb:	89 de                	mov    %ebx,%esi
40030ffd:	e9 e6 00 00 00       	jmp    400310e8 <_vprintk+0x21b>
				  out('0', ctx);
40031002:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031005:	b8 30 00 00 00       	mov    $0x30,%eax
4003100a:	ff d7                	call   *%edi
				  out('x', ctx);
4003100c:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003100f:	b8 78 00 00 00       	mov    $0x78,%eax
40031014:	ff d7                	call   *%edi
				  pad_zero = 1;
40031016:	89 5d e8             	mov    %ebx,-0x18(%ebp)
				  min_width = 8;
40031019:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
40031020:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
				unsigned long x = va_arg(
40031024:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
40031027:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
				unsigned long x = va_arg(
4003102e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40031031:	8b 06                	mov    (%esi),%eax
40031033:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int size = sizeof(num) * 2;
40031036:	be 08 00 00 00       	mov    $0x8,%esi
4003103b:	19 c0                	sbb    %eax,%eax
	int found_largest_digit = 0;
4003103d:	31 d2                	xor    %edx,%edx
4003103f:	89 45 dc             	mov    %eax,-0x24(%ebp)
40031042:	83 65 dc f0          	andl   $0xfffffff0,-0x24(%ebp)
40031046:	83 45 dc 30          	addl   $0x30,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
4003104a:	4e                   	dec    %esi
4003104b:	8b 45 d8             	mov    -0x28(%ebp),%eax
4003104e:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
40031055:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
40031057:	24 0f                	and    $0xf,%al
40031059:	75 0c                	jne    40031067 <_vprintk+0x19a>
4003105b:	85 d2                	test   %edx,%edx
4003105d:	75 08                	jne    40031067 <_vprintk+0x19a>
4003105f:	85 f6                	test   %esi,%esi
40031061:	75 1e                	jne    40031081 <_vprintk+0x1b4>
			nibble += nibble > 9 ? 87 : 48;
40031063:	b2 30                	mov    $0x30,%dl
40031065:	eb 0c                	jmp    40031073 <_vprintk+0x1a6>
40031067:	3c 09                	cmp    $0x9,%al
40031069:	0f 9f c2             	setg   %dl
4003106c:	4a                   	dec    %edx
4003106d:	83 e2 d9             	and    $0xffffffd9,%edx
40031070:	83 c2 57             	add    $0x57,%edx
40031073:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
40031075:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031078:	0f b6 c0             	movzbl %al,%eax
4003107b:	ff d7                	call   *%edi
			found_largest_digit = 1;
4003107d:	89 da                	mov    %ebx,%edx
4003107f:	eb 18                	jmp    40031099 <_vprintk+0x1cc>
		if (remaining-- <= min_width) {
40031081:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40031084:	39 45 ec             	cmp    %eax,-0x14(%ebp)
40031087:	8d 48 ff             	lea    -0x1(%eax),%ecx
4003108a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
4003108d:	7c 08                	jl     40031097 <_vprintk+0x1ca>
			out((int)(pad_zero ? '0' : ' '), ctx);
4003108f:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031092:	8b 45 dc             	mov    -0x24(%ebp),%eax
40031095:	ff d7                	call   *%edi
		if (remaining-- <= min_width) {
40031097:	31 d2                	xor    %edx,%edx
	for (; size; size--) {
40031099:	85 f6                	test   %esi,%esi
4003109b:	75 ad                	jne    4003104a <_vprintk+0x17d>
				unsigned long x = va_arg(
4003109d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
400310a0:	eb 46                	jmp    400310e8 <_vprintk+0x21b>
				char *s = va_arg(ap, char *);
400310a2:	8d 5e 04             	lea    0x4(%esi),%ebx
400310a5:	8b 36                	mov    (%esi),%esi
				while (*s)
400310a7:	0f be 06             	movsbl (%esi),%eax
400310aa:	84 c0                	test   %al,%al
400310ac:	0f 84 49 ff ff ff    	je     40030ffb <_vprintk+0x12e>
					out((int)(*s++), ctx);
400310b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
400310b5:	46                   	inc    %esi
400310b6:	ff d7                	call   *%edi
400310b8:	eb ed                	jmp    400310a7 <_vprintk+0x1da>
				out(c, ctx);
400310ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
400310bd:	8b 06                	mov    (%esi),%eax
				int c = va_arg(ap, int);
400310bf:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
400310c2:	ff d7                	call   *%edi
400310c4:	e9 32 ff ff ff       	jmp    40030ffb <_vprintk+0x12e>
				out((int)'%', ctx);
400310c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
400310cc:	b8 25 00 00 00       	mov    $0x25,%eax
400310d1:	eb 13                	jmp    400310e6 <_vprintk+0x219>
				out((int)'%', ctx);
400310d3:	8b 55 f0             	mov    -0x10(%ebp),%edx
400310d6:	b8 25 00 00 00       	mov    $0x25,%eax
400310db:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
400310dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
400310e0:	0f be 00             	movsbl (%eax),%eax
400310e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
400310e6:	ff d7                	call   *%edi
			might_format = 0;
400310e8:	31 db                	xor    %ebx,%ebx
				break;
400310ea:	eb 18                	jmp    40031104 <_vprintk+0x237>
				pad_zero = 0;
400310ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
400310f3:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				might_format = 1;
400310fa:	bb 01 00 00 00       	mov    $0x1,%ebx
400310ff:	eb 03                	jmp    40031104 <_vprintk+0x237>
					pad_zero = 1;
40031101:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		++fmt;
40031104:	ff 45 e0             	incl   -0x20(%ebp)
40031107:	e9 e5 fd ff ff       	jmp    40030ef1 <_vprintk+0x24>
}
4003110c:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003110f:	5b                   	pop    %ebx
40031110:	5e                   	pop    %esi
40031111:	5f                   	pop    %edi
40031112:	5d                   	pop    %ebp
40031113:	c3                   	ret    

40031114 <printk>:
{
40031114:	55                   	push   %ebp
40031115:	89 e5                	mov    %esp,%ebp
40031117:	50                   	push   %eax
	va_start(ap, fmt);
40031118:	8d 45 0c             	lea    0xc(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
4003111b:	8d 55 fc             	lea    -0x4(%ebp),%edx
4003111e:	50                   	push   %eax
4003111f:	8b 4d 08             	mov    0x8(%ebp),%ecx
40031122:	b8 07 0e 03 40       	mov    $0x40030e07,%eax
	struct out_context ctx = { 0 };
40031127:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
4003112e:	e8 9a fd ff ff       	call   40030ecd <_vprintk>
}
40031133:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031136:	5a                   	pop    %edx
}
40031137:	c9                   	leave  
40031138:	c3                   	ret    

40031139 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40031139:	55                   	push   %ebp
4003113a:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
4003113c:	5d                   	pop    %ebp
4003113d:	c3                   	ret    

4003113e <pinmux_initialize>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static int pinmux_initialize(struct device *port)
{
4003113e:	55                   	push   %ebp
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
4003113f:	b8 30 09 80 b0       	mov    $0xb0800930,%eax
{
40031144:	89 e5                	mov    %esp,%ebp
40031146:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  9, PINMUX_FUNC_C);
40031149:	c7 45 ec 55 00 0a 00 	movl   $0xa0055,-0x14(%ebp)
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
40031150:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
	PIN_CONFIG(mux_config, 41, PINMUX_FUNC_B);
40031157:	c7 45 f4 04 00 05 00 	movl   $0x50004,-0xc(%ebp)
	PIN_CONFIG(mux_config, 63, PINMUX_FUNC_B);
4003115e:	c7 45 f8 00 40 15 40 	movl   $0x40154000,-0x8(%ebp)
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
40031165:	c7 45 fc 15 00 00 00 	movl   $0x15,-0x4(%ebp)
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
4003116c:	8b 94 05 bc f6 7f 4f 	mov    0x4f7ff6bc(%ebp,%eax,1),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
40031173:	89 10                	mov    %edx,(%eax)
40031175:	83 c0 04             	add    $0x4,%eax
	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
40031178:	3d 44 09 80 b0       	cmp    $0xb0800944,%eax
4003117d:	75 ed                	jne    4003116c <pinmux_initialize+0x2e>
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);

	return 0;
}
4003117f:	31 c0                	xor    %eax,%eax
40031181:	c9                   	leave  
40031182:	c3                   	ret    

40031183 <clk_periph_enable>:

	return 0;
}

int clk_periph_enable(const clk_periph_t clocks)
{
40031183:	55                   	push   %ebp
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
40031184:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
{
4003118a:	89 e5                	mov    %esp,%ebp
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
4003118c:	09 d0                	or     %edx,%eax
4003118e:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
40031193:	31 c0                	xor    %eax,%eax
40031195:	5d                   	pop    %ebp
40031196:	c3                   	ret    

40031197 <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
40031197:	55                   	push   %ebp
40031198:	89 e5                	mov    %esp,%ebp
4003119a:	56                   	push   %esi
4003119b:	53                   	push   %ebx
4003119c:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
4003119e:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
		qm_power_soc_restore();
	}
#endif

	if (callback[gpio]) {
400311a5:	8b 0c 9d 18 69 00 a8 	mov    -0x57ff96e8(,%ebx,4),%ecx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
400311ac:	8b 70 40             	mov    0x40(%eax),%esi
	if (callback[gpio]) {
400311af:	85 c9                	test   %ecx,%ecx
400311b1:	74 0b                	je     400311be <gpio_isr+0x27>
		(*callback[gpio])(callback_data[gpio], int_status);
400311b3:	8b 04 9d 10 69 00 a8 	mov    -0x57ff96f0(,%ebx,4),%eax
400311ba:	89 f2                	mov    %esi,%edx
400311bc:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
400311be:	8b 04 9d cc 66 00 a8 	mov    -0x57ff9934(,%ebx,4),%eax
400311c5:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
}
400311c8:	5b                   	pop    %ebx
	QM_GPIO[gpio]->gpio_porta_eoi;
400311c9:	8b 40 4c             	mov    0x4c(%eax),%eax
}
400311cc:	5e                   	pop    %esi
400311cd:	5d                   	pop    %ebp
400311ce:	c3                   	ret    

400311cf <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
400311cf:	55                   	push   %ebp
	gpio_isr(QM_GPIO_0);
400311d0:	31 c0                	xor    %eax,%eax
{
400311d2:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_GPIO_0_INT_VECTOR);
}
400311d4:	5d                   	pop    %ebp
	gpio_isr(QM_GPIO_0);
400311d5:	e9 bd ff ff ff       	jmp    40031197 <gpio_isr>

400311da <qm_aon_gpio_0_isr>:

#if (HAS_AON_GPIO)
QM_ISR_DECLARE(qm_aon_gpio_0_isr)
{
400311da:	55                   	push   %ebp
	gpio_isr(QM_AON_GPIO_0);
400311db:	b8 01 00 00 00       	mov    $0x1,%eax
{
400311e0:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_AON_GPIO_0_INT_VECTOR);
}
400311e2:	5d                   	pop    %ebp
	gpio_isr(QM_AON_GPIO_0);
400311e3:	e9 af ff ff ff       	jmp    40031197 <gpio_isr>

400311e8 <qm_gpio_set_config>:
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
400311e8:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
400311e9:	8b 0c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ecx
{
400311f0:	89 e5                	mov    %esp,%ebp
400311f2:	56                   	push   %esi
400311f3:	53                   	push   %ebx

	uint32_t mask = controller->gpio_intmask;
	controller->gpio_intmask = 0xffffffff;

	controller->gpio_swporta_ddr = cfg->direction;
400311f4:	8b 1a                	mov    (%edx),%ebx
	uint32_t mask = controller->gpio_intmask;
400311f6:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
400311f9:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)
	controller->gpio_swporta_ddr = cfg->direction;
40031200:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
40031203:	8b 5a 04             	mov    0x4(%edx),%ebx
40031206:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
40031209:	8b 5a 08             	mov    0x8(%edx),%ebx
4003120c:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
4003120f:	8b 5a 0c             	mov    0xc(%edx),%ebx
40031212:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
40031215:	8b 5a 10             	mov    0x10(%edx),%ebx
40031218:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
4003121b:	8b 5a 14             	mov    0x14(%edx),%ebx
4003121e:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
40031221:	8b 59 60             	mov    0x60(%ecx),%ebx
40031224:	83 cb 01             	or     $0x1,%ebx
40031227:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
4003122a:	8b 5a 18             	mov    0x18(%edx),%ebx
	callback_data[gpio] = cfg->callback_data;
4003122d:	8b 52 1c             	mov    0x1c(%edx),%edx

	controller->gpio_intmask = mask;
40031230:	89 71 34             	mov    %esi,0x34(%ecx)
	callback[gpio] = cfg->callback;
40031233:	89 1c 85 18 69 00 a8 	mov    %ebx,-0x57ff96e8(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
4003123a:	89 14 85 10 69 00 a8 	mov    %edx,-0x57ff96f0(,%eax,4)

	return 0;
}
40031241:	5b                   	pop    %ebx
40031242:	31 c0                	xor    %eax,%eax
40031244:	5e                   	pop    %esi
40031245:	5d                   	pop    %ebp
40031246:	c3                   	ret    

40031247 <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
40031247:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031248:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
4003124f:	89 e5                	mov    %esp,%ebp
40031251:	53                   	push   %ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031252:	8b 40 50             	mov    0x50(%eax),%eax
{
40031255:	89 cb                	mov    %ecx,%ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031257:	88 d1                	mov    %dl,%cl
40031259:	d3 e8                	shr    %cl,%eax
4003125b:	83 e0 01             	and    $0x1,%eax
4003125e:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40031260:	31 c0                	xor    %eax,%eax
40031262:	5b                   	pop    %ebx
40031263:	5d                   	pop    %ebp
40031264:	c3                   	ret    

40031265 <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40031265:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40031266:	88 d1                	mov    %dl,%cl
{
40031268:	89 e5                	mov    %esp,%ebp
4003126a:	56                   	push   %esi
4003126b:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
4003126c:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
40031273:	b8 01 00 00 00       	mov    $0x1,%eax
40031278:	8b 33                	mov    (%ebx),%esi
4003127a:	d3 e0                	shl    %cl,%eax
4003127c:	09 f0                	or     %esi,%eax
4003127e:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40031280:	31 c0                	xor    %eax,%eax
40031282:	5b                   	pop    %ebx
40031283:	5e                   	pop    %esi
40031284:	5d                   	pop    %ebp
40031285:	c3                   	ret    

40031286 <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40031286:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
40031287:	88 d1                	mov    %dl,%cl
{
40031289:	89 e5                	mov    %esp,%ebp
4003128b:	56                   	push   %esi
4003128c:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
4003128d:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
40031294:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
40031299:	8b 33                	mov    (%ebx),%esi
4003129b:	d3 c0                	rol    %cl,%eax
4003129d:	21 f0                	and    %esi,%eax
4003129f:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400312a1:	31 c0                	xor    %eax,%eax
400312a3:	5b                   	pop    %ebx
400312a4:	5e                   	pop    %esi
400312a5:	5d                   	pop    %ebp
400312a6:	c3                   	ret    

400312a7 <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
400312a7:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400312ae:	55                   	push   %ebp
400312af:	89 e5                	mov    %esp,%ebp

	return 0;
}
400312b1:	5d                   	pop    %ebp
	*port = QM_GPIO[gpio]->gpio_ext_porta;
400312b2:	8b 40 50             	mov    0x50(%eax),%eax
400312b5:	89 02                	mov    %eax,(%edx)
}
400312b7:	31 c0                	xor    %eax,%eax
400312b9:	c3                   	ret    

400312ba <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
400312ba:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400312c1:	55                   	push   %ebp
400312c2:	89 e5                	mov    %esp,%ebp
	QM_GPIO[gpio]->gpio_swporta_dr = val;
400312c4:	89 10                	mov    %edx,(%eax)

	return 0;
}
400312c6:	31 c0                	xor    %eax,%eax
400312c8:	5d                   	pop    %ebp
400312c9:	c3                   	ret    

400312ca <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
400312ca:	55                   	push   %ebp
400312cb:	89 e5                	mov    %esp,%ebp
400312cd:	53                   	push   %ebx
400312ce:	51                   	push   %ecx
	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400312cf:	8b 4a 04             	mov    0x4(%edx),%ecx
	qm_uart_reg_t *const regs = QM_UART[uart];
400312d2:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400312d9:	89 cb                	mov    %ecx,%ebx
400312db:	c1 eb 10             	shr    $0x10,%ebx
	regs->lcr = 0;
400312de:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400312e5:	0f b6 db             	movzbl %bl,%ebx
	regs->lcr = QM_UART_LCR_DLAB;
400312e8:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400312ef:	89 58 04             	mov    %ebx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
400312f2:	0f b6 dd             	movzbl %ch,%ebx
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
400312f5:	0f b6 c9             	movzbl %cl,%ecx
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
400312f8:	89 18                	mov    %ebx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
400312fa:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
40031300:	8b 0a                	mov    (%edx),%ecx
40031302:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
40031305:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
4003130c:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
40031310:	74 09                	je     4003131b <qm_uart_set_config+0x51>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
40031312:	8b 50 10             	mov    0x10(%eax),%edx
40031315:	83 ca 22             	or     $0x22,%edx
40031318:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
4003131b:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
40031322:	8b 50 04             	mov    0x4(%eax),%edx
40031325:	80 ca 80             	or     $0x80,%dl
40031328:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
4003132b:	8b 40 14             	mov    0x14(%eax),%eax
4003132e:	89 45 f8             	mov    %eax,-0x8(%ebp)

	return 0;
}
40031331:	5a                   	pop    %edx
40031332:	31 c0                	xor    %eax,%eax
40031334:	5b                   	pop    %ebx
40031335:	5d                   	pop    %ebp
40031336:	c3                   	ret    

40031337 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
40031337:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
40031338:	8b 0c 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%ecx
{
4003133f:	89 e5                	mov    %esp,%ebp
40031341:	56                   	push   %esi
40031342:	53                   	push   %ebx
	uint32_t lsr = regs->lsr;
40031343:	8b 59 14             	mov    0x14(%ecx),%ebx

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
40031346:	8b 71 1c             	mov    0x1c(%ecx),%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031349:	89 d8                	mov    %ebx,%eax
4003134b:	83 e0 1e             	and    $0x1e,%eax
	if (regs->scr & BIT(0)) {
4003134e:	83 e6 01             	and    $0x1,%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031351:	89 02                	mov    %eax,(%edx)
	if (regs->scr & BIT(0)) {
40031353:	74 0b                	je     40031360 <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
40031355:	8b 41 1c             	mov    0x1c(%ecx),%eax
40031358:	83 e0 fe             	and    $0xfffffffe,%eax
4003135b:	89 41 1c             	mov    %eax,0x1c(%ecx)
4003135e:	eb 0a                	jmp    4003136a <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
40031360:	f6 c3 40             	test   $0x40,%bl
40031363:	75 05                	jne    4003136a <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
40031365:	83 c8 20             	or     $0x20,%eax
40031368:	89 02                	mov    %eax,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
4003136a:	80 e3 01             	and    $0x1,%bl
4003136d:	74 03                	je     40031372 <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
4003136f:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
40031372:	5b                   	pop    %ebx
40031373:	31 c0                	xor    %eax,%eax
40031375:	5e                   	pop    %esi
40031376:	5d                   	pop    %ebp
40031377:	c3                   	ret    

40031378 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
40031378:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
40031379:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
{
40031380:	89 e5                	mov    %esp,%ebp

	while (regs->lsr & QM_UART_LSR_THRE) {
40031382:	8b 48 14             	mov    0x14(%eax),%ecx
40031385:	80 e1 20             	and    $0x20,%cl
40031388:	75 f8                	jne    40031382 <qm_uart_write+0xa>
	}
	regs->rbr_thr_dll = data;
4003138a:	0f b6 d2             	movzbl %dl,%edx
4003138d:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
4003138f:	8b 50 14             	mov    0x14(%eax),%edx
40031392:	80 e2 40             	and    $0x40,%dl
40031395:	74 f8                	je     4003138f <qm_uart_write+0x17>
	}

	return 0;
}
40031397:	31 c0                	xor    %eax,%eax
40031399:	5d                   	pop    %ebp
4003139a:	c3                   	ret    

4003139b <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
4003139b:	55                   	push   %ebp
4003139c:	89 e5                	mov    %esp,%ebp
4003139e:	56                   	push   %esi
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
4003139f:	8b 34 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%esi
{
400313a6:	53                   	push   %ebx

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
		lsr = regs->lsr;
400313a7:	8b 46 14             	mov    0x14(%esi),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
400313aa:	a8 01                	test   $0x1,%al
400313ac:	74 f9                	je     400313a7 <qm_uart_read+0xc>
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
400313ae:	83 e0 1e             	and    $0x1e,%eax
400313b1:	89 c3                	mov    %eax,%ebx
400313b3:	74 0d                	je     400313c2 <qm_uart_read+0x27>
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
400313b5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		if (status) {
400313ba:	85 c9                	test   %ecx,%ecx
400313bc:	74 0a                	je     400313c8 <qm_uart_read+0x2d>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
400313be:	89 19                	mov    %ebx,(%ecx)
400313c0:	eb 06                	jmp    400313c8 <qm_uart_read+0x2d>
	}
	*data = regs->rbr_thr_dll;
400313c2:	8b 06                	mov    (%esi),%eax
400313c4:	88 02                	mov    %al,(%edx)

	return 0;
400313c6:	31 c0                	xor    %eax,%eax
}
400313c8:	5b                   	pop    %ebx
400313c9:	5e                   	pop    %esi
400313ca:	5d                   	pop    %ebp
400313cb:	c3                   	ret    

400313cc <read_frame>:
static dma_context_t dma_context_rx[QM_SPI_NUM];
/* DMA core being used by each SPI controller. */
static qm_dma_t dma_core[QM_SPI_NUM];

static void read_frame(const qm_spi_t spi, uint8_t *const rx_buffer)
{
400313cc:	55                   	push   %ebp
	const qm_spi_reg_t *const controller = QM_SPI[spi];
400313cd:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
400313d4:	8a 80 38 69 00 a8    	mov    -0x57ff96c8(%eax),%al
{
400313da:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
400313dc:	3c 01                	cmp    $0x1,%al
400313de:	75 07                	jne    400313e7 <read_frame+0x1b>
		*(uint8_t *)rx_buffer = controller->dr[0];
400313e0:	8b 41 60             	mov    0x60(%ecx),%eax
400313e3:	88 02                	mov    %al,(%edx)
400313e5:	eb 0e                	jmp    400313f5 <read_frame+0x29>
	} else if (frame_size == 2) {
400313e7:	3c 02                	cmp    $0x2,%al
		*(uint16_t *)rx_buffer = controller->dr[0];
400313e9:	8b 41 60             	mov    0x60(%ecx),%eax
	} else if (frame_size == 2) {
400313ec:	75 05                	jne    400313f3 <read_frame+0x27>
		*(uint16_t *)rx_buffer = controller->dr[0];
400313ee:	66 89 02             	mov    %ax,(%edx)
400313f1:	eb 02                	jmp    400313f5 <read_frame+0x29>
	} else {
		*(uint32_t *)rx_buffer = controller->dr[0];
400313f3:	89 02                	mov    %eax,(%edx)
	}
}
400313f5:	5d                   	pop    %ebp
400313f6:	c3                   	ret    

400313f7 <write_frame>:

static void write_frame(const qm_spi_t spi, const uint8_t *const tx_buffer)
{
400313f7:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
400313f8:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
400313ff:	8a 80 38 69 00 a8    	mov    -0x57ff96c8(%eax),%al
{
40031405:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031407:	3c 01                	cmp    $0x1,%al
40031409:	75 05                	jne    40031410 <write_frame+0x19>
		controller->dr[0] = *(uint8_t *)tx_buffer;
4003140b:	0f b6 02             	movzbl (%edx),%eax
4003140e:	eb 0b                	jmp    4003141b <write_frame+0x24>
	} else if (frame_size == 2) {
40031410:	3c 02                	cmp    $0x2,%al
40031412:	75 05                	jne    40031419 <write_frame+0x22>
		controller->dr[0] = *(uint16_t *)tx_buffer;
40031414:	0f b7 02             	movzwl (%edx),%eax
40031417:	eb 02                	jmp    4003141b <write_frame+0x24>
	} else {
		controller->dr[0] = *(uint32_t *)tx_buffer;
40031419:	8b 02                	mov    (%edx),%eax
4003141b:	89 41 60             	mov    %eax,0x60(%ecx)
	}
}
4003141e:	5d                   	pop    %ebp
4003141f:	c3                   	ret    

40031420 <handle_spi_overflow_interrupt>:
		controller->txftlr = 0;
	}
}

static void handle_spi_overflow_interrupt(const qm_spi_t spi)
{
40031420:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
	const volatile qm_spi_async_transfer_t *transfer =
40031421:	8b 0c 85 4c 69 00 a8 	mov    -0x57ff96b4(,%eax,4),%ecx
{
40031428:	89 e5                	mov    %esp,%ebp
4003142a:	56                   	push   %esi
4003142b:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
4003142c:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	    spi_async_transfer[spi];

	if (transfer->callback) {
40031433:	8b 51 10             	mov    0x10(%ecx),%edx
40031436:	85 d2                	test   %edx,%edx
40031438:	74 1c                	je     40031456 <handle_spi_overflow_interrupt+0x36>
		transfer->callback(transfer->callback_data, -EIO,
4003143a:	8b 71 10             	mov    0x10(%ecx),%esi
				   QM_SPI_RX_OVERFLOW, rx_counter[spi]);
4003143d:	0f b7 94 00 3c 69 00 	movzwl -0x57ff96c4(%eax,%eax,1),%edx
40031444:	a8 
		transfer->callback(transfer->callback_data, -EIO,
40031445:	8b 41 14             	mov    0x14(%ecx),%eax
40031448:	52                   	push   %edx
40031449:	b9 02 00 00 00       	mov    $0x2,%ecx
4003144e:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
40031453:	ff d6                	call   *%esi
40031455:	58                   	pop    %eax
	}

	/* Clear RX FIFO Overflow interrupt. */
	controller->rxoicr;
40031456:	8b 43 3c             	mov    0x3c(%ebx),%eax
	controller->imr = QM_SPI_IMR_MASK_ALL;
40031459:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	controller->ssienr = 0;
40031460:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
40031467:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003146a:	5b                   	pop    %ebx
4003146b:	5e                   	pop    %esi
4003146c:	5d                   	pop    %ebp
4003146d:	c3                   	ret    

4003146e <handle_spi_mst_interrupt>:

static void handle_spi_mst_interrupt(const qm_spi_t spi)
{
4003146e:	55                   	push   %ebp
4003146f:	89 e5                	mov    %esp,%ebp
40031471:	57                   	push   %edi
40031472:	56                   	push   %esi
40031473:	53                   	push   %ebx
40031474:	83 ec 0c             	sub    $0xc,%esp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031477:	8b 3c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edi
4003147e:	89 7d f0             	mov    %edi,-0x10(%ebp)
	const volatile qm_spi_async_transfer_t *transfer =
	    spi_async_transfer[spi];
	const uint32_t int_status = controller->isr;
40031481:	8b 4f 30             	mov    0x30(%edi),%ecx
40031484:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	QM_ASSERT((int_status & (QM_SPI_ISR_TXOIS | QM_SPI_ISR_RXUIS)) == 0);

	/* RX FIFO Overflow interrupt. */
	if (int_status & QM_SPI_ISR_RXOIS) {
40031487:	80 e1 08             	and    $0x8,%cl
4003148a:	74 0c                	je     40031498 <handle_spi_mst_interrupt+0x2a>

	if (int_status & QM_SPI_ISR_TXEIS &&
	    transfer->tx_len > tx_counter[spi]) {
		handle_mst_tx_interrupt(spi);
	}
}
4003148c:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003148f:	5b                   	pop    %ebx
40031490:	5e                   	pop    %esi
40031491:	5f                   	pop    %edi
40031492:	5d                   	pop    %ebp
		handle_spi_overflow_interrupt(spi);
40031493:	e9 88 ff ff ff       	jmp    40031420 <handle_spi_overflow_interrupt>
40031498:	89 c3                	mov    %eax,%ebx
	const volatile qm_spi_async_transfer_t *transfer =
4003149a:	8b 34 85 4c 69 00 a8 	mov    -0x57ff96b4(,%eax,4),%esi
	if (int_status & QM_SPI_ISR_RXFIS) {
400314a1:	f6 45 ec 10          	testb  $0x10,-0x14(%ebp)
400314a5:	0f 84 b6 00 00 00    	je     40031561 <handle_spi_mst_interrupt+0xf3>
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
400314ab:	8b 56 04             	mov    0x4(%esi),%edx
400314ae:	0f b7 8c 00 3c 69 00 	movzwl -0x57ff96c4(%eax,%eax,1),%ecx
400314b5:	a8 
400314b6:	0f b6 80 38 69 00 a8 	movzbl -0x57ff96c8(%eax),%eax
400314bd:	0f af c8             	imul   %eax,%ecx
		rx_buffer += dfs[spi];
400314c0:	89 c7                	mov    %eax,%edi
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
400314c2:	01 d1                	add    %edx,%ecx
	while (controller->rxflr) {
400314c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400314c7:	8b 40 24             	mov    0x24(%eax),%eax
400314ca:	85 c0                	test   %eax,%eax
400314cc:	74 77                	je     40031545 <handle_spi_mst_interrupt+0xd7>
		read_frame(spi, rx_buffer);
400314ce:	89 ca                	mov    %ecx,%edx
400314d0:	89 d8                	mov    %ebx,%eax
400314d2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
400314d5:	e8 f2 fe ff ff       	call   400313cc <read_frame>
		rx_counter[spi]++;
400314da:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
400314e1:	a8 
400314e2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400314e5:	40                   	inc    %eax
400314e6:	01 f9                	add    %edi,%ecx
400314e8:	66 89 84 1b 3c 69 00 	mov    %ax,-0x57ff96c4(%ebx,%ebx,1)
400314ef:	a8 
		if (transfer->rx_len == rx_counter[spi]) {
400314f0:	66 8b 56 0a          	mov    0xa(%esi),%dx
400314f4:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
400314fb:	a8 
400314fc:	66 39 c2             	cmp    %ax,%dx
400314ff:	75 c3                	jne    400314c4 <handle_spi_mst_interrupt+0x56>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40031501:	8b 45 f0             	mov    -0x10(%ebp),%eax
			if (tmode[spi] == QM_SPI_TMOD_RX) {
40031504:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
4003150b:	02 
4003150c:	75 2b                	jne    40031539 <handle_spi_mst_interrupt+0xcb>
				controller->imr = QM_SPI_IMR_MASK_ALL;
4003150e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				controller->ssienr = 0;
40031515:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				if (transfer->callback) {
4003151c:	8b 46 10             	mov    0x10(%esi),%eax
4003151f:	85 c0                	test   %eax,%eax
40031521:	74 22                	je     40031545 <handle_spi_mst_interrupt+0xd7>
					transfer->callback(
40031523:	8b 46 10             	mov    0x10(%esi),%eax
40031526:	31 c9                	xor    %ecx,%ecx
					    QM_SPI_IDLE, transfer->rx_len);
40031528:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
					transfer->callback(
4003152c:	89 c7                	mov    %eax,%edi
4003152e:	8b 46 14             	mov    0x14(%esi),%eax
40031531:	52                   	push   %edx
40031532:	31 d2                	xor    %edx,%edx
40031534:	ff d7                	call   *%edi
40031536:	5a                   	pop    %edx
40031537:	eb 0c                	jmp    40031545 <handle_spi_mst_interrupt+0xd7>
				controller->imr &=
40031539:	8b 40 2c             	mov    0x2c(%eax),%eax
4003153c:	8b 7d f0             	mov    -0x10(%ebp),%edi
4003153f:	83 e0 e3             	and    $0xffffffe3,%eax
40031542:	89 47 2c             	mov    %eax,0x2c(%edi)
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031545:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (frames_left <= controller->rxftlr) {
40031549:	8b 7d f0             	mov    -0x10(%ebp),%edi
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
4003154c:	0f b7 94 1b 3c 69 00 	movzwl -0x57ff96c4(%ebx,%ebx,1),%edx
40031553:	a8 
40031554:	29 d0                	sub    %edx,%eax
	if (frames_left <= controller->rxftlr) {
40031556:	8b 57 1c             	mov    0x1c(%edi),%edx
40031559:	39 d0                	cmp    %edx,%eax
4003155b:	77 04                	ja     40031561 <handle_spi_mst_interrupt+0xf3>
		controller->rxftlr = frames_left - 1;
4003155d:	48                   	dec    %eax
4003155e:	89 47 1c             	mov    %eax,0x1c(%edi)
	if (transfer->rx_len == rx_counter[spi] &&
40031561:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031565:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
4003156c:	a8 
4003156d:	66 39 c2             	cmp    %ax,%dx
40031570:	75 66                	jne    400315d8 <handle_spi_mst_interrupt+0x16a>
	    transfer->tx_len == tx_counter[spi] &&
40031572:	66 8b 56 08          	mov    0x8(%esi),%dx
40031576:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
4003157d:	a8 
	if (transfer->rx_len == rx_counter[spi] &&
4003157e:	66 39 c2             	cmp    %ax,%dx
40031581:	75 55                	jne    400315d8 <handle_spi_mst_interrupt+0x16a>
	    (controller->sr & QM_SPI_SR_TFE) &&
40031583:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031586:	8b 40 28             	mov    0x28(%eax),%eax
	    transfer->tx_len == tx_counter[spi] &&
40031589:	a8 04                	test   $0x4,%al
4003158b:	74 4b                	je     400315d8 <handle_spi_mst_interrupt+0x16a>
	    !(controller->sr & QM_SPI_SR_BUSY)) {
4003158d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031590:	8b 40 28             	mov    0x28(%eax),%eax
	    (controller->sr & QM_SPI_SR_TFE) &&
40031593:	a8 01                	test   $0x1,%al
40031595:	75 41                	jne    400315d8 <handle_spi_mst_interrupt+0x16a>
		controller->imr = QM_SPI_IMR_MASK_ALL;
40031597:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003159a:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
		controller->ssienr = 0;
400315a1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (transfer->callback && tmode[spi] != QM_SPI_TMOD_RX) {
400315a8:	8b 46 10             	mov    0x10(%esi),%eax
400315ab:	85 c0                	test   %eax,%eax
400315ad:	0f 84 bd 00 00 00    	je     40031670 <handle_spi_mst_interrupt+0x202>
400315b3:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
400315ba:	02 
400315bb:	0f 84 af 00 00 00    	je     40031670 <handle_spi_mst_interrupt+0x202>
			transfer->callback(transfer->callback_data, 0,
400315c1:	8b 5e 10             	mov    0x10(%esi),%ebx
400315c4:	31 c9                	xor    %ecx,%ecx
					   QM_SPI_IDLE, transfer->tx_len);
400315c6:	0f b7 56 08          	movzwl 0x8(%esi),%edx
			transfer->callback(transfer->callback_data, 0,
400315ca:	8b 46 14             	mov    0x14(%esi),%eax
400315cd:	52                   	push   %edx
400315ce:	31 d2                	xor    %edx,%edx
400315d0:	ff d3                	call   *%ebx
400315d2:	58                   	pop    %eax
400315d3:	e9 98 00 00 00       	jmp    40031670 <handle_spi_mst_interrupt+0x202>
	if (int_status & QM_SPI_ISR_TXEIS &&
400315d8:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
400315dc:	0f 84 8e 00 00 00    	je     40031670 <handle_spi_mst_interrupt+0x202>
	    transfer->tx_len > tx_counter[spi]) {
400315e2:	66 8b 56 08          	mov    0x8(%esi),%dx
400315e6:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
400315ed:	a8 
	if (int_status & QM_SPI_ISR_TXEIS &&
400315ee:	66 39 c2             	cmp    %ax,%dx
400315f1:	76 7d                	jbe    40031670 <handle_spi_mst_interrupt+0x202>
	const volatile qm_spi_async_transfer_t *const transfer =
400315f3:	8b 0c 9d 4c 69 00 a8 	mov    -0x57ff96b4(,%ebx,4),%ecx
	qm_spi_reg_t *const controller = QM_SPI[spi];
400315fa:	8b 3c 9d dc 66 00 a8 	mov    -0x57ff9924(,%ebx,4),%edi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031601:	0f b6 93 38 69 00 a8 	movzbl -0x57ff96c8(%ebx),%edx
40031608:	8b 31                	mov    (%ecx),%esi
		tx_buffer += dfs[spi];
4003160a:	89 55 ec             	mov    %edx,-0x14(%ebp)
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
4003160d:	0f b7 84 1b 44 69 00 	movzwl -0x57ff96bc(%ebx,%ebx,1),%eax
40031614:	a8 
40031615:	0f af c2             	imul   %edx,%eax
40031618:	01 f0                	add    %esi,%eax
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
4003161a:	8b 77 20             	mov    0x20(%edi),%esi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
4003161d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031620:	8b 47 24             	mov    0x24(%edi),%eax
40031623:	01 f0                	add    %esi,%eax
40031625:	be 07 00 00 00       	mov    $0x7,%esi
4003162a:	29 c6                	sub    %eax,%esi
	while (frames > 0) {
4003162c:	85 f6                	test   %esi,%esi
4003162e:	7e 40                	jle    40031670 <handle_spi_mst_interrupt+0x202>
		write_frame(spi, tx_buffer);
40031630:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031633:	89 d8                	mov    %ebx,%eax
40031635:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031638:	e8 ba fd ff ff       	call   400313f7 <write_frame>
		tx_counter[spi]++;
4003163d:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031644:	a8 
40031645:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40031648:	40                   	inc    %eax
40031649:	01 4d f0             	add    %ecx,-0x10(%ebp)
		if (transfer->tx_len == tx_counter[spi]) {
4003164c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		tx_counter[spi]++;
4003164f:	66 89 84 1b 44 69 00 	mov    %ax,-0x57ff96bc(%ebx,%ebx,1)
40031656:	a8 
		frames--;
40031657:	4e                   	dec    %esi
		if (transfer->tx_len == tx_counter[spi]) {
40031658:	66 8b 51 08          	mov    0x8(%ecx),%dx
4003165c:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031663:	a8 
40031664:	66 39 c2             	cmp    %ax,%dx
40031667:	75 c3                	jne    4003162c <handle_spi_mst_interrupt+0x1be>
			controller->txftlr = 0;
40031669:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
}
40031670:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031673:	5b                   	pop    %ebx
40031674:	5e                   	pop    %esi
40031675:	5f                   	pop    %edi
40031676:	5d                   	pop    %ebp
40031677:	c3                   	ret    

40031678 <qm_spi_set_config>:
		handle_slv_tx_interrupt(spi);
	}
}

int qm_spi_set_config(const qm_spi_t spi, const qm_spi_config_t *cfg)
{
40031678:	55                   	push   %ebp
40031679:	89 e5                	mov    %esp,%ebp
4003167b:	57                   	push   %edi
4003167c:	56                   	push   %esi
4003167d:	53                   	push   %ebx
4003167e:	51                   	push   %ecx
	QM_CHECK(QM_SPI_SLV_0 == spi
		     ? cfg->transfer_mode != QM_SPI_TMOD_EEPROM_READ
		     : 1,
		 -EINVAL);

	if (0 != QM_SPI[spi]->ssienr) {
4003167f:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi
40031686:	8b 4e 08             	mov    0x8(%esi),%ecx
40031689:	85 c9                	test   %ecx,%ecx
4003168b:	75 4d                	jne    400316da <qm_spi_set_config+0x62>
	}

	qm_spi_reg_t *const controller = QM_SPI[spi];

	/* Apply the selected cfg options. */
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
4003168d:	8b 3a                	mov    (%edx),%edi
4003168f:	89 7d f0             	mov    %edi,-0x10(%ebp)
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031692:	8b 7a 04             	mov    0x4(%edx),%edi
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031695:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031698:	89 f9                	mov    %edi,%ecx
4003169a:	c1 e1 08             	shl    $0x8,%ecx
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
4003169d:	c1 e3 10             	shl    $0x10,%ebx
400316a0:	09 cb                	or     %ecx,%ebx
			     (cfg->bus_mode << QM_SPI_CTRLR0_SCPOL_SCPH_OFFSET);
400316a2:	8b 4a 08             	mov    0x8(%edx),%ecx
400316a5:	c1 e1 06             	shl    $0x6,%ecx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
400316a8:	09 cb                	or     %ecx,%ebx

	/*
	 * If the device is configured as a slave, an external master will
	 * set the baud rate.
	 */
	if (QM_SPI_SLV_0 != spi) {
400316aa:	83 f8 02             	cmp    $0x2,%eax
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
400316ad:	89 1e                	mov    %ebx,(%esi)
	if (QM_SPI_SLV_0 != spi) {
400316af:	74 07                	je     400316b8 <qm_spi_set_config+0x40>
		controller->baudr = cfg->clk_divider;
400316b1:	0f b7 5a 10          	movzwl 0x10(%edx),%ebx
400316b5:	89 5e 14             	mov    %ebx,0x14(%esi)
	 * - 1 byte for DFS set from 4 to 8 bits;
	 * - 2 bytes for DFS set from 9 to 16 bits;
	 * - 3 bytes for DFS set from 17 to 24 bits;
	 * - 4 bytes for DFS set from 25 to 32 bits.
	 */
	dfs[spi] = (cfg->frame_size / 8) + 1;
400316b8:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	tmode[spi] = cfg->transfer_mode;
	frf[spi] = cfg->frame_format;
400316bb:	8b 52 0c             	mov    0xc(%edx),%edx
	dfs[spi] = (cfg->frame_size / 8) + 1;
400316be:	c1 e9 03             	shr    $0x3,%ecx
	tmode[spi] = cfg->transfer_mode;
400316c1:	89 3c 85 2c 69 00 a8 	mov    %edi,-0x57ff96d4(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
400316c8:	41                   	inc    %ecx
	frf[spi] = cfg->frame_format;
400316c9:	89 14 85 20 69 00 a8 	mov    %edx,-0x57ff96e0(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
400316d0:	88 88 38 69 00 a8    	mov    %cl,-0x57ff96c8(%eax)

	return 0;
400316d6:	31 c0                	xor    %eax,%eax
400316d8:	eb 05                	jmp    400316df <qm_spi_set_config+0x67>
		return -EBUSY;
400316da:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
400316df:	5a                   	pop    %edx
400316e0:	5b                   	pop    %ebx
400316e1:	5e                   	pop    %esi
400316e2:	5f                   	pop    %edi
400316e3:	5d                   	pop    %ebp
400316e4:	c3                   	ret    

400316e5 <qm_spi_slave_select>:
int qm_spi_slave_select(const qm_spi_t spi, const qm_spi_slave_select_t ss)
{
	QM_CHECK((spi < QM_SPI_NUM) && (spi != QM_SPI_SLV_0), -EINVAL);

	/* Check if the device reports as busy. */
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
400316e5:	8b 04 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%eax
{
400316ec:	55                   	push   %ebp
400316ed:	89 e5                	mov    %esp,%ebp
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
400316ef:	8b 48 28             	mov    0x28(%eax),%ecx
400316f2:	80 e1 01             	and    $0x1,%cl
400316f5:	75 07                	jne    400316fe <qm_spi_slave_select+0x19>
		return -EBUSY;
	}

	QM_SPI[spi]->ser = ss;
400316f7:	89 50 10             	mov    %edx,0x10(%eax)

	return 0;
400316fa:	31 c0                	xor    %eax,%eax
400316fc:	eb 05                	jmp    40031703 <qm_spi_slave_select+0x1e>
		return -EBUSY;
400316fe:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031703:	5d                   	pop    %ebp
40031704:	c3                   	ret    

40031705 <qm_spi_irq_update>:
}

int qm_spi_irq_update(const qm_spi_t spi,
		      const volatile qm_spi_async_transfer_t *const xfer,
		      const qm_spi_update_t update)
{
40031705:	55                   	push   %ebp
	QM_CHECK((update & QM_SPI_UPDATE_RX) ? (tmode[spi] != QM_SPI_TMOD_TX)
					     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
	spi_async_transfer[spi] = xfer;
40031706:	89 14 85 4c 69 00 a8 	mov    %edx,-0x57ff96b4(,%eax,4)
{
4003170d:	89 e5                	mov    %esp,%ebp

	if (update == QM_SPI_UPDATE_RX) {
4003170f:	83 f9 01             	cmp    $0x1,%ecx
{
40031712:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031713:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	if (update == QM_SPI_UPDATE_RX) {
4003171a:	75 13                	jne    4003172f <qm_spi_irq_update+0x2a>
		rx_counter[spi] = 0;
4003171c:	66 c7 84 00 3c 69 00 	movw   $0x0,-0x57ff96c4(%eax,%eax,1)
40031723:	a8 00 00 
		/* Unmask RX interrupt sources. */
		controller->imr =
40031726:	c7 43 2c 1c 00 00 00 	movl   $0x1c,0x2c(%ebx)
4003172d:	eb 33                	jmp    40031762 <qm_spi_irq_update+0x5d>
		    QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM | QM_SPI_IMR_RXFIM;
	} else if (update == QM_SPI_UPDATE_TX) {
4003172f:	83 f9 02             	cmp    $0x2,%ecx
40031732:	75 13                	jne    40031747 <qm_spi_irq_update+0x42>
		tx_counter[spi] = 0;
40031734:	66 c7 84 00 44 69 00 	movw   $0x0,-0x57ff96bc(%eax,%eax,1)
4003173b:	a8 00 00 
		/* Unmask TX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM;
4003173e:	c7 43 2c 03 00 00 00 	movl   $0x3,0x2c(%ebx)
40031745:	eb 1b                	jmp    40031762 <qm_spi_irq_update+0x5d>
	} else {
		rx_counter[spi] = 0;
40031747:	66 c7 84 00 3c 69 00 	movw   $0x0,-0x57ff96c4(%eax,%eax,1)
4003174e:	a8 00 00 
		tx_counter[spi] = 0;
40031751:	66 c7 84 00 44 69 00 	movw   $0x0,-0x57ff96bc(%eax,%eax,1)
40031758:	a8 00 00 
		/* Unmask both TX and RX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM |
4003175b:	c7 43 2c 1f 00 00 00 	movl   $0x1f,0x2c(%ebx)
				  QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM |
				  QM_SPI_IMR_RXFIM;
	}

	return 0;
}
40031762:	31 c0                	xor    %eax,%eax
40031764:	5b                   	pop    %ebx
40031765:	5d                   	pop    %ebp
40031766:	c3                   	ret    

40031767 <qm_spi_irq_transfer>:

int qm_spi_irq_transfer(const qm_spi_t spi,
			const volatile qm_spi_async_transfer_t *const xfer)
{
40031767:	55                   	push   %ebp
40031768:	89 e5                	mov    %esp,%ebp
4003176a:	57                   	push   %edi
4003176b:	56                   	push   %esi
4003176c:	53                   	push   %ebx
4003176d:	51                   	push   %ecx
4003176e:	89 c3                	mov    %eax,%ebx
	QM_CHECK(tmode[spi] == QM_SPI_TMOD_TX_RX
		     ? (xfer->tx_len == xfer->rx_len)
		     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
40031770:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi

	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031777:	8b 04 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%eax
4003177e:	89 45 f0             	mov    %eax,-0x10(%ebp)
40031781:	83 e8 02             	sub    $0x2,%eax
40031784:	83 f8 01             	cmp    $0x1,%eax
{
40031787:	89 d7                	mov    %edx,%edi
	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031789:	0f 96 c1             	setbe  %cl
4003178c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40031790:	0f 94 c0             	sete   %al
	qm_spi_update_t update = 0;
40031793:	09 c1                	or     %eax,%ecx
40031795:	0f b6 c9             	movzbl %cl,%ecx
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_RX;
	}
	if ((tmode[spi] == QM_SPI_TMOD_TX) ||
40031798:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
4003179c:	76 06                	jbe    400317a4 <qm_spi_irq_transfer+0x3d>
4003179e:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
400317a2:	75 03                	jne    400317a7 <qm_spi_irq_transfer+0x40>
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_TX;
400317a4:	83 c9 02             	or     $0x2,%ecx
	}

	rx_counter[spi] = 0;
	tx_counter[spi] = 0;
	qm_spi_irq_update(spi, xfer, update);
400317a7:	89 fa                	mov    %edi,%edx
400317a9:	89 d8                	mov    %ebx,%eax
	rx_counter[spi] = 0;
400317ab:	66 c7 84 1b 3c 69 00 	movw   $0x0,-0x57ff96c4(%ebx,%ebx,1)
400317b2:	a8 00 00 
	tx_counter[spi] = 0;
400317b5:	66 c7 84 1b 44 69 00 	movw   $0x0,-0x57ff96bc(%ebx,%ebx,1)
400317bc:	a8 00 00 
	qm_spi_irq_update(spi, xfer, update);
400317bf:	e8 41 ff ff ff       	call   40031705 <qm_spi_irq_update>
		 * holds how many bytes the controller solicits, minus 1.
		 * We also set the same into rxftlr, so the controller only
		 * triggers a RX_FIFO_FULL interrupt when all frames are
		 * available at the FIFO for consumption.
		 */
		if (xfer->rx_len) {
400317c4:	66 8b 47 0a          	mov    0xa(%edi),%ax
	if (QM_SPI_SLV_0 != spi) {
400317c8:	83 fb 02             	cmp    $0x2,%ebx
400317cb:	74 2d                	je     400317fa <qm_spi_irq_transfer+0x93>
		if (xfer->rx_len) {
400317cd:	66 85 c0             	test   %ax,%ax
400317d0:	74 1f                	je     400317f1 <qm_spi_irq_transfer+0x8a>
			controller->ctrlr1 = xfer->rx_len - 1;
400317d2:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
400317d6:	48                   	dec    %eax
400317d7:	89 46 04             	mov    %eax,0x4(%esi)
400317da:	b8 05 00 00 00       	mov    $0x5,%eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
400317df:	66 8b 57 0a          	mov    0xa(%edi),%dx
						 ? xfer->rx_len - 1
						 : SPI_MST_DEFAULT_RX_THRESHOLD;
400317e3:	66 83 fa 07          	cmp    $0x7,%dx
400317e7:	77 05                	ja     400317ee <qm_spi_irq_transfer+0x87>
						 ? xfer->rx_len - 1
400317e9:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
400317ed:	48                   	dec    %eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
400317ee:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_MST_DEFAULT_TX_THRESHOLD;
400317f1:	c7 46 18 05 00 00 00 	movl   $0x5,0x18(%esi)
400317f8:	eb 35                	jmp    4003182f <qm_spi_irq_transfer+0xc8>
	} else {
		if (xfer->rx_len) {
400317fa:	66 85 c0             	test   %ax,%ax
400317fd:	74 17                	je     40031816 <qm_spi_irq_transfer+0xaf>
			controller->rxftlr =
			    (xfer->rx_len < SPI_SLV_DEFAULT_RX_THRESHOLD)
400317ff:	66 8b 57 0a          	mov    0xa(%edi),%dx
40031803:	b8 03 00 00 00       	mov    $0x3,%eax
				? xfer->rx_len - 1
				: SPI_SLV_DEFAULT_RX_THRESHOLD;
40031808:	66 83 fa 02          	cmp    $0x2,%dx
4003180c:	77 05                	ja     40031813 <qm_spi_irq_transfer+0xac>
				? xfer->rx_len - 1
4003180e:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031812:	48                   	dec    %eax
			controller->rxftlr =
40031813:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_SLV_DEFAULT_TX_THRESHOLD;
40031816:	c7 46 18 04 00 00 00 	movl   $0x4,0x18(%esi)

		if (QM_SPI_TMOD_RX != tmode[spi]) {
4003181d:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
			/* Enable MISO line. */
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031821:	8b 06                	mov    (%esi),%eax
		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031823:	74 05                	je     4003182a <qm_spi_irq_transfer+0xc3>
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031825:	80 e4 fb             	and    $0xfb,%ah
40031828:	eb 03                	jmp    4003182d <qm_spi_irq_transfer+0xc6>
		} else {
			/* Disable MISO line. */
			controller->ctrlr0 |= QM_SPI_CTRLR0_SLV_OE;
4003182a:	80 cc 04             	or     $0x4,%ah
4003182d:	89 06                	mov    %eax,(%esi)
		}
	}

	/* Enable SPI controller. */
	controller->ssienr = QM_SPI_SSIENR_SSIENR;
4003182f:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)

	if ((QM_SPI_SLV_0 != spi && QM_SPI_TMOD_RX == tmode[spi]) &&
40031836:	83 fb 02             	cmp    $0x2,%ebx
40031839:	74 20                	je     4003185b <qm_spi_irq_transfer+0xf4>
4003183b:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
40031842:	02 
40031843:	75 16                	jne    4003185b <qm_spi_irq_transfer+0xf4>
40031845:	83 3c 9d 20 69 00 a8 	cmpl   $0x0,-0x57ff96e0(,%ebx,4)
4003184c:	00 
4003184d:	75 0c                	jne    4003185b <qm_spi_irq_transfer+0xf4>
		/*
		 * In RX only, master is required to send
		 * a dummy frame in order to start the
		 * communication.
		 */
		write_frame(spi, (uint8_t *)&tx_dummy_frame);
4003184f:	ba 88 56 03 40       	mov    $0x40035688,%edx
40031854:	89 d8                	mov    %ebx,%eax
40031856:	e8 9c fb ff ff       	call   400313f7 <write_frame>
	}

	return 0;
}
4003185b:	5a                   	pop    %edx
4003185c:	31 c0                	xor    %eax,%eax
4003185e:	5b                   	pop    %ebx
4003185f:	5e                   	pop    %esi
40031860:	5f                   	pop    %edi
40031861:	5d                   	pop    %ebp
40031862:	c3                   	ret    

40031863 <qm_spi_master_0_isr>:

QM_ISR_DECLARE(qm_spi_master_0_isr)
{
40031863:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031864:	31 c0                	xor    %eax,%eax
{
40031866:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_0_INT_VECTOR);
}
40031868:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031869:	e9 00 fc ff ff       	jmp    4003146e <handle_spi_mst_interrupt>

4003186e <qm_spi_master_1_isr>:

#if (QUARK_SE)
QM_ISR_DECLARE(qm_spi_master_1_isr)
{
4003186e:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
4003186f:	b8 01 00 00 00       	mov    $0x1,%eax
{
40031874:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_1_INT_VECTOR);
}
40031876:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40031877:	e9 f2 fb ff ff       	jmp    4003146e <handle_spi_mst_interrupt>

4003187c <qm_pmux_select>:
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
	return ((pin % (32 / width)) * width);
4003187c:	89 c1                	mov    %eax,%ecx
}

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
4003187e:	55                   	push   %ebp
	return (pin / (32 / width));
4003187f:	c1 e8 04             	shr    $0x4,%eax
	return ((pin % (32 / width)) * width);
40031882:	83 e1 0f             	and    $0xf,%ecx
{
40031885:	89 e5                	mov    %esp,%ebp
	return ((pin % (32 / width)) * width);
40031887:	01 c9                	add    %ecx,%ecx
{
40031889:	56                   	push   %esi
4003188a:	53                   	push   %ebx
4003188b:	8d 1c 85 00 09 80 b0 	lea    -0x4f7ff700(,%eax,4),%ebx
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
	uint32_t offs = pin_to_offset(pin, 2);

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
40031892:	b8 03 00 00 00       	mov    $0x3,%eax
40031897:	d3 e0                	shl    %cl,%eax
40031899:	8b 73 30             	mov    0x30(%ebx),%esi
4003189c:	f7 d0                	not    %eax
4003189e:	21 f0                	and    %esi,%eax
400318a0:	89 43 30             	mov    %eax,0x30(%ebx)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
400318a3:	8b 43 30             	mov    0x30(%ebx),%eax
400318a6:	d3 e2                	shl    %cl,%edx
400318a8:	09 c2                	or     %eax,%edx

	return 0;
}
400318aa:	31 c0                	xor    %eax,%eax
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
400318ac:	89 53 30             	mov    %edx,0x30(%ebx)
}
400318af:	5b                   	pop    %ebx
400318b0:	5e                   	pop    %esi
400318b1:	5d                   	pop    %ebp
400318b2:	c3                   	ret    

400318b3 <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
400318b3:	55                   	push   %ebp
400318b4:	89 c1                	mov    %eax,%ecx
400318b6:	89 e5                	mov    %esp,%ebp
400318b8:	53                   	push   %ebx
	return (pin / (32 / width));
400318b9:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400318bb:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
400318c0:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400318c3:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
400318c5:	84 d2                	test   %dl,%dl
400318c7:	8d 14 9d 00 09 80 b0 	lea    -0x4f7ff700(,%ebx,4),%edx
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
400318ce:	8b 4a 20             	mov    0x20(%edx),%ecx
	if (enable == false) {
400318d1:	75 06                	jne    400318d9 <qm_pmux_input_en+0x26>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
400318d3:	f7 d0                	not    %eax
400318d5:	21 c8                	and    %ecx,%eax
400318d7:	eb 02                	jmp    400318db <qm_pmux_input_en+0x28>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
400318d9:	09 c8                	or     %ecx,%eax
400318db:	89 42 20             	mov    %eax,0x20(%edx)
	}
	return 0;
}
400318de:	31 c0                	xor    %eax,%eax
400318e0:	5b                   	pop    %ebx
400318e1:	5d                   	pop    %ebp
400318e2:	c3                   	ret    

400318e3 <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
400318e3:	55                   	push   %ebp
400318e4:	89 c1                	mov    %eax,%ecx
400318e6:	89 e5                	mov    %esp,%ebp
400318e8:	53                   	push   %ebx
	return (pin / (32 / width));
400318e9:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400318eb:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
400318f0:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
400318f3:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
400318f5:	84 d2                	test   %dl,%dl
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
400318f7:	8b 14 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edx
	if (enable == false) {
400318fe:	75 06                	jne    40031906 <qm_pmux_pullup_en+0x23>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031900:	f7 d0                	not    %eax
40031902:	21 d0                	and    %edx,%eax
40031904:	eb 02                	jmp    40031908 <qm_pmux_pullup_en+0x25>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
40031906:	09 d0                	or     %edx,%eax
40031908:	89 04 9d 00 09 80 b0 	mov    %eax,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
4003190f:	31 c0                	xor    %eax,%eax
40031911:	5b                   	pop    %ebx
40031912:	5d                   	pop    %ebp
40031913:	c3                   	ret    

40031914 <mraa_init>:
mraa_board_t* plat = NULL;
struct _gpio _internalgpios[4];

mraa_result_t
mraa_init()
{
40031914:	55                   	push   %ebp
40031915:	89 e5                	mov    %esp,%ebp
#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
    plat = mraa_intel_arduino_101_sss();
#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
    plat = mraa_intel_d2k_crb();
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    plat = mraa_intel_quark_se_devboard();
40031917:	e8 3d 05 00 00       	call   40031e59 <mraa_intel_quark_se_devboard>
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
    plat = mraa_intel_quark_se_ss_devboard();
#endif
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
}
4003191c:	5d                   	pop    %ebp
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
4003191d:	83 f8 01             	cmp    $0x1,%eax
    plat = mraa_intel_quark_se_devboard();
40031920:	a3 58 69 00 a8       	mov    %eax,0xa8006958
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40031925:	19 c0                	sbb    %eax,%eax
40031927:	83 e0 06             	and    $0x6,%eax
}
4003192a:	c3                   	ret    

4003192b <mraa_setup_mux_mapped>:
    return false;
}

mraa_result_t
mraa_setup_mux_mapped(mraa_pin_t meta)
{
4003192b:	55                   	push   %ebp
    int mi;
    mraa_result_t ret;
    mraa_gpio_context mux_i = NULL;
    int last_pin = -1;
4003192c:	83 c8 ff             	or     $0xffffffff,%eax
{
4003192f:	89 e5                	mov    %esp,%ebp
40031931:	57                   	push   %edi
40031932:	56                   	push   %esi
40031933:	53                   	push   %ebx
40031934:	83 ec 08             	sub    $0x8,%esp
40031937:	8d 7d 08             	lea    0x8(%ebp),%edi
    mraa_gpio_context mux_i = NULL;
4003193a:	31 db                	xor    %ebx,%ebx

    for (mi = 0; mi < meta.mux_total; mi++) {
4003193c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40031943:	0f b6 55 0a          	movzbl 0xa(%ebp),%edx
40031947:	39 55 ec             	cmp    %edx,-0x14(%ebp)
4003194a:	0f 8d 8a 01 00 00    	jge    40031ada <mraa_setup_mux_mapped+0x1af>

        switch (meta.mux[mi].pincmd) {
40031950:	80 7f 03 05          	cmpb   $0x5,0x3(%edi)
40031954:	0f 87 6f 01 00 00    	ja     40031ac9 <mraa_setup_mux_mapped+0x19e>
4003195a:	0f b6 57 03          	movzbl 0x3(%edi),%edx
4003195e:	0f b6 77 04          	movzbl 0x4(%edi),%esi
                    return MRAA_ERROR_INVALID_RESOURCE;
                }
                break;

            case PINCMD_SET_MODE:
                if (meta.mux[mi].pin != last_pin) {
40031962:	89 75 f0             	mov    %esi,-0x10(%ebp)
40031965:	39 f0                	cmp    %esi,%eax
        switch (meta.mux[mi].pincmd) {
40031967:	ff 24 95 8c 56 03 40 	jmp    *0x4003568c(,%edx,4)
                if (meta.mux[mi].pin != last_pin) {
4003196e:	74 2b                	je     4003199b <mraa_setup_mux_mapped+0x70>
                    if (mux_i != NULL) {
40031970:	85 db                	test   %ebx,%ebx
40031972:	74 10                	je     40031984 <mraa_setup_mux_mapped+0x59>
                        mraa_gpio_owner(mux_i, 0);
40031974:	31 d2                	xor    %edx,%edx
40031976:	89 d8                	mov    %ebx,%eax
40031978:	e8 b7 03 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003197d:	89 d8                	mov    %ebx,%eax
4003197f:	e8 cc 03 00 00       	call   40031d50 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031984:	89 f0                	mov    %esi,%eax
40031986:	e8 dc 01 00 00       	call   40031b67 <mraa_gpio_init_raw>
4003198b:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003198d:	85 c0                	test   %eax,%eax
4003198f:	75 0a                	jne    4003199b <mraa_setup_mux_mapped+0x70>
                        return MRAA_ERROR_INVALID_HANDLE;
40031991:	b8 05 00 00 00       	mov    $0x5,%eax
40031996:	e9 57 01 00 00       	jmp    40031af2 <mraa_setup_mux_mapped+0x1c7>
                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
4003199b:	31 d2                	xor    %edx,%edx
4003199d:	89 d8                	mov    %ebx,%eax
4003199f:	e8 f1 02 00 00       	call   40031c95 <mraa_gpio_dir>
400319a4:	e9 c2 00 00 00       	jmp    40031a6b <mraa_setup_mux_mapped+0x140>
                if (meta.mux[mi].pin != last_pin) {
400319a9:	0f 84 bc 00 00 00    	je     40031a6b <mraa_setup_mux_mapped+0x140>
                    if (mux_i != NULL) {
400319af:	85 db                	test   %ebx,%ebx
400319b1:	74 10                	je     400319c3 <mraa_setup_mux_mapped+0x98>
                        mraa_gpio_owner(mux_i, 0);
400319b3:	31 d2                	xor    %edx,%edx
400319b5:	89 d8                	mov    %ebx,%eax
400319b7:	e8 78 03 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400319bc:	89 d8                	mov    %ebx,%eax
400319be:	e8 8d 03 00 00       	call   40031d50 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400319c3:	89 f0                	mov    %esi,%eax
400319c5:	e8 9d 01 00 00       	call   40031b67 <mraa_gpio_init_raw>
400319ca:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400319cc:	85 c0                	test   %eax,%eax
400319ce:	0f 85 97 00 00 00    	jne    40031a6b <mraa_setup_mux_mapped+0x140>
400319d4:	eb bb                	jmp    40031991 <mraa_setup_mux_mapped+0x66>
                if (meta.mux[mi].pin != last_pin) {
400319d6:	74 21                	je     400319f9 <mraa_setup_mux_mapped+0xce>
                    if (mux_i != NULL) {
400319d8:	85 db                	test   %ebx,%ebx
400319da:	74 10                	je     400319ec <mraa_setup_mux_mapped+0xc1>
                        mraa_gpio_owner(mux_i, 0);
400319dc:	31 d2                	xor    %edx,%edx
400319de:	89 d8                	mov    %ebx,%eax
400319e0:	e8 4f 03 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400319e5:	89 d8                	mov    %ebx,%eax
400319e7:	e8 64 03 00 00       	call   40031d50 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400319ec:	89 f0                	mov    %esi,%eax
400319ee:	e8 74 01 00 00       	call   40031b67 <mraa_gpio_init_raw>
400319f3:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400319f5:	85 c0                	test   %eax,%eax
400319f7:	74 98                	je     40031991 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
400319f9:	0f b6 57 05          	movzbl 0x5(%edi),%edx
400319fd:	89 d8                	mov    %ebx,%eax
400319ff:	e8 91 02 00 00       	call   40031c95 <mraa_gpio_dir>
40031a04:	e9 a1 00 00 00       	jmp    40031aaa <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40031a09:	74 25                	je     40031a30 <mraa_setup_mux_mapped+0x105>
                    if (mux_i != NULL) {
40031a0b:	85 db                	test   %ebx,%ebx
40031a0d:	74 10                	je     40031a1f <mraa_setup_mux_mapped+0xf4>
                        mraa_gpio_owner(mux_i, 0);
40031a0f:	31 d2                	xor    %edx,%edx
40031a11:	89 d8                	mov    %ebx,%eax
40031a13:	e8 1c 03 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031a18:	89 d8                	mov    %ebx,%eax
40031a1a:	e8 31 03 00 00       	call   40031d50 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031a1f:	89 f0                	mov    %esi,%eax
40031a21:	e8 41 01 00 00       	call   40031b67 <mraa_gpio_init_raw>
40031a26:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031a28:	85 c0                	test   %eax,%eax
40031a2a:	0f 84 61 ff ff ff    	je     40031991 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
40031a30:	ba 01 00 00 00       	mov    $0x1,%edx
40031a35:	eb 29                	jmp    40031a60 <mraa_setup_mux_mapped+0x135>
                if (meta.mux[mi].pin != last_pin) {
40031a37:	74 25                	je     40031a5e <mraa_setup_mux_mapped+0x133>
                    if (mux_i != NULL) {
40031a39:	85 db                	test   %ebx,%ebx
40031a3b:	74 10                	je     40031a4d <mraa_setup_mux_mapped+0x122>
                        mraa_gpio_owner(mux_i, 0);
40031a3d:	31 d2                	xor    %edx,%edx
40031a3f:	89 d8                	mov    %ebx,%eax
40031a41:	e8 ee 02 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031a46:	89 d8                	mov    %ebx,%eax
40031a48:	e8 03 03 00 00       	call   40031d50 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031a4d:	89 f0                	mov    %esi,%eax
40031a4f:	e8 13 01 00 00       	call   40031b67 <mraa_gpio_init_raw>
40031a54:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031a56:	85 c0                	test   %eax,%eax
40031a58:	0f 84 33 ff ff ff    	je     40031991 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40031a5e:	31 d2                	xor    %edx,%edx
40031a60:	89 d8                	mov    %ebx,%eax
40031a62:	e8 2e 02 00 00       	call   40031c95 <mraa_gpio_dir>
                if (ret == MRAA_SUCCESS)
40031a67:	85 c0                	test   %eax,%eax
40031a69:	75 43                	jne    40031aae <mraa_setup_mux_mapped+0x183>
                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
40031a6b:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40031a6f:	89 d8                	mov    %ebx,%eax
40031a71:	e8 95 02 00 00       	call   40031d0b <mraa_gpio_write>
40031a76:	eb 32                	jmp    40031aaa <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40031a78:	74 25                	je     40031a9f <mraa_setup_mux_mapped+0x174>
                    if (mux_i != NULL) {
40031a7a:	85 db                	test   %ebx,%ebx
40031a7c:	74 10                	je     40031a8e <mraa_setup_mux_mapped+0x163>
                        mraa_gpio_owner(mux_i, 0);
40031a7e:	31 d2                	xor    %edx,%edx
40031a80:	89 d8                	mov    %ebx,%eax
40031a82:	e8 ad 02 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031a87:	89 d8                	mov    %ebx,%eax
40031a89:	e8 c2 02 00 00       	call   40031d50 <mraa_gpio_close>
                    }
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031a8e:	89 f0                	mov    %esi,%eax
40031a90:	e8 d2 00 00 00       	call   40031b67 <mraa_gpio_init_raw>
40031a95:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031a97:	85 c0                	test   %eax,%eax
40031a99:	0f 84 f2 fe ff ff    	je     40031991 <mraa_setup_mux_mapped+0x66>
                        return MRAA_ERROR_INVALID_HANDLE;
                    last_pin = meta.mux[mi].pin;
                }

                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
40031a9f:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40031aa3:	89 d8                	mov    %ebx,%eax
40031aa5:	e8 9f 02 00 00       	call   40031d49 <mraa_gpio_mode>

                if (ret != MRAA_SUCCESS) {
40031aaa:	85 c0                	test   %eax,%eax
40031aac:	74 1e                	je     40031acc <mraa_setup_mux_mapped+0x1a1>
                    if (mux_i != NULL) {
40031aae:	85 db                	test   %ebx,%ebx
40031ab0:	74 10                	je     40031ac2 <mraa_setup_mux_mapped+0x197>
                        mraa_gpio_owner(mux_i, 0);
40031ab2:	31 d2                	xor    %edx,%edx
40031ab4:	89 d8                	mov    %ebx,%eax
40031ab6:	e8 79 02 00 00       	call   40031d34 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031abb:	89 d8                	mov    %ebx,%eax
40031abd:	e8 8e 02 00 00       	call   40031d50 <mraa_gpio_close>
                    return MRAA_ERROR_INVALID_RESOURCE;
40031ac2:	b8 07 00 00 00       	mov    $0x7,%eax
40031ac7:	eb 29                	jmp    40031af2 <mraa_setup_mux_mapped+0x1c7>
        switch (meta.mux[mi].pincmd) {
40031ac9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (mi = 0; mi < meta.mux_total; mi++) {
40031acc:	ff 45 ec             	incl   -0x14(%ebp)
40031acf:	83 c7 03             	add    $0x3,%edi
40031ad2:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031ad5:	e9 69 fe ff ff       	jmp    40031943 <mraa_setup_mux_mapped+0x18>

    if (mux_i != NULL) {
        mraa_gpio_owner(mux_i, 0);
        mraa_gpio_close(mux_i);
    }
    return MRAA_SUCCESS;
40031ada:	31 c0                	xor    %eax,%eax
    if (mux_i != NULL) {
40031adc:	85 db                	test   %ebx,%ebx
40031ade:	74 12                	je     40031af2 <mraa_setup_mux_mapped+0x1c7>
        mraa_gpio_owner(mux_i, 0);
40031ae0:	31 d2                	xor    %edx,%edx
40031ae2:	89 d8                	mov    %ebx,%eax
40031ae4:	e8 4b 02 00 00       	call   40031d34 <mraa_gpio_owner>
        mraa_gpio_close(mux_i);
40031ae9:	89 d8                	mov    %ebx,%eax
40031aeb:	e8 60 02 00 00       	call   40031d50 <mraa_gpio_close>
    return MRAA_SUCCESS;
40031af0:	31 c0                	xor    %eax,%eax
}
40031af2:	5a                   	pop    %edx
40031af3:	59                   	pop    %ecx
40031af4:	5b                   	pop    %ebx
40031af5:	5e                   	pop    %esi
40031af6:	5f                   	pop    %edi
40031af7:	5d                   	pop    %ebp
40031af8:	c3                   	ret    

40031af9 <mraa_set_pininfo>:


// Internal functions
mraa_result_t
mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
{
40031af9:	55                   	push   %ebp
40031afa:	89 e5                	mov    %esp,%ebp
40031afc:	53                   	push   %ebx
    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
    pin_info->gpio.pinmap = zephyr_pin;
40031afd:	6b da 44             	imul   $0x44,%edx,%ebx
#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB) || defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    pin_info->uart.pinmap = zephyr_pin;
#endif
    pin_info->pwm.pinmap = zephyr_pin;
    pin_info->gpio.mux_total = 0;
    pin_info->name = name;
40031b00:	42                   	inc    %edx
    pin_info->gpio.pinmap = zephyr_pin;
40031b01:	01 c3                	add    %eax,%ebx
    pin_info->name = name;
40031b03:	6b d2 44             	imul   $0x44,%edx,%edx
    pin_info->gpio.pinmap = zephyr_pin;
40031b06:	88 4b 4c             	mov    %cl,0x4c(%ebx)
    pin_info->uart.pinmap = zephyr_pin;
40031b09:	88 4b 7c             	mov    %cl,0x7c(%ebx)
    pin_info->pwm.pinmap = zephyr_pin;
40031b0c:	88 4b 58             	mov    %cl,0x58(%ebx)
    pin_info->name = name;
40031b0f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    pin_info->gpio.mux_total = 0;
40031b12:	c6 43 4e 00          	movb   $0x0,0x4e(%ebx)
    pin_info->name = name;
40031b16:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
    pin_info->capabilites = caps;
40031b19:	8a 45 0c             	mov    0xc(%ebp),%al
40031b1c:	88 43 48             	mov    %al,0x48(%ebx)
    return MRAA_SUCCESS;
}
40031b1f:	31 c0                	xor    %eax,%eax
40031b21:	5b                   	pop    %ebx
40031b22:	5d                   	pop    %ebp
40031b23:	c3                   	ret    

40031b24 <mraa_set_board_config>:


void
mraa_set_board_config(mraa_board_t* board)
{
40031b24:	55                   	push   %ebp
    memset(board, 0, sizeof(mraa_board_t));
40031b25:	b9 48 0d 00 00       	mov    $0xd48,%ecx
{
40031b2a:	89 e5                	mov    %esp,%ebp
40031b2c:	53                   	push   %ebx
40031b2d:	89 c3                	mov    %eax,%ebx
    memset(board, 0, sizeof(mraa_board_t));
40031b2f:	31 d2                	xor    %edx,%edx
40031b31:	e8 3f e5 ff ff       	call   40030075 <memset>
    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
40031b36:	c6 03 31             	movb   $0x31,(%ebx)
    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
40031b39:	c6 43 01 1f          	movb   $0x1f,0x1(%ebx)
    board->aio_count = CONFIG_MRAA_AIO_COUNT;
40031b3d:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
40031b41:	c6 43 03 02          	movb   $0x2,0x3(%ebx)
    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
40031b45:	c6 43 0b 02          	movb   $0x2,0xb(%ebx)
    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
40031b49:	c6 43 1e 01          	movb   $0x1,0x1e(%ebx)
}
40031b4d:	5b                   	pop    %ebx
40031b4e:	5d                   	pop    %ebp
40031b4f:	c3                   	ret    

40031b50 <gpio_pin_configure>:
{
40031b50:	55                   	push   %ebp
40031b51:	89 e5                	mov    %esp,%ebp
40031b53:	53                   	push   %ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40031b54:	8b 58 04             	mov    0x4(%eax),%ebx
40031b57:	51                   	push   %ecx
40031b58:	0f b6 d2             	movzbl %dl,%edx
40031b5b:	89 d1                	mov    %edx,%ecx
40031b5d:	31 d2                	xor    %edx,%edx
40031b5f:	ff 13                	call   *(%ebx)
40031b61:	5a                   	pop    %edx
}
40031b62:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031b65:	c9                   	leave  
40031b66:	c3                   	ret    

40031b67 <mraa_gpio_init_raw>:
    return dev;
}

mraa_gpio_context
mraa_gpio_init_raw(int gpiopin)
{
40031b67:	55                   	push   %ebp
40031b68:	89 e5                	mov    %esp,%ebp
40031b6a:	56                   	push   %esi
40031b6b:	89 c6                	mov    %eax,%esi
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40031b6d:	b8 20 00 00 00       	mov    $0x20,%eax
{
40031b72:	53                   	push   %ebx
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40031b73:	e8 96 25 00 00       	call   4003410e <malloc>
40031b78:	89 c3                	mov    %eax,%ebx
    if (!dev) {
40031b7a:	85 c0                	test   %eax,%eax
40031b7c:	75 13                	jne    40031b91 <mraa_gpio_init_raw+0x2a>
        printf("%s: context allocation failed\n", __FUNCTION__);
40031b7e:	68 70 57 03 40       	push   $0x40035770
40031b83:	68 a4 56 03 40       	push   $0x400356a4
40031b88:	e8 2d 27 00 00       	call   400342ba <iprintf>
40031b8d:	58                   	pop    %eax
40031b8e:	5a                   	pop    %edx
40031b8f:	eb 49                	jmp    40031bda <mraa_gpio_init_raw+0x73>
        return NULL;
    }

    dev->phy_pin = gpiopin;
40031b91:	89 f0                	mov    %esi,%eax
40031b93:	88 43 01             	mov    %al,0x1(%ebx)
    dev->zdev = device_get_binding(GPIO_DRV_NAME);
40031b96:	b8 f8 55 03 40       	mov    $0x400355f8,%eax
40031b9b:	e8 6a 1a 00 00       	call   4003360a <device_get_binding>
40031ba0:	89 43 04             	mov    %eax,0x4(%ebx)
//printf("GPIO : %s", GPIO_DRV_NAME);
    if (dev->zdev == NULL) {
40031ba3:	85 c0                	test   %eax,%eax
40031ba5:	74 2a                	je     40031bd1 <mraa_gpio_init_raw+0x6a>
        free(dev);
        return NULL;
    }
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
40031ba7:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
40031bab:	b9 01 00 00 00       	mov    $0x1,%ecx
40031bb0:	e8 9b ff ff ff       	call   40031b50 <gpio_pin_configure>
    if (ret) {
40031bb5:	85 c0                	test   %eax,%eax
40031bb7:	74 21                	je     40031bda <mraa_gpio_init_raw+0x73>
        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
40031bb9:	0f be 53 01          	movsbl 0x1(%ebx),%edx
40031bbd:	52                   	push   %edx
40031bbe:	68 f8 55 03 40       	push   $0x400355f8
40031bc3:	50                   	push   %eax
40031bc4:	68 c3 56 03 40       	push   $0x400356c3
40031bc9:	e8 ec 26 00 00       	call   400342ba <iprintf>
40031bce:	83 c4 10             	add    $0x10,%esp
        free(dev);
40031bd1:	89 d8                	mov    %ebx,%eax
        return NULL;
40031bd3:	31 db                	xor    %ebx,%ebx
        free(dev);
40031bd5:	e8 44 25 00 00       	call   4003411e <free>
    }
    return dev;
}
40031bda:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031bdd:	89 d8                	mov    %ebx,%eax
40031bdf:	5b                   	pop    %ebx
40031be0:	5e                   	pop    %esi
40031be1:	5d                   	pop    %ebp
40031be2:	c3                   	ret    

40031be3 <mraa_gpio_init>:
{
40031be3:	55                   	push   %ebp
40031be4:	89 e5                	mov    %esp,%ebp
40031be6:	57                   	push   %edi
40031be7:	56                   	push   %esi
40031be8:	53                   	push   %ebx
40031be9:	53                   	push   %ebx
    mraa_board_t* board = plat;
40031bea:	8b 15 58 69 00 a8    	mov    0xa8006958,%edx
    if (board == NULL) {
40031bf0:	85 d2                	test   %edx,%edx
40031bf2:	75 07                	jne    40031bfb <mraa_gpio_init+0x18>
        printf("gpio: platform not initialised\n");
40031bf4:	68 e3 56 03 40       	push   $0x400356e3
40031bf9:	eb 37                	jmp    40031c32 <mraa_gpio_init+0x4f>
40031bfb:	89 c3                	mov    %eax,%ebx
    if (pin < 0 || pin >= board->phy_pin_count) {
40031bfd:	85 c0                	test   %eax,%eax
40031bff:	78 07                	js     40031c08 <mraa_gpio_init+0x25>
40031c01:	0f b6 02             	movzbl (%edx),%eax
40031c04:	39 c3                	cmp    %eax,%ebx
40031c06:	7c 11                	jl     40031c19 <mraa_gpio_init+0x36>
        printf("gpio: pin %i beyond platform definition\n", pin);
40031c08:	53                   	push   %ebx
40031c09:	68 03 57 03 40       	push   $0x40035703
40031c0e:	e8 a7 26 00 00       	call   400342ba <iprintf>
40031c13:	5a                   	pop    %edx
40031c14:	59                   	pop    %ecx
        return NULL;
40031c15:	31 c0                	xor    %eax,%eax
40031c17:	eb 74                	jmp    40031c8d <mraa_gpio_init+0xaa>
    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
40031c19:	b8 ff 55 03 40       	mov    $0x400355ff,%eax
40031c1e:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031c21:	e8 e4 19 00 00       	call   4003360a <device_get_binding>
    if (pinmux_dev == NULL) {
40031c26:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031c29:	85 c0                	test   %eax,%eax
40031c2b:	75 0d                	jne    40031c3a <mraa_gpio_init+0x57>
        printf("Failed to get binding for pinmux\n");
40031c2d:	68 2c 57 03 40       	push   $0x4003572c
40031c32:	e8 83 26 00 00       	call   400342ba <iprintf>
40031c37:	58                   	pop    %eax
40031c38:	eb db                	jmp    40031c15 <mraa_gpio_init+0x32>
    if (board->pins[pin].capabilites.gpio != 1) {
40031c3a:	6b f3 44             	imul   $0x44,%ebx,%esi
40031c3d:	01 d6                	add    %edx,%esi
40031c3f:	f6 46 48 02          	testb  $0x2,0x48(%esi)
40031c43:	75 08                	jne    40031c4d <mraa_gpio_init+0x6a>
        printf("gpio: pin %i not capable of gpio\n", pin);
40031c45:	53                   	push   %ebx
40031c46:	68 4e 57 03 40       	push   $0x4003574e
40031c4b:	eb c1                	jmp    40031c0e <mraa_gpio_init+0x2b>
    if (board->pins[pin].gpio.mux_total > 0) {
40031c4d:	80 7e 4e 00          	cmpb   $0x0,0x4e(%esi)
40031c51:	75 15                	jne    40031c68 <mraa_gpio_init+0x85>
    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
40031c53:	6b c3 44             	imul   $0x44,%ebx,%eax
40031c56:	0f b6 44 02 4c       	movzbl 0x4c(%edx,%eax,1),%eax
40031c5b:	e8 07 ff ff ff       	call   40031b67 <mraa_gpio_init_raw>
    if (dev) {
40031c60:	85 c0                	test   %eax,%eax
40031c62:	74 29                	je     40031c8d <mraa_gpio_init+0xaa>
        dev->pin = pin;
40031c64:	88 18                	mov    %bl,(%eax)
40031c66:	eb 25                	jmp    40031c8d <mraa_gpio_init+0xaa>
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40031c68:	83 ec 0c             	sub    $0xc,%esp
40031c6b:	83 c6 4c             	add    $0x4c,%esi
40031c6e:	89 e7                	mov    %esp,%edi
40031c70:	b9 03 00 00 00       	mov    $0x3,%ecx
40031c75:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031c78:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40031c7a:	e8 ac fc ff ff       	call   4003192b <mraa_setup_mux_mapped>
40031c7f:	83 c4 0c             	add    $0xc,%esp
40031c82:	89 c1                	mov    %eax,%ecx
40031c84:	8b 55 f0             	mov    -0x10(%ebp),%edx
            return NULL;
40031c87:	31 c0                	xor    %eax,%eax
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40031c89:	85 c9                	test   %ecx,%ecx
40031c8b:	74 c6                	je     40031c53 <mraa_gpio_init+0x70>
}
40031c8d:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031c90:	5b                   	pop    %ebx
40031c91:	5e                   	pop    %esi
40031c92:	5f                   	pop    %edi
40031c93:	5d                   	pop    %ebp
40031c94:	c3                   	ret    

40031c95 <mraa_gpio_dir>:

mraa_result_t
mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
{
40031c95:	55                   	push   %ebp
    int flags = 0;
    uint32_t value = 0;
    switch (dir) {
40031c96:	83 fa 01             	cmp    $0x1,%edx
{
40031c99:	89 e5                	mov    %esp,%ebp
40031c9b:	57                   	push   %edi
40031c9c:	56                   	push   %esi
40031c9d:	53                   	push   %ebx
    switch (dir) {
40031c9e:	74 0e                	je     40031cae <mraa_gpio_dir+0x19>
40031ca0:	72 19                	jb     40031cbb <mraa_gpio_dir+0x26>
40031ca2:	83 fa 02             	cmp    $0x2,%edx
40031ca5:	74 0d                	je     40031cb4 <mraa_gpio_dir+0x1f>
40031ca7:	83 fa 03             	cmp    $0x3,%edx
40031caa:	75 52                	jne    40031cfe <mraa_gpio_dir+0x69>
40031cac:	eb 0d                	jmp    40031cbb <mraa_gpio_dir+0x26>
    uint32_t value = 0;
40031cae:	31 ff                	xor    %edi,%edi
        case MRAA_GPIO_OUT:
            flags = GPIO_DIR_OUT;
            break;
        case MRAA_GPIO_IN:
            flags = GPIO_DIR_IN;
40031cb0:	31 c9                	xor    %ecx,%ecx
40031cb2:	eb 0e                	jmp    40031cc2 <mraa_gpio_dir+0x2d>
            break;
        case MRAA_GPIO_OUT_HIGH:
            flags = GPIO_DIR_OUT;
            value = 1;
40031cb4:	bf 01 00 00 00       	mov    $0x1,%edi
40031cb9:	eb 02                	jmp    40031cbd <mraa_gpio_dir+0x28>
    uint32_t value = 0;
40031cbb:	31 ff                	xor    %edi,%edi
            flags = GPIO_DIR_OUT;
40031cbd:	b9 01 00 00 00       	mov    $0x1,%ecx
40031cc2:	89 d3                	mov    %edx,%ebx
40031cc4:	89 c6                	mov    %eax,%esi
            value = 0;
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }
    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
40031cc6:	0f b6 50 01          	movzbl 0x1(%eax),%edx
40031cca:	8b 40 04             	mov    0x4(%eax),%eax
40031ccd:	e8 7e fe ff ff       	call   40031b50 <gpio_pin_configure>
40031cd2:	85 c0                	test   %eax,%eax
40031cd4:	74 07                	je     40031cdd <mraa_gpio_dir+0x48>
        return MRAA_ERROR_UNSPECIFIED;
40031cd6:	b8 63 00 00 00       	mov    $0x63,%eax
40031cdb:	eb 26                	jmp    40031d03 <mraa_gpio_dir+0x6e>
    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
40031cdd:	83 eb 02             	sub    $0x2,%ebx
40031ce0:	83 fb 01             	cmp    $0x1,%ebx
40031ce3:	77 15                	ja     40031cfa <mraa_gpio_dir+0x65>
        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
40031ce5:	8b 46 04             	mov    0x4(%esi),%eax
	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40031ce8:	31 d2                	xor    %edx,%edx
40031cea:	0f be 4e 01          	movsbl 0x1(%esi),%ecx
40031cee:	8b 58 04             	mov    0x4(%eax),%ebx
40031cf1:	57                   	push   %edi
40031cf2:	ff 53 04             	call   *0x4(%ebx)
40031cf5:	5a                   	pop    %edx
40031cf6:	85 c0                	test   %eax,%eax
40031cf8:	75 dc                	jne    40031cd6 <mraa_gpio_dir+0x41>
            return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
40031cfa:	31 c0                	xor    %eax,%eax
40031cfc:	eb 05                	jmp    40031d03 <mraa_gpio_dir+0x6e>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
40031cfe:	b8 01 00 00 00       	mov    $0x1,%eax
}
40031d03:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031d06:	5b                   	pop    %ebx
40031d07:	5e                   	pop    %esi
40031d08:	5f                   	pop    %edi
40031d09:	5d                   	pop    %ebp
40031d0a:	c3                   	ret    

40031d0b <mraa_gpio_write>:
        return (int) value;
}

mraa_result_t
mraa_gpio_write(mraa_gpio_context dev, int value)
{
40031d0b:	55                   	push   %ebp
40031d0c:	89 e5                	mov    %esp,%ebp
40031d0e:	56                   	push   %esi
40031d0f:	53                   	push   %ebx
    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
40031d10:	8b 58 04             	mov    0x4(%eax),%ebx
40031d13:	0f be 48 01          	movsbl 0x1(%eax),%ecx
40031d17:	8b 73 04             	mov    0x4(%ebx),%esi
40031d1a:	89 d8                	mov    %ebx,%eax
40031d1c:	52                   	push   %edx
40031d1d:	31 d2                	xor    %edx,%edx
40031d1f:	ff 56 04             	call   *0x4(%esi)
40031d22:	5a                   	pop    %edx
        return MRAA_ERROR_UNSPECIFIED;
    return MRAA_SUCCESS;
40031d23:	83 f8 01             	cmp    $0x1,%eax
40031d26:	19 c0                	sbb    %eax,%eax
}
40031d28:	8d 65 f8             	lea    -0x8(%ebp),%esp
    return MRAA_SUCCESS;
40031d2b:	f7 d0                	not    %eax
}
40031d2d:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40031d2e:	83 e0 63             	and    $0x63,%eax
}
40031d31:	5e                   	pop    %esi
40031d32:	5d                   	pop    %ebp
40031d33:	c3                   	ret    

40031d34 <mraa_gpio_owner>:
}


mraa_result_t
mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
{
40031d34:	55                   	push   %ebp
    if (dev == NULL) {
40031d35:	85 c0                	test   %eax,%eax
{
40031d37:	89 e5                	mov    %esp,%ebp
    if (dev == NULL) {
40031d39:	74 07                	je     40031d42 <mraa_gpio_owner+0xe>
        return MRAA_ERROR_INVALID_RESOURCE;
    }
    dev->owner = own;
40031d3b:	88 50 14             	mov    %dl,0x14(%eax)
    return MRAA_SUCCESS;
40031d3e:	31 c0                	xor    %eax,%eax
40031d40:	eb 05                	jmp    40031d47 <mraa_gpio_owner+0x13>
        return MRAA_ERROR_INVALID_RESOURCE;
40031d42:	b8 07 00 00 00       	mov    $0x7,%eax
}
40031d47:	5d                   	pop    %ebp
40031d48:	c3                   	ret    

40031d49 <mraa_gpio_mode>:

mraa_result_t
mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
{
40031d49:	55                   	push   %ebp
    return MRAA_SUCCESS;
}
40031d4a:	31 c0                	xor    %eax,%eax
{
40031d4c:	89 e5                	mov    %esp,%ebp
}
40031d4e:	5d                   	pop    %ebp
40031d4f:	c3                   	ret    

40031d50 <mraa_gpio_close>:
    return dev->pin;
}

mraa_result_t
mraa_gpio_close(mraa_gpio_context dev)
{
40031d50:	55                   	push   %ebp
40031d51:	89 e5                	mov    %esp,%ebp
    free(dev);
40031d53:	e8 c6 23 00 00       	call   4003411e <free>

    return MRAA_SUCCESS;
}
40031d58:	31 c0                	xor    %eax,%eax
40031d5a:	5d                   	pop    %ebp
40031d5b:	c3                   	ret    

40031d5c <spi_configure>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
40031d5c:	55                   	push   %ebp
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
40031d5d:	8b 48 04             	mov    0x4(%eax),%ecx
{
40031d60:	89 e5                	mov    %esp,%ebp
}
40031d62:	5d                   	pop    %ebp
	return api->configure(dev, config);
40031d63:	8b 09                	mov    (%ecx),%ecx
40031d65:	ff e1                	jmp    *%ecx

40031d67 <spi_transceive>:
 * @retval Negative errno code if failure.
 */
static inline int spi_transceive(struct device *dev,
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
40031d67:	55                   	push   %ebp
40031d68:	89 e5                	mov    %esp,%ebp
40031d6a:	53                   	push   %ebx
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
40031d6b:	8b 58 04             	mov    0x4(%eax),%ebx
40031d6e:	ff 75 0c             	pushl  0xc(%ebp)
40031d71:	ff 75 08             	pushl  0x8(%ebp)
40031d74:	ff 53 08             	call   *0x8(%ebx)
40031d77:	5a                   	pop    %edx
40031d78:	59                   	pop    %ecx
}
40031d79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031d7c:	c9                   	leave  
40031d7d:	c3                   	ret    

40031d7e <mraa_spi_init>:

typedef struct spi_config* spi_config_ptr;

mraa_spi_context
mraa_spi_init(int bus)
{
40031d7e:	55                   	push   %ebp
40031d7f:	89 e5                	mov    %esp,%ebp
40031d81:	56                   	push   %esi
40031d82:	89 c6                	mov    %eax,%esi
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40031d84:	b8 10 00 00 00       	mov    $0x10,%eax
{
40031d89:	53                   	push   %ebx
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40031d8a:	e8 7f 23 00 00       	call   4003410e <malloc>
40031d8f:	89 c3                	mov    %eax,%ebx
    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);

    dev->pinmux_dev = pinmux_dev;
#endif

    dev->busnum = bus;
40031d91:	89 f0                	mov    %esi,%eax
40031d93:	88 03                	mov    %al,(%ebx)
    dev->zdev = device_get_binding(SPI_DRV_NAME);
40031d95:	b8 eb 55 03 40       	mov    $0x400355eb,%eax
40031d9a:	e8 6b 18 00 00       	call   4003360a <device_get_binding>
40031d9f:	89 43 08             	mov    %eax,0x8(%ebx)
    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
40031da2:	b8 08 00 00 00       	mov    $0x8,%eax
40031da7:	e8 62 23 00 00       	call   4003410e <malloc>
40031dac:	89 c6                	mov    %eax,%esi
    // only default settings, can be changed by using the other functions provided
    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
40031dae:	c7 00 83 00 00 00    	movl   $0x83,(%eax)
    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
40031db4:	c7 40 04 80 00 00 00 	movl   $0x80,0x4(%eax)
    dev->config = conf;

    if (spi_configure(dev->zdev, dev->config) != 0) {
40031dbb:	89 f2                	mov    %esi,%edx
    dev->config = conf;
40031dbd:	89 43 04             	mov    %eax,0x4(%ebx)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40031dc0:	8b 43 08             	mov    0x8(%ebx),%eax
40031dc3:	e8 94 ff ff ff       	call   40031d5c <spi_configure>
40031dc8:	85 c0                	test   %eax,%eax
40031dca:	74 1d                	je     40031de9 <mraa_spi_init+0x6b>
        printf("Unable to configure the SPI Driver\n");
40031dcc:	68 83 57 03 40       	push   $0x40035783
40031dd1:	e8 e4 24 00 00       	call   400342ba <iprintf>
40031dd6:	58                   	pop    %eax
        free(conf);
40031dd7:	89 f0                	mov    %esi,%eax
40031dd9:	e8 40 23 00 00       	call   4003411e <free>
        free(dev);
40031dde:	89 d8                	mov    %ebx,%eax
40031de0:	e8 39 23 00 00       	call   4003411e <free>
        return NULL;
40031de5:	31 db                	xor    %ebx,%ebx
40031de7:	eb 14                	jmp    40031dfd <mraa_spi_init+0x7f>
    }

    spi_slave_select(dev->zdev, SPI_SLAVE);
40031de9:	8b 43 08             	mov    0x8(%ebx),%eax
	if (!api->slave_select) {
40031dec:	8b 50 04             	mov    0x4(%eax),%edx
40031def:	8b 4a 04             	mov    0x4(%edx),%ecx
40031df2:	85 c9                	test   %ecx,%ecx
40031df4:	74 07                	je     40031dfd <mraa_spi_init+0x7f>
	return api->slave_select(dev, slave);
40031df6:	ba 01 00 00 00       	mov    $0x1,%edx
40031dfb:	ff d1                	call   *%ecx

    return dev;
}
40031dfd:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031e00:	89 d8                	mov    %ebx,%eax
40031e02:	5b                   	pop    %ebx
40031e03:	5e                   	pop    %esi
40031e04:	5d                   	pop    %ebp
40031e05:	c3                   	ret    

40031e06 <mraa_spi_frequency>:

mraa_result_t
mraa_spi_frequency(mraa_spi_context dev, int hz)
{
    uint32_t freq = 0;
    if (hz > 0) {
40031e06:	85 d2                	test   %edx,%edx
40031e08:	7e 2f                	jle    40031e39 <mraa_spi_frequency+0x33>
{
40031e0a:	55                   	push   %ebp
40031e0b:	89 d1                	mov    %edx,%ecx
40031e0d:	89 e5                	mov    %esp,%ebp
40031e0f:	56                   	push   %esi
40031e10:	53                   	push   %ebx
40031e11:	89 c3                	mov    %eax,%ebx
        freq = sys_clock_hw_cycles_per_sec / hz;
    } else {
        return MRAA_ERROR_INVALID_PARAMETER;
    }

    dev->config->max_sys_freq = freq;
40031e13:	8b 70 04             	mov    0x4(%eax),%esi
        freq = sys_clock_hw_cycles_per_sec / hz;
40031e16:	b8 00 48 e8 01       	mov    $0x1e84800,%eax
40031e1b:	99                   	cltd   
40031e1c:	f7 f9                	idiv   %ecx
    dev->config->max_sys_freq = freq;
40031e1e:	89 46 04             	mov    %eax,0x4(%esi)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40031e21:	89 f2                	mov    %esi,%edx
40031e23:	8b 43 08             	mov    0x8(%ebx),%eax
40031e26:	e8 31 ff ff ff       	call   40031d5c <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
40031e2b:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40031e2c:	83 f8 01             	cmp    $0x1,%eax
}
40031e2f:	5e                   	pop    %esi
    return MRAA_SUCCESS;
40031e30:	19 c0                	sbb    %eax,%eax
}
40031e32:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
40031e33:	f7 d0                	not    %eax
40031e35:	83 e0 63             	and    $0x63,%eax
}
40031e38:	c3                   	ret    
        return MRAA_ERROR_INVALID_PARAMETER;
40031e39:	b8 04 00 00 00       	mov    $0x4,%eax
40031e3e:	c3                   	ret    

40031e3f <mraa_spi_transfer_buf>:
    return MRAA_SUCCESS;
}

mraa_result_t
mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
{
40031e3f:	55                   	push   %ebp
40031e40:	89 e5                	mov    %esp,%ebp
40031e42:	53                   	push   %ebx
    mraa_result_t ret;
//printf("data %x %x\n", data[0], data[1]);
//k_busy_wait(1000);
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40031e43:	8b 40 08             	mov    0x8(%eax),%eax
{
40031e46:	8b 5d 08             	mov    0x8(%ebp),%ebx
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40031e49:	53                   	push   %ebx
40031e4a:	51                   	push   %ecx
40031e4b:	89 d9                	mov    %ebx,%ecx
40031e4d:	e8 15 ff ff ff       	call   40031d67 <spi_transceive>
40031e52:	5a                   	pop    %edx
40031e53:	59                   	pop    %ecx

    return ret;
}
40031e54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031e57:	c9                   	leave  
40031e58:	c3                   	ret    

40031e59 <mraa_intel_quark_se_devboard>:
#include "mraa/gpio.h"

static mraa_board_t _board;

mraa_board_t* mraa_intel_quark_se_devboard()
{
40031e59:	55                   	push   %ebp
    mraa_board_t* b = &_board;
    mraa_set_board_config(b);
40031e5a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
{
40031e5f:	89 e5                	mov    %esp,%ebp
40031e61:	57                   	push   %edi
40031e62:	56                   	push   %esi
40031e63:	53                   	push   %ebx
40031e64:	83 ec 10             	sub    $0x10,%esp
    mraa_set_board_config(b);
40031e67:	e8 b8 fc ff ff       	call   40031b24 <mraa_set_board_config>
b->phy_pin_count = 94;
    //b->platform_type = MRAA_INTEL_QUARK_SE_DEVBOARD;

// header - J14
#if 1
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031e6c:	b9 01 00 00 00       	mov    $0x1,%ecx
40031e71:	ba 01 00 00 00       	mov    $0x1,%edx
40031e76:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031e7b:	6a 00                	push   $0x0
    b->platform_name = "Quark SE Devboard/C1000 x86";
40031e7d:	c7 05 9c 69 00 a8 a7 	movl   $0x400357a7,0xa800699c
40031e84:	57 03 40 
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031e87:	68 c3 57 03 40       	push   $0x400357c3
b->phy_pin_count = 94;
40031e8c:	c6 05 60 69 00 a8 5e 	movb   $0x5e,0xa8006960
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031e93:	e8 61 fc ff ff       	call   40031af9 <mraa_set_pininfo>
40031e98:	5a                   	pop    %edx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40031e99:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031e9e:	59                   	pop    %ecx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40031e9f:	ba 02 00 00 00       	mov    $0x2,%edx
40031ea4:	b9 02 00 00 00       	mov    $0x2,%ecx
40031ea9:	6a 00                	push   $0x0
40031eab:	68 c3 57 03 40       	push   $0x400357c3
40031eb0:	e8 44 fc ff ff       	call   40031af9 <mraa_set_pininfo>
40031eb5:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031eb6:	b9 1f 00 00 00       	mov    $0x1f,%ecx
40031ebb:	8a 1d 80 55 03 40    	mov    0x40035580,%bl
40031ec1:	ba 03 00 00 00       	mov    $0x3,%edx
40031ec6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40031ecb:	5e                   	pop    %esi
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031ecc:	53                   	push   %ebx
40031ecd:	68 cb 57 03 40       	push   $0x400357cb
40031ed2:	e8 22 fc ff ff       	call   40031af9 <mraa_set_pininfo>
40031ed7:	5f                   	pop    %edi
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031ed8:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031eda:	58                   	pop    %eax
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031edb:	ba 04 00 00 00       	mov    $0x4,%edx
40031ee0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031ee5:	53                   	push   %ebx
40031ee6:	68 df 57 03 40       	push   $0x400357df
40031eeb:	e8 09 fc ff ff       	call   40031af9 <mraa_set_pininfo>
40031ef0:	58                   	pop    %eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031ef1:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031ef6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031ef7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031efc:	ba 05 00 00 00       	mov    $0x5,%edx
40031f01:	53                   	push   %ebx
40031f02:	68 f5 57 03 40       	push   $0x400357f5
40031f07:	e8 ed fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f0c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f0d:	ba 06 00 00 00       	mov    $0x6,%edx
40031f12:	b9 12 00 00 00       	mov    $0x12,%ecx
40031f17:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f1c:	5e                   	pop    %esi
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f1d:	53                   	push   %ebx
40031f1e:	68 08 58 03 40       	push   $0x40035808
40031f23:	e8 d1 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f28:	5f                   	pop    %edi
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f29:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f2e:	58                   	pop    %eax
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f2f:	ba 07 00 00 00       	mov    $0x7,%edx
40031f34:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031f39:	53                   	push   %ebx
40031f3a:	68 1e 58 03 40       	push   $0x4003581e
40031f3f:	e8 b5 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f44:	58                   	pop    %eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f45:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f4a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f4b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031f50:	ba 08 00 00 00       	mov    $0x8,%edx
40031f55:	53                   	push   %ebx
40031f56:	68 3b 58 03 40       	push   $0x4003583b
40031f5b:	e8 99 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f60:	59                   	pop    %ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f61:	ba 09 00 00 00       	mov    $0x9,%edx
40031f66:	b9 03 00 00 00       	mov    $0x3,%ecx
40031f6b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f70:	5e                   	pop    %esi
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f71:	53                   	push   %ebx
40031f72:	68 47 58 03 40       	push   $0x40035847
40031f77:	e8 7d fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f7c:	5f                   	pop    %edi
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f7d:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f82:	58                   	pop    %eax
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f83:	ba 0a 00 00 00       	mov    $0xa,%edx
40031f88:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031f8d:	53                   	push   %ebx
40031f8e:	68 64 58 03 40       	push   $0x40035864
40031f93:	e8 61 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031f98:	58                   	pop    %eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031f99:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40031f9e:	5a                   	pop    %edx
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031f9f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40031fa4:	ba 0b 00 00 00       	mov    $0xb,%edx
40031fa9:	6a 00                	push   $0x0
40031fab:	68 70 58 03 40       	push   $0x40035870
40031fb0:	e8 44 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031fb5:	59                   	pop    %ecx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fb6:	ba 0c 00 00 00       	mov    $0xc,%edx
40031fbb:	b9 0c 00 00 00       	mov    $0xc,%ecx
40031fc0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fc5:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fc6:	6a 00                	push   $0x0
40031fc8:	68 70 58 03 40       	push   $0x40035870
40031fcd:	e8 27 fb ff ff       	call   40031af9 <mraa_set_pininfo>
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40031fd2:	8a 1d 81 55 03 40    	mov    0x40035581,%bl
40031fd8:	b9 04 00 00 00       	mov    $0x4,%ecx
40031fdd:	ba 0d 00 00 00       	mov    $0xd,%edx
40031fe2:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fe7:	5e                   	pop    %esi
40031fe8:	5f                   	pop    %edi
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40031fe9:	53                   	push   %ebx
40031fea:	68 74 58 03 40       	push   $0x40035874
40031fef:	e8 05 fb ff ff       	call   40031af9 <mraa_set_pininfo>
40031ff4:	58                   	pop    %eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40031ff5:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40031ffa:	5a                   	pop    %edx
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40031ffb:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032000:	ba 0e 00 00 00       	mov    $0xe,%edx
40032005:	6a 01                	push   $0x1
40032007:	68 82 58 03 40       	push   $0x40035882
4003200c:	e8 e8 fa ff ff       	call   40031af9 <mraa_set_pininfo>
40032011:	59                   	pop    %ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032012:	ba 0f 00 00 00       	mov    $0xf,%edx
40032017:	b9 05 00 00 00       	mov    $0x5,%ecx
4003201c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032021:	5e                   	pop    %esi
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032022:	53                   	push   %ebx
40032023:	68 94 58 03 40       	push   $0x40035894
40032028:	e8 cc fa ff ff       	call   40031af9 <mraa_set_pininfo>
4003202d:	5f                   	pop    %edi
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003202e:	b9 10 00 00 00       	mov    $0x10,%ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032033:	58                   	pop    %eax
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032034:	ba 10 00 00 00       	mov    $0x10,%edx
40032039:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003203e:	6a 01                	push   $0x1
40032040:	68 a2 58 03 40       	push   $0x400358a2
40032045:	e8 af fa ff ff       	call   40031af9 <mraa_set_pininfo>
4003204a:	58                   	pop    %eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003204b:	b9 06 00 00 00       	mov    $0x6,%ecx
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032050:	5a                   	pop    %edx
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032051:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032056:	ba 11 00 00 00       	mov    $0x11,%edx
4003205b:	53                   	push   %ebx
4003205c:	68 b4 58 03 40       	push   $0x400358b4
40032061:	e8 93 fa ff ff       	call   40031af9 <mraa_set_pininfo>
40032066:	59                   	pop    %ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032067:	ba 12 00 00 00       	mov    $0x12,%edx
4003206c:	b9 12 00 00 00       	mov    $0x12,%ecx
40032071:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032076:	5e                   	pop    %esi
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032077:	6a 01                	push   $0x1
40032079:	68 c6 58 03 40       	push   $0x400358c6
4003207e:	e8 76 fa ff ff       	call   40031af9 <mraa_set_pininfo>
40032083:	5f                   	pop    %edi
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40032084:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032089:	58                   	pop    %eax
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
4003208a:	ba 13 00 00 00       	mov    $0x13,%edx
4003208f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032094:	53                   	push   %ebx
40032095:	68 d8 58 03 40       	push   $0x400358d8
4003209a:	e8 5a fa ff ff       	call   40031af9 <mraa_set_pininfo>
4003209f:	58                   	pop    %eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400320a0:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400320a5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400320a6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400320ab:	ba 14 00 00 00       	mov    $0x14,%edx
400320b0:	6a 01                	push   $0x1
400320b2:	68 ef 58 03 40       	push   $0x400358ef
400320b7:	e8 3d fa ff ff       	call   40031af9 <mraa_set_pininfo>
400320bc:	59                   	pop    %ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400320bd:	ba 15 00 00 00       	mov    $0x15,%edx
400320c2:	b9 0f 00 00 00       	mov    $0xf,%ecx
400320c7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400320cc:	5e                   	pop    %esi
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400320cd:	53                   	push   %ebx
400320ce:	68 01 59 03 40       	push   $0x40035901
400320d3:	e8 21 fa ff ff       	call   40031af9 <mraa_set_pininfo>
400320d8:	5f                   	pop    %edi
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400320d9:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400320de:	58                   	pop    %eax
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400320df:	ba 16 00 00 00       	mov    $0x16,%edx
400320e4:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400320e9:	6a 01                	push   $0x1
400320eb:	68 18 59 03 40       	push   $0x40035918
400320f0:	e8 04 fa ff ff       	call   40031af9 <mraa_set_pininfo>
400320f5:	58                   	pop    %eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400320f6:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400320fb:	5a                   	pop    %edx
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400320fc:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032101:	ba 17 00 00 00       	mov    $0x17,%edx
40032106:	6a 00                	push   $0x0
40032108:	68 c3 57 03 40       	push   $0x400357c3
4003210d:	e8 e7 f9 ff ff       	call   40031af9 <mraa_set_pininfo>
40032112:	59                   	pop    %ecx
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032113:	ba 18 00 00 00       	mov    $0x18,%edx
40032118:	b9 14 00 00 00       	mov    $0x14,%ecx
4003211d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032122:	5e                   	pop    %esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032123:	6a 01                	push   $0x1
40032125:	68 2a 59 03 40       	push   $0x4003592a
4003212a:	e8 ca f9 ff ff       	call   40031af9 <mraa_set_pininfo>
4003212f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032130:	0f b6 35 82 55 03 40 	movzbl 0x40035582,%esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032137:	58                   	pop    %eax
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032138:	31 c9                	xor    %ecx,%ecx
4003213a:	ba 19 00 00 00       	mov    $0x19,%edx
4003213f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032144:	56                   	push   %esi
40032145:	68 3c 59 03 40       	push   $0x4003593c
4003214a:	e8 aa f9 ff ff       	call   40031af9 <mraa_set_pininfo>
4003214f:	58                   	pop    %eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032150:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032155:	5a                   	pop    %edx
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032156:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003215b:	ba 1a 00 00 00       	mov    $0x1a,%edx
40032160:	6a 00                	push   $0x0
40032162:	68 c3 57 03 40       	push   $0x400357c3
40032167:	e8 8d f9 ff ff       	call   40031af9 <mraa_set_pininfo>
4003216c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003216d:	ba 1b 00 00 00       	mov    $0x1b,%edx
40032172:	b9 01 00 00 00       	mov    $0x1,%ecx
40032177:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003217c:	5f                   	pop    %edi
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003217d:	56                   	push   %esi
4003217e:	68 4e 59 03 40       	push   $0x4003594e
40032183:	e8 71 f9 ff ff       	call   40031af9 <mraa_set_pininfo>
40032188:	58                   	pop    %eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032189:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003218e:	5a                   	pop    %edx
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003218f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032194:	ba 1c 00 00 00       	mov    $0x1c,%edx
40032199:	53                   	push   %ebx
4003219a:	68 60 59 03 40       	push   $0x40035960
4003219f:	e8 55 f9 ff ff       	call   40031af9 <mraa_set_pininfo>
400321a4:	59                   	pop    %ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321a5:	ba 1d 00 00 00       	mov    $0x1d,%edx
400321aa:	b9 02 00 00 00       	mov    $0x2,%ecx
400321af:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321b4:	5f                   	pop    %edi
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321b5:	56                   	push   %esi
400321b6:	68 72 59 03 40       	push   $0x40035972
400321bb:	e8 39 f9 ff ff       	call   40031af9 <mraa_set_pininfo>
400321c0:	58                   	pop    %eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321c1:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321c6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321c7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400321cc:	ba 1e 00 00 00       	mov    $0x1e,%edx
400321d1:	53                   	push   %ebx
400321d2:	68 84 59 03 40       	push   $0x40035984
400321d7:	e8 1d f9 ff ff       	call   40031af9 <mraa_set_pininfo>
400321dc:	59                   	pop    %ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321dd:	ba 1f 00 00 00       	mov    $0x1f,%edx
400321e2:	b9 03 00 00 00       	mov    $0x3,%ecx
400321e7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321ec:	5f                   	pop    %edi
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321ed:	56                   	push   %esi
400321ee:	68 97 59 03 40       	push   $0x40035997
400321f3:	e8 01 f9 ff ff       	call   40031af9 <mraa_set_pininfo>
400321f8:	58                   	pop    %eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321f9:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400321fe:	5a                   	pop    %edx
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400321ff:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032204:	ba 20 00 00 00       	mov    $0x20,%edx
40032209:	53                   	push   %ebx
4003220a:	68 a9 59 03 40       	push   $0x400359a9
4003220f:	e8 e5 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
40032214:	59                   	pop    %ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032215:	ba 21 00 00 00       	mov    $0x21,%edx
4003221a:	b9 21 00 00 00       	mov    $0x21,%ecx
4003221f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032224:	5e                   	pop    %esi
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032225:	6a 00                	push   $0x0
40032227:	68 70 58 03 40       	push   $0x40035870
4003222c:	e8 c8 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
40032231:	5f                   	pop    %edi
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032232:	b9 12 00 00 00       	mov    $0x12,%ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032237:	58                   	pop    %eax
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032238:	ba 22 00 00 00       	mov    $0x22,%edx
4003223d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032242:	53                   	push   %ebx
40032243:	68 bb 59 03 40       	push   $0x400359bb
40032248:	e8 ac f8 ff ff       	call   40031af9 <mraa_set_pininfo>
4003224d:	58                   	pop    %eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003224e:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032250:	5a                   	pop    %edx
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032251:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032256:	ba 23 00 00 00       	mov    $0x23,%edx
4003225b:	53                   	push   %ebx
4003225c:	68 ce 59 03 40       	push   $0x400359ce
40032261:	e8 93 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
40032266:	59                   	pop    %ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032267:	ba 24 00 00 00       	mov    $0x24,%edx
4003226c:	b9 13 00 00 00       	mov    $0x13,%ecx
40032271:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032276:	5e                   	pop    %esi
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032277:	53                   	push   %ebx
40032278:	68 db 59 03 40       	push   $0x400359db
4003227d:	e8 77 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
40032282:	5f                   	pop    %edi
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032283:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032288:	58                   	pop    %eax
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032289:	ba 25 00 00 00       	mov    $0x25,%edx
4003228e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032293:	53                   	push   %ebx
40032294:	68 ed 59 03 40       	push   $0x400359ed
40032299:	e8 5b f8 ff ff       	call   40031af9 <mraa_set_pininfo>
4003229e:	58                   	pop    %eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003229f:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322a4:	5a                   	pop    %edx
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400322a5:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400322aa:	ba 26 00 00 00       	mov    $0x26,%edx
400322af:	53                   	push   %ebx
400322b0:	68 fa 59 03 40       	push   $0x400359fa
400322b5:	e8 3f f8 ff ff       	call   40031af9 <mraa_set_pininfo>
400322ba:	59                   	pop    %ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322bb:	ba 27 00 00 00       	mov    $0x27,%edx
400322c0:	b9 02 00 00 00       	mov    $0x2,%ecx
400322c5:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400322ca:	5e                   	pop    %esi
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322cb:	53                   	push   %ebx
400322cc:	68 0c 5a 03 40       	push   $0x40035a0c
400322d1:	e8 23 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
400322d6:	5f                   	pop    %edi
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400322d7:	b9 28 00 00 00       	mov    $0x28,%ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322dc:	58                   	pop    %eax
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400322dd:	ba 28 00 00 00       	mov    $0x28,%edx
400322e2:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400322e7:	6a 00                	push   $0x0
400322e9:	68 70 58 03 40       	push   $0x40035870
400322ee:	e8 06 f8 ff ff       	call   40031af9 <mraa_set_pininfo>
400322f3:	58                   	pop    %eax
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322f4:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400322f9:	5a                   	pop    %edx
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400322fa:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400322ff:	ba 29 00 00 00       	mov    $0x29,%edx
40032304:	53                   	push   %ebx
40032305:	68 19 5a 03 40       	push   $0x40035a19
4003230a:	e8 ea f7 ff ff       	call   40031af9 <mraa_set_pininfo>
4003230f:	59                   	pop    %ecx
40032310:	5e                   	pop    %esi
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032311:	b9 01 00 00 00       	mov    $0x1,%ecx
40032316:	0f b6 35 83 55 03 40 	movzbl 0x40035583,%esi
4003231d:	ba 2a 00 00 00       	mov    $0x2a,%edx
40032322:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032327:	56                   	push   %esi
40032328:	68 26 5a 03 40       	push   $0x40035a26
4003232d:	e8 c7 f7 ff ff       	call   40031af9 <mraa_set_pininfo>
40032332:	5f                   	pop    %edi
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032333:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032338:	58                   	pop    %eax
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032339:	ba 2b 00 00 00       	mov    $0x2b,%edx
4003233e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032343:	53                   	push   %ebx
40032344:	68 35 5a 03 40       	push   $0x40035a35
40032349:	e8 ab f7 ff ff       	call   40031af9 <mraa_set_pininfo>
4003234e:	58                   	pop    %eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003234f:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032354:	5a                   	pop    %edx
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032355:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003235a:	ba 2c 00 00 00       	mov    $0x2c,%edx
4003235f:	56                   	push   %esi
40032360:	68 42 5a 03 40       	push   $0x40035a42
40032365:	e8 8f f7 ff ff       	call   40031af9 <mraa_set_pininfo>
4003236a:	59                   	pop    %ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003236b:	ba 2d 00 00 00       	mov    $0x2d,%edx
40032370:	b9 05 00 00 00       	mov    $0x5,%ecx
40032375:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003237a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003237b:	53                   	push   %ebx
4003237c:	68 51 5a 03 40       	push   $0x40035a51
40032381:	e8 73 f7 ff ff       	call   40031af9 <mraa_set_pininfo>
40032386:	58                   	pop    %eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032387:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032389:	5a                   	pop    %edx
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003238a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003238f:	ba 2e 00 00 00       	mov    $0x2e,%edx
40032394:	6a 00                	push   $0x0
40032396:	68 5e 5a 03 40       	push   $0x40035a5e
4003239b:	e8 59 f7 ff ff       	call   40031af9 <mraa_set_pininfo>
400323a0:	59                   	pop    %ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323a1:	ba 2f 00 00 00       	mov    $0x2f,%edx
400323a6:	b9 07 00 00 00       	mov    $0x7,%ecx
400323ab:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323b0:	5f                   	pop    %edi
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323b1:	53                   	push   %ebx
400323b2:	68 64 5a 03 40       	push   $0x40035a64
400323b7:	e8 3d f7 ff ff       	call   40031af9 <mraa_set_pininfo>
400323bc:	58                   	pop    %eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323bd:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323bf:	5a                   	pop    %edx
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323c0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400323c5:	ba 30 00 00 00       	mov    $0x30,%edx
400323ca:	6a 00                	push   $0x0
400323cc:	68 72 5a 03 40       	push   $0x40035a72
400323d1:	e8 23 f7 ff ff       	call   40031af9 <mraa_set_pininfo>
400323d6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323d7:	ba 31 00 00 00       	mov    $0x31,%edx
400323dc:	b9 31 00 00 00       	mov    $0x31,%ecx
400323e1:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323e6:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323e7:	6a 00                	push   $0x0
400323e9:	68 c3 57 03 40       	push   $0x400357c3
400323ee:	e8 06 f7 ff ff       	call   40031af9 <mraa_set_pininfo>
400323f3:	5f                   	pop    %edi
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323f4:	b9 32 00 00 00       	mov    $0x32,%ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323f9:	58                   	pop    %eax
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400323fa:	ba 32 00 00 00       	mov    $0x32,%edx
400323ff:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032404:	6a 00                	push   $0x0
40032406:	68 c3 57 03 40       	push   $0x400357c3
4003240b:	e8 e9 f6 ff ff       	call   40031af9 <mraa_set_pininfo>
40032410:	58                   	pop    %eax
#endif
// the other big header - J15
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032411:	b9 33 00 00 00       	mov    $0x33,%ecx
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032416:	5a                   	pop    %edx
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032417:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003241c:	ba 33 00 00 00       	mov    $0x33,%edx
40032421:	6a 00                	push   $0x0
40032423:	68 c3 57 03 40       	push   $0x400357c3
40032428:	e8 cc f6 ff ff       	call   40031af9 <mraa_set_pininfo>
4003242d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003242e:	ba 34 00 00 00       	mov    $0x34,%edx
40032433:	b9 34 00 00 00       	mov    $0x34,%ecx
40032438:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003243d:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003243e:	6a 00                	push   $0x0
40032440:	68 c3 57 03 40       	push   $0x400357c3
40032445:	e8 af f6 ff ff       	call   40031af9 <mraa_set_pininfo>
4003244a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003244b:	0f b6 3d 84 55 03 40 	movzbl 0x40035584,%edi
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032452:	58                   	pop    %eax
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032453:	31 c9                	xor    %ecx,%ecx
40032455:	ba 35 00 00 00       	mov    $0x35,%edx
4003245a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003245f:	57                   	push   %edi
40032460:	68 80 5a 03 40       	push   $0x40035a80
40032465:	e8 8f f6 ff ff       	call   40031af9 <mraa_set_pininfo>
4003246a:	58                   	pop    %eax
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003246b:	8a 1d 85 55 03 40    	mov    0x40035585,%bl
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032471:	5a                   	pop    %edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032472:	b9 15 00 00 00       	mov    $0x15,%ecx
40032477:	ba 36 00 00 00       	mov    $0x36,%edx
4003247c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032481:	53                   	push   %ebx
40032482:	68 8f 5a 03 40       	push   $0x40035a8f
40032487:	e8 6d f6 ff ff       	call   40031af9 <mraa_set_pininfo>
4003248c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003248d:	ba 37 00 00 00       	mov    $0x37,%edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032492:	58                   	pop    %eax
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032493:	31 c9                	xor    %ecx,%ecx
40032495:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003249a:	57                   	push   %edi
4003249b:	68 a4 5a 03 40       	push   $0x40035aa4
400324a0:	e8 54 f6 ff ff       	call   40031af9 <mraa_set_pininfo>
400324a5:	58                   	pop    %eax
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324a6:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324ab:	5a                   	pop    %edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324ac:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400324b1:	ba 38 00 00 00       	mov    $0x38,%edx
400324b6:	53                   	push   %ebx
400324b7:	68 b4 5a 03 40       	push   $0x40035ab4
400324bc:	e8 38 f6 ff ff       	call   40031af9 <mraa_set_pininfo>
400324c1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324c2:	ba 39 00 00 00       	mov    $0x39,%edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324c7:	58                   	pop    %eax
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324c8:	31 c9                	xor    %ecx,%ecx
400324ca:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400324cf:	57                   	push   %edi
400324d0:	68 ca 5a 03 40       	push   $0x40035aca
400324d5:	e8 1f f6 ff ff       	call   40031af9 <mraa_set_pininfo>
400324da:	58                   	pop    %eax
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324db:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324e0:	5a                   	pop    %edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324e1:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400324e6:	ba 3a 00 00 00       	mov    $0x3a,%edx
400324eb:	53                   	push   %ebx
400324ec:	68 da 5a 03 40       	push   $0x40035ada
400324f1:	e8 03 f6 ff ff       	call   40031af9 <mraa_set_pininfo>
400324f6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324f7:	ba 3b 00 00 00       	mov    $0x3b,%edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400324fc:	58                   	pop    %eax
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400324fd:	31 c9                	xor    %ecx,%ecx
400324ff:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032504:	57                   	push   %edi
40032505:	68 f0 5a 03 40       	push   $0x40035af0
4003250a:	e8 ea f5 ff ff       	call   40031af9 <mraa_set_pininfo>
4003250f:	58                   	pop    %eax
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032510:	b9 18 00 00 00       	mov    $0x18,%ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032515:	5a                   	pop    %edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032516:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003251b:	ba 3c 00 00 00       	mov    $0x3c,%edx
40032520:	53                   	push   %ebx
40032521:	68 01 5b 03 40       	push   $0x40035b01
40032526:	e8 ce f5 ff ff       	call   40031af9 <mraa_set_pininfo>
4003252b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003252c:	ba 3d 00 00 00       	mov    $0x3d,%edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032531:	58                   	pop    %eax
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032532:	31 c9                	xor    %ecx,%ecx
40032534:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032539:	57                   	push   %edi
4003253a:	68 18 5b 03 40       	push   $0x40035b18
4003253f:	e8 b5 f5 ff ff       	call   40031af9 <mraa_set_pininfo>
40032544:	58                   	pop    %eax
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032545:	b9 19 00 00 00       	mov    $0x19,%ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003254a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003254b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032550:	ba 3e 00 00 00       	mov    $0x3e,%edx
40032555:	53                   	push   %ebx
40032556:	68 29 5b 03 40       	push   $0x40035b29
4003255b:	e8 99 f5 ff ff       	call   40031af9 <mraa_set_pininfo>
40032560:	59                   	pop    %ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032561:	ba 3f 00 00 00       	mov    $0x3f,%edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032566:	58                   	pop    %eax
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032567:	b9 1d 00 00 00       	mov    $0x1d,%ecx
4003256c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032571:	53                   	push   %ebx
40032572:	68 40 5b 03 40       	push   $0x40035b40
40032577:	e8 7d f5 ff ff       	call   40031af9 <mraa_set_pininfo>
4003257c:	58                   	pop    %eax
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003257d:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032582:	5a                   	pop    %edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032583:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032588:	ba 40 00 00 00       	mov    $0x40,%edx
4003258d:	53                   	push   %ebx
4003258e:	68 58 5b 03 40       	push   $0x40035b58
40032593:	e8 61 f5 ff ff       	call   40031af9 <mraa_set_pininfo>
40032598:	59                   	pop    %ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032599:	ba 41 00 00 00       	mov    $0x41,%edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003259e:	58                   	pop    %eax
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003259f:	b9 1e 00 00 00       	mov    $0x1e,%ecx
400325a4:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325a9:	53                   	push   %ebx
400325aa:	68 6f 5b 03 40       	push   $0x40035b6f
400325af:	e8 45 f5 ff ff       	call   40031af9 <mraa_set_pininfo>
400325b4:	58                   	pop    %eax
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325b5:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325ba:	5a                   	pop    %edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325bb:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325c0:	ba 42 00 00 00       	mov    $0x42,%edx
400325c5:	53                   	push   %ebx
400325c6:	68 87 5b 03 40       	push   $0x40035b87
400325cb:	e8 29 f5 ff ff       	call   40031af9 <mraa_set_pininfo>
400325d0:	59                   	pop    %ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325d1:	ba 43 00 00 00       	mov    $0x43,%edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325d6:	58                   	pop    %eax
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325d7:	b9 43 00 00 00       	mov    $0x43,%ecx
400325dc:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325e1:	6a 00                	push   $0x0
400325e3:	68 70 58 03 40       	push   $0x40035870
400325e8:	e8 0c f5 ff ff       	call   40031af9 <mraa_set_pininfo>
400325ed:	58                   	pop    %eax
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325ee:	b9 44 00 00 00       	mov    $0x44,%ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325f3:	5a                   	pop    %edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325f4:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325f9:	ba 44 00 00 00       	mov    $0x44,%edx
400325fe:	6a 00                	push   $0x0
40032600:	68 70 58 03 40       	push   $0x40035870
40032605:	e8 ef f4 ff ff       	call   40031af9 <mraa_set_pininfo>
4003260a:	59                   	pop    %ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003260b:	ba 45 00 00 00       	mov    $0x45,%edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032610:	58                   	pop    %eax
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032611:	31 c9                	xor    %ecx,%ecx
40032613:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032618:	57                   	push   %edi
40032619:	68 a2 5b 03 40       	push   $0x40035ba2
4003261e:	e8 d6 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
40032623:	58                   	pop    %eax
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032624:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032629:	5a                   	pop    %edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003262a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003262f:	ba 46 00 00 00       	mov    $0x46,%edx
40032634:	53                   	push   %ebx
40032635:	68 b1 5b 03 40       	push   $0x40035bb1
4003263a:	e8 ba f4 ff ff       	call   40031af9 <mraa_set_pininfo>
4003263f:	59                   	pop    %ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032640:	ba 47 00 00 00       	mov    $0x47,%edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032645:	58                   	pop    %eax
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032646:	31 c9                	xor    %ecx,%ecx
40032648:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003264d:	57                   	push   %edi
4003264e:	68 c5 5b 03 40       	push   $0x40035bc5
40032653:	e8 a1 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
40032658:	58                   	pop    %eax
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032659:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003265e:	5a                   	pop    %edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003265f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032664:	ba 48 00 00 00       	mov    $0x48,%edx
40032669:	53                   	push   %ebx
4003266a:	68 d5 5b 03 40       	push   $0x40035bd5
4003266f:	e8 85 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
40032674:	59                   	pop    %ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032675:	ba 49 00 00 00       	mov    $0x49,%edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003267a:	58                   	pop    %eax
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003267b:	31 c9                	xor    %ecx,%ecx
4003267d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032682:	57                   	push   %edi
40032683:	68 ea 5b 03 40       	push   $0x40035bea
40032688:	e8 6c f4 ff ff       	call   40031af9 <mraa_set_pininfo>
4003268d:	58                   	pop    %eax
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003268e:	b9 0a 00 00 00       	mov    $0xa,%ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032693:	5a                   	pop    %edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032694:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032699:	ba 4a 00 00 00       	mov    $0x4a,%edx
4003269e:	53                   	push   %ebx
4003269f:	68 fa 5b 03 40       	push   $0x40035bfa
400326a4:	e8 50 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
400326a9:	59                   	pop    %ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326aa:	ba 4b 00 00 00       	mov    $0x4b,%edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326af:	58                   	pop    %eax
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326b0:	31 c9                	xor    %ecx,%ecx
400326b2:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400326b7:	57                   	push   %edi
400326b8:	68 10 5c 03 40       	push   $0x40035c10
400326bd:	e8 37 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
400326c2:	58                   	pop    %eax
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326c3:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326c8:	5a                   	pop    %edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326c9:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400326ce:	ba 4c 00 00 00       	mov    $0x4c,%edx
400326d3:	53                   	push   %ebx
400326d4:	68 21 5c 03 40       	push   $0x40035c21
400326d9:	e8 1b f4 ff ff       	call   40031af9 <mraa_set_pininfo>
400326de:	59                   	pop    %ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326df:	ba 4d 00 00 00       	mov    $0x4d,%edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326e4:	58                   	pop    %eax
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326e5:	31 c9                	xor    %ecx,%ecx
400326e7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400326ec:	57                   	push   %edi
400326ed:	68 38 5c 03 40       	push   $0x40035c38
400326f2:	e8 02 f4 ff ff       	call   40031af9 <mraa_set_pininfo>
400326f7:	58                   	pop    %eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326f8:	b9 0c 00 00 00       	mov    $0xc,%ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400326fd:	5a                   	pop    %edx
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326fe:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032703:	ba 4e 00 00 00       	mov    $0x4e,%edx
40032708:	53                   	push   %ebx
40032709:	68 49 5c 03 40       	push   $0x40035c49
4003270e:	e8 e6 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
40032713:	59                   	pop    %ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032714:	ba 4f 00 00 00       	mov    $0x4f,%edx
40032719:	b9 4f 00 00 00       	mov    $0x4f,%ecx
4003271e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032723:	5f                   	pop    %edi
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032724:	6a 00                	push   $0x0
40032726:	68 c3 57 03 40       	push   $0x400357c3
4003272b:	e8 c9 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
40032730:	58                   	pop    %eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032731:	b9 0d 00 00 00       	mov    $0xd,%ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032736:	5a                   	pop    %edx
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032737:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003273c:	ba 50 00 00 00       	mov    $0x50,%edx
40032741:	53                   	push   %ebx
40032742:	68 60 5c 03 40       	push   $0x40035c60
40032747:	e8 ad f3 ff ff       	call   40031af9 <mraa_set_pininfo>
4003274c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003274d:	ba 51 00 00 00       	mov    $0x51,%edx
40032752:	31 c9                	xor    %ecx,%ecx
40032754:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032759:	5f                   	pop    %edi
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003275a:	56                   	push   %esi
4003275b:	68 77 5c 03 40       	push   $0x40035c77
40032760:	e8 94 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
40032765:	58                   	pop    %eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032766:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003276b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003276c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032771:	ba 52 00 00 00       	mov    $0x52,%edx
40032776:	53                   	push   %ebx
40032777:	68 83 5c 03 40       	push   $0x40035c83
4003277c:	e8 78 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
40032781:	59                   	pop    %ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032782:	ba 53 00 00 00       	mov    $0x53,%edx
40032787:	31 c9                	xor    %ecx,%ecx
40032789:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003278e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003278f:	56                   	push   %esi
40032790:	68 9a 5c 03 40       	push   $0x40035c9a
40032795:	e8 5f f3 ff ff       	call   40031af9 <mraa_set_pininfo>
4003279a:	58                   	pop    %eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003279b:	b9 54 00 00 00       	mov    $0x54,%ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327a0:	5a                   	pop    %edx
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400327a1:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400327a6:	ba 54 00 00 00       	mov    $0x54,%edx
400327ab:	6a 00                	push   $0x0
400327ad:	68 c3 57 03 40       	push   $0x400357c3
400327b2:	e8 42 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
400327b7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327b8:	ba 55 00 00 00       	mov    $0x55,%edx
400327bd:	31 c9                	xor    %ecx,%ecx
400327bf:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400327c4:	5f                   	pop    %edi
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327c5:	56                   	push   %esi
400327c6:	68 a6 5c 03 40       	push   $0x40035ca6
400327cb:	e8 29 f3 ff ff       	call   40031af9 <mraa_set_pininfo>
400327d0:	58                   	pop    %eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327d1:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327d6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327d7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400327dc:	ba 56 00 00 00       	mov    $0x56,%edx
400327e1:	53                   	push   %ebx
400327e2:	68 b5 5c 03 40       	push   $0x40035cb5
400327e7:	e8 0d f3 ff ff       	call   40031af9 <mraa_set_pininfo>
400327ec:	59                   	pop    %ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327ed:	ba 57 00 00 00       	mov    $0x57,%edx
400327f2:	31 c9                	xor    %ecx,%ecx
400327f4:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327f9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400327fa:	56                   	push   %esi
400327fb:	68 cd 5c 03 40       	push   $0x40035ccd
40032800:	e8 f4 f2 ff ff       	call   40031af9 <mraa_set_pininfo>
40032805:	58                   	pop    %eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032806:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003280b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003280c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032811:	ba 58 00 00 00       	mov    $0x58,%edx
40032816:	53                   	push   %ebx
40032817:	68 dc 5c 03 40       	push   $0x40035cdc
4003281c:	e8 d8 f2 ff ff       	call   40031af9 <mraa_set_pininfo>
40032821:	59                   	pop    %ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032822:	ba 59 00 00 00       	mov    $0x59,%edx
40032827:	31 c9                	xor    %ecx,%ecx
40032829:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003282e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003282f:	56                   	push   %esi
40032830:	68 f5 5c 03 40       	push   $0x40035cf5
40032835:	e8 bf f2 ff ff       	call   40031af9 <mraa_set_pininfo>
4003283a:	58                   	pop    %eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003283b:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032840:	5a                   	pop    %edx
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032841:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032846:	ba 5a 00 00 00       	mov    $0x5a,%edx
4003284b:	53                   	push   %ebx
4003284c:	68 01 5d 03 40       	push   $0x40035d01
40032851:	e8 a3 f2 ff ff       	call   40031af9 <mraa_set_pininfo>
40032856:	59                   	pop    %ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032857:	ba 5b 00 00 00       	mov    $0x5b,%edx
4003285c:	31 c9                	xor    %ecx,%ecx
4003285e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032863:	5f                   	pop    %edi
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032864:	56                   	push   %esi
40032865:	68 1a 5d 03 40       	push   $0x40035d1a
4003286a:	e8 8a f2 ff ff       	call   40031af9 <mraa_set_pininfo>
4003286f:	58                   	pop    %eax
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032870:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032872:	5a                   	pop    %edx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032873:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032878:	ba 5c 00 00 00       	mov    $0x5c,%edx
4003287d:	53                   	push   %ebx
    b->spi_bus[0].sclk = 13;
    b->spi_bus[0].mosi = 11;
    b->spi_bus[0].miso = 12;
    b->spi_bus[0].cs = 10;

    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
4003287e:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032881:	68 26 5d 03 40       	push   $0x40035d26
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032886:	be 88 55 03 40       	mov    $0x40035588,%esi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003288b:	e8 69 f2 ff ff       	call   40031af9 <mraa_set_pininfo>
40032890:	59                   	pop    %ecx
    struct device* zdev = device_get_binding("GPIO_0");
40032891:	b8 f8 55 03 40       	mov    $0x400355f8,%eax
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032896:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003289b:	5b                   	pop    %ebx
    b->def_i2c_bus = 0;
4003289c:	c6 05 6a 69 00 a8 00 	movb   $0x0,0xa800696a
    b->i2c_bus[0].bus_id = 0;
400328a3:	c6 05 64 69 00 a8 00 	movb   $0x0,0xa8006964
    b->pins[18].i2c.mux_total = 0;
400328aa:	c6 05 8e 6e 00 a8 00 	movb   $0x0,0xa8006e8e
    b->pins[19].i2c.mux_total = 0;
400328b1:	c6 05 d2 6e 00 a8 00 	movb   $0x0,0xa8006ed2
    b->i2c_bus[0].sda = 18;
400328b8:	c6 05 66 69 00 a8 12 	movb   $0x12,0xa8006966
    b->i2c_bus[0].scl = 19;
400328bf:	c6 05 65 69 00 a8 13 	movb   $0x13,0xa8006965
    b->spi_bus[0].bus_id = 0;
400328c6:	c6 05 6c 69 00 a8 00 	movb   $0x0,0xa800696c
    b->spi_bus[0].sclk = 13;
400328cd:	c6 05 6f 69 00 a8 0d 	movb   $0xd,0xa800696f
    b->spi_bus[0].mosi = 11;
400328d4:	c6 05 70 69 00 a8 0b 	movb   $0xb,0xa8006970
    b->spi_bus[0].miso = 12;
400328db:	c6 05 71 69 00 a8 0c 	movb   $0xc,0xa8006971
    b->spi_bus[0].cs = 10;
400328e2:	c6 05 72 69 00 a8 0a 	movb   $0xa,0xa8006972
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
400328e9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    struct device* zdev = device_get_binding("GPIO_0");
400328eb:	e8 1a 0d 00 00       	call   4003360a <device_get_binding>
    if (zdev != NULL) {
400328f0:	85 c0                	test   %eax,%eax
400328f2:	74 1e                	je     40032912 <mraa_intel_quark_se_devboard+0xab9>
400328f4:	89 c6                	mov    %eax,%esi
400328f6:	31 db                	xor    %ebx,%ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
400328f8:	0f b6 4c 9d e4       	movzbl -0x1c(%ebp,%ebx,4),%ecx
400328fd:	8b 7e 04             	mov    0x4(%esi),%edi
40032900:	31 d2                	xor    %edx,%edx
40032902:	89 f0                	mov    %esi,%eax
        for (int i = 0; i<4; ++i) {
40032904:	43                   	inc    %ebx
40032905:	68 00 01 00 00       	push   $0x100
4003290a:	ff 17                	call   *(%edi)
4003290c:	58                   	pop    %eax
4003290d:	83 fb 04             	cmp    $0x4,%ebx
40032910:	75 e6                	jne    400328f8 <mraa_intel_quark_se_devboard+0xa9f>
        return NULL;
    }
#endif

    return b;
}
40032912:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032915:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003291a:	5b                   	pop    %ebx
4003291b:	5e                   	pop    %esi
4003291c:	5f                   	pop    %edi
4003291d:	5d                   	pop    %ebp
4003291e:	c3                   	ret    

4003291f <upm_clock_init>:

#endif
}

void upm_clock_init(upm_clock_t *clock)
{
4003291f:	55                   	push   %ebp
40032920:	89 e5                	mov    %esp,%ebp
40032922:	53                   	push   %ebx
40032923:	89 c3                	mov    %eax,%ebx
#if defined(UPM_PLATFORM_LINUX)

    gettimeofday(clock, NULL);

#elif defined(UPM_PLATFORM_ZEPHYR)
    *clock = k_cycle_get_32();
40032925:	e8 eb da ff ff       	call   40030415 <_timer_cycle_get_32>
4003292a:	89 03                	mov    %eax,(%ebx)
#endif
}
4003292c:	5b                   	pop    %ebx
4003292d:	5d                   	pop    %ebp
4003292e:	c3                   	ret    

4003292f <upm_elapsed_us>:
    return elapsed;
#endif
}

uint32_t upm_elapsed_us(upm_clock_t *clock)
{
4003292f:	55                   	push   %ebp
40032930:	89 e5                	mov    %esp,%ebp
40032932:	56                   	push   %esi
40032933:	89 c6                	mov    %eax,%esi
40032935:	53                   	push   %ebx
        elapse = 1;

    return elapse;

#elif defined(UPM_PLATFORM_ZEPHYR)
    uint32_t now = k_cycle_get_32();
40032936:	e8 da da ff ff       	call   40030415 <_timer_cycle_get_32>

    uint32_t elapsed =
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
4003293b:	2b 06                	sub    (%esi),%eax
4003293d:	89 c3                	mov    %eax,%ebx
4003293f:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032944:	f7 2d f0 66 00 a8    	imull  0xa80066f0
4003294a:	89 d1                	mov    %edx,%ecx
4003294c:	0f af cb             	imul   %ebx,%ecx
4003294f:	f7 e3                	mul    %ebx
40032951:	01 ca                	add    %ecx,%edx
40032953:	8b 0d ec 66 00 a8    	mov    0xa80066ec,%ecx
40032959:	89 cb                	mov    %ecx,%ebx
4003295b:	c1 fb 1f             	sar    $0x1f,%ebx
4003295e:	53                   	push   %ebx
4003295f:	51                   	push   %ecx
40032960:	e8 56 d7 ff ff       	call   400300bb <__udivdi3>
40032965:	59                   	pop    %ecx
40032966:	5b                   	pop    %ebx
40032967:	6a 00                	push   $0x0
40032969:	68 e8 03 00 00       	push   $0x3e8
4003296e:	e8 48 d7 ff ff       	call   400300bb <__udivdi3>
40032973:	5e                   	pop    %esi
//printf("hello\n");
    // never return 0
    if (elapsed == 0)
40032974:	85 c0                	test   %eax,%eax
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40032976:	5a                   	pop    %edx
    if (elapsed == 0)
40032977:	75 05                	jne    4003297e <upm_elapsed_us+0x4f>
        elapsed = 1;
40032979:	b8 01 00 00 00       	mov    $0x1,%eax

    return elapsed;
#endif
}
4003297e:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032981:	5b                   	pop    %ebx
40032982:	5e                   	pop    %esi
40032983:	5d                   	pop    %ebp
40032984:	c3                   	ret    

40032985 <upm_delay_us>:
{
40032985:	55                   	push   %ebp
40032986:	85 c0                	test   %eax,%eax
40032988:	89 e5                	mov    %esp,%ebp
4003298a:	53                   	push   %ebx
4003298b:	bb 01 00 00 00       	mov    $0x1,%ebx
40032990:	52                   	push   %edx
40032991:	7e 02                	jle    40032995 <upm_delay_us+0x10>
40032993:	89 c3                	mov    %eax,%ebx
    upm_clock_init(&timer);
40032995:	8d 45 f8             	lea    -0x8(%ebp),%eax
40032998:	e8 82 ff ff ff       	call   4003291f <upm_clock_init>
    while (upm_elapsed_us(&timer) < time)
4003299d:	8d 45 f8             	lea    -0x8(%ebp),%eax
400329a0:	e8 8a ff ff ff       	call   4003292f <upm_elapsed_us>
400329a5:	39 d8                	cmp    %ebx,%eax
400329a7:	72 f4                	jb     4003299d <upm_delay_us+0x18>
}
400329a9:	58                   	pop    %eax
400329aa:	5b                   	pop    %ebx
400329ab:	5d                   	pop    %ebp
400329ac:	c3                   	ret    

400329ad <LoRaClass>:
  //_ss(LORA_DEFAULT_SS_PIN), _reset(LORA_DEFAULT_RESET_PIN), _dio0(LORA_DEFAULT_DIO0_PIN),
  //_frequency(0),
  //_packetIndex(0),
  //_implicitHeaderMode(0),
  //_onReceive(NULL)
{
400329ad:	55                   	push   %ebp
400329ae:	89 e5                	mov    %esp,%ebp
    // initialize MRAA
    int mraa_rv;
    if((mraa_rv = mraa_init()) != MRAA_SUCCESS) {
400329b0:	e8 5f ef ff ff       	call   40031914 <mraa_init>
400329b5:	85 c0                	test   %eax,%eax
400329b7:	74 13                	je     400329cc <LoRaClass+0x1f>
        printf("%s: mraa_init failed (%d).\n", __FUNCTION__, mraa_rv);
400329b9:	50                   	push   %eax
400329ba:	68 50 62 03 40       	push   $0x40036250
400329bf:	68 3f 5d 03 40       	push   $0x40035d3f
400329c4:	e8 f1 18 00 00       	call   400342ba <iprintf>
400329c9:	83 c4 0c             	add    $0xc,%esp
    }

    if(!(SX1276.spi = mraa_spi_init(0)))
400329cc:	31 c0                	xor    %eax,%eax
400329ce:	e8 ab f3 ff ff       	call   40031d7e <mraa_spi_init>
400329d3:	a3 94 78 00 a8       	mov    %eax,0xa8007894
400329d8:	85 c0                	test   %eax,%eax
400329da:	75 0b                	jne    400329e7 <LoRaClass+0x3a>
        printf("Unable to Initialize Spi bus\n");
400329dc:	68 5b 5d 03 40       	push   $0x40035d5b
400329e1:	e8 d4 18 00 00       	call   400342ba <iprintf>
400329e6:	5a                   	pop    %edx

    if(mraa_spi_frequency(SX1276.spi, 4000000) != MRAA_SUCCESS) {
400329e7:	ba 00 09 3d 00       	mov    $0x3d0900,%edx
400329ec:	a1 94 78 00 a8       	mov    0xa8007894,%eax
400329f1:	e8 10 f4 ff ff       	call   40031e06 <mraa_spi_frequency>
400329f6:	85 c0                	test   %eax,%eax
400329f8:	74 0b                	je     40032a05 <LoRaClass+0x58>
        printf("sx1276: Unable to set higher frequency\n");
400329fa:	68 79 5d 03 40       	push   $0x40035d79
400329ff:	e8 b6 18 00 00       	call   400342ba <iprintf>
40032a04:	58                   	pop    %eax
    }

    SX1276._frequency  = 0;
40032a05:	c7 05 98 78 00 a8 00 	movl   $0x0,0xa8007898
40032a0c:	00 00 00 
    SX1276._packetIndex = 0;
40032a0f:	c7 05 9c 78 00 a8 00 	movl   $0x0,0xa800789c
40032a16:	00 00 00 
    SX1276._implicitHeaderMode = 0;
40032a19:	c7 05 a0 78 00 a8 00 	movl   $0x0,0xa80078a0
40032a20:	00 00 00 

    SX1276._ss = LORA_DEFAULT_SS_PIN;
40032a23:	c6 05 8c 78 00 a8 0a 	movb   $0xa,0xa800788c
    SX1276._reset = LORA_DEFAULT_RESET_PIN;
40032a2a:	c6 05 8d 78 00 a8 09 	movb   $0x9,0xa800788d
    SX1276._dio0 = LORA_DEFAULT_DIO0_PIN;
40032a31:	c6 05 8e 78 00 a8 02 	movb   $0x2,0xa800788e
}
40032a38:	c9                   	leave  
40032a39:	c3                   	ret    

40032a3a <setPins>:

int8_t random() {
    return readRegister(REG_RSSI_WIDEBAND);
}

void setPins(int ss, int reset, int dio0) {
40032a3a:	55                   	push   %ebp
    SX1276._ss = ss;
40032a3b:	a2 8c 78 00 a8       	mov    %al,0xa800788c
void setPins(int ss, int reset, int dio0) {
40032a40:	89 e5                	mov    %esp,%ebp
    SX1276._reset = reset;
40032a42:	88 15 8d 78 00 a8    	mov    %dl,0xa800788d
    SX1276._dio0 = dio0;
40032a48:	88 0d 8e 78 00 a8    	mov    %cl,0xa800788e
}
40032a4e:	5d                   	pop    %ebp
40032a4f:	c3                   	ret    

40032a50 <readRegister>:
        // reset FIFO address
        writeRegister(REG_FIFO_ADDR_PTR, 0);
    }
}

uint8_t readRegister(uint8_t address) {
40032a50:	55                   	push   %ebp
    //return singleTransfer(address & 0x7f, 0x00);

    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032a51:	83 e0 7f             	and    $0x7f,%eax
uint8_t readRegister(uint8_t address) {
40032a54:	89 e5                	mov    %esp,%ebp
40032a56:	52                   	push   %edx
    uint8_t rx_buf[2];

    mraa_gpio_write(SX1276.gpio_ss, 0);
40032a57:	31 d2                	xor    %edx,%edx
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032a59:	88 45 fc             	mov    %al,-0x4(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40032a5c:	a1 80 78 00 a8       	mov    0xa8007880,%eax
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032a61:	c6 45 fd 00          	movb   $0x0,-0x3(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40032a65:	e8 a1 f2 ff ff       	call   40031d0b <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, tx_buf, rx_buf, 2) != MRAA_SUCCESS) {
40032a6a:	8d 4d fe             	lea    -0x2(%ebp),%ecx
40032a6d:	8d 55 fc             	lea    -0x4(%ebp),%edx
40032a70:	a1 94 78 00 a8       	mov    0xa8007894,%eax
40032a75:	6a 02                	push   $0x2
40032a77:	e8 c3 f3 ff ff       	call   40031e3f <mraa_spi_transfer_buf>
40032a7c:	59                   	pop    %ecx
40032a7d:	85 c0                	test   %eax,%eax
40032a7f:	74 2a                	je     40032aab <readRegister+0x5b>
        printf("Unable to transfer data over the SPI bus\n");
40032a81:	68 a1 5d 03 40       	push   $0x40035da1
40032a86:	e8 2f 18 00 00       	call   400342ba <iprintf>
        printf("SPI operation failed\n");
40032a8b:	c7 04 24 cb 5d 03 40 	movl   $0x40035dcb,(%esp)
40032a92:	e8 23 18 00 00       	call   400342ba <iprintf>
40032a97:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40032a98:	ba 01 00 00 00       	mov    $0x1,%edx
40032a9d:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032aa2:	e8 64 f2 ff ff       	call   40031d0b <mraa_gpio_write>
40032aa7:	b0 ff                	mov    $0xff,%al
40032aa9:	eb 12                	jmp    40032abd <readRegister+0x6d>
        return -1;
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032aab:	ba 01 00 00 00       	mov    $0x1,%edx
40032ab0:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032ab5:	e8 51 f2 ff ff       	call   40031d0b <mraa_gpio_write>

    return rx_buf[1];
40032aba:	8a 45 ff             	mov    -0x1(%ebp),%al
}
40032abd:	c9                   	leave  
40032abe:	c3                   	ret    

40032abf <dumpRegisters>:
{
40032abf:	55                   	push   %ebp
40032ac0:	89 e5                	mov    %esp,%ebp
40032ac2:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40032ac3:	31 db                	xor    %ebx,%ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
40032ac5:	89 d8                	mov    %ebx,%eax
40032ac7:	e8 84 ff ff ff       	call   40032a50 <readRegister>
40032acc:	0f b6 c0             	movzbl %al,%eax
40032acf:	50                   	push   %eax
40032ad0:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40032ad1:	43                   	inc    %ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
40032ad2:	68 e1 5d 03 40       	push   $0x40035de1
40032ad7:	e8 de 17 00 00       	call   400342ba <iprintf>
40032adc:	83 c4 0c             	add    $0xc,%esp
  for (int i = 0; i < 128; i++) {
40032adf:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
40032ae5:	75 de                	jne    40032ac5 <dumpRegisters+0x6>
}
40032ae7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032aea:	c9                   	leave  
40032aeb:	c3                   	ret    

40032aec <writeRegister>:

void writeRegister(uint8_t address, uint8_t value) {
40032aec:	55                   	push   %ebp
    //singleTransfer(address | 0x80, value);

    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40032aed:	83 c8 80             	or     $0xffffff80,%eax
void writeRegister(uint8_t address, uint8_t value) {
40032af0:	89 e5                	mov    %esp,%ebp
40032af2:	51                   	push   %ecx
    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40032af3:	88 45 fe             	mov    %al,-0x2(%ebp)
40032af6:	88 55 ff             	mov    %dl,-0x1(%ebp)

    mraa_gpio_write(SX1276.gpio_ss, 0);
40032af9:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032afe:	31 d2                	xor    %edx,%edx
40032b00:	e8 06 f2 ff ff       	call   40031d0b <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, pkt, NULL, 2) != MRAA_SUCCESS) {
40032b05:	31 c9                	xor    %ecx,%ecx
40032b07:	8d 55 fe             	lea    -0x2(%ebp),%edx
40032b0a:	a1 94 78 00 a8       	mov    0xa8007894,%eax
40032b0f:	6a 02                	push   $0x2
40032b11:	e8 29 f3 ff ff       	call   40031e3f <mraa_spi_transfer_buf>
40032b16:	5a                   	pop    %edx
40032b17:	85 c0                	test   %eax,%eax
40032b19:	74 26                	je     40032b41 <writeRegister+0x55>
        printf("Unable to transfer data over the SPI bus\n");
40032b1b:	68 a1 5d 03 40       	push   $0x40035da1
40032b20:	e8 95 17 00 00       	call   400342ba <iprintf>
        printf("SPI operation failed\n");
40032b25:	c7 04 24 cb 5d 03 40 	movl   $0x40035dcb,(%esp)
40032b2c:	e8 89 17 00 00       	call   400342ba <iprintf>
40032b31:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40032b32:	ba 01 00 00 00       	mov    $0x1,%edx
40032b37:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032b3c:	e8 ca f1 ff ff       	call   40031d0b <mraa_gpio_write>
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032b41:	ba 01 00 00 00       	mov    $0x1,%edx
40032b46:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032b4b:	e8 bb f1 ff ff       	call   40031d0b <mraa_gpio_write>
}
40032b50:	c9                   	leave  
40032b51:	c3                   	ret    

40032b52 <endPacket>:
int endPacket() {
40032b52:	55                   	push   %ebp
    printf("value of REG_IRQ_FLAGS very prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032b53:	b8 12 00 00 00       	mov    $0x12,%eax
int endPacket() {
40032b58:	89 e5                	mov    %esp,%ebp
    printf("value of REG_IRQ_FLAGS very prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032b5a:	e8 f1 fe ff ff       	call   40032a50 <readRegister>
40032b5f:	0f b6 c0             	movzbl %al,%eax
40032b62:	50                   	push   %eax
40032b63:	68 ed 5d 03 40       	push   $0x40035ded
40032b68:	e8 4d 17 00 00       	call   400342ba <iprintf>
40032b6d:	59                   	pop    %ecx
40032b6e:	58                   	pop    %eax
    printf("inside end packet\n");
40032b6f:	68 2e 5e 03 40       	push   $0x40035e2e
40032b74:	e8 41 17 00 00       	call   400342ba <iprintf>
40032b79:	58                   	pop    %eax
    printf("final value of REG_PAYLOAD_LENGTH: %x\n", readRegister(REG_PAYLOAD_LENGTH));
40032b7a:	b8 22 00 00 00       	mov    $0x22,%eax
40032b7f:	e8 cc fe ff ff       	call   40032a50 <readRegister>
40032b84:	0f b6 c0             	movzbl %al,%eax
40032b87:	50                   	push   %eax
40032b88:	68 41 5e 03 40       	push   $0x40035e41
40032b8d:	e8 28 17 00 00       	call   400342ba <iprintf>
40032b92:	58                   	pop    %eax
    printf("initial value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032b93:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("final value of REG_PAYLOAD_LENGTH: %x\n", readRegister(REG_PAYLOAD_LENGTH));
40032b98:	5a                   	pop    %edx
    printf("initial value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032b99:	e8 b2 fe ff ff       	call   40032a50 <readRegister>
40032b9e:	0f b6 c0             	movzbl %al,%eax
40032ba1:	50                   	push   %eax
40032ba2:	68 68 5e 03 40       	push   $0x40035e68
40032ba7:	e8 0e 17 00 00       	call   400342ba <iprintf>
40032bac:	59                   	pop    %ecx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_TX);
40032bad:	ba 83 00 00 00       	mov    $0x83,%edx
    printf("initial value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032bb2:	58                   	pop    %eax
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_TX);
40032bb3:	b8 01 00 00 00       	mov    $0x1,%eax
40032bb8:	e8 2f ff ff ff       	call   40032aec <writeRegister>
    printf("next value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032bbd:	b8 01 00 00 00       	mov    $0x1,%eax
40032bc2:	e8 89 fe ff ff       	call   40032a50 <readRegister>
40032bc7:	0f b6 c0             	movzbl %al,%eax
40032bca:	50                   	push   %eax
40032bcb:	68 8a 5e 03 40       	push   $0x40035e8a
40032bd0:	e8 e5 16 00 00       	call   400342ba <iprintf>
40032bd5:	58                   	pop    %eax
40032bd6:	5a                   	pop    %edx
    while((readRegister(REG_IRQ_FLAGS) & IRQ_TX_DONE_MASK) == 0);
40032bd7:	b8 12 00 00 00       	mov    $0x12,%eax
40032bdc:	e8 6f fe ff ff       	call   40032a50 <readRegister>
40032be1:	a8 08                	test   $0x8,%al
40032be3:	74 f2                	je     40032bd7 <endPacket+0x85>
    printf("interrupt 0 detected\n");
40032be5:	68 a9 5e 03 40       	push   $0x40035ea9
40032bea:	e8 cb 16 00 00       	call   400342ba <iprintf>
40032bef:	58                   	pop    %eax
    printf("value of REG_IRQ_FLAGS prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032bf0:	b8 12 00 00 00       	mov    $0x12,%eax
40032bf5:	e8 56 fe ff ff       	call   40032a50 <readRegister>
40032bfa:	0f b6 c0             	movzbl %al,%eax
40032bfd:	50                   	push   %eax
40032bfe:	68 bf 5e 03 40       	push   $0x40035ebf
40032c03:	e8 b2 16 00 00       	call   400342ba <iprintf>
40032c08:	5a                   	pop    %edx
    writeRegister(REG_IRQ_FLAGS, 0x80);
40032c09:	b8 12 00 00 00       	mov    $0x12,%eax
40032c0e:	ba 80 00 00 00       	mov    $0x80,%edx
    printf("value of REG_IRQ_FLAGS prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032c13:	59                   	pop    %ecx
    writeRegister(REG_IRQ_FLAGS, 0x80);
40032c14:	e8 d3 fe ff ff       	call   40032aec <writeRegister>
    printf("value of REG_IRQ_FLAGS after clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032c19:	b8 12 00 00 00       	mov    $0x12,%eax
40032c1e:	e8 2d fe ff ff       	call   40032a50 <readRegister>
40032c23:	0f b6 c0             	movzbl %al,%eax
40032c26:	50                   	push   %eax
40032c27:	68 fb 5e 03 40       	push   $0x40035efb
40032c2c:	e8 89 16 00 00       	call   400342ba <iprintf>
40032c31:	58                   	pop    %eax
}
40032c32:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("value of REG_IRQ_FLAGS after clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40032c37:	5a                   	pop    %edx
}
40032c38:	c9                   	leave  
40032c39:	c3                   	ret    

40032c3a <write_buf>:
{
40032c3a:	55                   	push   %ebp
40032c3b:	89 e5                	mov    %esp,%ebp
40032c3d:	57                   	push   %edi
40032c3e:	89 c7                	mov    %eax,%edi
40032c40:	56                   	push   %esi
40032c41:	53                   	push   %ebx
40032c42:	53                   	push   %ebx
40032c43:	89 d3                	mov    %edx,%ebx
    printf("aa\n");
40032c45:	68 34 5f 03 40       	push   $0x40035f34
40032c4a:	e8 6b 16 00 00       	call   400342ba <iprintf>
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
40032c4f:	b8 22 00 00 00       	mov    $0x22,%eax
    printf("aa\n");
40032c54:	5e                   	pop    %esi
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
40032c55:	e8 f6 fd ff ff       	call   40032a50 <readRegister>
40032c5a:	0f b6 f0             	movzbl %al,%esi
    printf("current length: %d\n", currentLength);
40032c5d:	56                   	push   %esi
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
40032c5e:	88 45 f3             	mov    %al,-0xd(%ebp)
    printf("current length: %d\n", currentLength);
40032c61:	68 38 5f 03 40       	push   $0x40035f38
40032c66:	e8 4f 16 00 00       	call   400342ba <iprintf>
40032c6b:	58                   	pop    %eax
    if ((currentLength + size) > MAX_PKT_LENGTH) {
40032c6c:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
    printf("current length: %d\n", currentLength);
40032c6f:	5a                   	pop    %edx
    if ((currentLength + size) > MAX_PKT_LENGTH) {
40032c70:	3d ff 00 00 00       	cmp    $0xff,%eax
40032c75:	76 07                	jbe    40032c7e <write_buf+0x44>
        size = MAX_PKT_LENGTH - currentLength;
40032c77:	bb ff 00 00 00       	mov    $0xff,%ebx
40032c7c:	29 f3                	sub    %esi,%ebx
    printf("bb\n");
40032c7e:	68 4c 5f 03 40       	push   $0x40035f4c
40032c83:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
40032c86:	e8 2f 16 00 00       	call   400342ba <iprintf>
40032c8b:	59                   	pop    %ecx
    for (size_t i = 0; i < size; i++) {
40032c8c:	39 f7                	cmp    %esi,%edi
40032c8e:	74 0d                	je     40032c9d <write_buf+0x63>
        writeRegister(REG_FIFO, buffer[i]);
40032c90:	0f b6 17             	movzbl (%edi),%edx
40032c93:	31 c0                	xor    %eax,%eax
40032c95:	47                   	inc    %edi
40032c96:	e8 51 fe ff ff       	call   40032aec <writeRegister>
40032c9b:	eb ef                	jmp    40032c8c <write_buf+0x52>
    printf("cc\n");
40032c9d:	68 50 5f 03 40       	push   $0x40035f50
40032ca2:	e8 13 16 00 00       	call   400342ba <iprintf>
    writeRegister(REG_PAYLOAD_LENGTH, currentLength + size);
40032ca7:	8a 55 f3             	mov    -0xd(%ebp),%dl
    printf("cc\n");
40032caa:	58                   	pop    %eax
    writeRegister(REG_PAYLOAD_LENGTH, currentLength + size);
40032cab:	01 da                	add    %ebx,%edx
40032cad:	b8 22 00 00 00       	mov    $0x22,%eax
40032cb2:	0f b6 d2             	movzbl %dl,%edx
40032cb5:	e8 32 fe ff ff       	call   40032aec <writeRegister>
    printf("dd\n");
40032cba:	68 54 5f 03 40       	push   $0x40035f54
40032cbf:	e8 f6 15 00 00       	call   400342ba <iprintf>
40032cc4:	5a                   	pop    %edx
}
40032cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032cc8:	89 d8                	mov    %ebx,%eax
40032cca:	5b                   	pop    %ebx
40032ccb:	5e                   	pop    %esi
40032ccc:	5f                   	pop    %edi
40032ccd:	5d                   	pop    %ebp
40032cce:	c3                   	ret    

40032ccf <idle>:
void idle() {
40032ccf:	55                   	push   %ebp
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032cd0:	b8 01 00 00 00       	mov    $0x1,%eax
void idle() {
40032cd5:	89 e5                	mov    %esp,%ebp
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032cd7:	e8 74 fd ff ff       	call   40032a50 <readRegister>
40032cdc:	0f b6 c0             	movzbl %al,%eax
40032cdf:	50                   	push   %eax
40032ce0:	68 58 5f 03 40       	push   $0x40035f58
40032ce5:	e8 d0 15 00 00       	call   400342ba <iprintf>
40032cea:	58                   	pop    %eax
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_STDBY);
40032ceb:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032cf0:	5a                   	pop    %edx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_STDBY);
40032cf1:	ba 81 00 00 00       	mov    $0x81,%edx
40032cf6:	e8 f1 fd ff ff       	call   40032aec <writeRegister>
    printf("next value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032cfb:	b8 01 00 00 00       	mov    $0x1,%eax
40032d00:	e8 4b fd ff ff       	call   40032a50 <readRegister>
40032d05:	0f b6 c0             	movzbl %al,%eax
40032d08:	50                   	push   %eax
40032d09:	68 8a 5e 03 40       	push   $0x40035e8a
40032d0e:	e8 a7 15 00 00       	call   400342ba <iprintf>
40032d13:	59                   	pop    %ecx
40032d14:	58                   	pop    %eax
}
40032d15:	c9                   	leave  
40032d16:	c3                   	ret    

40032d17 <SX1276sleep>:
void SX1276sleep() {
40032d17:	55                   	push   %ebp
40032d18:	89 e5                	mov    %esp,%ebp
    printf("Sleep function\n");
40032d1a:	68 7b 5f 03 40       	push   $0x40035f7b
40032d1f:	e8 96 15 00 00       	call   400342ba <iprintf>
40032d24:	58                   	pop    %eax
    printf("before: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d25:	b8 01 00 00 00       	mov    $0x1,%eax
40032d2a:	e8 21 fd ff ff       	call   40032a50 <readRegister>
40032d2f:	0f b6 c0             	movzbl %al,%eax
40032d32:	50                   	push   %eax
40032d33:	68 8b 5f 03 40       	push   $0x40035f8b
40032d38:	e8 7d 15 00 00       	call   400342ba <iprintf>
40032d3d:	5a                   	pop    %edx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_SLEEP);
40032d3e:	b8 01 00 00 00       	mov    $0x1,%eax
40032d43:	ba 80 00 00 00       	mov    $0x80,%edx
    printf("before: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d48:	59                   	pop    %ecx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_SLEEP);
40032d49:	e8 9e fd ff ff       	call   40032aec <writeRegister>
    printf("after: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d4e:	b8 01 00 00 00       	mov    $0x1,%eax
40032d53:	e8 f8 fc ff ff       	call   40032a50 <readRegister>
40032d58:	0f b6 c0             	movzbl %al,%eax
40032d5b:	50                   	push   %eax
40032d5c:	68 a4 5f 03 40       	push   $0x40035fa4
40032d61:	e8 54 15 00 00       	call   400342ba <iprintf>
40032d66:	58                   	pop    %eax
40032d67:	5a                   	pop    %edx
}
40032d68:	c9                   	leave  
40032d69:	c3                   	ret    

40032d6a <setTxPower.part.1>:
void setTxPower(int level, int outputPin) {
40032d6a:	55                   	push   %ebp
40032d6b:	83 f8 11             	cmp    $0x11,%eax
40032d6e:	89 e5                	mov    %esp,%ebp
40032d70:	53                   	push   %ebx
40032d71:	7e 05                	jle    40032d78 <setTxPower.part.1+0xe>
40032d73:	b8 11 00 00 00       	mov    $0x11,%eax
40032d78:	89 c3                	mov    %eax,%ebx
40032d7a:	83 f8 02             	cmp    $0x2,%eax
40032d7d:	7d 05                	jge    40032d84 <setTxPower.part.1+0x1a>
40032d7f:	bb 02 00 00 00       	mov    $0x2,%ebx
        printf("value to be written to REG_PA_CONFIG; %x\n", PA_BOOST | (level - 2));
40032d84:	8d 43 fe             	lea    -0x2(%ebx),%eax
40032d87:	0c 80                	or     $0x80,%al
40032d89:	50                   	push   %eax
40032d8a:	68 bc 5f 03 40       	push   $0x40035fbc
40032d8f:	e8 26 15 00 00       	call   400342ba <iprintf>
40032d94:	58                   	pop    %eax
40032d95:	5a                   	pop    %edx
        writeRegister(REG_PA_CONFIG, PA_BOOST | (level - 2));
40032d96:	8d 53 fe             	lea    -0x2(%ebx),%edx
40032d99:	83 ca 80             	or     $0xffffff80,%edx
40032d9c:	b8 09 00 00 00       	mov    $0x9,%eax
40032da1:	0f b6 d2             	movzbl %dl,%edx
40032da4:	e8 43 fd ff ff       	call   40032aec <writeRegister>
        printf("REG_PA_CONFIG: %x\n", readRegister(REG_PA_CONFIG));
40032da9:	b8 09 00 00 00       	mov    $0x9,%eax
40032dae:	e8 9d fc ff ff       	call   40032a50 <readRegister>
40032db3:	0f b6 c0             	movzbl %al,%eax
40032db6:	50                   	push   %eax
40032db7:	68 e6 5f 03 40       	push   $0x40035fe6
40032dbc:	e8 f9 14 00 00       	call   400342ba <iprintf>
40032dc1:	59                   	pop    %ecx
40032dc2:	5b                   	pop    %ebx
}
40032dc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032dc6:	c9                   	leave  
40032dc7:	c3                   	ret    

40032dc8 <setFrequency>:
void setFrequency(long frequency) {
40032dc8:	55                   	push   %ebp
    SX1276._frequency = frequency;
40032dc9:	a3 98 78 00 a8       	mov    %eax,0xa8007898
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032dce:	99                   	cltd   
void setFrequency(long frequency) {
40032dcf:	89 e5                	mov    %esp,%ebp
40032dd1:	57                   	push   %edi
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032dd2:	0f a4 c2 13          	shld   $0x13,%eax,%edx
40032dd6:	c1 e0 13             	shl    $0x13,%eax
void setFrequency(long frequency) {
40032dd9:	56                   	push   %esi
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032dda:	6a 00                	push   $0x0
40032ddc:	68 00 48 e8 01       	push   $0x1e84800
40032de1:	e8 d5 d2 ff ff       	call   400300bb <__udivdi3>
40032de6:	59                   	pop    %ecx
40032de7:	5e                   	pop    %esi
40032de8:	89 c6                	mov    %eax,%esi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40032dea:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032dee:	89 d7                	mov    %edx,%edi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40032df0:	0f b6 d0             	movzbl %al,%edx
40032df3:	b8 06 00 00 00       	mov    $0x6,%eax
40032df8:	e8 ef fc ff ff       	call   40032aec <writeRegister>
    writeRegister(REG_FRF_MID, (uint8_t)(frf >> 8));
40032dfd:	89 fa                	mov    %edi,%edx
40032dff:	89 f0                	mov    %esi,%eax
40032e01:	0f ac d0 08          	shrd   $0x8,%edx,%eax
40032e05:	0f b6 d0             	movzbl %al,%edx
40032e08:	b8 07 00 00 00       	mov    $0x7,%eax
40032e0d:	e8 da fc ff ff       	call   40032aec <writeRegister>
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
40032e12:	89 f0                	mov    %esi,%eax
40032e14:	0f b6 d0             	movzbl %al,%edx
40032e17:	b8 08 00 00 00       	mov    $0x8,%eax
40032e1c:	e8 cb fc ff ff       	call   40032aec <writeRegister>
    printf("REG_FRF_MSB: %x\n", readRegister(REG_FRF_MSB));
40032e21:	b8 06 00 00 00       	mov    $0x6,%eax
40032e26:	e8 25 fc ff ff       	call   40032a50 <readRegister>
40032e2b:	0f b6 c0             	movzbl %al,%eax
40032e2e:	50                   	push   %eax
40032e2f:	68 f9 5f 03 40       	push   $0x40035ff9
40032e34:	e8 81 14 00 00       	call   400342ba <iprintf>
40032e39:	5f                   	pop    %edi
40032e3a:	58                   	pop    %eax
    printf("REG_FRF_MID: %x\n", readRegister(REG_FRF_MID));
40032e3b:	b8 07 00 00 00       	mov    $0x7,%eax
40032e40:	e8 0b fc ff ff       	call   40032a50 <readRegister>
40032e45:	0f b6 c0             	movzbl %al,%eax
40032e48:	50                   	push   %eax
40032e49:	68 0a 60 03 40       	push   $0x4003600a
40032e4e:	e8 67 14 00 00       	call   400342ba <iprintf>
40032e53:	58                   	pop    %eax
    printf("REG_FRF_LSB: %x\n", readRegister(REG_FRF_LSB));
40032e54:	b8 08 00 00 00       	mov    $0x8,%eax
    printf("REG_FRF_MID: %x\n", readRegister(REG_FRF_MID));
40032e59:	5a                   	pop    %edx
    printf("REG_FRF_LSB: %x\n", readRegister(REG_FRF_LSB));
40032e5a:	e8 f1 fb ff ff       	call   40032a50 <readRegister>
40032e5f:	0f b6 c0             	movzbl %al,%eax
40032e62:	50                   	push   %eax
40032e63:	68 1b 60 03 40       	push   $0x4003601b
40032e68:	e8 4d 14 00 00       	call   400342ba <iprintf>
40032e6d:	59                   	pop    %ecx
40032e6e:	5e                   	pop    %esi
}
40032e6f:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032e72:	5e                   	pop    %esi
40032e73:	5f                   	pop    %edi
40032e74:	5d                   	pop    %ebp
40032e75:	c3                   	ret    

40032e76 <begin>:
{
40032e76:	55                   	push   %ebp
40032e77:	89 e5                	mov    %esp,%ebp
40032e79:	56                   	push   %esi
40032e7a:	89 c6                	mov    %eax,%esi
40032e7c:	53                   	push   %ebx
    if(!(SX1276.gpio_ss = mraa_gpio_init(SX1276._ss))) {
40032e7d:	0f b6 05 8c 78 00 a8 	movzbl 0xa800788c,%eax
40032e84:	e8 5a ed ff ff       	call   40031be3 <mraa_gpio_init>
40032e89:	a3 80 78 00 a8       	mov    %eax,0xa8007880
40032e8e:	85 c0                	test   %eax,%eax
40032e90:	75 0b                	jne    40032e9d <begin+0x27>
        printf("sx1276: unable to init SPI CS\n");
40032e92:	68 2c 60 03 40       	push   $0x4003602c
40032e97:	e8 1e 14 00 00       	call   400342ba <iprintf>
40032e9c:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_ss, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
40032e9d:	31 d2                	xor    %edx,%edx
40032e9f:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032ea4:	e8 ec ed ff ff       	call   40031c95 <mraa_gpio_dir>
40032ea9:	85 c0                	test   %eax,%eax
40032eab:	74 0b                	je     40032eb8 <begin+0x42>
        printf("sx1276: unable to set direction on SPI CS\n");
40032ead:	68 4b 60 03 40       	push   $0x4003604b
40032eb2:	e8 03 14 00 00       	call   400342ba <iprintf>
40032eb7:	58                   	pop    %eax
    if(!(SX1276.gpio_reset = mraa_gpio_init(SX1276._reset))) {
40032eb8:	0f b6 05 8d 78 00 a8 	movzbl 0xa800788d,%eax
40032ebf:	e8 1f ed ff ff       	call   40031be3 <mraa_gpio_init>
40032ec4:	a3 84 78 00 a8       	mov    %eax,0xa8007884
40032ec9:	85 c0                	test   %eax,%eax
40032ecb:	75 0b                	jne    40032ed8 <begin+0x62>
        printf("sx1276: unable to init chip reset\n");
40032ecd:	68 76 60 03 40       	push   $0x40036076
40032ed2:	e8 e3 13 00 00       	call   400342ba <iprintf>
40032ed7:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_reset, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
40032ed8:	31 d2                	xor    %edx,%edx
40032eda:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40032edf:	e8 b1 ed ff ff       	call   40031c95 <mraa_gpio_dir>
40032ee4:	85 c0                	test   %eax,%eax
40032ee6:	74 0b                	je     40032ef3 <begin+0x7d>
        printf("sx1276: unable to set direction on reset pin\n");
40032ee8:	68 99 60 03 40       	push   $0x40036099
40032eed:	e8 c8 13 00 00       	call   400342ba <iprintf>
40032ef2:	5b                   	pop    %ebx
    mraa_gpio_write(SX1276.gpio_reset, 1);
40032ef3:	ba 01 00 00 00       	mov    $0x1,%edx
40032ef8:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40032efd:	e8 09 ee ff ff       	call   40031d0b <mraa_gpio_write>
    upm_delay_us(1000);
40032f02:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032f07:	e8 79 fa ff ff       	call   40032985 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 0);
40032f0c:	31 d2                	xor    %edx,%edx
40032f0e:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40032f13:	e8 f3 ed ff ff       	call   40031d0b <mraa_gpio_write>
    upm_delay_us(1000);
40032f18:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032f1d:	e8 63 fa ff ff       	call   40032985 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 1);
40032f22:	ba 01 00 00 00       	mov    $0x1,%edx
40032f27:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40032f2c:	e8 da ed ff ff       	call   40031d0b <mraa_gpio_write>
    upm_delay_us(15000);
40032f31:	b8 98 3a 00 00       	mov    $0x3a98,%eax
40032f36:	e8 4a fa ff ff       	call   40032985 <upm_delay_us>
    dumpRegisters();
40032f3b:	e8 7f fb ff ff       	call   40032abf <dumpRegisters>
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032f40:	ba 01 00 00 00       	mov    $0x1,%edx
40032f45:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40032f4a:	e8 bc ed ff ff       	call   40031d0b <mraa_gpio_write>
    uint8_t version = readRegister(REG_VERSION);
40032f4f:	b8 42 00 00 00       	mov    $0x42,%eax
40032f54:	e8 f7 fa ff ff       	call   40032a50 <readRegister>
40032f59:	0f b6 d8             	movzbl %al,%ebx
    if (version != 0x12) {
40032f5c:	80 fb 12             	cmp    $0x12,%bl
40032f5f:	74 0b                	je     40032f6c <begin+0xf6>
        printf("wrong version\n");
40032f61:	68 c7 60 03 40       	push   $0x400360c7
40032f66:	e8 4f 13 00 00       	call   400342ba <iprintf>
40032f6b:	59                   	pop    %ecx
    printf("chip version: %x\n", version);
40032f6c:	53                   	push   %ebx
40032f6d:	68 d6 60 03 40       	push   $0x400360d6
40032f72:	e8 43 13 00 00       	call   400342ba <iprintf>
40032f77:	58                   	pop    %eax
40032f78:	5a                   	pop    %edx
    SX1276sleep();
40032f79:	e8 99 fd ff ff       	call   40032d17 <SX1276sleep>
    setFrequency(frequency);
40032f7e:	89 f0                	mov    %esi,%eax
40032f80:	e8 43 fe ff ff       	call   40032dc8 <setFrequency>
    printf("setting rx and tx base addresses\n");
40032f85:	68 e8 60 03 40       	push   $0x400360e8
40032f8a:	e8 2b 13 00 00       	call   400342ba <iprintf>
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
40032f8f:	31 d2                	xor    %edx,%edx
40032f91:	b8 0e 00 00 00       	mov    $0xe,%eax
    printf("setting rx and tx base addresses\n");
40032f96:	59                   	pop    %ecx
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
40032f97:	e8 50 fb ff ff       	call   40032aec <writeRegister>
    writeRegister(REG_FIFO_RX_BASE_ADDR, 0);
40032f9c:	31 d2                	xor    %edx,%edx
40032f9e:	b8 0f 00 00 00       	mov    $0xf,%eax
40032fa3:	e8 44 fb ff ff       	call   40032aec <writeRegister>
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
40032fa8:	b8 0e 00 00 00       	mov    $0xe,%eax
40032fad:	e8 9e fa ff ff       	call   40032a50 <readRegister>
40032fb2:	0f b6 c0             	movzbl %al,%eax
40032fb5:	50                   	push   %eax
40032fb6:	68 0a 61 03 40       	push   $0x4003610a
40032fbb:	e8 fa 12 00 00       	call   400342ba <iprintf>
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40032fc0:	b8 0f 00 00 00       	mov    $0xf,%eax
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
40032fc5:	5b                   	pop    %ebx
40032fc6:	5e                   	pop    %esi
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40032fc7:	e8 84 fa ff ff       	call   40032a50 <readRegister>
40032fcc:	0f b6 c0             	movzbl %al,%eax
40032fcf:	50                   	push   %eax
40032fd0:	68 25 61 03 40       	push   $0x40036125
40032fd5:	e8 e0 12 00 00       	call   400342ba <iprintf>
40032fda:	58                   	pop    %eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40032fdb:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40032fe0:	5a                   	pop    %edx
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40032fe1:	e8 6a fa ff ff       	call   40032a50 <readRegister>
40032fe6:	0f b6 c0             	movzbl %al,%eax
40032fe9:	50                   	push   %eax
40032fea:	68 40 61 03 40       	push   $0x40036140
40032fef:	e8 c6 12 00 00       	call   400342ba <iprintf>
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
40032ff4:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40032ff9:	59                   	pop    %ecx
40032ffa:	5b                   	pop    %ebx
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
40032ffb:	e8 50 fa ff ff       	call   40032a50 <readRegister>
40033000:	83 c8 23             	or     $0x23,%eax
40033003:	0f b6 d0             	movzbl %al,%edx
40033006:	b8 0c 00 00 00       	mov    $0xc,%eax
4003300b:	e8 dc fa ff ff       	call   40032aec <writeRegister>
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
40033010:	b8 0c 00 00 00       	mov    $0xc,%eax
40033015:	e8 36 fa ff ff       	call   40032a50 <readRegister>
4003301a:	0f b6 c0             	movzbl %al,%eax
4003301d:	50                   	push   %eax
4003301e:	68 54 61 03 40       	push   $0x40036154
40033023:	e8 92 12 00 00       	call   400342ba <iprintf>
40033028:	5e                   	pop    %esi
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
40033029:	ba 04 00 00 00       	mov    $0x4,%edx
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
4003302e:	58                   	pop    %eax
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
4003302f:	b8 26 00 00 00       	mov    $0x26,%eax
40033034:	e8 b3 fa ff ff       	call   40032aec <writeRegister>
    printf("REG_MODEM_CONFIG_3; %x\n", readRegister(REG_MODEM_CONFIG_3));
40033039:	b8 26 00 00 00       	mov    $0x26,%eax
4003303e:	e8 0d fa ff ff       	call   40032a50 <readRegister>
40033043:	0f b6 c0             	movzbl %al,%eax
40033046:	50                   	push   %eax
40033047:	68 67 61 03 40       	push   $0x40036167
4003304c:	e8 69 12 00 00       	call   400342ba <iprintf>
40033051:	58                   	pop    %eax
40033052:	b8 11 00 00 00       	mov    $0x11,%eax
40033057:	5a                   	pop    %edx
40033058:	e8 0d fd ff ff       	call   40032d6a <setTxPower.part.1>
    idle();
4003305d:	e8 6d fc ff ff       	call   40032ccf <idle>
}
40033062:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033065:	b8 01 00 00 00       	mov    $0x1,%eax
4003306a:	5b                   	pop    %ebx
4003306b:	5e                   	pop    %esi
4003306c:	5d                   	pop    %ebp
4003306d:	c3                   	ret    

4003306e <explicitHeaderMode>:
void explicitHeaderMode() {
4003306e:	55                   	push   %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
4003306f:	b8 1d 00 00 00       	mov    $0x1d,%eax
void explicitHeaderMode() {
40033074:	89 e5                	mov    %esp,%ebp
    SX1276._implicitHeaderMode = 0;
40033076:	c7 05 a0 78 00 a8 00 	movl   $0x0,0xa80078a0
4003307d:	00 00 00 
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
40033080:	e8 cb f9 ff ff       	call   40032a50 <readRegister>
}
40033085:	5d                   	pop    %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
40033086:	89 c2                	mov    %eax,%edx
40033088:	b8 1d 00 00 00       	mov    $0x1d,%eax
4003308d:	81 e2 fe 00 00 00    	and    $0xfe,%edx
40033093:	e9 54 fa ff ff       	jmp    40032aec <writeRegister>

40033098 <implicitHeaderMode>:
void implicitHeaderMode() {
40033098:	55                   	push   %ebp
40033099:	89 e5                	mov    %esp,%ebp
    printf("inside implicit header mode\n");
4003309b:	68 7f 61 03 40       	push   $0x4003617f
400330a0:	e8 15 12 00 00       	call   400342ba <iprintf>
400330a5:	58                   	pop    %eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400330a6:	b8 1d 00 00 00       	mov    $0x1d,%eax
    SX1276._implicitHeaderMode = 1;
400330ab:	c7 05 a0 78 00 a8 01 	movl   $0x1,0xa80078a0
400330b2:	00 00 00 
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400330b5:	e8 96 f9 ff ff       	call   40032a50 <readRegister>
400330ba:	0f b6 c0             	movzbl %al,%eax
400330bd:	50                   	push   %eax
400330be:	68 9c 61 03 40       	push   $0x4003619c
400330c3:	e8 f2 11 00 00       	call   400342ba <iprintf>
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
400330c8:	b8 1d 00 00 00       	mov    $0x1d,%eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400330cd:	5a                   	pop    %edx
400330ce:	59                   	pop    %ecx
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
400330cf:	e8 7c f9 ff ff       	call   40032a50 <readRegister>
400330d4:	83 c8 01             	or     $0x1,%eax
400330d7:	0f b6 d0             	movzbl %al,%edx
400330da:	b8 1d 00 00 00       	mov    $0x1d,%eax
400330df:	e8 08 fa ff ff       	call   40032aec <writeRegister>
    printf("next value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400330e4:	b8 1d 00 00 00       	mov    $0x1d,%eax
400330e9:	e8 62 f9 ff ff       	call   40032a50 <readRegister>
400330ee:	0f b6 c0             	movzbl %al,%eax
400330f1:	50                   	push   %eax
400330f2:	68 c5 61 03 40       	push   $0x400361c5
400330f7:	e8 be 11 00 00       	call   400342ba <iprintf>
400330fc:	58                   	pop    %eax
400330fd:	5a                   	pop    %edx
}
400330fe:	c9                   	leave  
400330ff:	c3                   	ret    

40033100 <beginPacket>:
int beginPacket(int implicitHeader) {
40033100:	55                   	push   %ebp
40033101:	89 e5                	mov    %esp,%ebp
40033103:	53                   	push   %ebx
40033104:	89 c3                	mov    %eax,%ebx
    idle();
40033106:	e8 c4 fb ff ff       	call   40032ccf <idle>
    printf("inside begin packet\n");
4003310b:	68 eb 61 03 40       	push   $0x400361eb
40033110:	e8 a5 11 00 00       	call   400342ba <iprintf>
40033115:	58                   	pop    %eax
    if (implicitHeader) {
40033116:	85 db                	test   %ebx,%ebx
40033118:	74 07                	je     40033121 <beginPacket+0x21>
        implicitHeaderMode();
4003311a:	e8 79 ff ff ff       	call   40033098 <implicitHeaderMode>
4003311f:	eb 05                	jmp    40033126 <beginPacket+0x26>
        explicitHeaderMode();
40033121:	e8 48 ff ff ff       	call   4003306e <explicitHeaderMode>
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
40033126:	b8 0d 00 00 00       	mov    $0xd,%eax
4003312b:	e8 20 f9 ff ff       	call   40032a50 <readRegister>
40033130:	0f b6 c0             	movzbl %al,%eax
40033133:	50                   	push   %eax
40033134:	68 00 62 03 40       	push   $0x40036200
40033139:	e8 7c 11 00 00       	call   400342ba <iprintf>
4003313e:	58                   	pop    %eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
4003313f:	b8 22 00 00 00       	mov    $0x22,%eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
40033144:	5a                   	pop    %edx
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
40033145:	e8 06 f9 ff ff       	call   40032a50 <readRegister>
4003314a:	0f b6 c0             	movzbl %al,%eax
4003314d:	50                   	push   %eax
4003314e:	68 00 62 03 40       	push   $0x40036200
40033153:	e8 62 11 00 00       	call   400342ba <iprintf>
    writeRegister(REG_FIFO_ADDR_PTR, 0);
40033158:	31 d2                	xor    %edx,%edx
4003315a:	b8 0d 00 00 00       	mov    $0xd,%eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
4003315f:	59                   	pop    %ecx
40033160:	5b                   	pop    %ebx
    writeRegister(REG_FIFO_ADDR_PTR, 0);
40033161:	e8 86 f9 ff ff       	call   40032aec <writeRegister>
    writeRegister(REG_PAYLOAD_LENGTH, 0);
40033166:	31 d2                	xor    %edx,%edx
40033168:	b8 22 00 00 00       	mov    $0x22,%eax
4003316d:	e8 7a f9 ff ff       	call   40032aec <writeRegister>
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
40033172:	b8 0d 00 00 00       	mov    $0xd,%eax
40033177:	e8 d4 f8 ff ff       	call   40032a50 <readRegister>
4003317c:	0f b6 c0             	movzbl %al,%eax
4003317f:	50                   	push   %eax
40033180:	68 28 62 03 40       	push   $0x40036228
40033185:	e8 30 11 00 00       	call   400342ba <iprintf>
4003318a:	58                   	pop    %eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
4003318b:	b8 22 00 00 00       	mov    $0x22,%eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
40033190:	5a                   	pop    %edx
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
40033191:	e8 ba f8 ff ff       	call   40032a50 <readRegister>
40033196:	0f b6 c0             	movzbl %al,%eax
40033199:	50                   	push   %eax
4003319a:	68 28 62 03 40       	push   $0x40036228
4003319f:	e8 16 11 00 00       	call   400342ba <iprintf>
400331a4:	59                   	pop    %ecx
}
400331a5:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400331aa:	5b                   	pop    %ebx
}
400331ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400331ae:	c9                   	leave  
400331af:	c3                   	ret    

400331b0 <_arc_init>:
{
	uint32_t *reset_vector;

	ARG_UNUSED(arg);

	if (!SCSS_REG_VAL(SCSS_SS_STS)) {
400331b0:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400331b5:	85 c0                	test   %eax,%eax
400331b7:	75 15                	jne    400331ce <_arc_init+0x1e>
{
400331b9:	55                   	push   %ebp
400331ba:	89 e5                	mov    %esp,%ebp
		/* ARC shouldn't already be running! */
		printk("ARC core already running!");
400331bc:	68 5a 62 03 40       	push   $0x4003625a
400331c1:	e8 4e df ff ff       	call   40031114 <printk>
400331c6:	58                   	pop    %eax
		return -EIO;
400331c7:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}

skip_arc_init:

	return 0;
}
400331cc:	c9                   	leave  
400331cd:	c3                   	ret    
	shared_data->arc_start = *reset_vector;
400331ce:	a1 00 00 00 40       	mov    0x40000000,%eax
400331d3:	a3 00 00 00 a8       	mov    %eax,0xa8000000
	shared_data->flags = 0;
400331d8:	c7 05 04 00 00 a8 00 	movl   $0x0,0xa8000004
400331df:	00 00 00 
	if (!shared_data->arc_start) {
400331e2:	a1 00 00 00 a8       	mov    0xa8000000,%eax
400331e7:	85 c0                	test   %eax,%eax
400331e9:	75 03                	jne    400331ee <_arc_init+0x3e>
	return 0;
400331eb:	31 c0                	xor    %eax,%eax
400331ed:	c3                   	ret    
	SCSS_REG_VAL(SCSS_SS_CFG) |= ARC_RUN_REQ_A;
400331ee:	a1 00 06 80 b0       	mov    0xb0800600,%eax
400331f3:	0d 00 00 00 01       	or     $0x1000000,%eax
400331f8:	a3 00 06 80 b0       	mov    %eax,0xb0800600
	while (SCSS_REG_VAL(SCSS_SS_STS) & 0x4000) {
400331fd:	a1 04 06 80 b0       	mov    0xb0800604,%eax
40033202:	0f ba e0 0e          	bt     $0xe,%eax
40033206:	72 f5                	jb     400331fd <_arc_init+0x4d>
	while (!(shared_data->flags & ARC_READY)) {
40033208:	a1 04 00 00 a8       	mov    0xa8000004,%eax
4003320d:	a8 01                	test   $0x1,%al
4003320f:	74 f7                	je     40033208 <_arc_init+0x58>
40033211:	eb d8                	jmp    400331eb <_arc_init+0x3b>

40033213 <_lakemont_eoi>:
#include <arch/x86/irq_controller.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
40033213:	55                   	push   %ebp
40033214:	89 e5                	mov    %esp,%ebp
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
40033216:	e8 fc d2 ff ff       	call   40030517 <__irq_controller_isr_vector_get>
4003321b:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
40033220:	31 c0                	xor    %eax,%eax
40033222:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	sys_write32(_irq_controller_isr_vector_get(),
		    CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);

	/* Send EOI to the LOAPIC as well */
	sys_write32(0, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI);
}
40033227:	5d                   	pop    %ebp
40033228:	c3                   	ret    

40033229 <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
40033229:	55                   	push   %ebp
4003322a:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
4003322c:	e8 61 0c 00 00       	call   40033e92 <k_is_in_isr>
40033231:	85 c0                	test   %eax,%eax
40033233:	74 15                	je     4003324a <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
40033235:	e8 58 0c 00 00       	call   40033e92 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
4003323a:	ba 74 62 03 40       	mov    $0x40036274,%edx
4003323f:	85 c0                	test   %eax,%eax
40033241:	75 2c                	jne    4003326f <_SysFatalErrorHandler+0x46>
40033243:	ba 78 62 03 40       	mov    $0x40036278,%edx
40033248:	eb 25                	jmp    4003326f <_SysFatalErrorHandler+0x46>
	if (k_is_in_isr() || _is_thread_essential()) {
4003324a:	e8 54 0c 00 00       	call   40033ea3 <_is_thread_essential>
4003324f:	85 c0                	test   %eax,%eax
40033251:	75 e2                	jne    40033235 <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
40033253:	ff 35 c8 76 00 a8    	pushl  0xa80076c8
40033259:	68 a9 62 03 40       	push   $0x400362a9
4003325e:	e8 b1 de ff ff       	call   40031114 <printk>
40033263:	58                   	pop    %eax
	k_thread_abort(_current);
40033264:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
	printk("Fatal fault in thread %p! Aborting.\n", _current);
40033269:	5a                   	pop    %edx
	k_thread_abort(_current);
4003326a:	e8 6f 0d 00 00       	call   40033fde <k_thread_abort>
		printk("Fatal fault in %s! Spinning...\n",
4003326f:	52                   	push   %edx
40033270:	68 89 62 03 40       	push   $0x40036289
40033275:	e8 9a de ff ff       	call   40031114 <printk>
4003327a:	59                   	pop    %ecx
4003327b:	58                   	pop    %eax
4003327c:	eb fe                	jmp    4003327c <_SysFatalErrorHandler+0x53>

4003327e <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
4003327e:	53                   	push   %ebx
	movl $1, %eax
4003327f:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
40033284:	0f a2                	cpuid  
	movl %ebx, %eax
40033286:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
40033288:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
4003328d:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
40033290:	5b                   	pop    %ebx
	ret
40033291:	c3                   	ret    

40033292 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
40033292:	55                   	push   %ebp
40033293:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
40033295:	e8 e4 ff ff ff       	call   4003327e <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
4003329a:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
4003329b:	a3 bc 78 00 a8       	mov    %eax,0xa80078bc
}
400332a0:	31 c0                	xor    %eax,%eax
400332a2:	c3                   	ret    

400332a3 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
400332a3:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
400332a4:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
400332a7:	50                   	push   %eax
	pushl	%edx
400332a8:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
400332a9:	57                   	push   %edi
	pushl	%esi
400332aa:	56                   	push   %esi
	pushl	%ebx
400332ab:	53                   	push   %ebx
	pushl	%ebp
400332ac:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
400332ad:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
400332b1:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
400332b2:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
400332b9:	00 
	je	allDone
400332ba:	74 01                	je     400332bd <allDone>
	sti
400332bc:	fb                   	sti    

400332bd <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
400332bd:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
400332bf:	ff d1                	call   *%ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
400332c1:	5d                   	pop    %ebp
	popl	%ebp
400332c2:	5d                   	pop    %ebp
	popl	%ebx
400332c3:	5b                   	pop    %ebx
	popl	%esi
400332c4:	5e                   	pop    %esi
	popl	%edi
400332c5:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
400332c6:	5a                   	pop    %edx
	popl	%eax
400332c7:	58                   	pop    %eax
	popl	%ecx
400332c8:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
400332c9:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
400332cc:	cf                   	iret   

400332cd <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
400332cd:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
400332ce:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
400332d2:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
400332d5:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
400332d6:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
400332d7:	b9 c0 76 00 a8       	mov    $0xa80076c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
400332dc:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
400332de:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
400332e1:	75 06                	jne    400332e9 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
400332e3:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
400332e5:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
400332e8:	57                   	push   %edi

400332e9 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
400332e9:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
400332ea:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
400332ec:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
400332ed:	e8 21 ff ff ff       	call   40033213 <_lakemont_eoi>
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
400332f2:	b9 c0 76 00 a8       	mov    $0xa80076c0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
400332f7:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
400332f9:	75 1e                	jne    40033319 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
400332fb:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
400332fe:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
40033304:	73 12                	jae    40033318 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
40033306:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
40033309:	74 0d                	je     40033318 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
4003330b:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
4003330c:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
4003330d:	58                   	pop    %eax
#endif
	call	_Swap
4003330e:	e8 27 00 00 00       	call   4003333a <_Swap>

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
40033313:	5f                   	pop    %edi
	popl	%ecx
40033314:	59                   	pop    %ecx
	popl	%edx
40033315:	5a                   	pop    %edx
	popl	%eax
40033316:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033317:	cf                   	iret   

40033318 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
40033318:	5c                   	pop    %esp

40033319 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
40033319:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
4003331a:	59                   	pop    %ecx
	popl	%edx
4003331b:	5a                   	pop    %edx
	popl	%eax
4003331c:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
4003331d:	cf                   	iret   

4003331e <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
4003331e:	6a 00                	push   $0x0

40033320 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
40033320:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
40033321:	50                   	push   %eax
	pushl %ecx
40033322:	51                   	push   %ecx
	pushl %edx
40033323:	52                   	push   %edx
	pushl %edi
40033324:	57                   	push   %edi
	pushl %esi
40033325:	56                   	push   %esi
	pushl %ebx
40033326:	53                   	push   %ebx
	pushl %ebp
40033327:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
40033328:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
4003332c:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
4003332d:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
4003332f:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
40033330:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
40033335:	e8 9b 00 00 00       	call   400333d5 <_NanoFatalErrorHandler>

4003333a <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
4003333a:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
4003333d:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
40033341:	57                   	push   %edi

	movl	$_kernel, %edi
40033342:	bf c0 76 00 a8       	mov    $0xa80076c0,%edi

	pushl	%esi
40033347:	56                   	push   %esi
	pushl	%ebx
40033348:	53                   	push   %ebx
	pushl	%ebp
40033349:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
4003334a:	ff 35 a4 64 03 40    	pushl  0x400364a4


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
40033350:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
40033353:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
40033356:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
40033359:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
4003335c:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
4003335f:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
40033360:	5d                   	pop    %ebp
	popl	%ebx
40033361:	5b                   	pop    %ebx
	popl	%esi
40033362:	5e                   	pop    %esi
	popl	%edi
40033363:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
40033364:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
40033368:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
40033369:	5a                   	pop    %edx
	movl	%edx, (%esp)
4003336a:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
4003336d:	c3                   	ret    

4003336e <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
4003336e:	55                   	push   %ebp
4003336f:	89 e5                	mov    %esp,%ebp
40033371:	56                   	push   %esi
40033372:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
40033373:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
40033376:	83 e3 fc             	and    $0xfffffffc,%ebx
{
40033379:	89 c6                	mov    %eax,%esi
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
4003337b:	8b 45 10             	mov    0x10(%ebp),%eax
4003337e:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
40033381:	8b 45 0c             	mov    0xc(%ebp),%eax
40033384:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
40033387:	8b 45 08             	mov    0x8(%ebp),%eax
4003338a:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
4003338d:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
40033390:	9c                   	pushf  
40033391:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033392:	80 e4 cd             	and    $0xcd,%ah
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
40033395:	c7 43 e8 60 00 03 40 	movl   $0x40030060,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
4003339c:	80 cc 02             	or     $0x2,%ah
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
4003339f:	8b 55 14             	mov    0x14(%ebp),%edx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400333a2:	89 43 ec             	mov    %eax,-0x14(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400333a5:	b9 04 00 00 00       	mov    $0x4,%ecx
400333aa:	ff 75 18             	pushl  0x18(%ebp)
400333ad:	89 f0                	mov    %esi,%eax
	pInitialCtx -= 11;
400333af:	83 eb 2c             	sub    $0x2c,%ebx
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400333b2:	e8 f4 0b 00 00       	call   40033fab <_init_thread_base>
	pInitialCtx -= 11;
400333b7:	89 5e 28             	mov    %ebx,0x28(%esi)
	thread->init_data = NULL;
400333ba:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
400333c1:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400333c8:	58                   	pop    %eax
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
400333c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
400333cc:	5b                   	pop    %ebx
400333cd:	5e                   	pop    %esi
400333ce:	5d                   	pop    %ebp
400333cf:	c3                   	ret    

400333d0 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
400333d0:	55                   	push   %ebp
400333d1:	89 e5                	mov    %esp,%ebp
400333d3:	5d                   	pop    %ebp
400333d4:	c3                   	ret    

400333d5 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
400333d5:	55                   	push   %ebp
400333d6:	89 e5                	mov    %esp,%ebp
400333d8:	57                   	push   %edi
400333d9:	56                   	push   %esi
400333da:	53                   	push   %ebx
400333db:	83 ec 28             	sub    $0x28,%esp
400333de:	89 c6                	mov    %eax,%esi
	_debug_fatal_hook(pEsf);
400333e0:	89 d0                	mov    %edx,%eax
{
400333e2:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
400333e4:	e8 e7 ff ff ff       	call   400333d0 <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
400333e9:	83 fe 03             	cmp    $0x3,%esi
400333ec:	74 3e                	je     4003342c <_NanoFatalErrorHandler+0x57>
400333ee:	77 06                	ja     400333f6 <_NanoFatalErrorHandler+0x21>
400333f0:	85 f6                	test   %esi,%esi
400333f2:	74 0e                	je     40033402 <_NanoFatalErrorHandler+0x2d>
400333f4:	eb 4a                	jmp    40033440 <_NanoFatalErrorHandler+0x6b>
400333f6:	83 fe 05             	cmp    $0x5,%esi
400333f9:	74 3e                	je     40033439 <_NanoFatalErrorHandler+0x64>
400333fb:	83 fe 06             	cmp    $0x6,%esi
400333fe:	74 4d                	je     4003344d <_NanoFatalErrorHandler+0x78>
40033400:	eb 3e                	jmp    40033440 <_NanoFatalErrorHandler+0x6b>
40033402:	e8 10 d1 ff ff       	call   40030517 <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
40033407:	68 ce 62 03 40       	push   $0x400362ce
4003340c:	89 c3                	mov    %eax,%ebx
4003340e:	e8 01 dd ff ff       	call   40031114 <printk>
40033413:	58                   	pop    %eax
		if (vector >= 0) {
40033414:	85 db                	test   %ebx,%ebx
40033416:	78 0d                	js     40033425 <_NanoFatalErrorHandler+0x50>
			printk("%d ", vector);
40033418:	53                   	push   %ebx
40033419:	68 f0 62 03 40       	push   $0x400362f0
4003341e:	e8 f1 dc ff ff       	call   40031114 <printk>
40033423:	5b                   	pop    %ebx
40033424:	58                   	pop    %eax
		}
		printk("*****\n");
40033425:	68 17 63 03 40       	push   $0x40036317
4003342a:	eb 05                	jmp    40033431 <_NanoFatalErrorHandler+0x5c>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
4003342c:	68 f4 62 03 40       	push   $0x400362f4
40033431:	e8 de dc ff ff       	call   40031114 <printk>
40033436:	59                   	pop    %ecx
		break;
40033437:	eb 14                	jmp    4003344d <_NanoFatalErrorHandler+0x78>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40033439:	68 1e 63 03 40       	push   $0x4003631e
4003343e:	eb f1                	jmp    40033431 <_NanoFatalErrorHandler+0x5c>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
40033440:	56                   	push   %esi
40033441:	68 44 63 03 40       	push   $0x40036344
40033446:	e8 c9 dc ff ff       	call   40031114 <printk>
4003344b:	58                   	pop    %eax
4003344c:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
4003344d:	8b 47 04             	mov    0x4(%edi),%eax
40033450:	8b 4f 2c             	mov    0x2c(%edi),%ecx
40033453:	89 45 f0             	mov    %eax,-0x10(%ebp)
40033456:	8b 47 10             	mov    0x10(%edi),%eax
40033459:	89 45 ec             	mov    %eax,-0x14(%ebp)
4003345c:	8b 47 0c             	mov    0xc(%edi),%eax
4003345f:	89 45 e8             	mov    %eax,-0x18(%ebp)
40033462:	8b 47 14             	mov    0x14(%edi),%eax
40033465:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40033468:	8b 47 1c             	mov    0x1c(%edi),%eax
4003346b:	89 45 e0             	mov    %eax,-0x20(%ebp)
4003346e:	8b 47 08             	mov    0x8(%edi),%eax
40033471:	89 45 dc             	mov    %eax,-0x24(%ebp)
40033474:	8b 47 18             	mov    0x18(%edi),%eax
40033477:	8b 17                	mov    (%edi),%edx
40033479:	89 45 d8             	mov    %eax,-0x28(%ebp)
4003347c:	8b 47 24             	mov    0x24(%edi),%eax
4003347f:	89 4d cc             	mov    %ecx,-0x34(%ebp)
40033482:	89 55 d0             	mov    %edx,-0x30(%ebp)
40033485:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40033488:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
4003348c:	e8 b3 05 00 00       	call   40033a44 <k_current_get>
40033491:	8b 55 d0             	mov    -0x30(%ebp),%edx
40033494:	8b 4d cc             	mov    -0x34(%ebp),%ecx
40033497:	51                   	push   %ecx
40033498:	52                   	push   %edx
40033499:	ff 75 f0             	pushl  -0x10(%ebp)
4003349c:	ff 75 ec             	pushl  -0x14(%ebp)
4003349f:	ff 75 e8             	pushl  -0x18(%ebp)
400334a2:	ff 75 e4             	pushl  -0x1c(%ebp)
400334a5:	ff 75 e0             	pushl  -0x20(%ebp)
400334a8:	ff 75 dc             	pushl  -0x24(%ebp)
400334ab:	ff 75 d8             	pushl  -0x28(%ebp)
400334ae:	ff 75 d4             	pushl  -0x2c(%ebp)
400334b1:	53                   	push   %ebx
400334b2:	50                   	push   %eax
400334b3:	68 67 63 03 40       	push   $0x40036367
400334b8:	e8 57 dc ff ff       	call   40031114 <printk>
400334bd:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
400334c0:	89 fa                	mov    %edi,%edx
400334c2:	89 f0                	mov    %esi,%eax
400334c4:	e8 60 fd ff ff       	call   40033229 <_SysFatalErrorHandler>

400334c9 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
400334c9:	55                   	push   %ebp
400334ca:	89 e5                	mov    %esp,%ebp
400334cc:	56                   	push   %esi
400334cd:	89 c6                	mov    %eax,%esi
400334cf:	53                   	push   %ebx
400334d0:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
400334d2:	50                   	push   %eax
400334d3:	68 06 64 03 40       	push   $0x40036406
400334d8:	e8 37 dc ff ff       	call   40031114 <printk>
400334dd:	59                   	pop    %ecx
400334de:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
400334df:	b8 00 7d 02 00       	mov    $0x27d00,%eax
400334e4:	0f a3 f0             	bt     %esi,%eax
400334e7:	73 0f                	jae    400334f8 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
400334e9:	ff 73 20             	pushl  0x20(%ebx)
400334ec:	68 1e 64 03 40       	push   $0x4003641e
400334f1:	e8 1e dc ff ff       	call   40031114 <printk>
400334f6:	58                   	pop    %eax
400334f7:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
400334f8:	89 da                	mov    %ebx,%edx
400334fa:	b8 06 00 00 00       	mov    $0x6,%eax
400334ff:	e8 d1 fe ff ff       	call   400333d5 <_NanoFatalErrorHandler>

40033504 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
40033504:	55                   	push   %ebp
40033505:	89 c2                	mov    %eax,%edx
40033507:	89 e5                	mov    %esp,%ebp
40033509:	31 c0                	xor    %eax,%eax
4003350b:	e8 b9 ff ff ff       	call   400334c9 <generic_exc_handle>

40033510 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
40033510:	55                   	push   %ebp
40033511:	89 c2                	mov    %eax,%edx
40033513:	89 e5                	mov    %esp,%ebp
40033515:	b8 02 00 00 00       	mov    $0x2,%eax
4003351a:	e8 aa ff ff ff       	call   400334c9 <generic_exc_handle>

4003351f <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
4003351f:	55                   	push   %ebp
40033520:	89 c2                	mov    %eax,%edx
40033522:	89 e5                	mov    %esp,%ebp
40033524:	b8 04 00 00 00       	mov    $0x4,%eax
40033529:	e8 9b ff ff ff       	call   400334c9 <generic_exc_handle>

4003352e <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
4003352e:	55                   	push   %ebp
4003352f:	89 c2                	mov    %eax,%edx
40033531:	89 e5                	mov    %esp,%ebp
40033533:	b8 05 00 00 00       	mov    $0x5,%eax
40033538:	e8 8c ff ff ff       	call   400334c9 <generic_exc_handle>

4003353d <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
4003353d:	55                   	push   %ebp
4003353e:	89 c2                	mov    %eax,%edx
40033540:	89 e5                	mov    %esp,%ebp
40033542:	b8 06 00 00 00       	mov    $0x6,%eax
40033547:	e8 7d ff ff ff       	call   400334c9 <generic_exc_handle>

4003354c <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
4003354c:	55                   	push   %ebp
4003354d:	89 c2                	mov    %eax,%edx
4003354f:	89 e5                	mov    %esp,%ebp
40033551:	b8 07 00 00 00       	mov    $0x7,%eax
40033556:	e8 6e ff ff ff       	call   400334c9 <generic_exc_handle>

4003355b <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
4003355b:	55                   	push   %ebp
4003355c:	89 c2                	mov    %eax,%edx
4003355e:	89 e5                	mov    %esp,%ebp
40033560:	b8 08 00 00 00       	mov    $0x8,%eax
40033565:	e8 5f ff ff ff       	call   400334c9 <generic_exc_handle>

4003356a <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
4003356a:	55                   	push   %ebp
4003356b:	89 c2                	mov    %eax,%edx
4003356d:	89 e5                	mov    %esp,%ebp
4003356f:	b8 0a 00 00 00       	mov    $0xa,%eax
40033574:	e8 50 ff ff ff       	call   400334c9 <generic_exc_handle>

40033579 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
40033579:	55                   	push   %ebp
4003357a:	89 c2                	mov    %eax,%edx
4003357c:	89 e5                	mov    %esp,%ebp
4003357e:	b8 0b 00 00 00       	mov    $0xb,%eax
40033583:	e8 41 ff ff ff       	call   400334c9 <generic_exc_handle>

40033588 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
40033588:	55                   	push   %ebp
40033589:	89 c2                	mov    %eax,%edx
4003358b:	89 e5                	mov    %esp,%ebp
4003358d:	b8 0c 00 00 00       	mov    $0xc,%eax
40033592:	e8 32 ff ff ff       	call   400334c9 <generic_exc_handle>

40033597 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
40033597:	55                   	push   %ebp
40033598:	89 c2                	mov    %eax,%edx
4003359a:	89 e5                	mov    %esp,%ebp
4003359c:	b8 0d 00 00 00       	mov    $0xd,%eax
400335a1:	e8 23 ff ff ff       	call   400334c9 <generic_exc_handle>

400335a6 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
400335a6:	55                   	push   %ebp
400335a7:	89 c2                	mov    %eax,%edx
400335a9:	89 e5                	mov    %esp,%ebp
400335ab:	b8 0e 00 00 00       	mov    $0xe,%eax
400335b0:	e8 14 ff ff ff       	call   400334c9 <generic_exc_handle>

400335b5 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
400335b5:	55                   	push   %ebp
400335b6:	89 c2                	mov    %eax,%edx
400335b8:	89 e5                	mov    %esp,%ebp
400335ba:	b8 10 00 00 00       	mov    $0x10,%eax
400335bf:	e8 05 ff ff ff       	call   400334c9 <generic_exc_handle>

400335c4 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
400335c4:	55                   	push   %ebp
400335c5:	89 c2                	mov    %eax,%edx
400335c7:	89 e5                	mov    %esp,%ebp
400335c9:	b8 11 00 00 00       	mov    $0x11,%eax
400335ce:	e8 f6 fe ff ff       	call   400334c9 <generic_exc_handle>

400335d3 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
400335d3:	55                   	push   %ebp
400335d4:	89 c2                	mov    %eax,%edx
400335d6:	89 e5                	mov    %esp,%ebp
400335d8:	b8 12 00 00 00       	mov    $0x12,%eax
400335dd:	e8 e7 fe ff ff       	call   400334c9 <generic_exc_handle>

400335e2 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
400335e2:	55                   	push   %ebp
400335e3:	89 e5                	mov    %esp,%ebp
400335e5:	56                   	push   %esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
400335e6:	8d 70 01             	lea    0x1(%eax),%esi
{
400335e9:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
400335ea:	8b 1c 85 80 64 03 40 	mov    0x40036480(,%eax,4),%ebx
400335f1:	3b 1c b5 80 64 03 40 	cmp    0x40036480(,%esi,4),%ebx
400335f8:	73 0c                	jae    40033606 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
400335fa:	8b 13                	mov    (%ebx),%edx
400335fc:	89 d8                	mov    %ebx,%eax
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
400335fe:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
40033601:	ff 52 04             	call   *0x4(%edx)
40033604:	eb eb                	jmp    400335f1 <_sys_device_do_config_level+0xf>
	}
}
40033606:	5b                   	pop    %ebx
40033607:	5e                   	pop    %esi
40033608:	5d                   	pop    %ebp
40033609:	c3                   	ret    

4003360a <device_get_binding>:

struct device *device_get_binding(const char *name)
{
4003360a:	55                   	push   %ebp
4003360b:	89 e5                	mov    %esp,%ebp
4003360d:	56                   	push   %esi
4003360e:	89 c6                	mov    %eax,%esi
40033610:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40033611:	bb f4 66 00 a8       	mov    $0xa80066f4,%ebx
40033616:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
4003361c:	74 1c                	je     4003363a <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
4003361e:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
40033622:	75 05                	jne    40033629 <device_get_binding+0x1f>
	for (info = __device_init_start; info != __device_init_end; info++) {
40033624:	83 c3 0c             	add    $0xc,%ebx
40033627:	eb ed                	jmp    40033616 <device_get_binding+0xc>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033629:	8b 03                	mov    (%ebx),%eax
4003362b:	8b 10                	mov    (%eax),%edx
4003362d:	89 f0                	mov    %esi,%eax
4003362f:	e8 47 0d 00 00       	call   4003437b <strcmp>
40033634:	85 c0                	test   %eax,%eax
40033636:	75 ec                	jne    40033624 <device_get_binding+0x1a>
40033638:	eb 02                	jmp    4003363c <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
4003363a:	31 db                	xor    %ebx,%ebx
}
4003363c:	89 d8                	mov    %ebx,%eax
4003363e:	5b                   	pop    %ebx
4003363f:	5e                   	pop    %esi
40033640:	5d                   	pop    %ebp
40033641:	c3                   	ret    

40033642 <device_busy_set>:
40033642:	55                   	push   %ebp
40033643:	89 e5                	mov    %esp,%ebp
40033645:	5d                   	pop    %ebp
40033646:	c3                   	ret    

40033647 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
40033647:	55                   	push   %ebp
40033648:	89 e5                	mov    %esp,%ebp
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
4003364a:	5d                   	pop    %ebp
4003364b:	c3                   	ret    

4003364c <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
4003364c:	55                   	push   %ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
4003364d:	b8 02 00 00 00       	mov    $0x2,%eax
{
40033652:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40033654:	e8 89 ff ff ff       	call   400335e2 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40033659:	b8 05 00 00 00       	mov    $0x5,%eax
4003365e:	e8 7f ff ff ff       	call   400335e2 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
40033663:	b8 06 00 00 00       	mov    $0x6,%eax
40033668:	e8 75 ff ff ff       	call   400335e2 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
4003366d:	b8 07 00 00 00       	mov    $0x7,%eax
40033672:	e8 6b ff ff ff       	call   400335e2 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
40033677:	b8 03 00 00 00       	mov    $0x3,%eax
4003367c:	e8 61 ff ff ff       	call   400335e2 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
40033681:	e8 ac 08 00 00       	call   40033f32 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
40033686:	e8 26 cb ff ff       	call   400301b1 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}
4003368b:	5d                   	pop    %ebp
	_main_thread->base.user_options &= ~K_ESSENTIAL;
4003368c:	80 25 e4 81 00 a8 fe 	andb   $0xfe,0xa80081e4
}
40033693:	c3                   	ret    

40033694 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40033694:	55                   	push   %ebp
40033695:	89 e5                	mov    %esp,%ebp
40033697:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
4003369a:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
4003369d:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
400336a1:	a3 c8 76 00 a8       	mov    %eax,0xa80076c8
	dummy_thread->base.user_options = K_ESSENTIAL;
400336a6:	b8 1c 00 00 00       	mov    $0x1c,%eax
400336ab:	8d 90 c0 76 00 a8    	lea    -0x57ff8940(%eax),%edx
400336b1:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
400336b4:	89 90 b8 76 00 a8    	mov    %edx,-0x57ff8948(%eax)
	list->tail = (sys_dnode_t *)list;
400336ba:	89 90 bc 76 00 a8    	mov    %edx,-0x57ff8944(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
400336c0:	3d 1c 01 00 00       	cmp    $0x11c,%eax
400336c5:	75 e4                	jne    400336ab <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
400336c7:	6a 01                	push   $0x1
400336c9:	b9 4c 36 03 40       	mov    $0x4003364c,%ecx
400336ce:	6a 00                	push   $0x0
400336d0:	ba 00 04 00 00       	mov    $0x400,%edx
400336d5:	6a 00                	push   $0x0
400336d7:	b8 dc 81 00 a8       	mov    $0xa80081dc,%eax
400336dc:	6a 00                	push   $0x0
400336de:	6a 00                	push   $0x0
	_ready_q.cache = _main_thread;
400336e0:	c7 05 d4 76 00 a8 dc 	movl   $0xa80081dc,0xa80076d4
400336e7:	81 00 a8 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
400336ea:	e8 7f fc ff ff       	call   4003336e <_new_thread>
400336ef:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_main_thread);
400336f2:	b8 dc 81 00 a8       	mov    $0xa80081dc,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
400336f7:	80 25 e5 81 00 a8 fb 	andb   $0xfb,0xa80081e5
400336fe:	e8 2c 01 00 00       	call   4003382f <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
40033703:	b9 cf 2c 03 40       	mov    $0x40032ccf,%ecx
40033708:	ba 00 01 00 00       	mov    $0x100,%edx
4003370d:	6a 01                	push   $0x1
4003370f:	b8 dc 80 00 a8       	mov    $0xa80080dc,%eax
40033714:	6a 0f                	push   $0xf
40033716:	6a 00                	push   $0x0
40033718:	6a 00                	push   $0x0
4003371a:	6a 00                	push   $0x0
4003371c:	e8 4d fc ff ff       	call   4003336e <_new_thread>
40033721:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_idle_thread);
40033724:	b8 dc 80 00 a8       	mov    $0xa80080dc,%eax
40033729:	80 25 e5 80 00 a8 fb 	andb   $0xfb,0xa80080e5
40033730:	e8 fa 00 00 00       	call   4003382f <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
40033735:	b8 04 00 00 00       	mov    $0x4,%eax
	list->head = (sys_dnode_t *)list;
4003373a:	c7 05 cc 76 00 a8 cc 	movl   $0xa80076cc,0xa80076cc
40033741:	76 00 a8 
	list->tail = (sys_dnode_t *)list;
40033744:	c7 05 d0 76 00 a8 cc 	movl   $0xa80076cc,0xa80076d0
4003374b:	76 00 a8 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
4003374e:	c7 05 c0 76 00 a8 00 	movl   $0x0,0xa80076c0
40033755:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
40033758:	c7 05 c4 76 00 a8 dc 	movl   $0xa80080dc,0xa80076c4
4003375f:	80 00 a8 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
40033762:	c7 05 c0 78 00 a8 00 	movl   $0x800,0xa80078c0
40033769:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
4003376c:	c7 05 a4 78 00 a8 a3 	movl   $0x400332a3,0xa80078a4
40033773:	32 03 40 
40033776:	e8 67 fe ff ff       	call   400335e2 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
4003377b:	31 c0                	xor    %eax,%eax
4003377d:	e8 60 fe ff ff       	call   400335e2 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
40033782:	b8 01 00 00 00       	mov    $0x1,%eax
40033787:	e8 56 fe ff ff       	call   400335e2 <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
4003378c:	68 a8 64 03 40       	push   $0x400364a8
40033791:	68 c4 64 03 40       	push   $0x400364c4
40033796:	e8 79 d9 ff ff       	call   40031114 <printk>
4003379b:	58                   	pop    %eax
4003379c:	5a                   	pop    %edx
	__asm__ volatile (
4003379d:	9c                   	pushf  
4003379e:	fa                   	cli    
4003379f:	58                   	pop    %eax
	_Swap(irq_lock());
400337a0:	e8 95 fb ff ff       	call   4003333a <_Swap>

400337a5 <_get_highest_ready_prio>:
{
400337a5:	55                   	push   %ebp
400337a6:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
400337a8:	0f bc 05 d8 76 00 a8 	bsf    0xa80076d8,%eax
400337af:	75 05                	jne    400337b6 <_get_highest_ready_prio+0x11>
400337b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
400337b6:	83 e8 10             	sub    $0x10,%eax
}
400337b9:	5d                   	pop    %ebp
400337ba:	c3                   	ret    

400337bb <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
400337bb:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
400337bc:	89 42 08             	mov    %eax,0x8(%edx)
{
400337bf:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
400337c1:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
400337c4:	53                   	push   %ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
400337c5:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
400337ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
400337cd:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
400337cf:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
400337d2:	74 07                	je     400337db <_add_timeout+0x20>
400337d4:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
400337d9:	75 1d                	jne    400337f8 <_add_timeout+0x3d>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
400337db:	c7 02 cc 76 00 a8    	movl   $0xa80076cc,(%edx)
	node->prev = list->tail;
400337e1:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
400337e6:	89 42 04             	mov    %eax,0x4(%edx)

	list->tail->next = node;
400337e9:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
400337ee:	89 10                	mov    %edx,(%eax)
	list->tail = node;
400337f0:	89 15 d0 76 00 a8    	mov    %edx,0xa80076d0
400337f6:	eb 34                	jmp    4003382c <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
400337f8:	8b 4a 10             	mov    0x10(%edx),%ecx
400337fb:	8b 58 10             	mov    0x10(%eax),%ebx
400337fe:	39 d9                	cmp    %ebx,%ecx
40033800:	7f 17                	jg     40033819 <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
40033802:	29 cb                	sub    %ecx,%ebx
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
40033804:	8b 48 04             	mov    0x4(%eax),%ecx
40033807:	89 58 10             	mov    %ebx,0x10(%eax)
4003380a:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
4003380d:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
4003380f:	8b 48 04             	mov    0x4(%eax),%ecx
40033812:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
40033814:	89 50 04             	mov    %edx,0x4(%eax)
40033817:	eb 13                	jmp    4003382c <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
40033819:	29 d9                	sub    %ebx,%ecx
4003381b:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
4003381e:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
40033824:	74 b5                	je     400337db <_add_timeout+0x20>
40033826:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033828:	85 c0                	test   %eax,%eax
4003382a:	eb ad                	jmp    400337d9 <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
4003382c:	5b                   	pop    %ebx
4003382d:	5d                   	pop    %ebp
4003382e:	c3                   	ret    

4003382f <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
4003382f:	55                   	push   %ebp
40033830:	89 e5                	mov    %esp,%ebp
40033832:	56                   	push   %esi
40033833:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033834:	bb 01 00 00 00       	mov    $0x1,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033839:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
4003383d:	8d 4a 10             	lea    0x10(%edx),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033840:	89 ce                	mov    %ecx,%esi
40033842:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033845:	d3 e3                	shl    %cl,%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
40033847:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx
	node->prev = list->tail;
4003384e:	83 c2 14             	add    $0x14,%edx
	*bmap |= _get_ready_q_prio_bit(prio);
40033851:	09 1c b5 d8 76 00 a8 	or     %ebx,-0x57ff8928(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
40033858:	89 08                	mov    %ecx,(%eax)
4003385a:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40033861:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40033864:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
4003386b:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
4003386d:	89 04 d5 c0 76 00 a8 	mov    %eax,-0x57ff8940(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033874:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
4003387a:	8a 5a 0a             	mov    0xa(%edx),%bl
4003387d:	38 58 0a             	cmp    %bl,0xa(%eax)
40033880:	7c 02                	jl     40033884 <_add_thread_to_ready_q+0x55>
40033882:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
40033884:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033885:	a3 d4 76 00 a8       	mov    %eax,0xa80076d4
}
4003388a:	5e                   	pop    %esi
4003388b:	5d                   	pop    %ebp
4003388c:	c3                   	ret    

4003388d <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
4003388d:	55                   	push   %ebp
4003388e:	89 e5                	mov    %esp,%ebp
40033890:	53                   	push   %ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40033891:	8b 48 04             	mov    0x4(%eax),%ecx
40033894:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033896:	0f be 50 0a          	movsbl 0xa(%eax),%edx
4003389a:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
4003389c:	8b 18                	mov    (%eax),%ebx
4003389e:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
400338a1:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
400338a8:	3b 0c d5 5c 77 00 a8 	cmp    -0x57ff88a4(,%edx,8),%ecx
400338af:	75 1c                	jne    400338cd <_remove_thread_from_ready_q+0x40>
		_clear_ready_q_prio_bit(thread->base.prio);
400338b1:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
400338b5:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
400338b8:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
400338bd:	89 cb                	mov    %ecx,%ebx
400338bf:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
400338c2:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
400338c4:	f7 d2                	not    %edx
400338c6:	21 14 9d d8 76 00 a8 	and    %edx,-0x57ff8928(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
400338cd:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
400338d3:	39 d0                	cmp    %edx,%eax
400338d5:	75 0c                	jne    400338e3 <_remove_thread_from_ready_q+0x56>
	int prio = _get_highest_ready_prio();
400338d7:	e8 c9 fe ff ff       	call   400337a5 <_get_highest_ready_prio>
400338dc:	8b 14 c5 5c 77 00 a8 	mov    -0x57ff88a4(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
400338e3:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
400338e4:	89 15 d4 76 00 a8    	mov    %edx,0xa80076d4
}
400338ea:	5d                   	pop    %ebp
400338eb:	c3                   	ret    

400338ec <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
400338ec:	55                   	push   %ebp
400338ed:	89 e5                	mov    %esp,%ebp
400338ef:	57                   	push   %edi
400338f0:	56                   	push   %esi
400338f1:	53                   	push   %ebx
	return list->head == list;
400338f2:	8b 1a                	mov    (%edx),%ebx
400338f4:	89 cf                	mov    %ecx,%edi
	return sys_dlist_is_empty(list) ? NULL : list->head;
400338f6:	39 da                	cmp    %ebx,%edx
400338f8:	75 0b                	jne    40033905 <_pend_thread+0x19>
400338fa:	31 db                	xor    %ebx,%ebx
400338fc:	eb 07                	jmp    40033905 <_pend_thread+0x19>
	return (node == list->tail) ? NULL : node->next;
400338fe:	3b 5a 04             	cmp    0x4(%edx),%ebx
40033901:	74 20                	je     40033923 <_pend_thread+0x37>
40033903:	8b 1b                	mov    (%ebx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
40033905:	85 db                	test   %ebx,%ebx
40033907:	74 1a                	je     40033923 <_pend_thread+0x37>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
40033909:	8a 4b 0a             	mov    0xa(%ebx),%cl
4003390c:	38 48 0a             	cmp    %cl,0xa(%eax)
4003390f:	7d ed                	jge    400338fe <_pend_thread+0x12>
		node->prev = insert_point->prev;
40033911:	8b 73 04             	mov    0x4(%ebx),%esi
		node->next = insert_point;
40033914:	89 18                	mov    %ebx,(%eax)
		node->prev = insert_point->prev;
40033916:	89 70 04             	mov    %esi,0x4(%eax)
		insert_point->prev->next = node;
40033919:	8b 73 04             	mov    0x4(%ebx),%esi
4003391c:	89 06                	mov    %eax,(%esi)
		insert_point->prev = node;
4003391e:	89 43 04             	mov    %eax,0x4(%ebx)
40033921:	eb 10                	jmp    40033933 <_pend_thread+0x47>
	node->next = list;
40033923:	89 10                	mov    %edx,(%eax)
	node->prev = list->tail;
40033925:	8b 5a 04             	mov    0x4(%edx),%ebx
40033928:	89 58 04             	mov    %ebx,0x4(%eax)
	list->tail->next = node;
4003392b:	8b 5a 04             	mov    0x4(%edx),%ebx
4003392e:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
40033930:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state |= _THREAD_PENDING;
40033933:	80 48 09 02          	orb    $0x2,0x9(%eax)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
40033937:	83 ff ff             	cmp    $0xffffffff,%edi
4003393a:	74 1f                	je     4003395b <_pend_thread+0x6f>
4003393c:	89 d1                	mov    %edx,%ecx
4003393e:	89 c3                	mov    %eax,%ebx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40033940:	8d 70 10             	lea    0x10(%eax),%esi
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40033943:	31 d2                	xor    %edx,%edx
40033945:	8d 47 09             	lea    0x9(%edi),%eax
40033948:	bf 0a 00 00 00       	mov    $0xa,%edi
4003394d:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
4003394f:	40                   	inc    %eax
40033950:	89 f2                	mov    %esi,%edx
40033952:	50                   	push   %eax
40033953:	89 d8                	mov    %ebx,%eax
40033955:	e8 61 fe ff ff       	call   400337bb <_add_timeout>
4003395a:	58                   	pop    %eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
4003395b:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003395e:	5b                   	pop    %ebx
4003395f:	5e                   	pop    %esi
40033960:	5f                   	pop    %edi
40033961:	5d                   	pop    %ebp
40033962:	c3                   	ret    

40033963 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
40033963:	55                   	push   %ebp
40033964:	89 e5                	mov    %esp,%ebp
40033966:	56                   	push   %esi
40033967:	53                   	push   %ebx
40033968:	89 c3                	mov    %eax,%ebx
	_remove_thread_from_ready_q(_current);
4003396a:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
4003396f:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
40033971:	e8 17 ff ff ff       	call   4003388d <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
40033976:	89 f1                	mov    %esi,%ecx
40033978:	89 da                	mov    %ebx,%edx
4003397a:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
}
4003397f:	5b                   	pop    %ebx
40033980:	5e                   	pop    %esi
40033981:	5d                   	pop    %ebp
	_pend_thread(_current, wait_q, timeout);
40033982:	e9 65 ff ff ff       	jmp    400338ec <_pend_thread>

40033987 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
40033987:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
40033988:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
4003398d:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
4003398f:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40033993:	e8 0d fe ff ff       	call   400337a5 <_get_highest_ready_prio>
#else
	return 0;
#endif
}
40033998:	5d                   	pop    %ebp
	return prio1 < prio2;
40033999:	39 c2                	cmp    %eax,%edx
4003399b:	0f 9f c0             	setg   %al
4003399e:	0f b6 c0             	movzbl %al,%eax
400339a1:	c3                   	ret    

400339a2 <_reschedule_threads>:
{
400339a2:	89 c1                	mov    %eax,%ecx
	return _is_preempt(_current) && __must_switch_threads();
400339a4:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
400339a9:	55                   	push   %ebp
400339aa:	89 e5                	mov    %esp,%ebp
400339ac:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
400339b1:	77 09                	ja     400339bc <_reschedule_threads+0x1a>
400339b3:	e8 cf ff ff ff       	call   40033987 <__must_switch_threads>
400339b8:	85 c0                	test   %eax,%eax
400339ba:	75 09                	jne    400339c5 <_reschedule_threads+0x23>
400339bc:	0f ba e1 09          	bt     $0x9,%ecx
400339c0:	73 0b                	jae    400339cd <_reschedule_threads+0x2b>
	__asm__ volatile (
400339c2:	fb                   	sti    
}
400339c3:	eb 08                	jmp    400339cd <_reschedule_threads+0x2b>
		_Swap(key);
400339c5:	89 c8                	mov    %ecx,%eax
}
400339c7:	5d                   	pop    %ebp
		_Swap(key);
400339c8:	e9 6d f9 ff ff       	jmp    4003333a <_Swap>
}
400339cd:	5d                   	pop    %ebp
400339ce:	c3                   	ret    

400339cf <k_sched_unlock>:
{
400339cf:	55                   	push   %ebp
400339d0:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
400339d2:	9c                   	pushf  
400339d3:	fa                   	cli    
400339d4:	58                   	pop    %eax
	++_current->base.sched_locked;
400339d5:	8b 15 c8 76 00 a8    	mov    0xa80076c8,%edx
400339db:	fe 42 0b             	incb   0xb(%edx)
}
400339de:	5d                   	pop    %ebp
	_reschedule_threads(key);
400339df:	e9 be ff ff ff       	jmp    400339a2 <_reschedule_threads>

400339e4 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
400339e4:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
400339e8:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
400339ef:	3b 41 04             	cmp    0x4(%ecx),%eax
400339f2:	74 4f                	je     40033a43 <_move_thread_to_end_of_prio_q+0x5f>
{
400339f4:	55                   	push   %ebp
	node->prev = list->tail;
400339f5:	83 c2 14             	add    $0x14,%edx
400339f8:	89 e5                	mov    %esp,%ebp
400339fa:	56                   	push   %esi
400339fb:	53                   	push   %ebx
	node->prev->next = node->next;
400339fc:	8b 58 04             	mov    0x4(%eax),%ebx
400339ff:	8b 30                	mov    (%eax),%esi
40033a01:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
40033a03:	8b 30                	mov    (%eax),%esi
40033a05:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
40033a08:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
40033a0a:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40033a11:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40033a14:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40033a1b:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40033a1d:	89 04 d5 c0 76 00 a8 	mov    %eax,-0x57ff8940(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033a24:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
40033a2a:	39 d0                	cmp    %edx,%eax
40033a2c:	75 0c                	jne    40033a3a <_move_thread_to_end_of_prio_q+0x56>
	int prio = _get_highest_ready_prio();
40033a2e:	e8 72 fd ff ff       	call   400337a5 <_get_highest_ready_prio>
40033a33:	8b 14 c5 5c 77 00 a8 	mov    -0x57ff88a4(,%eax,8),%edx
#endif
}
40033a3a:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033a3b:	89 15 d4 76 00 a8    	mov    %edx,0xa80076d4
}
40033a41:	5e                   	pop    %esi
40033a42:	5d                   	pop    %ebp
40033a43:	c3                   	ret    

40033a44 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
40033a44:	55                   	push   %ebp
	return _current;
}
40033a45:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
40033a4a:	89 e5                	mov    %esp,%ebp
}
40033a4c:	5d                   	pop    %ebp
40033a4d:	c3                   	ret    

40033a4e <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033a4e:	8a 50 09             	mov    0x9(%eax),%dl
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
40033a51:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033a52:	88 d1                	mov    %dl,%cl
{
40033a54:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033a56:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40033a59:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033a5c:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40033a5f:	75 0c                	jne    40033a6d <_ready_thread+0x1f>
40033a61:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033a65:	75 06                	jne    40033a6d <_ready_thread+0x1f>
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
	}
}
40033a67:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40033a68:	e9 c2 fd ff ff       	jmp    4003382f <_add_thread_to_ready_q>
}
40033a6d:	5d                   	pop    %ebp
40033a6e:	c3                   	ret    

40033a6f <_unpend_first_thread>:
}

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
40033a6f:	55                   	push   %ebp
	if (_handling_timeouts) {
40033a70:	8b 15 c4 78 00 a8    	mov    0xa80078c4,%edx
{
40033a76:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
40033a78:	85 d2                	test   %edx,%edx
40033a7a:	8b 08                	mov    (%eax),%ecx
40033a7c:	74 1f                	je     40033a9d <_unpend_first_thread+0x2e>
	return list->head == list;
40033a7e:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033a80:	39 c8                	cmp    %ecx,%eax
40033a82:	75 11                	jne    40033a95 <_unpend_first_thread+0x26>
40033a84:	31 d2                	xor    %edx,%edx
40033a86:	eb 0d                	jmp    40033a95 <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
40033a88:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
40033a8c:	75 1b                	jne    40033aa9 <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
40033a8e:	3b 50 04             	cmp    0x4(%eax),%edx
40033a91:	74 06                	je     40033a99 <_unpend_first_thread+0x2a>
40033a93:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
40033a95:	85 d2                	test   %edx,%edx
40033a97:	75 ef                	jne    40033a88 <_unpend_first_thread+0x19>
40033a99:	31 d2                	xor    %edx,%edx
40033a9b:	eb 1c                	jmp    40033ab9 <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033a9d:	31 d2                	xor    %edx,%edx
40033a9f:	39 c8                	cmp    %ecx,%eax
40033aa1:	74 16                	je     40033ab9 <_unpend_first_thread+0x4a>
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
40033aa3:	85 c9                	test   %ecx,%ecx
40033aa5:	74 12                	je     40033ab9 <_unpend_first_thread+0x4a>
40033aa7:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
40033aa9:	8b 42 04             	mov    0x4(%edx),%eax
40033aac:	8b 0a                	mov    (%edx),%ecx
40033aae:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40033ab0:	8b 0a                	mov    (%edx),%ecx
40033ab2:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033ab5:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
40033ab9:	89 d0                	mov    %edx,%eax
40033abb:	5d                   	pop    %ebp
40033abc:	c3                   	ret    

40033abd <_abort_timeout>:
{
40033abd:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033abe:	8b 48 10             	mov    0x10(%eax),%ecx
{
40033ac1:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033ac3:	83 f9 ff             	cmp    $0xffffffff,%ecx
40033ac6:	74 24                	je     40033aec <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
40033ac8:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
40033ace:	74 05                	je     40033ad5 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40033ad0:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40033ad2:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40033ad5:	8b 50 04             	mov    0x4(%eax),%edx
40033ad8:	8b 08                	mov    (%eax),%ecx
40033ada:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033adc:	8b 08                	mov    (%eax),%ecx
40033ade:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40033ae1:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
40033ae8:	31 c0                	xor    %eax,%eax
40033aea:	eb 03                	jmp    40033aef <_abort_timeout+0x32>
		return _INACTIVE;
40033aec:	83 c8 ff             	or     $0xffffffff,%eax
}
40033aef:	5d                   	pop    %ebp
40033af0:	c3                   	ret    

40033af1 <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
40033af1:	55                   	push   %ebp
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
40033af2:	89 50 08             	mov    %edx,0x8(%eax)
{
40033af5:	89 e5                	mov    %esp,%ebp
	sem->limit = limit;
40033af7:	89 48 0c             	mov    %ecx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
40033afa:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
40033afc:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
40033aff:	5d                   	pop    %ebp
40033b00:	c3                   	ret    

40033b01 <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
40033b01:	55                   	push   %ebp
40033b02:	89 e5                	mov    %esp,%ebp
40033b04:	57                   	push   %edi
40033b05:	56                   	push   %esi
40033b06:	89 c6                	mov    %eax,%esi
40033b08:	53                   	push   %ebx
40033b09:	9c                   	pushf  
40033b0a:	fa                   	cli    
40033b0b:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
40033b0c:	e8 5e ff ff ff       	call   40033a6f <_unpend_first_thread>
	if (!thread) {
40033b11:	85 c0                	test   %eax,%eax
40033b13:	75 12                	jne    40033b27 <k_sem_give+0x26>
	sem->count += (sem->count != sem->limit);
40033b15:	8b 56 08             	mov    0x8(%esi),%edx
40033b18:	31 c0                	xor    %eax,%eax
40033b1a:	39 56 0c             	cmp    %edx,0xc(%esi)
40033b1d:	0f 95 c0             	setne  %al
40033b20:	01 d0                	add    %edx,%eax
40033b22:	89 46 08             	mov    %eax,0x8(%esi)
40033b25:	eb 43                	jmp    40033b6a <k_sem_give+0x69>
40033b27:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
40033b29:	8d 40 10             	lea    0x10(%eax),%eax
40033b2c:	e8 8c ff ff ff       	call   40033abd <_abort_timeout>
	_ready_thread(thread);
40033b31:	89 d8                	mov    %ebx,%eax
40033b33:	e8 16 ff ff ff       	call   40033a4e <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
40033b38:	8b 43 28             	mov    0x28(%ebx),%eax
40033b3b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
40033b41:	83 3d c0 76 00 a8 00 	cmpl   $0x0,0xa80076c0
40033b48:	75 20                	jne    40033b6a <k_sem_give+0x69>
	return _is_preempt(_current) && __must_switch_threads();
40033b4a:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40033b4f:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40033b54:	77 14                	ja     40033b6a <k_sem_give+0x69>
40033b56:	e8 2c fe ff ff       	call   40033987 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
40033b5b:	85 c0                	test   %eax,%eax
40033b5d:	74 0b                	je     40033b6a <k_sem_give+0x69>
		_Swap(key);
40033b5f:	89 f8                	mov    %edi,%eax
	} else {
		irq_unlock(key);
	}
}
40033b61:	5b                   	pop    %ebx
40033b62:	5e                   	pop    %esi
40033b63:	5f                   	pop    %edi
40033b64:	5d                   	pop    %ebp
		_Swap(key);
40033b65:	e9 d0 f7 ff ff       	jmp    4003333a <_Swap>
40033b6a:	0f ba e7 09          	bt     $0x9,%edi
40033b6e:	73 01                	jae    40033b71 <k_sem_give+0x70>
	__asm__ volatile (
40033b70:	fb                   	sti    
}
40033b71:	5b                   	pop    %ebx
40033b72:	5e                   	pop    %esi
40033b73:	5f                   	pop    %edi
40033b74:	5d                   	pop    %ebp
40033b75:	c3                   	ret    

40033b76 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
40033b76:	55                   	push   %ebp
40033b77:	89 e5                	mov    %esp,%ebp
40033b79:	53                   	push   %ebx
	__asm__ volatile (
40033b7a:	9c                   	pushf  
40033b7b:	fa                   	cli    
40033b7c:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
40033b7d:	8b 48 08             	mov    0x8(%eax),%ecx
40033b80:	85 c9                	test   %ecx,%ecx
40033b82:	74 08                	je     40033b8c <k_sem_take+0x16>
		sem->count--;
40033b84:	49                   	dec    %ecx
40033b85:	89 48 08             	mov    %ecx,0x8(%eax)
		irq_unlock(key);
		return 0;
40033b88:	31 c0                	xor    %eax,%eax
40033b8a:	eb 09                	jmp    40033b95 <k_sem_take+0x1f>
	}

	if (timeout == K_NO_WAIT) {
40033b8c:	85 d2                	test   %edx,%edx
40033b8e:	75 0e                	jne    40033b9e <k_sem_take+0x28>
		irq_unlock(key);
		return -EBUSY;
40033b90:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
40033b95:	0f ba e3 09          	bt     $0x9,%ebx
40033b99:	73 11                	jae    40033bac <k_sem_take+0x36>
	__asm__ volatile (
40033b9b:	fb                   	sti    
40033b9c:	eb 0e                	jmp    40033bac <k_sem_take+0x36>
	}

	_pend_current_thread(&sem->wait_q, timeout);
40033b9e:	e8 c0 fd ff ff       	call   40033963 <_pend_current_thread>

	return _Swap(key);
40033ba3:	89 d8                	mov    %ebx,%eax
}
40033ba5:	5b                   	pop    %ebx
40033ba6:	5d                   	pop    %ebp
	return _Swap(key);
40033ba7:	e9 8e f7 ff ff       	jmp    4003333a <_Swap>
}
40033bac:	5b                   	pop    %ebx
40033bad:	5d                   	pop    %ebp
40033bae:	c3                   	ret    

40033baf <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
40033baf:	55                   	push   %ebp
40033bb0:	89 e5                	mov    %esp,%ebp
40033bb2:	57                   	push   %edi
40033bb3:	56                   	push   %esi
40033bb4:	53                   	push   %ebx
40033bb5:	83 ec 08             	sub    $0x8,%esp
40033bb8:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
40033bba:	9c                   	pushf  
40033bbb:	fa                   	cli    
40033bbc:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
40033bbd:	89 df                	mov    %ebx,%edi
40033bbf:	c1 ff 1f             	sar    $0x1f,%edi
40033bc2:	01 1d cc 78 00 a8    	add    %ebx,0xa80078cc
40033bc8:	11 3d d0 78 00 a8    	adc    %edi,0xa80078d0
40033bce:	0f ba e0 09          	bt     $0x9,%eax
40033bd2:	73 01                	jae    40033bd5 <_nano_sys_clock_tick_announce+0x26>
	__asm__ volatile (
40033bd4:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
40033bd5:	8d 4d ec             	lea    -0x14(%ebp),%ecx
40033bd8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
40033bdb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
40033bde:	9c                   	pushf  
40033bdf:	fa                   	cli    
40033be0:	5e                   	pop    %esi
	return list->head == list;
40033be1:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
40033be6:	89 f2                	mov    %esi,%edx
	if (!head) {
40033be8:	85 c0                	test   %eax,%eax
40033bea:	74 07                	je     40033bf3 <_nano_sys_clock_tick_announce+0x44>
40033bec:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
40033bf1:	75 10                	jne    40033c03 <_nano_sys_clock_tick_announce+0x54>
40033bf3:	0f ba e6 09          	bt     $0x9,%esi
40033bf7:	0f 83 07 01 00 00    	jae    40033d04 <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
40033bfd:	fb                   	sti    
40033bfe:	e9 01 01 00 00       	jmp    40033d04 <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
40033c03:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
40033c06:	c7 05 c4 78 00 a8 01 	movl   $0x1,0xa80078c4
40033c0d:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40033c10:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
40033c14:	75 3e                	jne    40033c54 <_nano_sys_clock_tick_announce+0xa5>
	node->prev->next = node->next;
40033c16:	8b 70 04             	mov    0x4(%eax),%esi
40033c19:	8b 38                	mov    (%eax),%edi
40033c1b:	0f ba e2 09          	bt     $0x9,%edx
40033c1f:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
40033c21:	8b 38                	mov    (%eax),%edi
40033c23:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
40033c26:	8b 75 ec             	mov    -0x14(%ebp),%esi
40033c29:	89 30                	mov    %esi,(%eax)
	node->prev = list;
40033c2b:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
40033c2e:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
40033c31:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
40033c34:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
40033c37:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
40033c3e:	73 01                	jae    40033c41 <_nano_sys_clock_tick_announce+0x92>
40033c40:	fb                   	sti    
	__asm__ volatile (
40033c41:	9c                   	pushf  
40033c42:	fa                   	cli    
40033c43:	5a                   	pop    %edx
	return list->head == list;
40033c44:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033c49:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
40033c4e:	74 04                	je     40033c54 <_nano_sys_clock_tick_announce+0xa5>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40033c50:	85 c0                	test   %eax,%eax
40033c52:	75 bc                	jne    40033c10 <_nano_sys_clock_tick_announce+0x61>
40033c54:	0f ba e2 09          	bt     $0x9,%edx
40033c58:	73 01                	jae    40033c5b <_nano_sys_clock_tick_announce+0xac>
	__asm__ volatile (
40033c5a:	fb                   	sti    
	return list->head == list;
40033c5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
40033c5e:	39 ca                	cmp    %ecx,%edx
40033c60:	74 04                	je     40033c66 <_nano_sys_clock_tick_announce+0xb7>
40033c62:	85 d2                	test   %edx,%edx
40033c64:	75 0f                	jne    40033c75 <_nano_sys_clock_tick_announce+0xc6>
	_handling_timeouts = 0;
40033c66:	c7 05 c4 78 00 a8 00 	movl   $0x0,0xa80078c4
40033c6d:	00 00 00 
40033c70:	e9 8f 00 00 00       	jmp    40033d04 <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
40033c75:	31 f6                	xor    %esi,%esi
40033c77:	3b 55 f0             	cmp    -0x10(%ebp),%edx
40033c7a:	74 4d                	je     40033cc9 <_nano_sys_clock_tick_announce+0x11a>
40033c7c:	8b 32                	mov    (%edx),%esi
40033c7e:	eb 49                	jmp    40033cc9 <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
40033c80:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
40033c84:	74 17                	je     40033c9d <_nano_sys_clock_tick_announce+0xee>
	node->prev->next = node->next;
40033c86:	8b 50 04             	mov    0x4(%eax),%edx
40033c89:	8b 08                	mov    (%eax),%ecx
40033c8b:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033c8d:	8b 08                	mov    (%eax),%ecx
40033c8f:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
40033c92:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033c99:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033c9d:	8a 50 09             	mov    0x9(%eax),%dl
40033ca0:	88 d1                	mov    %dl,%cl
40033ca2:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40033ca5:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033ca8:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40033cab:	74 3b                	je     40033ce8 <_nano_sys_clock_tick_announce+0x139>
40033cad:	0f ba e7 09          	bt     $0x9,%edi
40033cb1:	73 01                	jae    40033cb4 <_nano_sys_clock_tick_announce+0x105>
40033cb3:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
40033cb4:	85 f6                	test   %esi,%esi
40033cb6:	74 ae                	je     40033c66 <_nano_sys_clock_tick_announce+0xb7>
	return (node == list->tail) ? NULL : node->next;
40033cb8:	31 c0                	xor    %eax,%eax
40033cba:	39 75 f0             	cmp    %esi,-0x10(%ebp)
40033cbd:	74 02                	je     40033cc1 <_nano_sys_clock_tick_announce+0x112>
40033cbf:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
40033cc1:	85 f6                	test   %esi,%esi
40033cc3:	74 a1                	je     40033c66 <_nano_sys_clock_tick_announce+0xb7>
40033cc5:	89 f2                	mov    %esi,%edx
40033cc7:	89 c6                	mov    %eax,%esi
	node->prev->next = node->next;
40033cc9:	8b 42 04             	mov    0x4(%edx),%eax
40033ccc:	8b 0a                	mov    (%edx),%ecx
40033cce:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40033cd0:	8b 0a                	mov    (%edx),%ecx
40033cd2:	89 41 04             	mov    %eax,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
40033cd5:	8b 42 08             	mov    0x8(%edx),%eax
	__asm__ volatile (
40033cd8:	9c                   	pushf  
40033cd9:	fa                   	cli    
40033cda:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
40033cdb:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
40033ce2:	85 c0                	test   %eax,%eax
40033ce4:	75 9a                	jne    40033c80 <_nano_sys_clock_tick_announce+0xd1>
40033ce6:	eb 08                	jmp    40033cf0 <_nano_sys_clock_tick_announce+0x141>
40033ce8:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033cec:	75 bf                	jne    40033cad <_nano_sys_clock_tick_announce+0xfe>
40033cee:	eb 64                	jmp    40033d54 <_nano_sys_clock_tick_announce+0x1a5>
40033cf0:	0f ba e7 09          	bt     $0x9,%edi
40033cf4:	73 01                	jae    40033cf7 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
40033cf6:	fb                   	sti    
		if (timeout->func) {
40033cf7:	8b 4a 14             	mov    0x14(%edx),%ecx
40033cfa:	85 c9                	test   %ecx,%ecx
40033cfc:	74 b6                	je     40033cb4 <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
40033cfe:	89 d0                	mov    %edx,%eax
40033d00:	ff d1                	call   *%ecx
40033d02:	eb b0                	jmp    40033cb4 <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
40033d04:	a1 e0 77 00 a8       	mov    0xa80077e0,%eax
40033d09:	85 c0                	test   %eax,%eax
40033d0b:	74 51                	je     40033d5e <_nano_sys_clock_tick_announce+0x1af>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
40033d0d:	8b 15 c8 76 00 a8    	mov    0xa80076c8,%edx
40033d13:	0f be 52 0a          	movsbl 0xa(%edx),%edx
40033d17:	39 15 dc 77 00 a8    	cmp    %edx,0xa80077dc
40033d1d:	7f 3f                	jg     40033d5e <_nano_sys_clock_tick_announce+0x1af>
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
40033d1f:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
40033d22:	03 1d c8 78 00 a8    	add    0xa80078c8,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
40033d28:	39 d8                	cmp    %ebx,%eax
40033d2a:	7e 08                	jle    40033d34 <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
40033d2c:	89 1d c8 78 00 a8    	mov    %ebx,0xa80078c8
40033d32:	eb 2a                	jmp    40033d5e <_nano_sys_clock_tick_announce+0x1af>
		_time_slice_elapsed = 0;
40033d34:	c7 05 c8 78 00 a8 00 	movl   $0x0,0xa80078c8
40033d3b:	00 00 00 
	__asm__ volatile (
40033d3e:	9c                   	pushf  
40033d3f:	fa                   	cli    
40033d40:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
40033d41:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40033d46:	e8 99 fc ff ff       	call   400339e4 <_move_thread_to_end_of_prio_q>
40033d4b:	0f ba e3 09          	bt     $0x9,%ebx
40033d4f:	73 0d                	jae    40033d5e <_nano_sys_clock_tick_announce+0x1af>
	__asm__ volatile (
40033d51:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
40033d52:	eb 0a                	jmp    40033d5e <_nano_sys_clock_tick_announce+0x1af>
		_add_thread_to_ready_q(thread);
40033d54:	e8 d6 fa ff ff       	call   4003382f <_add_thread_to_ready_q>
40033d59:	e9 4f ff ff ff       	jmp    40033cad <_nano_sys_clock_tick_announce+0xfe>
40033d5e:	58                   	pop    %eax
40033d5f:	5a                   	pop    %edx
40033d60:	5b                   	pop    %ebx
40033d61:	5e                   	pop    %esi
40033d62:	5f                   	pop    %edi
40033d63:	5d                   	pop    %ebp
40033d64:	c3                   	ret    

40033d65 <_is_thread_ready>:
{
40033d65:	55                   	push   %ebp
40033d66:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
40033d68:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
40033d6c:	75 09                	jne    40033d77 <_is_thread_ready+0x12>
40033d6e:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033d72:	0f 94 c0             	sete   %al
40033d75:	eb 02                	jmp    40033d79 <_is_thread_ready+0x14>
40033d77:	31 c0                	xor    %eax,%eax
40033d79:	0f b6 c0             	movzbl %al,%eax
}
40033d7c:	5d                   	pop    %ebp
40033d7d:	c3                   	ret    

40033d7e <_abort_timeout>:
{
40033d7e:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033d7f:	8b 48 10             	mov    0x10(%eax),%ecx
{
40033d82:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033d84:	83 f9 ff             	cmp    $0xffffffff,%ecx
40033d87:	74 24                	je     40033dad <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
40033d89:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
40033d8f:	74 05                	je     40033d96 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40033d91:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40033d93:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40033d96:	8b 50 04             	mov    0x4(%eax),%edx
40033d99:	8b 08                	mov    (%eax),%ecx
40033d9b:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033d9d:	8b 08                	mov    (%eax),%ecx
40033d9f:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40033da2:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
40033da9:	31 c0                	xor    %eax,%eax
40033dab:	eb 03                	jmp    40033db0 <_abort_timeout+0x32>
		return _INACTIVE;
40033dad:	83 c8 ff             	or     $0xffffffff,%eax
}
40033db0:	5d                   	pop    %ebp
40033db1:	c3                   	ret    

40033db2 <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
40033db2:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
40033db3:	85 d2                	test   %edx,%edx
{
40033db5:	89 e5                	mov    %esp,%ebp
40033db7:	57                   	push   %edi
40033db8:	56                   	push   %esi
40033db9:	53                   	push   %ebx
40033dba:	51                   	push   %ecx
40033dbb:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
40033dbd:	75 41                	jne    40033e00 <schedule_new_thread+0x4e>
	__asm__ volatile (
40033dbf:	9c                   	pushf  
40033dc0:	fa                   	cli    
40033dc1:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033dc2:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
40033dc6:	e8 9a ff ff ff       	call   40033d65 <_is_thread_ready>
40033dcb:	85 c0                	test   %eax,%eax
40033dcd:	75 09                	jne    40033dd8 <schedule_new_thread+0x26>
40033dcf:	0f ba e3 09          	bt     $0x9,%ebx
40033dd3:	e9 b1 00 00 00       	jmp    40033e89 <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
40033dd8:	89 c8                	mov    %ecx,%eax
40033dda:	e8 50 fa ff ff       	call   4003382f <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
40033ddf:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40033de4:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40033de9:	77 e4                	ja     40033dcf <schedule_new_thread+0x1d>
40033deb:	e8 97 fb ff ff       	call   40033987 <__must_switch_threads>
40033df0:	85 c0                	test   %eax,%eax
40033df2:	74 db                	je     40033dcf <schedule_new_thread+0x1d>
			_Swap(key);
40033df4:	89 d8                	mov    %ebx,%eax
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
40033df6:	5a                   	pop    %edx
40033df7:	5b                   	pop    %ebx
40033df8:	5e                   	pop    %esi
40033df9:	5f                   	pop    %edi
40033dfa:	5d                   	pop    %ebp
			_Swap(key);
40033dfb:	e9 3a f5 ff ff       	jmp    4003333a <_Swap>
40033e00:	9c                   	pushf  
40033e01:	fa                   	cli    
40033e02:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40033e05:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40033e0a:	8d 58 10             	lea    0x10(%eax),%ebx
40033e0d:	8d 42 09             	lea    0x9(%edx),%eax
40033e10:	31 d2                	xor    %edx,%edx
40033e12:	f7 f6                	div    %esi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
40033e14:	40                   	inc    %eax
	timeout->thread = thread;
40033e15:	89 49 18             	mov    %ecx,0x18(%ecx)
40033e18:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
40033e1b:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
40033e20:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033e27:	85 c0                	test   %eax,%eax
40033e29:	74 0d                	je     40033e38 <schedule_new_thread+0x86>
40033e2b:	8b 3d d0 76 00 a8    	mov    0xa80076d0,%edi
40033e31:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
40033e36:	75 19                	jne    40033e51 <schedule_new_thread+0x9f>
	node->next = list;
40033e38:	c7 41 10 cc 76 00 a8 	movl   $0xa80076cc,0x10(%ecx)
	node->prev = list->tail;
40033e3f:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
40033e44:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
40033e47:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
40033e49:	89 1d d0 76 00 a8    	mov    %ebx,0xa80076d0
40033e4f:	eb 31                	jmp    40033e82 <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
40033e51:	8b 51 20             	mov    0x20(%ecx),%edx
40033e54:	8b 70 10             	mov    0x10(%eax),%esi
40033e57:	39 f2                	cmp    %esi,%edx
40033e59:	7f 18                	jg     40033e73 <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
40033e5b:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
40033e5d:	8b 50 04             	mov    0x4(%eax),%edx
40033e60:	89 70 10             	mov    %esi,0x10(%eax)
40033e63:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
40033e66:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
40033e69:	8b 50 04             	mov    0x4(%eax),%edx
40033e6c:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
40033e6e:	89 58 04             	mov    %ebx,0x4(%eax)
40033e71:	eb 0f                	jmp    40033e82 <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
40033e73:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
40033e75:	39 f8                	cmp    %edi,%eax
40033e77:	89 51 20             	mov    %edx,0x20(%ecx)
40033e7a:	74 bc                	je     40033e38 <schedule_new_thread+0x86>
40033e7c:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033e7e:	85 c0                	test   %eax,%eax
40033e80:	eb b4                	jmp    40033e36 <schedule_new_thread+0x84>
40033e82:	8b 45 f0             	mov    -0x10(%ebp),%eax
40033e85:	0f ba e0 09          	bt     $0x9,%eax
40033e89:	73 01                	jae    40033e8c <schedule_new_thread+0xda>
	__asm__ volatile (
40033e8b:	fb                   	sti    
}
40033e8c:	58                   	pop    %eax
40033e8d:	5b                   	pop    %ebx
40033e8e:	5e                   	pop    %esi
40033e8f:	5f                   	pop    %edi
40033e90:	5d                   	pop    %ebp
40033e91:	c3                   	ret    

40033e92 <k_is_in_isr>:
{
40033e92:	55                   	push   %ebp
	return _is_in_isr();
40033e93:	31 c0                	xor    %eax,%eax
{
40033e95:	89 e5                	mov    %esp,%ebp
}
40033e97:	5d                   	pop    %ebp
	return _is_in_isr();
40033e98:	83 3d c0 76 00 a8 00 	cmpl   $0x0,0xa80076c0
40033e9f:	0f 95 c0             	setne  %al
}
40033ea2:	c3                   	ret    

40033ea3 <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
40033ea3:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
40033ea8:	55                   	push   %ebp
40033ea9:	89 e5                	mov    %esp,%ebp
}
40033eab:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
40033eac:	8a 40 08             	mov    0x8(%eax),%al
40033eaf:	83 e0 01             	and    $0x1,%eax
}
40033eb2:	c3                   	ret    

40033eb3 <_thread_entry>:
{
40033eb3:	55                   	push   %ebp
40033eb4:	89 e5                	mov    %esp,%ebp
40033eb6:	53                   	push   %ebx
40033eb7:	89 c3                	mov    %eax,%ebx
40033eb9:	89 d0                	mov    %edx,%eax
40033ebb:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
40033ebd:	8b 4d 08             	mov    0x8(%ebp),%ecx
40033ec0:	ff d3                	call   *%ebx
	if (_is_thread_essential()) {
40033ec2:	e8 dc ff ff ff       	call   40033ea3 <_is_thread_essential>
40033ec7:	85 c0                	test   %eax,%eax
40033ec9:	74 0f                	je     40033eda <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
40033ecb:	ba 40 64 03 40       	mov    $0x40036440,%edx
40033ed0:	b8 03 00 00 00       	mov    $0x3,%eax
40033ed5:	e8 fb f4 ff ff       	call   400333d5 <_NanoFatalErrorHandler>
	k_thread_abort(_current);
40033eda:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40033edf:	e8 fa 00 00 00       	call   40033fde <k_thread_abort>

40033ee4 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
40033ee4:	55                   	push   %ebp
40033ee5:	89 e5                	mov    %esp,%ebp
40033ee7:	53                   	push   %ebx
40033ee8:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
40033eea:	8b 40 30             	mov    0x30(%eax),%eax
40033eed:	85 c0                	test   %eax,%eax
40033eef:	74 02                	je     40033ef3 <_k_thread_single_abort+0xf>
		thread->fn_abort();
40033ef1:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
40033ef3:	89 d8                	mov    %ebx,%eax
40033ef5:	e8 6b fe ff ff       	call   40033d65 <_is_thread_ready>
40033efa:	85 c0                	test   %eax,%eax
40033efc:	74 09                	je     40033f07 <_k_thread_single_abort+0x23>
		_remove_thread_from_ready_q(thread);
40033efe:	89 d8                	mov    %ebx,%eax
40033f00:	e8 88 f9 ff ff       	call   4003388d <_remove_thread_from_ready_q>
40033f05:	eb 24                	jmp    40033f2b <_k_thread_single_abort+0x47>
	} else {
		if (_is_thread_pending(thread)) {
40033f07:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
40033f0b:	74 10                	je     40033f1d <_k_thread_single_abort+0x39>
	node->prev->next = node->next;
40033f0d:	8b 43 04             	mov    0x4(%ebx),%eax
40033f10:	8b 13                	mov    (%ebx),%edx
40033f12:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
40033f14:	8b 13                	mov    (%ebx),%edx
40033f16:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033f19:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
40033f1d:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
40033f21:	74 08                	je     40033f2b <_k_thread_single_abort+0x47>
	return _abort_timeout(&thread->base.timeout);
40033f23:	8d 43 10             	lea    0x10(%ebx),%eax
40033f26:	e8 53 fe ff ff       	call   40033d7e <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
40033f2b:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
40033f2f:	5b                   	pop    %ebx
40033f30:	5d                   	pop    %ebp
40033f31:	c3                   	ret    

40033f32 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
40033f32:	55                   	push   %ebp
40033f33:	89 e5                	mov    %esp,%ebp
40033f35:	56                   	push   %esi
40033f36:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
40033f37:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
40033f3c:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033f42:	73 29                	jae    40033f6d <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
40033f44:	ff 73 1c             	pushl  0x1c(%ebx)
40033f47:	ff 73 18             	pushl  0x18(%ebx)
40033f4a:	ff 73 14             	pushl  0x14(%ebx)
40033f4d:	ff 73 10             	pushl  0x10(%ebx)
40033f50:	ff 73 0c             	pushl  0xc(%ebx)
40033f53:	8b 03                	mov    (%ebx),%eax
40033f55:	8b 4b 08             	mov    0x8(%ebx),%ecx
40033f58:	8b 53 04             	mov    0x4(%ebx),%edx
40033f5b:	e8 0e f4 ff ff       	call   4003336e <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
40033f60:	8b 03                	mov    (%ebx),%eax
		_new_thread(
40033f62:	83 c4 14             	add    $0x14,%esp
		thread_data->thread->init_data = thread_data;
40033f65:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
40033f68:	83 c3 2c             	add    $0x2c,%ebx
40033f6b:	eb cf                	jmp    40033f3c <_init_static_threads+0xa>
	--_current->base.sched_locked;
40033f6d:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40033f72:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
40033f75:	9c                   	pushf  
40033f76:	fa                   	cli    
40033f77:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
40033f78:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
40033f7d:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033f83:	73 14                	jae    40033f99 <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
40033f85:	8b 53 20             	mov    0x20(%ebx),%edx
40033f88:	83 fa ff             	cmp    $0xffffffff,%edx
40033f8b:	74 07                	je     40033f94 <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
40033f8d:	8b 03                	mov    (%ebx),%eax
40033f8f:	e8 1e fe ff ff       	call   40033db2 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
40033f94:	83 c3 2c             	add    $0x2c,%ebx
40033f97:	eb e4                	jmp    40033f7d <_init_static_threads+0x4b>
40033f99:	0f ba e6 09          	bt     $0x9,%esi
40033f9d:	73 01                	jae    40033fa0 <_init_static_threads+0x6e>
	__asm__ volatile (
40033f9f:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
40033fa0:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033fa3:	5b                   	pop    %ebx
40033fa4:	5e                   	pop    %esi
40033fa5:	5d                   	pop    %ebp
	k_sched_unlock();
40033fa6:	e9 24 fa ff ff       	jmp    400339cf <k_sched_unlock>

40033fab <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
40033fab:	55                   	push   %ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;
40033fac:	88 48 09             	mov    %cl,0x9(%eax)
{
40033faf:	89 e5                	mov    %esp,%ebp
40033fb1:	53                   	push   %ebx

	thread_base->prio = priority;
40033fb2:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
40033fb5:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	thread_base->user_options = (uint8_t)options;
40033fb9:	8a 5d 08             	mov    0x8(%ebp),%bl
	t->delta_ticks_from_prev = _INACTIVE;
40033fbc:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
40033fc3:	88 58 08             	mov    %bl,0x8(%eax)
	t->wait_q = NULL;
40033fc6:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
40033fcd:	5b                   	pop    %ebx
	t->thread = NULL;
40033fce:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
40033fd5:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
40033fdc:	5d                   	pop    %ebp
40033fdd:	c3                   	ret    

40033fde <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
40033fde:	55                   	push   %ebp
40033fdf:	89 e5                	mov    %esp,%ebp
40033fe1:	56                   	push   %esi
40033fe2:	89 c6                	mov    %eax,%esi
40033fe4:	53                   	push   %ebx
	__asm__ volatile (
40033fe5:	9c                   	pushf  
40033fe6:	fa                   	cli    
40033fe7:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
40033fe8:	e8 f7 fe ff ff       	call   40033ee4 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
		_Swap(key);
40033fed:	89 d8                	mov    %ebx,%eax
	if (_current == thread) {
40033fef:	3b 35 c8 76 00 a8    	cmp    0xa80076c8,%esi
40033ff5:	75 05                	jne    40033ffc <k_thread_abort+0x1e>
		_Swap(key);
40033ff7:	e8 3e f3 ff ff       	call   4003333a <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
}
40033ffc:	5b                   	pop    %ebx
40033ffd:	5e                   	pop    %esi
40033ffe:	5d                   	pop    %ebp
	_reschedule_threads(key);
40033fff:	e9 9e f9 ff ff       	jmp    400339a2 <_reschedule_threads>

40034004 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034004:	8a 50 09             	mov    0x9(%eax),%dl
{
40034007:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034008:	88 d1                	mov    %dl,%cl
{
4003400a:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003400c:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
4003400f:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034012:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40034015:	75 0c                	jne    40034023 <_ready_thread+0x1f>
40034017:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003401b:	75 06                	jne    40034023 <_ready_thread+0x1f>
}
4003401d:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
4003401e:	e9 0c f8 ff ff       	jmp    4003382f <_add_thread_to_ready_q>
}
40034023:	5d                   	pop    %ebp
40034024:	c3                   	ret    

40034025 <_add_timeout.constprop.7>:
	timeout->thread = thread;
40034025:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003402c:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003402f:	55                   	push   %ebp
	return list->head == list;
40034030:	8b 15 cc 76 00 a8    	mov    0xa80076cc,%edx
40034036:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40034038:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003403b:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003403c:	85 d2                	test   %edx,%edx
4003403e:	74 08                	je     40034048 <_add_timeout.constprop.7+0x23>
40034040:	81 fa cc 76 00 a8    	cmp    $0xa80076cc,%edx
40034046:	75 1e                	jne    40034066 <_add_timeout.constprop.7+0x41>
	node->next = list;
40034048:	c7 00 cc 76 00 a8    	movl   $0xa80076cc,(%eax)
	node->prev = list->tail;
4003404e:	8b 15 d0 76 00 a8    	mov    0xa80076d0,%edx
40034054:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
40034057:	8b 15 d0 76 00 a8    	mov    0xa80076d0,%edx
4003405d:	89 02                	mov    %eax,(%edx)
	list->tail = node;
4003405f:	a3 d0 76 00 a8       	mov    %eax,0xa80076d0
40034064:	eb 34                	jmp    4003409a <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
40034066:	8b 48 10             	mov    0x10(%eax),%ecx
40034069:	8b 5a 10             	mov    0x10(%edx),%ebx
4003406c:	39 d9                	cmp    %ebx,%ecx
4003406e:	7f 17                	jg     40034087 <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
40034070:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
40034072:	8b 4a 04             	mov    0x4(%edx),%ecx
40034075:	89 5a 10             	mov    %ebx,0x10(%edx)
40034078:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
4003407b:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
4003407d:	8b 4a 04             	mov    0x4(%edx),%ecx
40034080:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
40034082:	89 42 04             	mov    %eax,0x4(%edx)
40034085:	eb 13                	jmp    4003409a <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
40034087:	29 d9                	sub    %ebx,%ecx
40034089:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
4003408c:	3b 15 d0 76 00 a8    	cmp    0xa80076d0,%edx
40034092:	74 b4                	je     40034048 <_add_timeout.constprop.7+0x23>
40034094:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40034096:	85 d2                	test   %edx,%edx
40034098:	eb ac                	jmp    40034046 <_add_timeout.constprop.7+0x21>
}
4003409a:	5b                   	pop    %ebx
4003409b:	5d                   	pop    %ebp
4003409c:	c3                   	ret    

4003409d <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
4003409d:	55                   	push   %ebp
4003409e:	89 e5                	mov    %esp,%ebp
400340a0:	56                   	push   %esi
400340a1:	53                   	push   %ebx
400340a2:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
400340a4:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
400340a8:	7e 15                	jle    400340bf <_timer_expiration_handler+0x22>
400340aa:	9c                   	pushf  
400340ab:	fa                   	cli    
400340ac:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
400340ad:	8b 48 28             	mov    0x28(%eax),%ecx
400340b0:	8d 50 18             	lea    0x18(%eax),%edx
400340b3:	e8 6d ff ff ff       	call   40034025 <_add_timeout.constprop.7>
400340b8:	0f ba e6 09          	bt     $0x9,%esi
400340bc:	73 01                	jae    400340bf <_timer_expiration_handler+0x22>
	__asm__ volatile (
400340be:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
400340bf:	8b 53 20             	mov    0x20(%ebx),%edx
	timer->status += 1;
400340c2:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
400340c5:	85 d2                	test   %edx,%edx
400340c7:	74 04                	je     400340cd <_timer_expiration_handler+0x30>
		timer->expiry_fn(timer);
400340c9:	89 d8                	mov    %ebx,%eax
400340cb:	ff d2                	call   *%edx
	return list->head == list;
400340cd:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
400340d0:	85 f6                	test   %esi,%esi
400340d2:	74 31                	je     40034105 <_timer_expiration_handler+0x68>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
400340d4:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
400340d7:	39 de                	cmp    %ebx,%esi
400340d9:	74 2a                	je     40034105 <_timer_expiration_handler+0x68>
	node->prev->next = node->next;
400340db:	8b 46 04             	mov    0x4(%esi),%eax
400340de:	8b 16                	mov    (%esi),%edx
400340e0:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
400340e2:	8b 16                	mov    (%esi),%edx
400340e4:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
400340e7:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
400340eb:	9c                   	pushf  
400340ec:	fa                   	cli    
400340ed:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
400340ee:	89 f0                	mov    %esi,%eax
400340f0:	e8 0f ff ff ff       	call   40034004 <_ready_thread>
400340f5:	0f ba e3 09          	bt     $0x9,%ebx
400340f9:	73 01                	jae    400340fc <_timer_expiration_handler+0x5f>
	__asm__ volatile (
400340fb:	fb                   	sti    
400340fc:	8b 46 28             	mov    0x28(%esi),%eax
400340ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
40034105:	5b                   	pop    %ebx
40034106:	5e                   	pop    %esi
40034107:	5d                   	pop    %ebp
40034108:	c3                   	ret    

40034109 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
40034109:	55                   	push   %ebp
4003410a:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
4003410c:	5d                   	pop    %ebp
4003410d:	c3                   	ret    

4003410e <malloc>:
4003410e:	53                   	push   %ebx
4003410f:	89 c3                	mov    %eax,%ebx
40034111:	e8 7c 02 00 00       	call   40034392 <__getreent>
40034116:	89 da                	mov    %ebx,%edx
40034118:	5b                   	pop    %ebx
40034119:	e9 c9 00 00 00       	jmp    400341e7 <_malloc_r>

4003411e <free>:
4003411e:	53                   	push   %ebx
4003411f:	89 c3                	mov    %eax,%ebx
40034121:	e8 6c 02 00 00       	call   40034392 <__getreent>
40034126:	89 da                	mov    %ebx,%edx
40034128:	5b                   	pop    %ebx
40034129:	e9 00 00 00 00       	jmp    4003412e <_free_r>

4003412e <_free_r>:
4003412e:	85 d2                	test   %edx,%edx
40034130:	0f 84 b0 00 00 00    	je     400341e6 <_free_r+0xb8>
40034136:	8d 4a fc             	lea    -0x4(%edx),%ecx
40034139:	8b 52 fc             	mov    -0x4(%edx),%edx
4003413c:	85 d2                	test   %edx,%edx
4003413e:	79 02                	jns    40034142 <_free_r+0x14>
40034140:	01 d1                	add    %edx,%ecx
40034142:	8b 15 e4 67 00 a8    	mov    0xa80067e4,%edx
40034148:	85 d2                	test   %edx,%edx
4003414a:	75 0e                	jne    4003415a <_free_r+0x2c>
4003414c:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
40034153:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
40034159:	c3                   	ret    
4003415a:	57                   	push   %edi
4003415b:	39 ca                	cmp    %ecx,%edx
4003415d:	56                   	push   %esi
4003415e:	53                   	push   %ebx
4003415f:	53                   	push   %ebx
40034160:	76 20                	jbe    40034182 <_free_r+0x54>
40034162:	8b 01                	mov    (%ecx),%eax
40034164:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
40034167:	39 da                	cmp    %ebx,%edx
40034169:	75 0c                	jne    40034177 <_free_r+0x49>
4003416b:	03 02                	add    (%edx),%eax
4003416d:	89 01                	mov    %eax,(%ecx)
4003416f:	8b 42 04             	mov    0x4(%edx),%eax
40034172:	89 41 04             	mov    %eax,0x4(%ecx)
40034175:	eb 03                	jmp    4003417a <_free_r+0x4c>
40034177:	89 51 04             	mov    %edx,0x4(%ecx)
4003417a:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
40034180:	eb 60                	jmp    400341e2 <_free_r+0xb4>
40034182:	8b 72 04             	mov    0x4(%edx),%esi
40034185:	85 f6                	test   %esi,%esi
40034187:	0f 95 44 24 03       	setne  0x3(%esp)
4003418c:	39 ce                	cmp    %ecx,%esi
4003418e:	0f 96 c3             	setbe  %bl
40034191:	84 5c 24 03          	test   %bl,0x3(%esp)
40034195:	74 04                	je     4003419b <_free_r+0x6d>
40034197:	89 f2                	mov    %esi,%edx
40034199:	eb e7                	jmp    40034182 <_free_r+0x54>
4003419b:	8b 1a                	mov    (%edx),%ebx
4003419d:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
400341a0:	39 cf                	cmp    %ecx,%edi
400341a2:	75 19                	jne    400341bd <_free_r+0x8f>
400341a4:	8b 01                	mov    (%ecx),%eax
400341a6:	01 d8                	add    %ebx,%eax
400341a8:	89 02                	mov    %eax,(%edx)
400341aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
400341ad:	39 ce                	cmp    %ecx,%esi
400341af:	75 31                	jne    400341e2 <_free_r+0xb4>
400341b1:	03 06                	add    (%esi),%eax
400341b3:	89 02                	mov    %eax,(%edx)
400341b5:	8b 46 04             	mov    0x4(%esi),%eax
400341b8:	89 42 04             	mov    %eax,0x4(%edx)
400341bb:	eb 25                	jmp    400341e2 <_free_r+0xb4>
400341bd:	76 08                	jbe    400341c7 <_free_r+0x99>
400341bf:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
400341c5:	eb 1b                	jmp    400341e2 <_free_r+0xb4>
400341c7:	8b 01                	mov    (%ecx),%eax
400341c9:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
400341cc:	39 de                	cmp    %ebx,%esi
400341ce:	75 0c                	jne    400341dc <_free_r+0xae>
400341d0:	03 06                	add    (%esi),%eax
400341d2:	89 01                	mov    %eax,(%ecx)
400341d4:	8b 46 04             	mov    0x4(%esi),%eax
400341d7:	89 41 04             	mov    %eax,0x4(%ecx)
400341da:	eb 03                	jmp    400341df <_free_r+0xb1>
400341dc:	89 71 04             	mov    %esi,0x4(%ecx)
400341df:	89 4a 04             	mov    %ecx,0x4(%edx)
400341e2:	58                   	pop    %eax
400341e3:	5b                   	pop    %ebx
400341e4:	5e                   	pop    %esi
400341e5:	5f                   	pop    %edi
400341e6:	c3                   	ret    

400341e7 <_malloc_r>:
400341e7:	57                   	push   %edi
400341e8:	8d 7a 03             	lea    0x3(%edx),%edi
400341eb:	83 e7 fc             	and    $0xfffffffc,%edi
400341ee:	56                   	push   %esi
400341ef:	83 c7 08             	add    $0x8,%edi
400341f2:	53                   	push   %ebx
400341f3:	89 c6                	mov    %eax,%esi
400341f5:	83 ff 0c             	cmp    $0xc,%edi
400341f8:	73 05                	jae    400341ff <_malloc_r+0x18>
400341fa:	bf 0c 00 00 00       	mov    $0xc,%edi
400341ff:	89 f8                	mov    %edi,%eax
40034201:	c1 e8 1f             	shr    $0x1f,%eax
40034204:	75 0c                	jne    40034212 <_malloc_r+0x2b>
40034206:	8b 0d e4 67 00 a8    	mov    0xa80067e4,%ecx
4003420c:	39 fa                	cmp    %edi,%edx
4003420e:	89 c8                	mov    %ecx,%eax
40034210:	76 18                	jbe    4003422a <_malloc_r+0x43>
40034212:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
40034218:	31 c0                	xor    %eax,%eax
4003421a:	e9 97 00 00 00       	jmp    400342b6 <_malloc_r+0xcf>
4003421f:	8b 10                	mov    (%eax),%edx
40034221:	29 fa                	sub    %edi,%edx
40034223:	79 0b                	jns    40034230 <_malloc_r+0x49>
40034225:	89 c1                	mov    %eax,%ecx
40034227:	8b 40 04             	mov    0x4(%eax),%eax
4003422a:	85 c0                	test   %eax,%eax
4003422c:	75 f1                	jne    4003421f <_malloc_r+0x38>
4003422e:	eb 26                	jmp    40034256 <_malloc_r+0x6f>
40034230:	83 fa 0b             	cmp    $0xb,%edx
40034233:	76 09                	jbe    4003423e <_malloc_r+0x57>
40034235:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40034238:	89 10                	mov    %edx,(%eax)
4003423a:	89 39                	mov    %edi,(%ecx)
4003423c:	eb 4d                	jmp    4003428b <_malloc_r+0xa4>
4003423e:	39 c1                	cmp    %eax,%ecx
40034240:	75 0a                	jne    4003424c <_malloc_r+0x65>
40034242:	8b 41 04             	mov    0x4(%ecx),%eax
40034245:	a3 e4 67 00 a8       	mov    %eax,0xa80067e4
4003424a:	eb 3f                	jmp    4003428b <_malloc_r+0xa4>
4003424c:	8b 50 04             	mov    0x4(%eax),%edx
4003424f:	89 51 04             	mov    %edx,0x4(%ecx)
40034252:	89 c1                	mov    %eax,%ecx
40034254:	eb 35                	jmp    4003428b <_malloc_r+0xa4>
40034256:	83 3d e0 67 00 a8 00 	cmpl   $0x0,0xa80067e0
4003425d:	75 0e                	jne    4003426d <_malloc_r+0x86>
4003425f:	31 d2                	xor    %edx,%edx
40034261:	89 f0                	mov    %esi,%eax
40034263:	e8 6a 00 00 00       	call   400342d2 <_sbrk_r>
40034268:	a3 e0 67 00 a8       	mov    %eax,0xa80067e0
4003426d:	89 fa                	mov    %edi,%edx
4003426f:	89 f0                	mov    %esi,%eax
40034271:	e8 5c 00 00 00       	call   400342d2 <_sbrk_r>
40034276:	83 f8 ff             	cmp    $0xffffffff,%eax
40034279:	74 97                	je     40034212 <_malloc_r+0x2b>
4003427b:	8d 48 03             	lea    0x3(%eax),%ecx
4003427e:	89 cb                	mov    %ecx,%ebx
40034280:	83 e3 fc             	and    $0xfffffffc,%ebx
40034283:	39 d8                	cmp    %ebx,%eax
40034285:	75 1c                	jne    400342a3 <_malloc_r+0xbc>
40034287:	89 3b                	mov    %edi,(%ebx)
40034289:	89 d9                	mov    %ebx,%ecx
4003428b:	8d 41 0b             	lea    0xb(%ecx),%eax
4003428e:	8d 51 04             	lea    0x4(%ecx),%edx
40034291:	83 e0 f8             	and    $0xfffffff8,%eax
40034294:	89 c6                	mov    %eax,%esi
40034296:	29 d6                	sub    %edx,%esi
40034298:	74 1c                	je     400342b6 <_malloc_r+0xcf>
4003429a:	89 f3                	mov    %esi,%ebx
4003429c:	f7 db                	neg    %ebx
4003429e:	89 1c 31             	mov    %ebx,(%ecx,%esi,1)
400342a1:	eb 13                	jmp    400342b6 <_malloc_r+0xcf>
400342a3:	89 da                	mov    %ebx,%edx
400342a5:	29 c2                	sub    %eax,%edx
400342a7:	89 f0                	mov    %esi,%eax
400342a9:	e8 24 00 00 00       	call   400342d2 <_sbrk_r>
400342ae:	40                   	inc    %eax
400342af:	75 d6                	jne    40034287 <_malloc_r+0xa0>
400342b1:	e9 5c ff ff ff       	jmp    40034212 <_malloc_r+0x2b>
400342b6:	5b                   	pop    %ebx
400342b7:	5e                   	pop    %esi
400342b8:	5f                   	pop    %edi
400342b9:	c3                   	ret    

400342ba <iprintf>:
400342ba:	e8 d3 00 00 00       	call   40034392 <__getreent>
400342bf:	8d 4c 24 08          	lea    0x8(%esp),%ecx
400342c3:	8b 50 08             	mov    0x8(%eax),%edx
400342c6:	51                   	push   %ecx
400342c7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
400342cb:	e8 e8 07 00 00       	call   40034ab8 <_vfiprintf_r>
400342d0:	5a                   	pop    %edx
400342d1:	c3                   	ret    

400342d2 <_sbrk_r>:
400342d2:	53                   	push   %ebx
400342d3:	89 c3                	mov    %eax,%ebx
400342d5:	89 d0                	mov    %edx,%eax
400342d7:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
400342de:	00 00 00 
400342e1:	e8 ed ca ff ff       	call   40030dd3 <_sbrk>
400342e6:	83 f8 ff             	cmp    $0xffffffff,%eax
400342e9:	75 0c                	jne    400342f7 <_sbrk_r+0x25>
400342eb:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
400342f1:	85 d2                	test   %edx,%edx
400342f3:	74 02                	je     400342f7 <_sbrk_r+0x25>
400342f5:	89 13                	mov    %edx,(%ebx)
400342f7:	5b                   	pop    %ebx
400342f8:	c3                   	ret    

400342f9 <sniprintf>:
400342f9:	57                   	push   %edi
400342fa:	56                   	push   %esi
400342fb:	53                   	push   %ebx
400342fc:	83 ec 68             	sub    $0x68,%esp
400342ff:	8b 5c 24 7c          	mov    0x7c(%esp),%ebx
40034303:	8b 7c 24 78          	mov    0x78(%esp),%edi
40034307:	e8 86 00 00 00       	call   40034392 <__getreent>
4003430c:	85 db                	test   %ebx,%ebx
4003430e:	89 c6                	mov    %eax,%esi
40034310:	79 0b                	jns    4003431d <sniprintf+0x24>
40034312:	c7 00 8b 00 00 00    	movl   $0x8b,(%eax)
40034318:	83 c8 ff             	or     $0xffffffff,%eax
4003431b:	eb 57                	jmp    40034374 <sniprintf+0x7b>
4003431d:	66 c7 44 24 0c 08 02 	movw   $0x208,0xc(%esp)
40034324:	89 3c 24             	mov    %edi,(%esp)
40034327:	89 7c 24 10          	mov    %edi,0x10(%esp)
4003432b:	b8 00 00 00 00       	mov    $0x0,%eax
40034330:	74 03                	je     40034335 <sniprintf+0x3c>
40034332:	8d 43 ff             	lea    -0x1(%ebx),%eax
40034335:	89 44 24 08          	mov    %eax,0x8(%esp)
40034339:	89 44 24 14          	mov    %eax,0x14(%esp)
4003433d:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
40034344:	66 c7 44 24 0e ff ff 	movw   $0xffff,0xe(%esp)
4003434b:	50                   	push   %eax
4003434c:	89 f0                	mov    %esi,%eax
4003434e:	8b 8c 24 84 00 00 00 	mov    0x84(%esp),%ecx
40034355:	8d 54 24 04          	lea    0x4(%esp),%edx
40034359:	e8 22 01 00 00       	call   40034480 <_svfiprintf_r>
4003435e:	5a                   	pop    %edx
4003435f:	83 f8 ff             	cmp    $0xffffffff,%eax
40034362:	7d 06                	jge    4003436a <sniprintf+0x71>
40034364:	c7 06 8b 00 00 00    	movl   $0x8b,(%esi)
4003436a:	85 db                	test   %ebx,%ebx
4003436c:	74 06                	je     40034374 <sniprintf+0x7b>
4003436e:	8b 14 24             	mov    (%esp),%edx
40034371:	c6 02 00             	movb   $0x0,(%edx)
40034374:	83 c4 68             	add    $0x68,%esp
40034377:	5b                   	pop    %ebx
40034378:	5e                   	pop    %esi
40034379:	5f                   	pop    %edi
4003437a:	c3                   	ret    

4003437b <strcmp>:
4003437b:	8a 08                	mov    (%eax),%cl
4003437d:	84 c9                	test   %cl,%cl
4003437f:	74 08                	je     40034389 <strcmp+0xe>
40034381:	3a 0a                	cmp    (%edx),%cl
40034383:	75 04                	jne    40034389 <strcmp+0xe>
40034385:	40                   	inc    %eax
40034386:	42                   	inc    %edx
40034387:	eb f2                	jmp    4003437b <strcmp>
40034389:	0f b6 12             	movzbl (%edx),%edx
4003438c:	0f b6 c1             	movzbl %cl,%eax
4003438f:	29 d0                	sub    %edx,%eax
40034391:	c3                   	ret    

40034392 <__getreent>:
40034392:	a1 00 64 00 a8       	mov    0xa8006400,%eax
40034397:	c3                   	ret    

40034398 <__ssputs_r>:
40034398:	55                   	push   %ebp
40034399:	57                   	push   %edi
4003439a:	56                   	push   %esi
4003439b:	53                   	push   %ebx
4003439c:	83 ec 08             	sub    $0x8,%esp
4003439f:	89 d3                	mov    %edx,%ebx
400343a1:	8b 7a 08             	mov    0x8(%edx),%edi
400343a4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400343a8:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
400343ac:	0f 87 a8 00 00 00    	ja     4003445a <__ssputs_r+0xc2>
400343b2:	8b 4a 0c             	mov    0xc(%edx),%ecx
400343b5:	66 f7 c1 80 04       	test   $0x480,%cx
400343ba:	0f 84 9a 00 00 00    	je     4003445a <__ssputs_r+0xc2>
400343c0:	8b 7a 10             	mov    0x10(%edx),%edi
400343c3:	89 c5                	mov    %eax,%ebp
400343c5:	8b 02                	mov    (%edx),%eax
400343c7:	be 02 00 00 00       	mov    $0x2,%esi
400343cc:	29 f8                	sub    %edi,%eax
400343ce:	89 04 24             	mov    %eax,(%esp)
400343d1:	6b 42 14 03          	imul   $0x3,0x14(%edx),%eax
400343d5:	99                   	cltd   
400343d6:	f7 fe                	idiv   %esi
400343d8:	89 c6                	mov    %eax,%esi
400343da:	8b 54 24 1c          	mov    0x1c(%esp),%edx
400343de:	8b 04 24             	mov    (%esp),%eax
400343e1:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
400343e5:	39 f0                	cmp    %esi,%eax
400343e7:	76 02                	jbe    400343eb <__ssputs_r+0x53>
400343e9:	89 c6                	mov    %eax,%esi
400343eb:	80 e5 04             	and    $0x4,%ch
400343ee:	74 29                	je     40034419 <__ssputs_r+0x81>
400343f0:	89 f2                	mov    %esi,%edx
400343f2:	89 e8                	mov    %ebp,%eax
400343f4:	e8 ee fd ff ff       	call   400341e7 <_malloc_r>
400343f9:	89 c7                	mov    %eax,%edi
400343fb:	85 c0                	test   %eax,%eax
400343fd:	74 35                	je     40034434 <__ssputs_r+0x9c>
400343ff:	8b 53 10             	mov    0x10(%ebx),%edx
40034402:	8b 0c 24             	mov    (%esp),%ecx
40034405:	e8 60 bc ff ff       	call   4003006a <memcpy>
4003440a:	8b 43 0c             	mov    0xc(%ebx),%eax
4003440d:	66 25 7f fb          	and    $0xfb7f,%ax
40034411:	0c 80                	or     $0x80,%al
40034413:	66 89 43 0c          	mov    %ax,0xc(%ebx)
40034417:	eb 2c                	jmp    40034445 <__ssputs_r+0xad>
40034419:	89 fa                	mov    %edi,%edx
4003441b:	89 f1                	mov    %esi,%ecx
4003441d:	89 e8                	mov    %ebp,%eax
4003441f:	e8 0b 0e 00 00       	call   4003522f <_realloc_r>
40034424:	89 c7                	mov    %eax,%edi
40034426:	85 c0                	test   %eax,%eax
40034428:	75 1b                	jne    40034445 <__ssputs_r+0xad>
4003442a:	8b 53 10             	mov    0x10(%ebx),%edx
4003442d:	89 e8                	mov    %ebp,%eax
4003442f:	e8 fa fc ff ff       	call   4003412e <_free_r>
40034434:	c7 45 00 0c 00 00 00 	movl   $0xc,0x0(%ebp)
4003443b:	83 c8 ff             	or     $0xffffffff,%eax
4003443e:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
40034443:	eb 33                	jmp    40034478 <__ssputs_r+0xe0>
40034445:	89 7b 10             	mov    %edi,0x10(%ebx)
40034448:	89 73 14             	mov    %esi,0x14(%ebx)
4003444b:	03 3c 24             	add    (%esp),%edi
4003444e:	2b 34 24             	sub    (%esp),%esi
40034451:	89 3b                	mov    %edi,(%ebx)
40034453:	89 73 08             	mov    %esi,0x8(%ebx)
40034456:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
4003445a:	39 7c 24 1c          	cmp    %edi,0x1c(%esp)
4003445e:	73 04                	jae    40034464 <__ssputs_r+0xcc>
40034460:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
40034464:	89 f9                	mov    %edi,%ecx
40034466:	8b 54 24 04          	mov    0x4(%esp),%edx
4003446a:	8b 03                	mov    (%ebx),%eax
4003446c:	e8 2a bc ff ff       	call   4003009b <memmove>
40034471:	29 7b 08             	sub    %edi,0x8(%ebx)
40034474:	01 3b                	add    %edi,(%ebx)
40034476:	31 c0                	xor    %eax,%eax
40034478:	83 c4 08             	add    $0x8,%esp
4003447b:	5b                   	pop    %ebx
4003447c:	5e                   	pop    %esi
4003447d:	5f                   	pop    %edi
4003447e:	5d                   	pop    %ebp
4003447f:	c3                   	ret    

40034480 <_svfiprintf_r>:
40034480:	55                   	push   %ebp
40034481:	57                   	push   %edi
40034482:	56                   	push   %esi
40034483:	53                   	push   %ebx
40034484:	83 ec 68             	sub    $0x68,%esp
40034487:	89 c5                	mov    %eax,%ebp
40034489:	89 d6                	mov    %edx,%esi
4003448b:	89 cf                	mov    %ecx,%edi
4003448d:	f6 42 0c 80          	testb  $0x80,0xc(%edx)
40034491:	74 2f                	je     400344c2 <_svfiprintf_r+0x42>
40034493:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
40034497:	75 29                	jne    400344c2 <_svfiprintf_r+0x42>
40034499:	ba 40 00 00 00       	mov    $0x40,%edx
4003449e:	e8 44 fd ff ff       	call   400341e7 <_malloc_r>
400344a3:	89 06                	mov    %eax,(%esi)
400344a5:	89 46 10             	mov    %eax,0x10(%esi)
400344a8:	85 c0                	test   %eax,%eax
400344aa:	75 0f                	jne    400344bb <_svfiprintf_r+0x3b>
400344ac:	c7 45 00 0c 00 00 00 	movl   $0xc,0x0(%ebp)
400344b3:	83 c8 ff             	or     $0xffffffff,%eax
400344b6:	e9 27 02 00 00       	jmp    400346e2 <_svfiprintf_r+0x262>
400344bb:	c7 46 14 40 00 00 00 	movl   $0x40,0x14(%esi)
400344c2:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
400344c9:	00 
400344ca:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
400344cf:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
400344d4:	89 fb                	mov    %edi,%ebx
400344d6:	8a 03                	mov    (%ebx),%al
400344d8:	84 c0                	test   %al,%al
400344da:	0f 95 c2             	setne  %dl
400344dd:	3c 25                	cmp    $0x25,%al
400344df:	0f 95 c0             	setne  %al
400344e2:	20 c2                	and    %al,%dl
400344e4:	88 54 24 07          	mov    %dl,0x7(%esp)
400344e8:	74 03                	je     400344ed <_svfiprintf_r+0x6d>
400344ea:	43                   	inc    %ebx
400344eb:	eb e9                	jmp    400344d6 <_svfiprintf_r+0x56>
400344ed:	89 d8                	mov    %ebx,%eax
400344ef:	29 f8                	sub    %edi,%eax
400344f1:	89 44 24 08          	mov    %eax,0x8(%esp)
400344f5:	74 1c                	je     40034513 <_svfiprintf_r+0x93>
400344f7:	50                   	push   %eax
400344f8:	89 f9                	mov    %edi,%ecx
400344fa:	89 f2                	mov    %esi,%edx
400344fc:	89 e8                	mov    %ebp,%eax
400344fe:	e8 95 fe ff ff       	call   40034398 <__ssputs_r>
40034503:	59                   	pop    %ecx
40034504:	40                   	inc    %eax
40034505:	0f 84 ca 01 00 00    	je     400346d5 <_svfiprintf_r+0x255>
4003450b:	8b 44 24 08          	mov    0x8(%esp),%eax
4003450f:	01 44 24 20          	add    %eax,0x20(%esp)
40034513:	80 3b 00             	cmpb   $0x0,(%ebx)
40034516:	0f 84 b9 01 00 00    	je     400346d5 <_svfiprintf_r+0x255>
4003451c:	43                   	inc    %ebx
4003451d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
40034524:	00 
40034525:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
4003452c:	00 
4003452d:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034534:	ff 
40034535:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
4003453c:	00 
4003453d:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
40034542:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
40034549:	00 
4003454a:	0f be 13             	movsbl (%ebx),%edx
4003454d:	b9 05 00 00 00       	mov    $0x5,%ecx
40034552:	b8 f2 64 03 40       	mov    $0x400364f2,%eax
40034557:	e8 27 bb ff ff       	call   40030083 <memchr>
4003455c:	85 c0                	test   %eax,%eax
4003455e:	74 15                	je     40034575 <_svfiprintf_r+0xf5>
40034560:	2d f2 64 03 40       	sub    $0x400364f2,%eax
40034565:	ba 01 00 00 00       	mov    $0x1,%edx
4003456a:	88 c1                	mov    %al,%cl
4003456c:	43                   	inc    %ebx
4003456d:	d3 e2                	shl    %cl,%edx
4003456f:	09 54 24 0c          	or     %edx,0xc(%esp)
40034573:	eb d5                	jmp    4003454a <_svfiprintf_r+0xca>
40034575:	8b 44 24 0c          	mov    0xc(%esp),%eax
40034579:	a8 10                	test   $0x10,%al
4003457b:	74 05                	je     40034582 <_svfiprintf_r+0x102>
4003457d:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40034582:	a8 08                	test   $0x8,%al
40034584:	74 05                	je     4003458b <_svfiprintf_r+0x10b>
40034586:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
4003458b:	80 3b 2a             	cmpb   $0x2a,(%ebx)
4003458e:	74 08                	je     40034598 <_svfiprintf_r+0x118>
40034590:	8b 44 24 18          	mov    0x18(%esp),%eax
40034594:	31 c9                	xor    %ecx,%ecx
40034596:	eb 27                	jmp    400345bf <_svfiprintf_r+0x13f>
40034598:	8b 54 24 7c          	mov    0x7c(%esp),%edx
4003459c:	8d 4a 04             	lea    0x4(%edx),%ecx
4003459f:	8b 12                	mov    (%edx),%edx
400345a1:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
400345a5:	85 d2                	test   %edx,%edx
400345a7:	78 06                	js     400345af <_svfiprintf_r+0x12f>
400345a9:	89 54 24 18          	mov    %edx,0x18(%esp)
400345ad:	eb 0d                	jmp    400345bc <_svfiprintf_r+0x13c>
400345af:	f7 da                	neg    %edx
400345b1:	83 c8 02             	or     $0x2,%eax
400345b4:	89 54 24 18          	mov    %edx,0x18(%esp)
400345b8:	89 44 24 0c          	mov    %eax,0xc(%esp)
400345bc:	43                   	inc    %ebx
400345bd:	eb 1d                	jmp    400345dc <_svfiprintf_r+0x15c>
400345bf:	0f be 13             	movsbl (%ebx),%edx
400345c2:	83 ea 30             	sub    $0x30,%edx
400345c5:	83 fa 09             	cmp    $0x9,%edx
400345c8:	77 0a                	ja     400345d4 <_svfiprintf_r+0x154>
400345ca:	6b c0 0a             	imul   $0xa,%eax,%eax
400345cd:	43                   	inc    %ebx
400345ce:	01 d0                	add    %edx,%eax
400345d0:	b1 01                	mov    $0x1,%cl
400345d2:	eb eb                	jmp    400345bf <_svfiprintf_r+0x13f>
400345d4:	84 c9                	test   %cl,%cl
400345d6:	74 04                	je     400345dc <_svfiprintf_r+0x15c>
400345d8:	89 44 24 18          	mov    %eax,0x18(%esp)
400345dc:	80 3b 2e             	cmpb   $0x2e,(%ebx)
400345df:	75 56                	jne    40034637 <_svfiprintf_r+0x1b7>
400345e1:	8d 43 01             	lea    0x1(%ebx),%eax
400345e4:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
400345e8:	75 1e                	jne    40034608 <_svfiprintf_r+0x188>
400345ea:	8b 44 24 7c          	mov    0x7c(%esp),%eax
400345ee:	83 c3 02             	add    $0x2,%ebx
400345f1:	8d 50 04             	lea    0x4(%eax),%edx
400345f4:	8b 00                	mov    (%eax),%eax
400345f6:	89 54 24 7c          	mov    %edx,0x7c(%esp)
400345fa:	85 c0                	test   %eax,%eax
400345fc:	79 35                	jns    40034633 <_svfiprintf_r+0x1b3>
400345fe:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034605:	ff 
40034606:	eb 2f                	jmp    40034637 <_svfiprintf_r+0x1b7>
40034608:	89 c3                	mov    %eax,%ebx
4003460a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
40034611:	00 
40034612:	31 c0                	xor    %eax,%eax
40034614:	0f be 13             	movsbl (%ebx),%edx
40034617:	83 ea 30             	sub    $0x30,%edx
4003461a:	83 fa 09             	cmp    $0x9,%edx
4003461d:	77 0d                	ja     4003462c <_svfiprintf_r+0x1ac>
4003461f:	6b c0 0a             	imul   $0xa,%eax,%eax
40034622:	43                   	inc    %ebx
40034623:	01 d0                	add    %edx,%eax
40034625:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
4003462a:	eb e8                	jmp    40034614 <_svfiprintf_r+0x194>
4003462c:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
40034631:	74 04                	je     40034637 <_svfiprintf_r+0x1b7>
40034633:	89 44 24 10          	mov    %eax,0x10(%esp)
40034637:	0f be 13             	movsbl (%ebx),%edx
4003463a:	b9 03 00 00 00       	mov    $0x3,%ecx
4003463f:	b8 f8 64 03 40       	mov    $0x400364f8,%eax
40034644:	e8 3a ba ff ff       	call   40030083 <memchr>
40034649:	85 c0                	test   %eax,%eax
4003464b:	74 13                	je     40034660 <_svfiprintf_r+0x1e0>
4003464d:	2d f8 64 03 40       	sub    $0x400364f8,%eax
40034652:	ba 40 00 00 00       	mov    $0x40,%edx
40034657:	88 c1                	mov    %al,%cl
40034659:	43                   	inc    %ebx
4003465a:	d3 e2                	shl    %cl,%edx
4003465c:	09 54 24 0c          	or     %edx,0xc(%esp)
40034660:	0f be 13             	movsbl (%ebx),%edx
40034663:	b9 06 00 00 00       	mov    $0x6,%ecx
40034668:	b8 fc 64 03 40       	mov    $0x400364fc,%eax
4003466d:	88 54 24 24          	mov    %dl,0x24(%esp)
40034671:	e8 0d ba ff ff       	call   40030083 <memchr>
40034676:	8d 7b 01             	lea    0x1(%ebx),%edi
40034679:	85 c0                	test   %eax,%eax
4003467b:	74 29                	je     400346a6 <_svfiprintf_r+0x226>
4003467d:	b8 00 00 00 00       	mov    $0x0,%eax
40034682:	85 c0                	test   %eax,%eax
40034684:	75 07                	jne    4003468d <_svfiprintf_r+0x20d>
40034686:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
4003468b:	eb 3c                	jmp    400346c9 <_svfiprintf_r+0x249>
4003468d:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034691:	89 f1                	mov    %esi,%ecx
40034693:	50                   	push   %eax
40034694:	68 98 43 03 40       	push   $0x40034398
40034699:	8d 54 24 14          	lea    0x14(%esp),%edx
4003469d:	89 e8                	mov    %ebp,%eax
4003469f:	e8 5c b9 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
400346a4:	eb 17                	jmp    400346bd <_svfiprintf_r+0x23d>
400346a6:	8d 44 24 7c          	lea    0x7c(%esp),%eax
400346aa:	89 f1                	mov    %esi,%ecx
400346ac:	50                   	push   %eax
400346ad:	68 98 43 03 40       	push   $0x40034398
400346b2:	8d 54 24 14          	lea    0x14(%esp),%edx
400346b6:	89 e8                	mov    %ebp,%eax
400346b8:	e8 09 01 00 00       	call   400347c6 <_printf_i>
400346bd:	89 44 24 08          	mov    %eax,0x8(%esp)
400346c1:	58                   	pop    %eax
400346c2:	5a                   	pop    %edx
400346c3:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
400346c7:	74 0c                	je     400346d5 <_svfiprintf_r+0x255>
400346c9:	8b 04 24             	mov    (%esp),%eax
400346cc:	01 44 24 20          	add    %eax,0x20(%esp)
400346d0:	e9 ff fd ff ff       	jmp    400344d4 <_svfiprintf_r+0x54>
400346d5:	83 c8 ff             	or     $0xffffffff,%eax
400346d8:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
400346dc:	75 04                	jne    400346e2 <_svfiprintf_r+0x262>
400346de:	8b 44 24 20          	mov    0x20(%esp),%eax
400346e2:	83 c4 68             	add    $0x68,%esp
400346e5:	5b                   	pop    %ebx
400346e6:	5e                   	pop    %esi
400346e7:	5f                   	pop    %edi
400346e8:	5d                   	pop    %ebp
400346e9:	c3                   	ret    

400346ea <_printf_common>:
400346ea:	55                   	push   %ebp
400346eb:	57                   	push   %edi
400346ec:	56                   	push   %esi
400346ed:	53                   	push   %ebx
400346ee:	53                   	push   %ebx
400346ef:	89 d3                	mov    %edx,%ebx
400346f1:	89 c5                	mov    %eax,%ebp
400346f3:	8b 52 08             	mov    0x8(%edx),%edx
400346f6:	8b 43 10             	mov    0x10(%ebx),%eax
400346f9:	89 ce                	mov    %ecx,%esi
400346fb:	39 d0                	cmp    %edx,%eax
400346fd:	7d 02                	jge    40034701 <_printf_common+0x17>
400346ff:	89 d0                	mov    %edx,%eax
40034701:	89 06                	mov    %eax,(%esi)
40034703:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034707:	74 03                	je     4003470c <_printf_common+0x22>
40034709:	40                   	inc    %eax
4003470a:	89 06                	mov    %eax,(%esi)
4003470c:	f6 03 20             	testb  $0x20,(%ebx)
4003470f:	74 03                	je     40034714 <_printf_common+0x2a>
40034711:	83 06 02             	addl   $0x2,(%esi)
40034714:	8b 3b                	mov    (%ebx),%edi
40034716:	83 e7 06             	and    $0x6,%edi
40034719:	75 26                	jne    40034741 <_printf_common+0x57>
4003471b:	8d 43 19             	lea    0x19(%ebx),%eax
4003471e:	89 04 24             	mov    %eax,(%esp)
40034721:	eb 15                	jmp    40034738 <_printf_common+0x4e>
40034723:	6a 01                	push   $0x1
40034725:	89 e8                	mov    %ebp,%eax
40034727:	8b 4c 24 04          	mov    0x4(%esp),%ecx
4003472b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
4003472f:	ff 54 24 20          	call   *0x20(%esp)
40034733:	5a                   	pop    %edx
40034734:	40                   	inc    %eax
40034735:	74 3c                	je     40034773 <_printf_common+0x89>
40034737:	47                   	inc    %edi
40034738:	8b 43 0c             	mov    0xc(%ebx),%eax
4003473b:	2b 06                	sub    (%esi),%eax
4003473d:	39 c7                	cmp    %eax,%edi
4003473f:	7c e2                	jl     40034723 <_printf_common+0x39>
40034741:	31 c0                	xor    %eax,%eax
40034743:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034747:	0f 95 c0             	setne  %al
4003474a:	f6 03 20             	testb  $0x20,(%ebx)
4003474d:	74 12                	je     40034761 <_printf_common+0x77>
4003474f:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
40034754:	8d 50 01             	lea    0x1(%eax),%edx
40034757:	8a 4b 45             	mov    0x45(%ebx),%cl
4003475a:	83 c0 02             	add    $0x2,%eax
4003475d:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
40034761:	50                   	push   %eax
40034762:	8d 4b 43             	lea    0x43(%ebx),%ecx
40034765:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034769:	89 e8                	mov    %ebp,%eax
4003476b:	ff 54 24 20          	call   *0x20(%esp)
4003476f:	5f                   	pop    %edi
40034770:	40                   	inc    %eax
40034771:	75 05                	jne    40034778 <_printf_common+0x8e>
40034773:	83 c8 ff             	or     $0xffffffff,%eax
40034776:	eb 48                	jmp    400347c0 <_printf_common+0xd6>
40034778:	8b 43 0c             	mov    0xc(%ebx),%eax
4003477b:	2b 06                	sub    (%esi),%eax
4003477d:	89 c6                	mov    %eax,%esi
4003477f:	8b 03                	mov    (%ebx),%eax
40034781:	83 e0 06             	and    $0x6,%eax
40034784:	83 f8 04             	cmp    $0x4,%eax
40034787:	75 07                	jne    40034790 <_printf_common+0xa6>
40034789:	89 f0                	mov    %esi,%eax
4003478b:	c1 e8 1f             	shr    $0x1f,%eax
4003478e:	74 02                	je     40034792 <_printf_common+0xa8>
40034790:	31 f6                	xor    %esi,%esi
40034792:	8b 43 08             	mov    0x8(%ebx),%eax
40034795:	8b 53 10             	mov    0x10(%ebx),%edx
40034798:	39 d0                	cmp    %edx,%eax
4003479a:	7e 04                	jle    400347a0 <_printf_common+0xb6>
4003479c:	29 d0                	sub    %edx,%eax
4003479e:	01 c6                	add    %eax,%esi
400347a0:	31 ff                	xor    %edi,%edi
400347a2:	83 c3 1a             	add    $0x1a,%ebx
400347a5:	39 fe                	cmp    %edi,%esi
400347a7:	74 15                	je     400347be <_printf_common+0xd4>
400347a9:	6a 01                	push   $0x1
400347ab:	89 d9                	mov    %ebx,%ecx
400347ad:	8b 54 24 1c          	mov    0x1c(%esp),%edx
400347b1:	89 e8                	mov    %ebp,%eax
400347b3:	ff 54 24 20          	call   *0x20(%esp)
400347b7:	59                   	pop    %ecx
400347b8:	40                   	inc    %eax
400347b9:	74 b8                	je     40034773 <_printf_common+0x89>
400347bb:	47                   	inc    %edi
400347bc:	eb e7                	jmp    400347a5 <_printf_common+0xbb>
400347be:	31 c0                	xor    %eax,%eax
400347c0:	5a                   	pop    %edx
400347c1:	5b                   	pop    %ebx
400347c2:	5e                   	pop    %esi
400347c3:	5f                   	pop    %edi
400347c4:	5d                   	pop    %ebp
400347c5:	c3                   	ret    

400347c6 <_printf_i>:
400347c6:	55                   	push   %ebp
400347c7:	57                   	push   %edi
400347c8:	56                   	push   %esi
400347c9:	53                   	push   %ebx
400347ca:	83 ec 0c             	sub    $0xc,%esp
400347cd:	89 d3                	mov    %edx,%ebx
400347cf:	8d 6a 43             	lea    0x43(%edx),%ebp
400347d2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400347d6:	8a 4a 18             	mov    0x18(%edx),%cl
400347d9:	89 04 24             	mov    %eax,(%esp)
400347dc:	80 f9 6e             	cmp    $0x6e,%cl
400347df:	8b 44 24 24          	mov    0x24(%esp),%eax
400347e3:	0f 84 83 01 00 00    	je     4003496c <_printf_i+0x1a6>
400347e9:	7f 35                	jg     40034820 <_printf_i+0x5a>
400347eb:	80 f9 63             	cmp    $0x63,%cl
400347ee:	74 60                	je     40034850 <_printf_i+0x8a>
400347f0:	7f 1f                	jg     40034811 <_printf_i+0x4b>
400347f2:	84 c9                	test   %cl,%cl
400347f4:	0f 84 9d 01 00 00    	je     40034997 <_printf_i+0x1d1>
400347fa:	80 f9 58             	cmp    $0x58,%cl
400347fd:	0f 85 c5 01 00 00    	jne    400349c8 <_printf_i+0x202>
40034803:	c6 42 45 58          	movb   $0x58,0x45(%edx)
40034807:	bf 03 65 03 40       	mov    $0x40036503,%edi
4003480c:	e9 c2 00 00 00       	jmp    400348d3 <_printf_i+0x10d>
40034811:	80 f9 64             	cmp    $0x64,%cl
40034814:	74 4e                	je     40034864 <_printf_i+0x9e>
40034816:	80 f9 69             	cmp    $0x69,%cl
40034819:	74 49                	je     40034864 <_printf_i+0x9e>
4003481b:	e9 a8 01 00 00       	jmp    400349c8 <_printf_i+0x202>
40034820:	80 f9 73             	cmp    $0x73,%cl
40034823:	0f 84 79 01 00 00    	je     400349a2 <_printf_i+0x1dc>
40034829:	7f 16                	jg     40034841 <_printf_i+0x7b>
4003482b:	80 f9 6f             	cmp    $0x6f,%cl
4003482e:	74 65                	je     40034895 <_printf_i+0xcf>
40034830:	80 f9 70             	cmp    $0x70,%cl
40034833:	0f 85 8f 01 00 00    	jne    400349c8 <_printf_i+0x202>
40034839:	83 0a 20             	orl    $0x20,(%edx)
4003483c:	e9 89 00 00 00       	jmp    400348ca <_printf_i+0x104>
40034841:	80 f9 75             	cmp    $0x75,%cl
40034844:	74 4f                	je     40034895 <_printf_i+0xcf>
40034846:	80 f9 78             	cmp    $0x78,%cl
40034849:	74 7f                	je     400348ca <_printf_i+0x104>
4003484b:	e9 78 01 00 00       	jmp    400349c8 <_printf_i+0x202>
40034850:	8d 72 42             	lea    0x42(%edx),%esi
40034853:	8b 10                	mov    (%eax),%edx
40034855:	8d 4a 04             	lea    0x4(%edx),%ecx
40034858:	89 08                	mov    %ecx,(%eax)
4003485a:	8b 02                	mov    (%edx),%eax
4003485c:	88 43 42             	mov    %al,0x42(%ebx)
4003485f:	e9 6a 01 00 00       	jmp    400349ce <_printf_i+0x208>
40034864:	8b 0b                	mov    (%ebx),%ecx
40034866:	8b 10                	mov    (%eax),%edx
40034868:	f6 c1 80             	test   $0x80,%cl
4003486b:	74 07                	je     40034874 <_printf_i+0xae>
4003486d:	8d 4a 04             	lea    0x4(%edx),%ecx
40034870:	89 08                	mov    %ecx,(%eax)
40034872:	eb 0f                	jmp    40034883 <_printf_i+0xbd>
40034874:	80 e1 40             	and    $0x40,%cl
40034877:	8d 4a 04             	lea    0x4(%edx),%ecx
4003487a:	89 08                	mov    %ecx,(%eax)
4003487c:	74 05                	je     40034883 <_printf_i+0xbd>
4003487e:	0f bf 02             	movswl (%edx),%eax
40034881:	eb 02                	jmp    40034885 <_printf_i+0xbf>
40034883:	8b 02                	mov    (%edx),%eax
40034885:	85 c0                	test   %eax,%eax
40034887:	0f 89 83 00 00 00    	jns    40034910 <_printf_i+0x14a>
4003488d:	f7 d8                	neg    %eax
4003488f:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
40034893:	eb 7b                	jmp    40034910 <_printf_i+0x14a>
40034895:	8b 33                	mov    (%ebx),%esi
40034897:	8b 10                	mov    (%eax),%edx
40034899:	f7 c6 80 00 00 00    	test   $0x80,%esi
4003489f:	74 07                	je     400348a8 <_printf_i+0xe2>
400348a1:	8d 72 04             	lea    0x4(%edx),%esi
400348a4:	89 30                	mov    %esi,(%eax)
400348a6:	eb 0f                	jmp    400348b7 <_printf_i+0xf1>
400348a8:	83 e6 40             	and    $0x40,%esi
400348ab:	8d 72 04             	lea    0x4(%edx),%esi
400348ae:	89 30                	mov    %esi,(%eax)
400348b0:	74 05                	je     400348b7 <_printf_i+0xf1>
400348b2:	0f b7 02             	movzwl (%edx),%eax
400348b5:	eb 02                	jmp    400348b9 <_printf_i+0xf3>
400348b7:	8b 02                	mov    (%edx),%eax
400348b9:	bf 03 65 03 40       	mov    $0x40036503,%edi
400348be:	80 f9 6f             	cmp    $0x6f,%cl
400348c1:	74 42                	je     40034905 <_printf_i+0x13f>
400348c3:	b9 0a 00 00 00       	mov    $0xa,%ecx
400348c8:	eb 40                	jmp    4003490a <_printf_i+0x144>
400348ca:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
400348ce:	bf 14 65 03 40       	mov    $0x40036514,%edi
400348d3:	8b 08                	mov    (%eax),%ecx
400348d5:	8b 13                	mov    (%ebx),%edx
400348d7:	f6 c2 80             	test   $0x80,%dl
400348da:	8d 71 04             	lea    0x4(%ecx),%esi
400348dd:	89 30                	mov    %esi,(%eax)
400348df:	75 0a                	jne    400348eb <_printf_i+0x125>
400348e1:	f6 c2 40             	test   $0x40,%dl
400348e4:	74 05                	je     400348eb <_printf_i+0x125>
400348e6:	0f b7 01             	movzwl (%ecx),%eax
400348e9:	eb 02                	jmp    400348ed <_printf_i+0x127>
400348eb:	8b 01                	mov    (%ecx),%eax
400348ed:	f6 c2 01             	test   $0x1,%dl
400348f0:	74 05                	je     400348f7 <_printf_i+0x131>
400348f2:	83 ca 20             	or     $0x20,%edx
400348f5:	89 13                	mov    %edx,(%ebx)
400348f7:	b9 10 00 00 00       	mov    $0x10,%ecx
400348fc:	85 c0                	test   %eax,%eax
400348fe:	75 0a                	jne    4003490a <_printf_i+0x144>
40034900:	83 23 df             	andl   $0xffffffdf,(%ebx)
40034903:	eb 05                	jmp    4003490a <_printf_i+0x144>
40034905:	b9 08 00 00 00       	mov    $0x8,%ecx
4003490a:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
4003490e:	eb 0a                	jmp    4003491a <_printf_i+0x154>
40034910:	bf 03 65 03 40       	mov    $0x40036503,%edi
40034915:	b9 0a 00 00 00       	mov    $0xa,%ecx
4003491a:	8b 53 04             	mov    0x4(%ebx),%edx
4003491d:	89 53 08             	mov    %edx,0x8(%ebx)
40034920:	85 d2                	test   %edx,%edx
40034922:	78 12                	js     40034936 <_printf_i+0x170>
40034924:	83 23 fb             	andl   $0xfffffffb,(%ebx)
40034927:	85 c0                	test   %eax,%eax
40034929:	75 13                	jne    4003493e <_printf_i+0x178>
4003492b:	89 ee                	mov    %ebp,%esi
4003492d:	85 d2                	test   %edx,%edx
4003492f:	74 1d                	je     4003494e <_printf_i+0x188>
40034931:	e9 14 01 00 00       	jmp    40034a4a <_printf_i+0x284>
40034936:	85 c0                	test   %eax,%eax
40034938:	0f 84 0c 01 00 00    	je     40034a4a <_printf_i+0x284>
4003493e:	89 ee                	mov    %ebp,%esi
40034940:	31 d2                	xor    %edx,%edx
40034942:	4e                   	dec    %esi
40034943:	f7 f1                	div    %ecx
40034945:	85 c0                	test   %eax,%eax
40034947:	8a 14 17             	mov    (%edi,%edx,1),%dl
4003494a:	88 16                	mov    %dl,(%esi)
4003494c:	75 f2                	jne    40034940 <_printf_i+0x17a>
4003494e:	83 f9 08             	cmp    $0x8,%ecx
40034951:	75 12                	jne    40034965 <_printf_i+0x19f>
40034953:	f6 03 01             	testb  $0x1,(%ebx)
40034956:	74 0d                	je     40034965 <_printf_i+0x19f>
40034958:	8b 43 10             	mov    0x10(%ebx),%eax
4003495b:	39 43 04             	cmp    %eax,0x4(%ebx)
4003495e:	7f 05                	jg     40034965 <_printf_i+0x19f>
40034960:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
40034964:	4e                   	dec    %esi
40034965:	29 f5                	sub    %esi,%ebp
40034967:	89 6b 10             	mov    %ebp,0x10(%ebx)
4003496a:	eb 6d                	jmp    400349d9 <_printf_i+0x213>
4003496c:	8b 32                	mov    (%edx),%esi
4003496e:	8b 4b 14             	mov    0x14(%ebx),%ecx
40034971:	f7 c6 80 00 00 00    	test   $0x80,%esi
40034977:	8b 10                	mov    (%eax),%edx
40034979:	74 09                	je     40034984 <_printf_i+0x1be>
4003497b:	8d 72 04             	lea    0x4(%edx),%esi
4003497e:	89 30                	mov    %esi,(%eax)
40034980:	8b 02                	mov    (%edx),%eax
40034982:	eb 11                	jmp    40034995 <_printf_i+0x1cf>
40034984:	83 e6 40             	and    $0x40,%esi
40034987:	8d 72 04             	lea    0x4(%edx),%esi
4003498a:	89 30                	mov    %esi,(%eax)
4003498c:	8b 02                	mov    (%edx),%eax
4003498e:	74 05                	je     40034995 <_printf_i+0x1cf>
40034990:	66 89 08             	mov    %cx,(%eax)
40034993:	eb 02                	jmp    40034997 <_printf_i+0x1d1>
40034995:	89 08                	mov    %ecx,(%eax)
40034997:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
4003499e:	89 ee                	mov    %ebp,%esi
400349a0:	eb 37                	jmp    400349d9 <_printf_i+0x213>
400349a2:	8b 10                	mov    (%eax),%edx
400349a4:	8d 4a 04             	lea    0x4(%edx),%ecx
400349a7:	89 08                	mov    %ecx,(%eax)
400349a9:	8b 4b 04             	mov    0x4(%ebx),%ecx
400349ac:	8b 32                	mov    (%edx),%esi
400349ae:	31 d2                	xor    %edx,%edx
400349b0:	89 f0                	mov    %esi,%eax
400349b2:	e8 cc b6 ff ff       	call   40030083 <memchr>
400349b7:	85 c0                	test   %eax,%eax
400349b9:	74 05                	je     400349c0 <_printf_i+0x1fa>
400349bb:	29 f0                	sub    %esi,%eax
400349bd:	89 43 04             	mov    %eax,0x4(%ebx)
400349c0:	8b 43 04             	mov    0x4(%ebx),%eax
400349c3:	89 43 10             	mov    %eax,0x10(%ebx)
400349c6:	eb 0d                	jmp    400349d5 <_printf_i+0x20f>
400349c8:	8d 73 42             	lea    0x42(%ebx),%esi
400349cb:	88 4b 42             	mov    %cl,0x42(%ebx)
400349ce:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
400349d5:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
400349d9:	ff 74 24 20          	pushl  0x20(%esp)
400349dd:	ff 74 24 08          	pushl  0x8(%esp)
400349e1:	89 da                	mov    %ebx,%edx
400349e3:	8d 4c 24 10          	lea    0x10(%esp),%ecx
400349e7:	8b 44 24 08          	mov    0x8(%esp),%eax
400349eb:	e8 fa fc ff ff       	call   400346ea <_printf_common>
400349f0:	5f                   	pop    %edi
400349f1:	40                   	inc    %eax
400349f2:	5d                   	pop    %ebp
400349f3:	75 05                	jne    400349fa <_printf_i+0x234>
400349f5:	83 c8 ff             	or     $0xffffffff,%eax
400349f8:	eb 5d                	jmp    40034a57 <_printf_i+0x291>
400349fa:	ff 73 10             	pushl  0x10(%ebx)
400349fd:	89 f1                	mov    %esi,%ecx
400349ff:	8b 54 24 08          	mov    0x8(%esp),%edx
40034a03:	8b 44 24 04          	mov    0x4(%esp),%eax
40034a07:	ff 54 24 24          	call   *0x24(%esp)
40034a0b:	59                   	pop    %ecx
40034a0c:	40                   	inc    %eax
40034a0d:	74 e6                	je     400349f5 <_printf_i+0x22f>
40034a0f:	f6 03 02             	testb  $0x2,(%ebx)
40034a12:	74 27                	je     40034a3b <_printf_i+0x275>
40034a14:	31 f6                	xor    %esi,%esi
40034a16:	8d 7b 19             	lea    0x19(%ebx),%edi
40034a19:	eb 15                	jmp    40034a30 <_printf_i+0x26a>
40034a1b:	6a 01                	push   $0x1
40034a1d:	89 f9                	mov    %edi,%ecx
40034a1f:	8b 54 24 08          	mov    0x8(%esp),%edx
40034a23:	8b 44 24 04          	mov    0x4(%esp),%eax
40034a27:	ff 54 24 24          	call   *0x24(%esp)
40034a2b:	5a                   	pop    %edx
40034a2c:	40                   	inc    %eax
40034a2d:	74 c6                	je     400349f5 <_printf_i+0x22f>
40034a2f:	46                   	inc    %esi
40034a30:	8b 43 0c             	mov    0xc(%ebx),%eax
40034a33:	2b 44 24 08          	sub    0x8(%esp),%eax
40034a37:	39 c6                	cmp    %eax,%esi
40034a39:	7c e0                	jl     40034a1b <_printf_i+0x255>
40034a3b:	8b 54 24 08          	mov    0x8(%esp),%edx
40034a3f:	8b 43 0c             	mov    0xc(%ebx),%eax
40034a42:	39 d0                	cmp    %edx,%eax
40034a44:	7d 11                	jge    40034a57 <_printf_i+0x291>
40034a46:	89 d0                	mov    %edx,%eax
40034a48:	eb 0d                	jmp    40034a57 <_printf_i+0x291>
40034a4a:	8a 07                	mov    (%edi),%al
40034a4c:	8d 73 42             	lea    0x42(%ebx),%esi
40034a4f:	88 43 42             	mov    %al,0x42(%ebx)
40034a52:	e9 f7 fe ff ff       	jmp    4003494e <_printf_i+0x188>
40034a57:	83 c4 0c             	add    $0xc,%esp
40034a5a:	5b                   	pop    %ebx
40034a5b:	5e                   	pop    %esi
40034a5c:	5f                   	pop    %edi
40034a5d:	5d                   	pop    %ebp
40034a5e:	c3                   	ret    

40034a5f <__sfputc_r>:
40034a5f:	53                   	push   %ebx
40034a60:	8b 59 08             	mov    0x8(%ecx),%ebx
40034a63:	4b                   	dec    %ebx
40034a64:	89 59 08             	mov    %ebx,0x8(%ecx)
40034a67:	85 db                	test   %ebx,%ebx
40034a69:	79 10                	jns    40034a7b <__sfputc_r+0x1c>
40034a6b:	3b 59 18             	cmp    0x18(%ecx),%ebx
40034a6e:	7c 05                	jl     40034a75 <__sfputc_r+0x16>
40034a70:	80 fa 0a             	cmp    $0xa,%dl
40034a73:	75 06                	jne    40034a7b <__sfputc_r+0x1c>
40034a75:	5b                   	pop    %ebx
40034a76:	e9 cf 02 00 00       	jmp    40034d4a <__swbuf_r>
40034a7b:	8b 01                	mov    (%ecx),%eax
40034a7d:	8d 58 01             	lea    0x1(%eax),%ebx
40034a80:	89 19                	mov    %ebx,(%ecx)
40034a82:	88 10                	mov    %dl,(%eax)
40034a84:	5b                   	pop    %ebx
40034a85:	0f b6 c2             	movzbl %dl,%eax
40034a88:	c3                   	ret    

40034a89 <__sfputs_r>:
40034a89:	55                   	push   %ebp
40034a8a:	57                   	push   %edi
40034a8b:	56                   	push   %esi
40034a8c:	53                   	push   %ebx
40034a8d:	8b 74 24 14          	mov    0x14(%esp),%esi
40034a91:	89 c7                	mov    %eax,%edi
40034a93:	89 d5                	mov    %edx,%ebp
40034a95:	89 cb                	mov    %ecx,%ebx
40034a97:	01 ce                	add    %ecx,%esi
40034a99:	39 f3                	cmp    %esi,%ebx
40034a9b:	74 14                	je     40034ab1 <__sfputs_r+0x28>
40034a9d:	0f be 13             	movsbl (%ebx),%edx
40034aa0:	89 e9                	mov    %ebp,%ecx
40034aa2:	89 f8                	mov    %edi,%eax
40034aa4:	e8 b6 ff ff ff       	call   40034a5f <__sfputc_r>
40034aa9:	43                   	inc    %ebx
40034aaa:	83 f8 ff             	cmp    $0xffffffff,%eax
40034aad:	75 ea                	jne    40034a99 <__sfputs_r+0x10>
40034aaf:	eb 02                	jmp    40034ab3 <__sfputs_r+0x2a>
40034ab1:	31 c0                	xor    %eax,%eax
40034ab3:	5b                   	pop    %ebx
40034ab4:	5e                   	pop    %esi
40034ab5:	5f                   	pop    %edi
40034ab6:	5d                   	pop    %ebp
40034ab7:	c3                   	ret    

40034ab8 <_vfiprintf_r>:
40034ab8:	55                   	push   %ebp
40034ab9:	57                   	push   %edi
40034aba:	56                   	push   %esi
40034abb:	53                   	push   %ebx
40034abc:	83 ec 68             	sub    $0x68,%esp
40034abf:	89 c5                	mov    %eax,%ebp
40034ac1:	89 d6                	mov    %edx,%esi
40034ac3:	89 cf                	mov    %ecx,%edi
40034ac5:	85 c0                	test   %eax,%eax
40034ac7:	74 0b                	je     40034ad4 <_vfiprintf_r+0x1c>
40034ac9:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034acd:	75 05                	jne    40034ad4 <_vfiprintf_r+0x1c>
40034acf:	e8 93 05 00 00       	call   40035067 <__sinit>
40034ad4:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
40034ad8:	74 1d                	je     40034af7 <_vfiprintf_r+0x3f>
40034ada:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
40034ade:	74 17                	je     40034af7 <_vfiprintf_r+0x3f>
40034ae0:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
40034ae7:	00 
40034ae8:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
40034aed:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
40034af2:	e9 9b 00 00 00       	jmp    40034b92 <_vfiprintf_r+0xda>
40034af7:	89 f2                	mov    %esi,%edx
40034af9:	89 e8                	mov    %ebp,%eax
40034afb:	e8 d8 02 00 00       	call   40034dd8 <__swsetup_r>
40034b00:	85 c0                	test   %eax,%eax
40034b02:	74 dc                	je     40034ae0 <_vfiprintf_r+0x28>
40034b04:	83 c8 ff             	or     $0xffffffff,%eax
40034b07:	e9 36 02 00 00       	jmp    40034d42 <_vfiprintf_r+0x28a>
40034b0c:	8b 54 24 7c          	mov    0x7c(%esp),%edx
40034b10:	8d 4a 04             	lea    0x4(%edx),%ecx
40034b13:	8b 12                	mov    (%edx),%edx
40034b15:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
40034b19:	85 d2                	test   %edx,%edx
40034b1b:	0f 88 39 01 00 00    	js     40034c5a <_vfiprintf_r+0x1a2>
40034b21:	89 54 24 18          	mov    %edx,0x18(%esp)
40034b25:	43                   	inc    %ebx
40034b26:	80 3b 2e             	cmpb   $0x2e,(%ebx)
40034b29:	0f 84 63 01 00 00    	je     40034c92 <_vfiprintf_r+0x1da>
40034b2f:	0f be 13             	movsbl (%ebx),%edx
40034b32:	b9 03 00 00 00       	mov    $0x3,%ecx
40034b37:	b8 f8 64 03 40       	mov    $0x400364f8,%eax
40034b3c:	e8 42 b5 ff ff       	call   40030083 <memchr>
40034b41:	85 c0                	test   %eax,%eax
40034b43:	74 13                	je     40034b58 <_vfiprintf_r+0xa0>
40034b45:	2d f8 64 03 40       	sub    $0x400364f8,%eax
40034b4a:	ba 40 00 00 00       	mov    $0x40,%edx
40034b4f:	88 c1                	mov    %al,%cl
40034b51:	43                   	inc    %ebx
40034b52:	d3 e2                	shl    %cl,%edx
40034b54:	09 54 24 0c          	or     %edx,0xc(%esp)
40034b58:	0f be 13             	movsbl (%ebx),%edx
40034b5b:	b9 06 00 00 00       	mov    $0x6,%ecx
40034b60:	b8 fc 64 03 40       	mov    $0x400364fc,%eax
40034b65:	88 54 24 24          	mov    %dl,0x24(%esp)
40034b69:	e8 15 b5 ff ff       	call   40030083 <memchr>
40034b6e:	8d 7b 01             	lea    0x1(%ebx),%edi
40034b71:	85 c0                	test   %eax,%eax
40034b73:	0f 84 94 01 00 00    	je     40034d0d <_vfiprintf_r+0x255>
40034b79:	b8 00 00 00 00       	mov    $0x0,%eax
40034b7e:	85 c0                	test   %eax,%eax
40034b80:	0f 85 6e 01 00 00    	jne    40034cf4 <_vfiprintf_r+0x23c>
40034b86:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
40034b8b:	8b 04 24             	mov    (%esp),%eax
40034b8e:	01 44 24 20          	add    %eax,0x20(%esp)
40034b92:	89 fb                	mov    %edi,%ebx
40034b94:	8a 03                	mov    (%ebx),%al
40034b96:	84 c0                	test   %al,%al
40034b98:	0f 95 c2             	setne  %dl
40034b9b:	3c 25                	cmp    $0x25,%al
40034b9d:	0f 95 c0             	setne  %al
40034ba0:	20 c2                	and    %al,%dl
40034ba2:	88 54 24 07          	mov    %dl,0x7(%esp)
40034ba6:	74 03                	je     40034bab <_vfiprintf_r+0xf3>
40034ba8:	43                   	inc    %ebx
40034ba9:	eb e9                	jmp    40034b94 <_vfiprintf_r+0xdc>
40034bab:	89 d8                	mov    %ebx,%eax
40034bad:	29 f8                	sub    %edi,%eax
40034baf:	89 44 24 08          	mov    %eax,0x8(%esp)
40034bb3:	74 1c                	je     40034bd1 <_vfiprintf_r+0x119>
40034bb5:	50                   	push   %eax
40034bb6:	89 f9                	mov    %edi,%ecx
40034bb8:	89 f2                	mov    %esi,%edx
40034bba:	89 e8                	mov    %ebp,%eax
40034bbc:	e8 c8 fe ff ff       	call   40034a89 <__sfputs_r>
40034bc1:	59                   	pop    %ecx
40034bc2:	40                   	inc    %eax
40034bc3:	0f 84 6b 01 00 00    	je     40034d34 <_vfiprintf_r+0x27c>
40034bc9:	8b 44 24 08          	mov    0x8(%esp),%eax
40034bcd:	01 44 24 20          	add    %eax,0x20(%esp)
40034bd1:	80 3b 00             	cmpb   $0x0,(%ebx)
40034bd4:	0f 84 5a 01 00 00    	je     40034d34 <_vfiprintf_r+0x27c>
40034bda:	43                   	inc    %ebx
40034bdb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
40034be2:	00 
40034be3:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
40034bea:	00 
40034beb:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034bf2:	ff 
40034bf3:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
40034bfa:	00 
40034bfb:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
40034c00:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
40034c07:	00 
40034c08:	0f be 13             	movsbl (%ebx),%edx
40034c0b:	b9 05 00 00 00       	mov    $0x5,%ecx
40034c10:	b8 f2 64 03 40       	mov    $0x400364f2,%eax
40034c15:	e8 69 b4 ff ff       	call   40030083 <memchr>
40034c1a:	85 c0                	test   %eax,%eax
40034c1c:	74 15                	je     40034c33 <_vfiprintf_r+0x17b>
40034c1e:	2d f2 64 03 40       	sub    $0x400364f2,%eax
40034c23:	ba 01 00 00 00       	mov    $0x1,%edx
40034c28:	88 c1                	mov    %al,%cl
40034c2a:	43                   	inc    %ebx
40034c2b:	d3 e2                	shl    %cl,%edx
40034c2d:	09 54 24 0c          	or     %edx,0xc(%esp)
40034c31:	eb d5                	jmp    40034c08 <_vfiprintf_r+0x150>
40034c33:	8b 44 24 0c          	mov    0xc(%esp),%eax
40034c37:	a8 10                	test   $0x10,%al
40034c39:	74 05                	je     40034c40 <_vfiprintf_r+0x188>
40034c3b:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40034c40:	a8 08                	test   $0x8,%al
40034c42:	74 05                	je     40034c49 <_vfiprintf_r+0x191>
40034c44:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
40034c49:	80 3b 2a             	cmpb   $0x2a,(%ebx)
40034c4c:	0f 84 ba fe ff ff    	je     40034b0c <_vfiprintf_r+0x54>
40034c52:	8b 44 24 18          	mov    0x18(%esp),%eax
40034c56:	31 c9                	xor    %ecx,%ecx
40034c58:	eb 12                	jmp    40034c6c <_vfiprintf_r+0x1b4>
40034c5a:	f7 da                	neg    %edx
40034c5c:	83 c8 02             	or     $0x2,%eax
40034c5f:	89 54 24 18          	mov    %edx,0x18(%esp)
40034c63:	89 44 24 0c          	mov    %eax,0xc(%esp)
40034c67:	e9 b9 fe ff ff       	jmp    40034b25 <_vfiprintf_r+0x6d>
40034c6c:	0f be 13             	movsbl (%ebx),%edx
40034c6f:	83 ea 30             	sub    $0x30,%edx
40034c72:	83 fa 09             	cmp    $0x9,%edx
40034c75:	77 0a                	ja     40034c81 <_vfiprintf_r+0x1c9>
40034c77:	6b c0 0a             	imul   $0xa,%eax,%eax
40034c7a:	43                   	inc    %ebx
40034c7b:	01 d0                	add    %edx,%eax
40034c7d:	b1 01                	mov    $0x1,%cl
40034c7f:	eb eb                	jmp    40034c6c <_vfiprintf_r+0x1b4>
40034c81:	84 c9                	test   %cl,%cl
40034c83:	0f 84 9d fe ff ff    	je     40034b26 <_vfiprintf_r+0x6e>
40034c89:	89 44 24 18          	mov    %eax,0x18(%esp)
40034c8d:	e9 94 fe ff ff       	jmp    40034b26 <_vfiprintf_r+0x6e>
40034c92:	8d 43 01             	lea    0x1(%ebx),%eax
40034c95:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
40034c99:	75 21                	jne    40034cbc <_vfiprintf_r+0x204>
40034c9b:	8b 44 24 7c          	mov    0x7c(%esp),%eax
40034c9f:	83 c3 02             	add    $0x2,%ebx
40034ca2:	8d 50 04             	lea    0x4(%eax),%edx
40034ca5:	8b 00                	mov    (%eax),%eax
40034ca7:	89 54 24 7c          	mov    %edx,0x7c(%esp)
40034cab:	85 c0                	test   %eax,%eax
40034cad:	79 3c                	jns    40034ceb <_vfiprintf_r+0x233>
40034caf:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034cb6:	ff 
40034cb7:	e9 73 fe ff ff       	jmp    40034b2f <_vfiprintf_r+0x77>
40034cbc:	89 c3                	mov    %eax,%ebx
40034cbe:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
40034cc5:	00 
40034cc6:	31 c0                	xor    %eax,%eax
40034cc8:	0f be 13             	movsbl (%ebx),%edx
40034ccb:	83 ea 30             	sub    $0x30,%edx
40034cce:	83 fa 09             	cmp    $0x9,%edx
40034cd1:	77 0d                	ja     40034ce0 <_vfiprintf_r+0x228>
40034cd3:	6b c0 0a             	imul   $0xa,%eax,%eax
40034cd6:	43                   	inc    %ebx
40034cd7:	01 d0                	add    %edx,%eax
40034cd9:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
40034cde:	eb e8                	jmp    40034cc8 <_vfiprintf_r+0x210>
40034ce0:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
40034ce5:	0f 84 44 fe ff ff    	je     40034b2f <_vfiprintf_r+0x77>
40034ceb:	89 44 24 10          	mov    %eax,0x10(%esp)
40034cef:	e9 3b fe ff ff       	jmp    40034b2f <_vfiprintf_r+0x77>
40034cf4:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034cf8:	89 f1                	mov    %esi,%ecx
40034cfa:	50                   	push   %eax
40034cfb:	68 89 4a 03 40       	push   $0x40034a89
40034d00:	8d 54 24 14          	lea    0x14(%esp),%edx
40034d04:	89 e8                	mov    %ebp,%eax
40034d06:	e8 f5 b2 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
40034d0b:	eb 17                	jmp    40034d24 <_vfiprintf_r+0x26c>
40034d0d:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034d11:	89 f1                	mov    %esi,%ecx
40034d13:	50                   	push   %eax
40034d14:	68 89 4a 03 40       	push   $0x40034a89
40034d19:	8d 54 24 14          	lea    0x14(%esp),%edx
40034d1d:	89 e8                	mov    %ebp,%eax
40034d1f:	e8 a2 fa ff ff       	call   400347c6 <_printf_i>
40034d24:	89 44 24 08          	mov    %eax,0x8(%esp)
40034d28:	58                   	pop    %eax
40034d29:	5a                   	pop    %edx
40034d2a:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
40034d2e:	0f 85 57 fe ff ff    	jne    40034b8b <_vfiprintf_r+0xd3>
40034d34:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
40034d38:	0f 85 c6 fd ff ff    	jne    40034b04 <_vfiprintf_r+0x4c>
40034d3e:	8b 44 24 20          	mov    0x20(%esp),%eax
40034d42:	83 c4 68             	add    $0x68,%esp
40034d45:	5b                   	pop    %ebx
40034d46:	5e                   	pop    %esi
40034d47:	5f                   	pop    %edi
40034d48:	5d                   	pop    %ebp
40034d49:	c3                   	ret    

40034d4a <__swbuf_r>:
40034d4a:	55                   	push   %ebp
40034d4b:	85 c0                	test   %eax,%eax
40034d4d:	57                   	push   %edi
40034d4e:	89 d5                	mov    %edx,%ebp
40034d50:	56                   	push   %esi
40034d51:	89 c6                	mov    %eax,%esi
40034d53:	53                   	push   %ebx
40034d54:	89 cb                	mov    %ecx,%ebx
40034d56:	74 0b                	je     40034d63 <__swbuf_r+0x19>
40034d58:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034d5c:	75 05                	jne    40034d63 <__swbuf_r+0x19>
40034d5e:	e8 04 03 00 00       	call   40035067 <__sinit>
40034d63:	8b 43 18             	mov    0x18(%ebx),%eax
40034d66:	f6 43 0c 08          	testb  $0x8,0xc(%ebx)
40034d6a:	89 43 08             	mov    %eax,0x8(%ebx)
40034d6d:	74 17                	je     40034d86 <__swbuf_r+0x3c>
40034d6f:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034d73:	74 11                	je     40034d86 <__swbuf_r+0x3c>
40034d75:	89 e8                	mov    %ebp,%eax
40034d77:	0f b6 f8             	movzbl %al,%edi
40034d7a:	8b 03                	mov    (%ebx),%eax
40034d7c:	2b 43 10             	sub    0x10(%ebx),%eax
40034d7f:	3b 43 14             	cmp    0x14(%ebx),%eax
40034d82:	7c 21                	jl     40034da5 <__swbuf_r+0x5b>
40034d84:	eb 12                	jmp    40034d98 <__swbuf_r+0x4e>
40034d86:	89 da                	mov    %ebx,%edx
40034d88:	89 f0                	mov    %esi,%eax
40034d8a:	e8 49 00 00 00       	call   40034dd8 <__swsetup_r>
40034d8f:	85 c0                	test   %eax,%eax
40034d91:	74 e2                	je     40034d75 <__swbuf_r+0x2b>
40034d93:	83 cf ff             	or     $0xffffffff,%edi
40034d96:	eb 39                	jmp    40034dd1 <__swbuf_r+0x87>
40034d98:	89 da                	mov    %ebx,%edx
40034d9a:	89 f0                	mov    %esi,%eax
40034d9c:	e8 23 02 00 00       	call   40034fc4 <_fflush_r>
40034da1:	85 c0                	test   %eax,%eax
40034da3:	75 ee                	jne    40034d93 <__swbuf_r+0x49>
40034da5:	8b 13                	mov    (%ebx),%edx
40034da7:	ff 4b 08             	decl   0x8(%ebx)
40034daa:	8d 4a 01             	lea    0x1(%edx),%ecx
40034dad:	40                   	inc    %eax
40034dae:	89 0b                	mov    %ecx,(%ebx)
40034db0:	89 e9                	mov    %ebp,%ecx
40034db2:	88 0a                	mov    %cl,(%edx)
40034db4:	3b 43 14             	cmp    0x14(%ebx),%eax
40034db7:	74 0b                	je     40034dc4 <__swbuf_r+0x7a>
40034db9:	83 ff 0a             	cmp    $0xa,%edi
40034dbc:	75 13                	jne    40034dd1 <__swbuf_r+0x87>
40034dbe:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
40034dc2:	74 0d                	je     40034dd1 <__swbuf_r+0x87>
40034dc4:	89 da                	mov    %ebx,%edx
40034dc6:	89 f0                	mov    %esi,%eax
40034dc8:	e8 f7 01 00 00       	call   40034fc4 <_fflush_r>
40034dcd:	85 c0                	test   %eax,%eax
40034dcf:	75 c2                	jne    40034d93 <__swbuf_r+0x49>
40034dd1:	5b                   	pop    %ebx
40034dd2:	89 f8                	mov    %edi,%eax
40034dd4:	5e                   	pop    %esi
40034dd5:	5f                   	pop    %edi
40034dd6:	5d                   	pop    %ebp
40034dd7:	c3                   	ret    

40034dd8 <__swsetup_r>:
40034dd8:	56                   	push   %esi
40034dd9:	89 c6                	mov    %eax,%esi
40034ddb:	53                   	push   %ebx
40034ddc:	89 d3                	mov    %edx,%ebx
40034dde:	e8 af f5 ff ff       	call   40034392 <__getreent>
40034de3:	85 c0                	test   %eax,%eax
40034de5:	74 0b                	je     40034df2 <__swsetup_r+0x1a>
40034de7:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034deb:	75 05                	jne    40034df2 <__swsetup_r+0x1a>
40034ded:	e8 75 02 00 00       	call   40035067 <__sinit>
40034df2:	8b 43 0c             	mov    0xc(%ebx),%eax
40034df5:	a8 08                	test   $0x8,%al
40034df7:	75 4c                	jne    40034e45 <__swsetup_r+0x6d>
40034df9:	a8 10                	test   $0x10,%al
40034dfb:	75 12                	jne    40034e0f <__swsetup_r+0x37>
40034dfd:	83 c8 40             	or     $0x40,%eax
40034e00:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
40034e06:	66 89 43 0c          	mov    %ax,0xc(%ebx)
40034e0a:	e9 8c 00 00 00       	jmp    40034e9b <__swsetup_r+0xc3>
40034e0f:	a8 04                	test   $0x4,%al
40034e11:	74 2d                	je     40034e40 <__swsetup_r+0x68>
40034e13:	8b 53 30             	mov    0x30(%ebx),%edx
40034e16:	85 d2                	test   %edx,%edx
40034e18:	74 15                	je     40034e2f <__swsetup_r+0x57>
40034e1a:	8d 43 40             	lea    0x40(%ebx),%eax
40034e1d:	39 c2                	cmp    %eax,%edx
40034e1f:	74 07                	je     40034e28 <__swsetup_r+0x50>
40034e21:	89 f0                	mov    %esi,%eax
40034e23:	e8 06 f3 ff ff       	call   4003412e <_free_r>
40034e28:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40034e2f:	66 83 63 0c db       	andw   $0xffdb,0xc(%ebx)
40034e34:	8b 43 10             	mov    0x10(%ebx),%eax
40034e37:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40034e3e:	89 03                	mov    %eax,(%ebx)
40034e40:	66 83 4b 0c 08       	orw    $0x8,0xc(%ebx)
40034e45:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034e49:	75 16                	jne    40034e61 <__swsetup_r+0x89>
40034e4b:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e4e:	66 25 80 02          	and    $0x280,%ax
40034e52:	66 3d 00 02          	cmp    $0x200,%ax
40034e56:	74 09                	je     40034e61 <__swsetup_r+0x89>
40034e58:	89 da                	mov    %ebx,%edx
40034e5a:	89 f0                	mov    %esi,%eax
40034e5c:	e8 2e 03 00 00       	call   4003518f <__smakebuf_r>
40034e61:	8b 53 0c             	mov    0xc(%ebx),%edx
40034e64:	f6 c2 01             	test   $0x1,%dl
40034e67:	74 11                	je     40034e7a <__swsetup_r+0xa2>
40034e69:	8b 43 14             	mov    0x14(%ebx),%eax
40034e6c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
40034e73:	f7 d8                	neg    %eax
40034e75:	89 43 18             	mov    %eax,0x18(%ebx)
40034e78:	eb 0d                	jmp    40034e87 <__swsetup_r+0xaf>
40034e7a:	31 c0                	xor    %eax,%eax
40034e7c:	f6 c2 02             	test   $0x2,%dl
40034e7f:	75 03                	jne    40034e84 <__swsetup_r+0xac>
40034e81:	8b 43 14             	mov    0x14(%ebx),%eax
40034e84:	89 43 08             	mov    %eax,0x8(%ebx)
40034e87:	31 c0                	xor    %eax,%eax
40034e89:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034e8d:	75 0f                	jne    40034e9e <__swsetup_r+0xc6>
40034e8f:	f6 c2 80             	test   $0x80,%dl
40034e92:	74 0a                	je     40034e9e <__swsetup_r+0xc6>
40034e94:	83 ca 40             	or     $0x40,%edx
40034e97:	66 89 53 0c          	mov    %dx,0xc(%ebx)
40034e9b:	83 c8 ff             	or     $0xffffffff,%eax
40034e9e:	5b                   	pop    %ebx
40034e9f:	5e                   	pop    %esi
40034ea0:	c3                   	ret    

40034ea1 <__sflush_r>:
40034ea1:	55                   	push   %ebp
40034ea2:	57                   	push   %edi
40034ea3:	56                   	push   %esi
40034ea4:	53                   	push   %ebx
40034ea5:	89 c6                	mov    %eax,%esi
40034ea7:	8b 42 0c             	mov    0xc(%edx),%eax
40034eaa:	89 d3                	mov    %edx,%ebx
40034eac:	a8 08                	test   $0x8,%al
40034eae:	0f 85 cc 00 00 00    	jne    40034f80 <__sflush_r+0xdf>
40034eb4:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
40034eb8:	7f 0a                	jg     40034ec4 <__sflush_r+0x23>
40034eba:	83 7a 3c 00          	cmpl   $0x0,0x3c(%edx)
40034ebe:	0f 8e b8 00 00 00    	jle    40034f7c <__sflush_r+0xdb>
40034ec4:	8b 6b 28             	mov    0x28(%ebx),%ebp
40034ec7:	85 ed                	test   %ebp,%ebp
40034ec9:	0f 84 ad 00 00 00    	je     40034f7c <__sflush_r+0xdb>
40034ecf:	8b 3e                	mov    (%esi),%edi
40034ed1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40034ed7:	f6 c4 10             	test   $0x10,%ah
40034eda:	74 05                	je     40034ee1 <__sflush_r+0x40>
40034edc:	8b 43 50             	mov    0x50(%ebx),%eax
40034edf:	eb 29                	jmp    40034f0a <__sflush_r+0x69>
40034ee1:	31 c9                	xor    %ecx,%ecx
40034ee3:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034ee6:	89 f0                	mov    %esi,%eax
40034ee8:	6a 01                	push   $0x1
40034eea:	ff d5                	call   *%ebp
40034eec:	5d                   	pop    %ebp
40034eed:	83 f8 ff             	cmp    $0xffffffff,%eax
40034ef0:	75 18                	jne    40034f0a <__sflush_r+0x69>
40034ef2:	8b 16                	mov    (%esi),%edx
40034ef4:	85 d2                	test   %edx,%edx
40034ef6:	74 12                	je     40034f0a <__sflush_r+0x69>
40034ef8:	83 fa 1d             	cmp    $0x1d,%edx
40034efb:	74 09                	je     40034f06 <__sflush_r+0x65>
40034efd:	83 fa 16             	cmp    $0x16,%edx
40034f00:	0f 85 95 00 00 00    	jne    40034f9b <__sflush_r+0xfa>
40034f06:	89 3e                	mov    %edi,(%esi)
40034f08:	eb 72                	jmp    40034f7c <__sflush_r+0xdb>
40034f0a:	f6 43 0c 04          	testb  $0x4,0xc(%ebx)
40034f0e:	74 0c                	je     40034f1c <__sflush_r+0x7b>
40034f10:	2b 43 04             	sub    0x4(%ebx),%eax
40034f13:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
40034f17:	74 03                	je     40034f1c <__sflush_r+0x7b>
40034f19:	2b 43 3c             	sub    0x3c(%ebx),%eax
40034f1c:	89 c1                	mov    %eax,%ecx
40034f1e:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034f21:	89 f0                	mov    %esi,%eax
40034f23:	6a 00                	push   $0x0
40034f25:	ff 53 28             	call   *0x28(%ebx)
40034f28:	59                   	pop    %ecx
40034f29:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f2c:	75 11                	jne    40034f3f <__sflush_r+0x9e>
40034f2e:	8b 16                	mov    (%esi),%edx
40034f30:	83 fa 1d             	cmp    $0x1d,%edx
40034f33:	77 66                	ja     40034f9b <__sflush_r+0xfa>
40034f35:	b9 01 00 40 20       	mov    $0x20400001,%ecx
40034f3a:	0f a3 d1             	bt     %edx,%ecx
40034f3d:	73 5c                	jae    40034f9b <__sflush_r+0xfa>
40034f3f:	8b 53 10             	mov    0x10(%ebx),%edx
40034f42:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40034f49:	89 13                	mov    %edx,(%ebx)
40034f4b:	f6 43 0d 10          	testb  $0x10,0xd(%ebx)
40034f4f:	74 0d                	je     40034f5e <__sflush_r+0xbd>
40034f51:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f54:	75 05                	jne    40034f5b <__sflush_r+0xba>
40034f56:	83 3e 00             	cmpl   $0x0,(%esi)
40034f59:	75 03                	jne    40034f5e <__sflush_r+0xbd>
40034f5b:	89 43 50             	mov    %eax,0x50(%ebx)
40034f5e:	8b 53 30             	mov    0x30(%ebx),%edx
40034f61:	89 3e                	mov    %edi,(%esi)
40034f63:	85 d2                	test   %edx,%edx
40034f65:	74 15                	je     40034f7c <__sflush_r+0xdb>
40034f67:	8d 43 40             	lea    0x40(%ebx),%eax
40034f6a:	39 c2                	cmp    %eax,%edx
40034f6c:	74 07                	je     40034f75 <__sflush_r+0xd4>
40034f6e:	89 f0                	mov    %esi,%eax
40034f70:	e8 b9 f1 ff ff       	call   4003412e <_free_r>
40034f75:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40034f7c:	31 c0                	xor    %eax,%eax
40034f7e:	eb 3f                	jmp    40034fbf <__sflush_r+0x11e>
40034f80:	8b 6a 10             	mov    0x10(%edx),%ebp
40034f83:	85 ed                	test   %ebp,%ebp
40034f85:	74 f5                	je     40034f7c <__sflush_r+0xdb>
40034f87:	8b 3a                	mov    (%edx),%edi
40034f89:	89 2a                	mov    %ebp,(%edx)
40034f8b:	29 ef                	sub    %ebp,%edi
40034f8d:	31 d2                	xor    %edx,%edx
40034f8f:	a8 03                	test   $0x3,%al
40034f91:	75 03                	jne    40034f96 <__sflush_r+0xf5>
40034f93:	8b 53 14             	mov    0x14(%ebx),%edx
40034f96:	89 53 08             	mov    %edx,0x8(%ebx)
40034f99:	eb 1e                	jmp    40034fb9 <__sflush_r+0x118>
40034f9b:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
40034fa0:	83 c8 ff             	or     $0xffffffff,%eax
40034fa3:	eb 1a                	jmp    40034fbf <__sflush_r+0x11e>
40034fa5:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034fa8:	89 e9                	mov    %ebp,%ecx
40034faa:	89 f0                	mov    %esi,%eax
40034fac:	57                   	push   %edi
40034fad:	ff 53 24             	call   *0x24(%ebx)
40034fb0:	5a                   	pop    %edx
40034fb1:	85 c0                	test   %eax,%eax
40034fb3:	7e e6                	jle    40034f9b <__sflush_r+0xfa>
40034fb5:	01 c5                	add    %eax,%ebp
40034fb7:	29 c7                	sub    %eax,%edi
40034fb9:	85 ff                	test   %edi,%edi
40034fbb:	7f e8                	jg     40034fa5 <__sflush_r+0x104>
40034fbd:	eb bd                	jmp    40034f7c <__sflush_r+0xdb>
40034fbf:	5b                   	pop    %ebx
40034fc0:	5e                   	pop    %esi
40034fc1:	5f                   	pop    %edi
40034fc2:	5d                   	pop    %ebp
40034fc3:	c3                   	ret    

40034fc4 <_fflush_r>:
40034fc4:	53                   	push   %ebx
40034fc5:	85 c0                	test   %eax,%eax
40034fc7:	53                   	push   %ebx
40034fc8:	89 c3                	mov    %eax,%ebx
40034fca:	74 11                	je     40034fdd <_fflush_r+0x19>
40034fcc:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034fd0:	75 0b                	jne    40034fdd <_fflush_r+0x19>
40034fd2:	89 14 24             	mov    %edx,(%esp)
40034fd5:	e8 8d 00 00 00       	call   40035067 <__sinit>
40034fda:	8b 14 24             	mov    (%esp),%edx
40034fdd:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
40034fe2:	74 09                	je     40034fed <_fflush_r+0x29>
40034fe4:	89 d8                	mov    %ebx,%eax
40034fe6:	59                   	pop    %ecx
40034fe7:	5b                   	pop    %ebx
40034fe8:	e9 b4 fe ff ff       	jmp    40034ea1 <__sflush_r>
40034fed:	31 c0                	xor    %eax,%eax
40034fef:	5a                   	pop    %edx
40034ff0:	5b                   	pop    %ebx
40034ff1:	c3                   	ret    

40034ff2 <_cleanup_r>:
40034ff2:	ba c4 4f 03 40       	mov    $0x40034fc4,%edx
40034ff7:	e9 d7 00 00 00       	jmp    400350d3 <_fwalk_reent>

40034ffc <std.isra.0>:
40034ffc:	53                   	push   %ebx
40034ffd:	89 c3                	mov    %eax,%ebx
40034fff:	66 89 50 0c          	mov    %dx,0xc(%eax)
40035003:	66 89 48 0e          	mov    %cx,0xe(%eax)
40035007:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
4003500d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40035014:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
4003501b:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
40035022:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
40035029:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40035030:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40035037:	b9 08 00 00 00       	mov    $0x8,%ecx
4003503c:	8d 40 5c             	lea    0x5c(%eax),%eax
4003503f:	31 d2                	xor    %edx,%edx
40035041:	e8 2f b0 ff ff       	call   40030075 <memset>
40035046:	89 5b 1c             	mov    %ebx,0x1c(%ebx)
40035049:	c7 43 20 84 52 03 40 	movl   $0x40035284,0x20(%ebx)
40035050:	c7 43 24 a6 52 03 40 	movl   $0x400352a6,0x24(%ebx)
40035057:	c7 43 28 e3 52 03 40 	movl   $0x400352e3,0x28(%ebx)
4003505e:	c7 43 2c 0c 53 03 40 	movl   $0x4003530c,0x2c(%ebx)
40035065:	5b                   	pop    %ebx
40035066:	c3                   	ret    

40035067 <__sinit>:
40035067:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003506b:	75 65                	jne    400350d2 <__sinit+0x6b>
4003506d:	53                   	push   %ebx
4003506e:	89 c3                	mov    %eax,%ebx
40035070:	c7 40 3c f2 4f 03 40 	movl   $0x40034ff2,0x3c(%eax)
40035077:	c7 80 4c 01 00 00 00 	movl   $0x0,0x14c(%eax)
4003507e:	00 00 00 
40035081:	c7 80 50 01 00 00 03 	movl   $0x3,0x150(%eax)
40035088:	00 00 00 
4003508b:	8d 80 58 01 00 00    	lea    0x158(%eax),%eax
40035091:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
40035097:	31 c9                	xor    %ecx,%ecx
40035099:	8b 43 04             	mov    0x4(%ebx),%eax
4003509c:	ba 04 00 00 00       	mov    $0x4,%edx
400350a1:	e8 56 ff ff ff       	call   40034ffc <std.isra.0>
400350a6:	8b 43 08             	mov    0x8(%ebx),%eax
400350a9:	b9 01 00 00 00       	mov    $0x1,%ecx
400350ae:	ba 09 00 00 00       	mov    $0x9,%edx
400350b3:	e8 44 ff ff ff       	call   40034ffc <std.isra.0>
400350b8:	8b 43 0c             	mov    0xc(%ebx),%eax
400350bb:	b9 02 00 00 00       	mov    $0x2,%ecx
400350c0:	ba 12 00 00 00       	mov    $0x12,%edx
400350c5:	e8 32 ff ff ff       	call   40034ffc <std.isra.0>
400350ca:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
400350d1:	5b                   	pop    %ebx
400350d2:	c3                   	ret    

400350d3 <_fwalk_reent>:
400350d3:	55                   	push   %ebp
400350d4:	57                   	push   %edi
400350d5:	56                   	push   %esi
400350d6:	53                   	push   %ebx
400350d7:	83 ec 08             	sub    $0x8,%esp
400350da:	89 c5                	mov    %eax,%ebp
400350dc:	89 d1                	mov    %edx,%ecx
400350de:	8d 98 4c 01 00 00    	lea    0x14c(%eax),%ebx
400350e4:	31 ff                	xor    %edi,%edi
400350e6:	85 db                	test   %ebx,%ebx
400350e8:	74 35                	je     4003511f <_fwalk_reent+0x4c>
400350ea:	8b 43 04             	mov    0x4(%ebx),%eax
400350ed:	8b 73 08             	mov    0x8(%ebx),%esi
400350f0:	89 04 24             	mov    %eax,(%esp)
400350f3:	ff 0c 24             	decl   (%esp)
400350f6:	78 23                	js     4003511b <_fwalk_reent+0x48>
400350f8:	66 83 7e 0c 01       	cmpw   $0x1,0xc(%esi)
400350fd:	76 17                	jbe    40035116 <_fwalk_reent+0x43>
400350ff:	66 83 7e 0e ff       	cmpw   $0xffff,0xe(%esi)
40035104:	74 10                	je     40035116 <_fwalk_reent+0x43>
40035106:	89 f2                	mov    %esi,%edx
40035108:	89 e8                	mov    %ebp,%eax
4003510a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
4003510e:	ff d1                	call   *%ecx
40035110:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40035114:	09 c7                	or     %eax,%edi
40035116:	83 c6 68             	add    $0x68,%esi
40035119:	eb d8                	jmp    400350f3 <_fwalk_reent+0x20>
4003511b:	8b 1b                	mov    (%ebx),%ebx
4003511d:	eb c7                	jmp    400350e6 <_fwalk_reent+0x13>
4003511f:	83 c4 08             	add    $0x8,%esp
40035122:	89 f8                	mov    %edi,%eax
40035124:	5b                   	pop    %ebx
40035125:	5e                   	pop    %esi
40035126:	5f                   	pop    %edi
40035127:	5d                   	pop    %ebp
40035128:	c3                   	ret    

40035129 <__swhatbuf_r>:
40035129:	57                   	push   %edi
4003512a:	56                   	push   %esi
4003512b:	53                   	push   %ebx
4003512c:	89 d7                	mov    %edx,%edi
4003512e:	83 ec 3c             	sub    $0x3c,%esp
40035131:	89 cb                	mov    %ecx,%ebx
40035133:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035137:	66 85 d2             	test   %dx,%dx
4003513a:	8b 74 24 4c          	mov    0x4c(%esp),%esi
4003513e:	79 1f                	jns    4003515f <__swhatbuf_r+0x36>
40035140:	8b 47 0c             	mov    0xc(%edi),%eax
40035143:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40035149:	66 25 80 00          	and    $0x80,%ax
4003514d:	66 83 f8 01          	cmp    $0x1,%ax
40035151:	19 c0                	sbb    %eax,%eax
40035153:	25 c0 03 00 00       	and    $0x3c0,%eax
40035158:	83 c0 40             	add    $0x40,%eax
4003515b:	89 03                	mov    %eax,(%ebx)
4003515d:	eb 27                	jmp    40035186 <__swhatbuf_r+0x5d>
4003515f:	89 e1                	mov    %esp,%ecx
40035161:	e8 03 02 00 00       	call   40035369 <_fstat_r>
40035166:	85 c0                	test   %eax,%eax
40035168:	78 d6                	js     40035140 <__swhatbuf_r+0x17>
4003516a:	8b 44 24 04          	mov    0x4(%esp),%eax
4003516e:	25 00 f0 00 00       	and    $0xf000,%eax
40035173:	3d 00 20 00 00       	cmp    $0x2000,%eax
40035178:	0f 94 c0             	sete   %al
4003517b:	0f b6 c0             	movzbl %al,%eax
4003517e:	89 06                	mov    %eax,(%esi)
40035180:	c7 03 00 04 00 00    	movl   $0x400,(%ebx)
40035186:	83 c4 3c             	add    $0x3c,%esp
40035189:	31 c0                	xor    %eax,%eax
4003518b:	5b                   	pop    %ebx
4003518c:	5e                   	pop    %esi
4003518d:	5f                   	pop    %edi
4003518e:	c3                   	ret    

4003518f <__smakebuf_r>:
4003518f:	f6 42 0c 02          	testb  $0x2,0xc(%edx)
40035193:	74 10                	je     400351a5 <__smakebuf_r+0x16>
40035195:	8d 42 43             	lea    0x43(%edx),%eax
40035198:	c7 42 14 01 00 00 00 	movl   $0x1,0x14(%edx)
4003519f:	89 02                	mov    %eax,(%edx)
400351a1:	89 42 10             	mov    %eax,0x10(%edx)
400351a4:	c3                   	ret    
400351a5:	57                   	push   %edi
400351a6:	56                   	push   %esi
400351a7:	53                   	push   %ebx
400351a8:	89 c6                	mov    %eax,%esi
400351aa:	83 ec 08             	sub    $0x8,%esp
400351ad:	89 d3                	mov    %edx,%ebx
400351af:	8d 44 24 04          	lea    0x4(%esp),%eax
400351b3:	50                   	push   %eax
400351b4:	89 f0                	mov    %esi,%eax
400351b6:	8d 4c 24 04          	lea    0x4(%esp),%ecx
400351ba:	e8 6a ff ff ff       	call   40035129 <__swhatbuf_r>
400351bf:	8b 54 24 04          	mov    0x4(%esp),%edx
400351c3:	89 c7                	mov    %eax,%edi
400351c5:	89 f0                	mov    %esi,%eax
400351c7:	e8 1b f0 ff ff       	call   400341e7 <_malloc_r>
400351cc:	5a                   	pop    %edx
400351cd:	85 c0                	test   %eax,%eax
400351cf:	75 20                	jne    400351f1 <__smakebuf_r+0x62>
400351d1:	8b 43 0c             	mov    0xc(%ebx),%eax
400351d4:	f6 c4 02             	test   $0x2,%ah
400351d7:	75 4f                	jne    40035228 <__smakebuf_r+0x99>
400351d9:	83 c8 02             	or     $0x2,%eax
400351dc:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
400351e3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
400351e7:	8d 43 43             	lea    0x43(%ebx),%eax
400351ea:	89 03                	mov    %eax,(%ebx)
400351ec:	89 43 10             	mov    %eax,0x10(%ebx)
400351ef:	eb 37                	jmp    40035228 <__smakebuf_r+0x99>
400351f1:	c7 46 3c f2 4f 03 40 	movl   $0x40034ff2,0x3c(%esi)
400351f8:	89 03                	mov    %eax,(%ebx)
400351fa:	89 43 10             	mov    %eax,0x10(%ebx)
400351fd:	8b 04 24             	mov    (%esp),%eax
40035200:	66 81 4b 0c 80 00    	orw    $0x80,0xc(%ebx)
40035206:	89 43 14             	mov    %eax,0x14(%ebx)
40035209:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
4003520e:	74 14                	je     40035224 <__smakebuf_r+0x95>
40035210:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
40035214:	89 f0                	mov    %esi,%eax
40035216:	e8 77 01 00 00       	call   40035392 <_isatty_r>
4003521b:	85 c0                	test   %eax,%eax
4003521d:	74 05                	je     40035224 <__smakebuf_r+0x95>
4003521f:	66 83 4b 0c 01       	orw    $0x1,0xc(%ebx)
40035224:	66 09 7b 0c          	or     %di,0xc(%ebx)
40035228:	83 c4 08             	add    $0x8,%esp
4003522b:	5b                   	pop    %ebx
4003522c:	5e                   	pop    %esi
4003522d:	5f                   	pop    %edi
4003522e:	c3                   	ret    

4003522f <_realloc_r>:
4003522f:	85 d2                	test   %edx,%edx
40035231:	75 07                	jne    4003523a <_realloc_r+0xb>
40035233:	89 ca                	mov    %ecx,%edx
40035235:	e9 ad ef ff ff       	jmp    400341e7 <_malloc_r>
4003523a:	55                   	push   %ebp
4003523b:	85 c9                	test   %ecx,%ecx
4003523d:	57                   	push   %edi
4003523e:	89 cd                	mov    %ecx,%ebp
40035240:	56                   	push   %esi
40035241:	89 c6                	mov    %eax,%esi
40035243:	53                   	push   %ebx
40035244:	89 d3                	mov    %edx,%ebx
40035246:	75 09                	jne    40035251 <_realloc_r+0x22>
40035248:	e8 e1 ee ff ff       	call   4003412e <_free_r>
4003524d:	31 ff                	xor    %edi,%edi
4003524f:	eb 2c                	jmp    4003527d <_realloc_r+0x4e>
40035251:	e8 90 01 00 00       	call   400353e6 <_malloc_usable_size_r>
40035256:	89 df                	mov    %ebx,%edi
40035258:	39 c5                	cmp    %eax,%ebp
4003525a:	76 21                	jbe    4003527d <_realloc_r+0x4e>
4003525c:	89 ea                	mov    %ebp,%edx
4003525e:	89 f0                	mov    %esi,%eax
40035260:	e8 82 ef ff ff       	call   400341e7 <_malloc_r>
40035265:	89 c7                	mov    %eax,%edi
40035267:	85 c0                	test   %eax,%eax
40035269:	74 12                	je     4003527d <_realloc_r+0x4e>
4003526b:	89 da                	mov    %ebx,%edx
4003526d:	89 e9                	mov    %ebp,%ecx
4003526f:	e8 f6 ad ff ff       	call   4003006a <memcpy>
40035274:	89 da                	mov    %ebx,%edx
40035276:	89 f0                	mov    %esi,%eax
40035278:	e8 b1 ee ff ff       	call   4003412e <_free_r>
4003527d:	5b                   	pop    %ebx
4003527e:	89 f8                	mov    %edi,%eax
40035280:	5e                   	pop    %esi
40035281:	5f                   	pop    %edi
40035282:	5d                   	pop    %ebp
40035283:	c3                   	ret    

40035284 <__sread>:
40035284:	53                   	push   %ebx
40035285:	89 d3                	mov    %edx,%ebx
40035287:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003528b:	ff 74 24 08          	pushl  0x8(%esp)
4003528f:	e8 61 01 00 00       	call   400353f5 <_read_r>
40035294:	5a                   	pop    %edx
40035295:	85 c0                	test   %eax,%eax
40035297:	78 05                	js     4003529e <__sread+0x1a>
40035299:	01 43 50             	add    %eax,0x50(%ebx)
4003529c:	eb 06                	jmp    400352a4 <__sread+0x20>
4003529e:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400352a4:	5b                   	pop    %ebx
400352a5:	c3                   	ret    

400352a6 <__swrite>:
400352a6:	55                   	push   %ebp
400352a7:	57                   	push   %edi
400352a8:	56                   	push   %esi
400352a9:	53                   	push   %ebx
400352aa:	89 c6                	mov    %eax,%esi
400352ac:	89 d3                	mov    %edx,%ebx
400352ae:	89 cf                	mov    %ecx,%edi
400352b0:	8b 6c 24 14          	mov    0x14(%esp),%ebp
400352b4:	f6 42 0d 01          	testb  $0x1,0xd(%edx)
400352b8:	74 0e                	je     400352c8 <__swrite+0x22>
400352ba:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400352be:	31 c9                	xor    %ecx,%ecx
400352c0:	6a 02                	push   $0x2
400352c2:	e8 f2 00 00 00       	call   400353b9 <_lseek_r>
400352c7:	58                   	pop    %eax
400352c8:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400352ce:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
400352d2:	89 f9                	mov    %edi,%ecx
400352d4:	89 f0                	mov    %esi,%eax
400352d6:	89 6c 24 14          	mov    %ebp,0x14(%esp)
400352da:	5b                   	pop    %ebx
400352db:	5e                   	pop    %esi
400352dc:	5f                   	pop    %edi
400352dd:	5d                   	pop    %ebp
400352de:	e9 32 00 00 00       	jmp    40035315 <_write_r>

400352e3 <__sseek>:
400352e3:	53                   	push   %ebx
400352e4:	89 d3                	mov    %edx,%ebx
400352e6:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400352ea:	ff 74 24 08          	pushl  0x8(%esp)
400352ee:	e8 c6 00 00 00       	call   400353b9 <_lseek_r>
400352f3:	5a                   	pop    %edx
400352f4:	83 f8 ff             	cmp    $0xffffffff,%eax
400352f7:	75 08                	jne    40035301 <__sseek+0x1e>
400352f9:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400352ff:	eb 09                	jmp    4003530a <__sseek+0x27>
40035301:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
40035307:	89 43 50             	mov    %eax,0x50(%ebx)
4003530a:	5b                   	pop    %ebx
4003530b:	c3                   	ret    

4003530c <__sclose>:
4003530c:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035310:	e9 2d 00 00 00       	jmp    40035342 <_close_r>

40035315 <_write_r>:
40035315:	53                   	push   %ebx
40035316:	89 c3                	mov    %eax,%ebx
40035318:	89 d0                	mov    %edx,%eax
4003531a:	89 ca                	mov    %ecx,%edx
4003531c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035320:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035327:	00 00 00 
4003532a:	e8 48 ba ff ff       	call   40030d77 <_write>
4003532f:	83 f8 ff             	cmp    $0xffffffff,%eax
40035332:	75 0c                	jne    40035340 <_write_r+0x2b>
40035334:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
4003533a:	85 d2                	test   %edx,%edx
4003533c:	74 02                	je     40035340 <_write_r+0x2b>
4003533e:	89 13                	mov    %edx,(%ebx)
40035340:	5b                   	pop    %ebx
40035341:	c3                   	ret    

40035342 <_close_r>:
40035342:	53                   	push   %ebx
40035343:	89 c3                	mov    %eax,%ebx
40035345:	89 d0                	mov    %edx,%eax
40035347:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
4003534e:	00 00 00 
40035351:	e8 6e ba ff ff       	call   40030dc4 <_close>
40035356:	83 f8 ff             	cmp    $0xffffffff,%eax
40035359:	75 0c                	jne    40035367 <_close_r+0x25>
4003535b:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035361:	85 d2                	test   %edx,%edx
40035363:	74 02                	je     40035367 <_close_r+0x25>
40035365:	89 13                	mov    %edx,(%ebx)
40035367:	5b                   	pop    %ebx
40035368:	c3                   	ret    

40035369 <_fstat_r>:
40035369:	53                   	push   %ebx
4003536a:	89 c3                	mov    %eax,%ebx
4003536c:	89 d0                	mov    %edx,%eax
4003536e:	89 ca                	mov    %ecx,%edx
40035370:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035377:	00 00 00 
4003537a:	e8 37 ba ff ff       	call   40030db6 <_fstat>
4003537f:	83 f8 ff             	cmp    $0xffffffff,%eax
40035382:	75 0c                	jne    40035390 <_fstat_r+0x27>
40035384:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
4003538a:	85 d2                	test   %edx,%edx
4003538c:	74 02                	je     40035390 <_fstat_r+0x27>
4003538e:	89 13                	mov    %edx,(%ebx)
40035390:	5b                   	pop    %ebx
40035391:	c3                   	ret    

40035392 <_isatty_r>:
40035392:	53                   	push   %ebx
40035393:	89 c3                	mov    %eax,%ebx
40035395:	89 d0                	mov    %edx,%eax
40035397:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
4003539e:	00 00 00 
400353a1:	e8 06 ba ff ff       	call   40030dac <_isatty>
400353a6:	83 f8 ff             	cmp    $0xffffffff,%eax
400353a9:	75 0c                	jne    400353b7 <_isatty_r+0x25>
400353ab:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
400353b1:	85 d2                	test   %edx,%edx
400353b3:	74 02                	je     400353b7 <_isatty_r+0x25>
400353b5:	89 13                	mov    %edx,(%ebx)
400353b7:	5b                   	pop    %ebx
400353b8:	c3                   	ret    

400353b9 <_lseek_r>:
400353b9:	53                   	push   %ebx
400353ba:	89 c3                	mov    %eax,%ebx
400353bc:	89 d0                	mov    %edx,%eax
400353be:	89 ca                	mov    %ecx,%edx
400353c0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
400353c4:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
400353cb:	00 00 00 
400353ce:	e8 f9 b9 ff ff       	call   40030dcc <_lseek>
400353d3:	83 f8 ff             	cmp    $0xffffffff,%eax
400353d6:	75 0c                	jne    400353e4 <_lseek_r+0x2b>
400353d8:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
400353de:	85 d2                	test   %edx,%edx
400353e0:	74 02                	je     400353e4 <_lseek_r+0x2b>
400353e2:	89 13                	mov    %edx,(%ebx)
400353e4:	5b                   	pop    %ebx
400353e5:	c3                   	ret    

400353e6 <_malloc_usable_size_r>:
400353e6:	8b 4a fc             	mov    -0x4(%edx),%ecx
400353e9:	85 c9                	test   %ecx,%ecx
400353eb:	8d 41 fc             	lea    -0x4(%ecx),%eax
400353ee:	79 04                	jns    400353f4 <_malloc_usable_size_r+0xe>
400353f0:	03 44 0a fc          	add    -0x4(%edx,%ecx,1),%eax
400353f4:	c3                   	ret    

400353f5 <_read_r>:
400353f5:	53                   	push   %ebx
400353f6:	89 c3                	mov    %eax,%ebx
400353f8:	89 d0                	mov    %edx,%eax
400353fa:	89 ca                	mov    %ecx,%edx
400353fc:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035400:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035407:	00 00 00 
4003540a:	e8 3d b9 ff ff       	call   40030d4c <_read>
4003540f:	83 f8 ff             	cmp    $0xffffffff,%eax
40035412:	75 0c                	jne    40035420 <_read_r+0x2b>
40035414:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
4003541a:	85 d2                	test   %edx,%edx
4003541c:	74 02                	je     40035420 <_read_r+0x2b>
4003541e:	89 13                	mov    %edx,(%ebx)
40035420:	5b                   	pop    %ebx
40035421:	c3                   	ret    

40035422 <_handle_exc_0_vector_0_stub>:
40035422:	6a 00                	push   $0x0
40035424:	68 04 35 03 40       	push   $0x40033504
40035429:	e9 75 de ff ff       	jmp    400332a3 <_exception_enter>

4003542e <_handle_exc_2_vector_2_stub>:
4003542e:	6a 00                	push   $0x0
40035430:	68 10 35 03 40       	push   $0x40033510
40035435:	e9 69 de ff ff       	jmp    400332a3 <_exception_enter>

4003543a <_handle_exc_4_vector_4_stub>:
4003543a:	6a 00                	push   $0x0
4003543c:	68 1f 35 03 40       	push   $0x4003351f
40035441:	e9 5d de ff ff       	jmp    400332a3 <_exception_enter>

40035446 <_handle_exc_5_vector_5_stub>:
40035446:	6a 00                	push   $0x0
40035448:	68 2e 35 03 40       	push   $0x4003352e
4003544d:	e9 51 de ff ff       	jmp    400332a3 <_exception_enter>

40035452 <_handle_exc_6_vector_6_stub>:
40035452:	6a 00                	push   $0x0
40035454:	68 3d 35 03 40       	push   $0x4003353d
40035459:	e9 45 de ff ff       	jmp    400332a3 <_exception_enter>

4003545e <_handle_exc_7_vector_7_stub>:
4003545e:	6a 00                	push   $0x0
40035460:	68 4c 35 03 40       	push   $0x4003354c
40035465:	e9 39 de ff ff       	jmp    400332a3 <_exception_enter>

4003546a <_handle_exc_8_vector_8_stub>:
4003546a:	68 5b 35 03 40       	push   $0x4003355b
4003546f:	e9 2f de ff ff       	jmp    400332a3 <_exception_enter>

40035474 <_handle_exc_10_vector_10_stub>:
40035474:	68 6a 35 03 40       	push   $0x4003356a
40035479:	e9 25 de ff ff       	jmp    400332a3 <_exception_enter>

4003547e <_handle_exc_11_vector_11_stub>:
4003547e:	68 79 35 03 40       	push   $0x40033579
40035483:	e9 1b de ff ff       	jmp    400332a3 <_exception_enter>

40035488 <_handle_exc_12_vector_12_stub>:
40035488:	68 88 35 03 40       	push   $0x40033588
4003548d:	e9 11 de ff ff       	jmp    400332a3 <_exception_enter>

40035492 <_handle_exc_13_vector_13_stub>:
40035492:	68 97 35 03 40       	push   $0x40033597
40035497:	e9 07 de ff ff       	jmp    400332a3 <_exception_enter>

4003549c <_handle_exc_14_vector_14_stub>:
4003549c:	68 a6 35 03 40       	push   $0x400335a6
400354a1:	e9 fd dd ff ff       	jmp    400332a3 <_exception_enter>

400354a6 <_handle_exc_16_vector_16_stub>:
400354a6:	6a 00                	push   $0x0
400354a8:	68 b5 35 03 40       	push   $0x400335b5
400354ad:	e9 f1 dd ff ff       	jmp    400332a3 <_exception_enter>

400354b2 <_handle_exc_17_vector_17_stub>:
400354b2:	68 c4 35 03 40       	push   $0x400335c4
400354b7:	e9 e7 dd ff ff       	jmp    400332a3 <_exception_enter>

400354bc <_handle_exc_18_vector_18_stub>:
400354bc:	6a 00                	push   $0x0
400354be:	68 d3 35 03 40       	push   $0x400335d3
400354c3:	e9 db dd ff ff       	jmp    400332a3 <_exception_enter>
