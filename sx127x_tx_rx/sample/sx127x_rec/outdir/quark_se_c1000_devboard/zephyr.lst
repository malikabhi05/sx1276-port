
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
4003000c:	0f 01 1d 4c 00 03 40 	lidtl  0x4003004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
40030013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
4003001c:	bc bc 78 00 a8       	mov    $0xa80078bc,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
40030021:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030027:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003002c:	be 68 69 03 40       	mov    $0x40036968,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030031:	b9 f5 00 00 00       	mov    $0xf5,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
40030038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003003a:	bf e0 67 00 a8       	mov    $0xa80067e0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
4003003f:	b9 36 04 00 00       	mov    $0x436,%ecx
	cld
40030044:	fc                   	cld    
	rep
40030045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030047:	e9 a2 36 00 00       	jmp    400336ee <_Cstart>

4003004c <_Idt>:
4003004c:	ff 07 e8 60 03 40 66 90 66 90 66 90 66 90 66 90     ...`.@f.f.f.f.f.
4003005c:	66 90 66 90                                         f.f.

40030060 <_thread_entry_wrapper>:
40030060:	58                   	pop    %eax
40030061:	5a                   	pop    %edx
40030062:	59                   	pop    %ecx
40030063:	6a 00                	push   $0x0
40030065:	e9 a3 3e 00 00       	jmp    40033f0d <_thread_entry>

4003006a <memset>:
4003006a:	57                   	push   %edi
4003006b:	89 c7                	mov    %eax,%edi
4003006d:	0f b6 c2             	movzbl %dl,%eax
40030070:	89 fa                	mov    %edi,%edx
40030072:	f3 aa                	rep stos %al,%es:(%edi)
40030074:	89 d0                	mov    %edx,%eax
40030076:	5f                   	pop    %edi
40030077:	c3                   	ret    

40030078 <memchr>:
40030078:	57                   	push   %edi
40030079:	89 c7                	mov    %eax,%edi
4003007b:	89 d0                	mov    %edx,%eax
4003007d:	31 d2                	xor    %edx,%edx
4003007f:	85 c9                	test   %ecx,%ecx
40030081:	74 09                	je     4003008c <L20>
40030083:	f2 ae                	repnz scas %es:(%edi),%al
40030085:	0f 95 c2             	setne  %dl
40030088:	4f                   	dec    %edi
40030089:	4a                   	dec    %edx
4003008a:	21 fa                	and    %edi,%edx

4003008c <L20>:
4003008c:	89 d0                	mov    %edx,%eax
4003008e:	5f                   	pop    %edi
4003008f:	c3                   	ret    

40030090 <__udivdi3>:
40030090:	55                   	push   %ebp
40030091:	89 e5                	mov    %esp,%ebp
40030093:	57                   	push   %edi
40030094:	56                   	push   %esi
40030095:	53                   	push   %ebx
40030096:	83 ec 10             	sub    $0x10,%esp
40030099:	89 45 f0             	mov    %eax,-0x10(%ebp)
4003009c:	8b 45 08             	mov    0x8(%ebp),%eax
4003009f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400300a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
400300a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300a8:	89 d6                	mov    %edx,%esi
400300aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
400300ad:	89 d9                	mov    %ebx,%ecx
400300af:	89 d0                	mov    %edx,%eax
400300b1:	85 db                	test   %ebx,%ebx
400300b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
400300b6:	75 30                	jne    400300e8 <__udivdi3+0x58>
400300b8:	89 d7                	mov    %edx,%edi
400300ba:	39 f2                	cmp    %esi,%edx
400300bc:	76 07                	jbe    400300c5 <__udivdi3+0x35>
400300be:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300c1:	89 f2                	mov    %esi,%edx
400300c3:	eb 1a                	jmp    400300df <__udivdi3+0x4f>
400300c5:	85 d2                	test   %edx,%edx
400300c7:	75 0b                	jne    400300d4 <__udivdi3+0x44>
400300c9:	b8 01 00 00 00       	mov    $0x1,%eax
400300ce:	31 d2                	xor    %edx,%edx
400300d0:	f7 f7                	div    %edi
400300d2:	89 c7                	mov    %eax,%edi
400300d4:	31 d2                	xor    %edx,%edx
400300d6:	89 f0                	mov    %esi,%eax
400300d8:	f7 f7                	div    %edi
400300da:	89 c1                	mov    %eax,%ecx
400300dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300df:	f7 f7                	div    %edi
400300e1:	89 c3                	mov    %eax,%ebx
400300e3:	e9 92 00 00 00       	jmp    4003017a <__udivdi3+0xea>
400300e8:	39 f3                	cmp    %esi,%ebx
400300ea:	0f 87 82 00 00 00    	ja     40030172 <__udivdi3+0xe2>
400300f0:	0f bd f3             	bsr    %ebx,%esi
400300f3:	89 75 f0             	mov    %esi,-0x10(%ebp)
400300f6:	83 75 f0 1f          	xorl   $0x1f,-0x10(%ebp)
400300fa:	75 15                	jne    40030111 <__udivdi3+0x81>
400300fc:	39 c3                	cmp    %eax,%ebx
400300fe:	b9 00 00 00 00       	mov    $0x0,%ecx
40030103:	72 05                	jb     4003010a <__udivdi3+0x7a>
40030105:	3b 55 ec             	cmp    -0x14(%ebp),%edx
40030108:	77 6a                	ja     40030174 <__udivdi3+0xe4>
4003010a:	bb 01 00 00 00       	mov    $0x1,%ebx
4003010f:	eb 69                	jmp    4003017a <__udivdi3+0xea>
40030111:	be 20 00 00 00       	mov    $0x20,%esi
40030116:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030119:	2b 75 f0             	sub    -0x10(%ebp),%esi
4003011c:	89 d7                	mov    %edx,%edi
4003011e:	d3 e3                	shl    %cl,%ebx
40030120:	89 f1                	mov    %esi,%ecx
40030122:	d3 ef                	shr    %cl,%edi
40030124:	89 f9                	mov    %edi,%ecx
40030126:	09 d9                	or     %ebx,%ecx
40030128:	8b 5d ec             	mov    -0x14(%ebp),%ebx
4003012b:	89 4d e8             	mov    %ecx,-0x18(%ebp)
4003012e:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030131:	d3 e2                	shl    %cl,%edx
40030133:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030136:	89 f1                	mov    %esi,%ecx
40030138:	89 c2                	mov    %eax,%edx
4003013a:	d3 ea                	shr    %cl,%edx
4003013c:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003013f:	d3 e0                	shl    %cl,%eax
40030141:	89 f1                	mov    %esi,%ecx
40030143:	d3 eb                	shr    %cl,%ebx
40030145:	09 c3                	or     %eax,%ebx
40030147:	89 d8                	mov    %ebx,%eax
40030149:	f7 75 e8             	divl   -0x18(%ebp)
4003014c:	89 d6                	mov    %edx,%esi
4003014e:	89 c7                	mov    %eax,%edi
40030150:	89 c3                	mov    %eax,%ebx
40030152:	f7 65 e4             	mull   -0x1c(%ebp)
40030155:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030158:	39 d6                	cmp    %edx,%esi
4003015a:	72 11                	jb     4003016d <__udivdi3+0xdd>
4003015c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003015f:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030162:	d3 e0                	shl    %cl,%eax
40030164:	3b 45 e8             	cmp    -0x18(%ebp),%eax
40030167:	73 0f                	jae    40030178 <__udivdi3+0xe8>
40030169:	39 d6                	cmp    %edx,%esi
4003016b:	75 0b                	jne    40030178 <__udivdi3+0xe8>
4003016d:	8d 5f ff             	lea    -0x1(%edi),%ebx
40030170:	eb 06                	jmp    40030178 <__udivdi3+0xe8>
40030172:	31 c9                	xor    %ecx,%ecx
40030174:	31 db                	xor    %ebx,%ebx
40030176:	eb 02                	jmp    4003017a <__udivdi3+0xea>
40030178:	31 c9                	xor    %ecx,%ecx
4003017a:	89 d8                	mov    %ebx,%eax
4003017c:	89 ca                	mov    %ecx,%edx
4003017e:	83 c4 10             	add    $0x10,%esp
40030181:	5b                   	pop    %ebx
40030182:	5e                   	pop    %esi
40030183:	5f                   	pop    %edi
40030184:	5d                   	pop    %ebp
40030185:	c3                   	ret    

40030186 <__ledf2>:
40030186:	55                   	push   %ebp
40030187:	89 e5                	mov    %esp,%ebp
40030189:	57                   	push   %edi
4003018a:	56                   	push   %esi
4003018b:	53                   	push   %ebx
4003018c:	83 ec 14             	sub    $0x14,%esp
4003018f:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030192:	89 d0                	mov    %edx,%eax
40030194:	89 d7                	mov    %edx,%edi
40030196:	c1 e8 14             	shr    $0x14,%eax
40030199:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
4003019f:	c1 ea 1f             	shr    $0x1f,%edx
400301a2:	25 ff 07 00 00       	and    $0x7ff,%eax
400301a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
400301aa:	89 55 e0             	mov    %edx,-0x20(%ebp)
400301ad:	8b 45 08             	mov    0x8(%ebp),%eax
400301b0:	8b 55 0c             	mov    0xc(%ebp),%edx
400301b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400301b6:	89 d0                	mov    %edx,%eax
400301b8:	c1 e8 14             	shr    $0x14,%eax
400301bb:	89 d6                	mov    %edx,%esi
400301bd:	25 ff 07 00 00       	and    $0x7ff,%eax
400301c2:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
400301c8:	c1 ea 1f             	shr    $0x1f,%edx
400301cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400301ce:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
400301d5:	75 10                	jne    400301e7 <__ledf2+0x61>
400301d7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400301da:	b8 02 00 00 00       	mov    $0x2,%eax
400301df:	09 f9                	or     %edi,%ecx
400301e1:	0f 85 a8 00 00 00    	jne    4003028f <__ledf2+0x109>
400301e7:	81 7d e4 ff 07 00 00 	cmpl   $0x7ff,-0x1c(%ebp)
400301ee:	75 10                	jne    40030200 <__ledf2+0x7a>
400301f0:	8b 5d ec             	mov    -0x14(%ebp),%ebx
400301f3:	b8 02 00 00 00       	mov    $0x2,%eax
400301f8:	09 f3                	or     %esi,%ebx
400301fa:	0f 85 8f 00 00 00    	jne    4003028f <__ledf2+0x109>
40030200:	31 db                	xor    %ebx,%ebx
40030202:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030206:	75 08                	jne    40030210 <__ledf2+0x8a>
40030208:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003020b:	09 f8                	or     %edi,%eax
4003020d:	0f 94 c3             	sete   %bl
40030210:	31 c9                	xor    %ecx,%ecx
40030212:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
40030216:	75 08                	jne    40030220 <__ledf2+0x9a>
40030218:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003021b:	09 f0                	or     %esi,%eax
4003021d:	0f 94 c1             	sete   %cl
40030220:	84 db                	test   %bl,%bl
40030222:	74 06                	je     4003022a <__ledf2+0xa4>
40030224:	31 c0                	xor    %eax,%eax
40030226:	84 c9                	test   %cl,%cl
40030228:	75 65                	jne    4003028f <__ledf2+0x109>
4003022a:	0f b6 d2             	movzbl %dl,%edx
4003022d:	84 db                	test   %bl,%bl
4003022f:	74 0b                	je     4003023c <__ledf2+0xb6>
40030231:	83 c8 ff             	or     $0xffffffff,%eax
40030234:	85 d2                	test   %edx,%edx
40030236:	74 57                	je     4003028f <__ledf2+0x109>
40030238:	89 d0                	mov    %edx,%eax
4003023a:	eb 53                	jmp    4003028f <__ledf2+0x109>
4003023c:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
40030240:	84 c9                	test   %cl,%cl
40030242:	75 29                	jne    4003026d <__ledf2+0xe7>
40030244:	39 d0                	cmp    %edx,%eax
40030246:	75 1d                	jne    40030265 <__ledf2+0xdf>
40030248:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
4003024b:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
4003024e:	7f 15                	jg     40030265 <__ledf2+0xdf>
40030250:	7c 32                	jl     40030284 <__ledf2+0xfe>
40030252:	39 f7                	cmp    %esi,%edi
40030254:	77 0f                	ja     40030265 <__ledf2+0xdf>
40030256:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030259:	0f 94 c2             	sete   %dl
4003025c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
4003025f:	76 13                	jbe    40030274 <__ledf2+0xee>
40030261:	84 d2                	test   %dl,%dl
40030263:	74 0f                	je     40030274 <__ledf2+0xee>
40030265:	85 c0                	test   %eax,%eax
40030267:	0f 95 c0             	setne  %al
4003026a:	0f b6 c0             	movzbl %al,%eax
4003026d:	f7 d8                	neg    %eax
4003026f:	83 c8 01             	or     $0x1,%eax
40030272:	eb 1b                	jmp    4003028f <__ledf2+0x109>
40030274:	39 f7                	cmp    %esi,%edi
40030276:	72 0c                	jb     40030284 <__ledf2+0xfe>
40030278:	8b 7d ec             	mov    -0x14(%ebp),%edi
4003027b:	39 7d f0             	cmp    %edi,-0x10(%ebp)
4003027e:	73 0d                	jae    4003028d <__ledf2+0x107>
40030280:	84 d2                	test   %dl,%dl
40030282:	74 09                	je     4003028d <__ledf2+0x107>
40030284:	85 c0                	test   %eax,%eax
40030286:	75 07                	jne    4003028f <__ledf2+0x109>
40030288:	83 c8 ff             	or     $0xffffffff,%eax
4003028b:	eb 02                	jmp    4003028f <__ledf2+0x109>
4003028d:	31 c0                	xor    %eax,%eax
4003028f:	83 c4 14             	add    $0x14,%esp
40030292:	5b                   	pop    %ebx
40030293:	5e                   	pop    %esi
40030294:	5f                   	pop    %edi
40030295:	5d                   	pop    %ebp
40030296:	c3                   	ret    

40030297 <__floatsidf>:
40030297:	55                   	push   %ebp
40030298:	85 c0                	test   %eax,%eax
4003029a:	89 e5                	mov    %esp,%ebp
4003029c:	57                   	push   %edi
4003029d:	56                   	push   %esi
4003029e:	53                   	push   %ebx
4003029f:	74 43                	je     400302e4 <__floatsidf+0x4d>
400302a1:	99                   	cltd   
400302a2:	89 c7                	mov    %eax,%edi
400302a4:	31 d0                	xor    %edx,%eax
400302a6:	29 d0                	sub    %edx,%eax
400302a8:	ba 1e 04 00 00       	mov    $0x41e,%edx
400302ad:	0f bd f0             	bsr    %eax,%esi
400302b0:	bb 33 04 00 00       	mov    $0x433,%ebx
400302b5:	c1 ef 1f             	shr    $0x1f,%edi
400302b8:	83 f6 1f             	xor    $0x1f,%esi
400302bb:	29 f2                	sub    %esi,%edx
400302bd:	29 d3                	sub    %edx,%ebx
400302bf:	83 fb 1f             	cmp    $0x1f,%ebx
400302c2:	7f 11                	jg     400302d5 <__floatsidf+0x3e>
400302c4:	b9 0b 00 00 00       	mov    $0xb,%ecx
400302c9:	29 f1                	sub    %esi,%ecx
400302cb:	89 c6                	mov    %eax,%esi
400302cd:	d3 ee                	shr    %cl,%esi
400302cf:	88 d9                	mov    %bl,%cl
400302d1:	d3 e0                	shl    %cl,%eax
400302d3:	eb 17                	jmp    400302ec <__floatsidf+0x55>
400302d5:	b9 13 04 00 00       	mov    $0x413,%ecx
400302da:	29 d1                	sub    %edx,%ecx
400302dc:	d3 e0                	shl    %cl,%eax
400302de:	89 c6                	mov    %eax,%esi
400302e0:	31 c0                	xor    %eax,%eax
400302e2:	eb 08                	jmp    400302ec <__floatsidf+0x55>
400302e4:	31 f6                	xor    %esi,%esi
400302e6:	31 c0                	xor    %eax,%eax
400302e8:	31 d2                	xor    %edx,%edx
400302ea:	31 ff                	xor    %edi,%edi
400302ec:	31 db                	xor    %ebx,%ebx
400302ee:	89 c1                	mov    %eax,%ecx
400302f0:	89 f0                	mov    %esi,%eax
400302f2:	89 de                	mov    %ebx,%esi
400302f4:	25 ff ff 0f 00       	and    $0xfffff,%eax
400302f9:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
400302ff:	09 c6                	or     %eax,%esi
40030301:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
40030307:	81 e6 ff ff 0f 80    	and    $0x800fffff,%esi
4003030d:	5b                   	pop    %ebx
4003030e:	c1 e2 14             	shl    $0x14,%edx
40030311:	89 c8                	mov    %ecx,%eax
40030313:	c1 e7 1f             	shl    $0x1f,%edi
40030316:	09 f2                	or     %esi,%edx
40030318:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
4003031e:	5e                   	pop    %esi
4003031f:	09 fa                	or     %edi,%edx
40030321:	5f                   	pop    %edi
40030322:	5d                   	pop    %ebp
40030323:	c3                   	ret    

40030324 <main>:

int counter = 0;

uint8_t buffer[10] = {0};

void main() {
40030324:	55                   	push   %ebp
40030325:	89 e5                	mov    %esp,%ebp
    printf("LoRa Receiver\n");
40030327:	68 b8 51 03 40       	push   $0x400351b8
4003032c:	e8 e3 3f 00 00       	call   40034314 <iprintf>
40030331:	58                   	pop    %eax

    // start initialization
    LoRaClass();
40030332:	e8 c3 27 00 00       	call   40032afa <LoRaClass>
    // call pinset
    // ss, reset, dio0
    // 101
    //setPins(10, 3, 2);
    // c1000
    setPins(60, 82, 72);
40030337:	b9 48 00 00 00       	mov    $0x48,%ecx
4003033c:	ba 52 00 00 00       	mov    $0x52,%edx
40030341:	b8 3c 00 00 00       	mov    $0x3c,%eax
40030346:	e8 3c 28 00 00       	call   40032b87 <setPins>

    // complete initialization by finishing pin setup and
    // setting frequency
    //begin(915e6);
    begin(914984144);
4003034b:	b8 d0 8c 89 36       	mov    $0x36898cd0,%eax
40030350:	e8 6c 2b 00 00       	call   40032ec1 <begin>

    dumpRegisters();
40030355:	e8 2d 29 00 00       	call   40032c87 <dumpRegisters>

    int packet_size = 0;

#if 1
    printf("Receiver\n");
4003035a:	68 bd 51 03 40       	push   $0x400351bd
4003035f:	e8 b0 3f 00 00       	call   40034314 <iprintf>
40030364:	58                   	pop    %eax
    while(1) {

        // receive packet actually
        packet_size = parsePacket(0);
40030365:	31 c0                	xor    %eax,%eax
40030367:	e8 df 2d 00 00       	call   4003314b <parsePacket>
        if(packet_size) {
4003036c:	85 c0                	test   %eax,%eax
4003036e:	74 f5                	je     40030365 <main+0x41>
            printf("Received a packet yayy!! packet size: %d\n", packet_size);
40030370:	50                   	push   %eax
40030371:	68 c7 51 03 40       	push   $0x400351c7

            while(available()) {
                printf("value: %x\n", SX1276read());
40030376:	e8 99 3f 00 00       	call   40034314 <iprintf>
4003037b:	59                   	pop    %ecx
4003037c:	58                   	pop    %eax
            while(available()) {
4003037d:	e8 ca 28 00 00       	call   40032c4c <available>
40030382:	85 c0                	test   %eax,%eax
40030384:	74 0d                	je     40030393 <main+0x6f>
                printf("value: %x\n", SX1276read());
40030386:	e8 d9 28 00 00       	call   40032c64 <SX1276read>
4003038b:	50                   	push   %eax
4003038c:	68 f1 51 03 40       	push   $0x400351f1
40030391:	eb e3                	jmp    40030376 <main+0x52>
            }
            printf("With RSSI: %d\n", packetRssi());
40030393:	e8 74 28 00 00       	call   40032c0c <packetRssi>
40030398:	50                   	push   %eax
40030399:	68 fc 51 03 40       	push   $0x400351fc
4003039e:	e8 71 3f 00 00       	call   40034314 <iprintf>
400303a3:	58                   	pop    %eax
400303a4:	5a                   	pop    %edx
400303a5:	eb be                	jmp    40030365 <main+0x41>

400303a7 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
400303a7:	55                   	push   %ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
400303a8:	83 f8 0a             	cmp    $0xa,%eax
{
400303ab:	89 e5                	mov    %esp,%ebp
400303ad:	53                   	push   %ebx
400303ae:	89 c3                	mov    %eax,%ebx
	if ('\n' == c) {
400303b0:	75 10                	jne    400303c2 <console_out+0x1b>
		uart_poll_out(uart_console_dev, '\r');
400303b2:	a1 e8 67 00 a8       	mov    0xa80067e8,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
400303b7:	ba 0d 00 00 00       	mov    $0xd,%edx
400303bc:	8b 48 04             	mov    0x4(%eax),%ecx
400303bf:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
400303c2:	a1 e8 67 00 a8       	mov    0xa80067e8,%eax
400303c7:	0f b6 d3             	movzbl %bl,%edx
400303ca:	8b 48 04             	mov    0x4(%eax),%ecx
400303cd:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
400303d0:	89 d8                	mov    %ebx,%eax
400303d2:	5b                   	pop    %ebx
400303d3:	5d                   	pop    %ebp
400303d4:	c3                   	ret    

400303d5 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
400303d5:	55                   	push   %ebp
	__stdout_hook_install(console_out);
400303d6:	b8 a7 03 03 40       	mov    $0x400303a7,%eax
{
400303db:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
400303dd:	e8 ad 0a 00 00       	call   40030e8f <__stdout_hook_install>
	__printk_hook_install(console_out);
400303e2:	b8 a7 03 03 40       	mov    $0x400303a7,%eax
}
400303e7:	5d                   	pop    %ebp
	__printk_hook_install(console_out);
400303e8:	e9 23 0c 00 00       	jmp    40031010 <__printk_hook_install>

400303ed <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
400303ed:	55                   	push   %ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400303ee:	b8 0b 52 03 40       	mov    $0x4003520b,%eax
{
400303f3:	89 e5                	mov    %esp,%ebp
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400303f5:	e8 6a 32 00 00       	call   40033664 <device_get_binding>
400303fa:	a3 e8 67 00 a8       	mov    %eax,0xa80067e8
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
400303ff:	e8 d1 ff ff ff       	call   400303d5 <uart_console_hook_install>

	return 0;
}
40030404:	31 c0                	xor    %eax,%eax
40030406:	5d                   	pop    %ebp
40030407:	c3                   	ret    

40030408 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
40030408:	55                   	push   %ebp
40030409:	89 e5                	mov    %esp,%ebp
4003040b:	56                   	push   %esi
4003040c:	53                   	push   %ebx
4003040d:	89 c6                	mov    %eax,%esi
4003040f:	83 ec 0c             	sub    $0xc,%esp
	const struct uart_qmsi_config_info *config = dev->config->config_info;
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
40030412:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
	const struct uart_qmsi_config_info *config = dev->config->config_info;
40030419:	8b 00                	mov    (%eax),%eax
4003041b:	8b 58 08             	mov    0x8(%eax),%ebx
	cfg.baud_divisor = config->baud_divisor;
4003041e:	8b 43 08             	mov    0x8(%ebx),%eax
40030421:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cfg.hw_fc = config->hw_fc;
40030424:	8a 43 0c             	mov    0xc(%ebx),%al
40030427:	88 45 f4             	mov    %al,-0xc(%ebp)

	clk_periph_enable(config->clock_gate);
4003042a:	8b 43 04             	mov    0x4(%ebx),%eax
4003042d:	e8 9e 0e 00 00       	call   400312d0 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
40030432:	8d 55 ec             	lea    -0x14(%ebp),%edx
40030435:	8b 03                	mov    (%ebx),%eax
40030437:	e8 db 0f 00 00       	call   40031417 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
4003043c:	c7 46 04 44 52 03 40 	movl   $0x40035244,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
40030443:	83 c4 0c             	add    $0xc,%esp
40030446:	31 c0                	xor    %eax,%eax
40030448:	5b                   	pop    %ebx
40030449:	5e                   	pop    %esi
4003044a:	5d                   	pop    %ebp
4003044b:	c3                   	ret    

4003044c <uart_qmsi_err_check>:
{
4003044c:	55                   	push   %ebp
4003044d:	89 e5                	mov    %esp,%ebp
4003044f:	52                   	push   %edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030450:	8b 00                	mov    (%eax),%eax
	qm_uart_get_status(instance, &status);
40030452:	8d 55 fc             	lea    -0x4(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030455:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_get_status(instance, &status);
40030458:	8b 00                	mov    (%eax),%eax
4003045a:	e8 25 10 00 00       	call   40031484 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
4003045f:	8b 45 fc             	mov    -0x4(%ebp),%eax
40030462:	83 e0 1e             	and    $0x1e,%eax
}
40030465:	c9                   	leave  
40030466:	c3                   	ret    

40030467 <uart_qmsi_poll_out>:
{
40030467:	55                   	push   %ebp
40030468:	89 e5                	mov    %esp,%ebp
4003046a:	53                   	push   %ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003046b:	8b 00                	mov    (%eax),%eax
{
4003046d:	89 d3                	mov    %edx,%ebx
	qm_uart_write(instance, data);
4003046f:	0f b6 d2             	movzbl %dl,%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030472:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_write(instance, data);
40030475:	8b 00                	mov    (%eax),%eax
40030477:	e8 49 10 00 00       	call   400314c5 <qm_uart_write>
}
4003047c:	88 d8                	mov    %bl,%al
4003047e:	5b                   	pop    %ebx
4003047f:	5d                   	pop    %ebp
40030480:	c3                   	ret    

40030481 <uart_qmsi_poll_in>:
{
40030481:	55                   	push   %ebp
40030482:	89 e5                	mov    %esp,%ebp
40030484:	56                   	push   %esi
40030485:	53                   	push   %ebx
40030486:	51                   	push   %ecx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030487:	8b 00                	mov    (%eax),%eax
{
40030489:	89 d6                	mov    %edx,%esi
	qm_uart_get_status(instance, &status);
4003048b:	8d 55 f4             	lea    -0xc(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003048e:	8b 40 08             	mov    0x8(%eax),%eax
40030491:	8b 18                	mov    (%eax),%ebx
	qm_uart_get_status(instance, &status);
40030493:	89 d8                	mov    %ebx,%eax
40030495:	e8 ea 0f 00 00       	call   40031484 <qm_uart_get_status>
		return -1;
4003049a:	83 c8 ff             	or     $0xffffffff,%eax
	if (!(status & QM_UART_RX_BUSY))
4003049d:	f6 45 f4 40          	testb  $0x40,-0xc(%ebp)
400304a1:	74 0d                	je     400304b0 <uart_qmsi_poll_in+0x2f>
	qm_uart_read(instance, data, NULL);
400304a3:	31 c9                	xor    %ecx,%ecx
400304a5:	89 f2                	mov    %esi,%edx
400304a7:	89 d8                	mov    %ebx,%eax
400304a9:	e8 3a 10 00 00       	call   400314e8 <qm_uart_read>
	return 0;
400304ae:	31 c0                	xor    %eax,%eax
}
400304b0:	5a                   	pop    %edx
400304b1:	5b                   	pop    %ebx
400304b2:	5e                   	pop    %esi
400304b3:	5d                   	pop    %ebp
400304b4:	c3                   	ret    

400304b5 <_timer_int_handler>:

	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick * _sys_idle_elapsed_ticks;
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
400304b5:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
{
400304ba:	55                   	push   %ebp
	accumulated_cycle_count += cycles_per_tick;
400304bb:	01 05 fc 67 00 a8    	add    %eax,0xa80067fc

	_sys_clock_tick_announce();
400304c1:	a1 e8 66 00 a8       	mov    0xa80066e8,%eax
{
400304c6:	89 e5                	mov    %esp,%ebp
#endif /*CONFIG_TICKLESS_IDLE*/

}
400304c8:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
400304c9:	e9 3b 37 00 00       	jmp    40033c09 <_nano_sys_clock_tick_announce>

400304ce <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
400304ce:	a1 ec 66 00 a8       	mov    0xa80066ec,%eax
{
400304d3:	55                   	push   %ebp
	cycles_per_tick = sys_clock_hw_cycles_per_tick;
400304d4:	a3 b8 78 00 a8       	mov    %eax,0xa80078b8
{
400304d9:	89 e5                	mov    %esp,%ebp
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
400304db:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
400304e0:	83 e0 f0             	and    $0xfffffff0,%eax
400304e3:	83 c8 0b             	or     $0xb,%eax
400304e6:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
400304eb:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
400304f0:	48                   	dec    %eax
	*_REG_TIMER_ICR = count;
400304f1:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
400304f6:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
400304fb:	0d 00 00 02 00       	or     $0x20000,%eax
40030500:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
40030505:	0f b6 05 28 69 03 40 	movzbl 0x40036928,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
4003050c:	31 c9                	xor    %ecx,%ecx
4003050e:	ba 40 00 00 00       	mov    $0x40,%edx
40030513:	e8 7b 01 00 00       	call   40030693 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
40030518:	b8 40 00 00 00       	mov    $0x40,%eax
4003051d:	e8 93 01 00 00       	call   400306b5 <_arch_irq_enable>

	return 0;
}
40030522:	31 c0                	xor    %eax,%eax
40030524:	5d                   	pop    %ebp
40030525:	c3                   	ret    

40030526 <_timer_int_handler_irq64_stub>:
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
40030526:	6a 00                	push   $0x0
40030528:	68 b5 04 03 40       	push   $0x400304b5
4003052d:	e9 f5 2d 00 00       	jmp    40033327 <_interrupt_enter>

40030532 <qm_spi_master_1_isr_irq3_stub>:
40030532:	6a 00                	push   $0x0
40030534:	68 bb 19 03 40       	push   $0x400319bb
40030539:	e9 e9 2d 00 00       	jmp    40033327 <_interrupt_enter>

4003053e <qm_spi_master_0_isr_irq2_stub>:
4003053e:	6a 00                	push   $0x0
40030540:	68 b0 19 03 40       	push   $0x400319b0
40030545:	e9 dd 2d 00 00       	jmp    40033327 <_interrupt_enter>

4003054a <qm_aon_gpio_0_isr_irq31_stub>:
4003054a:	6a 00                	push   $0x0
4003054c:	68 27 13 03 40       	push   $0x40031327
40030551:	e9 d1 2d 00 00       	jmp    40033327 <_interrupt_enter>

40030556 <qm_gpio_0_isr_irq8_stub>:
40030556:	6a 00                	push   $0x0
40030558:	68 1c 13 03 40       	push   $0x4003131c
4003055d:	e9 c5 2d 00 00       	jmp    40033327 <_interrupt_enter>

40030562 <_timer_cycle_get_32>:
	 * in the Initial Count Register (ICR).
	 */

#if !defined(CONFIG_TICKLESS_IDLE)
	/* The value in the ICR always matches cycles_per_tick. */
	val = accumulated_cycle_count - current_count_register_get() +
40030562:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
{
40030567:	55                   	push   %ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030568:	03 05 fc 67 00 a8    	add    0xa80067fc,%eax
	return *_REG_TIMER_CCR;
4003056e:	8b 15 90 03 e0 fe    	mov    0xfee00390,%edx
{
40030574:	89 e5                	mov    %esp,%ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030576:	29 d0                	sub    %edx,%eax
	val = accumulated_cycle_count - current_count_register_get() +
	      initial_count_register_get();
#endif

	return val;
}
40030578:	5d                   	pop    %ebp
40030579:	c3                   	ret    

4003057a <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
4003057a:	55                   	push   %ebp
4003057b:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
4003057d:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
40030582:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
40030585:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
4003058a:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
4003058f:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
40030596:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
40030599:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
4003059c:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
400305a3:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
400305a6:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
400305ad:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
400305b0:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
400305b7:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
400305ba:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
400305c0:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
400305c6:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
400305c9:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
400305cf:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
400305d5:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
400305db:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
400305de:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
400305e1:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
400305e7:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
400305ea:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
400305f1:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
400305f4:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
400305fb:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
400305fe:	7e 19                	jle    40030619 <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
40030600:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
40030607:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
4003060a:	83 f8 04             	cmp    $0x4,%eax
4003060d:	74 0a                	je     40030619 <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
4003060f:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
40030616:	00 01 00 
		| (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF);
#endif

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
40030619:	e8 4f 2c 00 00       	call   4003326d <_lakemont_eoi>
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
#endif

	return 0;
}
4003061e:	31 c0                	xor    %eax,%eax
40030620:	5d                   	pop    %ebp
40030621:	c3                   	ret    

40030622 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
40030622:	55                   	push   %ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030623:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030628:	c1 e0 04             	shl    $0x4,%eax
{
4003062b:	89 e5                	mov    %esp,%ebp
4003062d:	53                   	push   %ebx
	__asm__ volatile (
4003062e:	9c                   	pushf  
4003062f:	fa                   	cli    
40030630:	5b                   	pop    %ebx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
40030631:	8b 08                	mov    (%eax),%ecx
40030633:	30 c9                	xor    %cl,%cl
40030635:	09 ca                	or     %ecx,%edx
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
40030637:	0f ba e3 09          	bt     $0x9,%ebx
4003063b:	89 10                	mov    %edx,(%eax)
4003063d:	73 01                	jae    40030640 <_loapic_int_vec_set+0x1e>
	__asm__ volatile (
4003063f:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030640:	5b                   	pop    %ebx
40030641:	5d                   	pop    %ebp
40030642:	c3                   	ret    

40030643 <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
40030643:	55                   	push   %ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030644:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030649:	c1 e0 04             	shl    $0x4,%eax
{
4003064c:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
4003064e:	9c                   	pushf  
4003064f:	fa                   	cli    
40030650:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
40030651:	8b 10                	mov    (%eax),%edx
40030653:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40030659:	0f ba e1 09          	bt     $0x9,%ecx
4003065d:	89 10                	mov    %edx,(%eax)
4003065f:	73 01                	jae    40030662 <_loapic_irq_enable+0x1f>
	__asm__ volatile (
40030661:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030662:	5d                   	pop    %ebp
40030663:	c3                   	ret    

40030664 <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
40030664:	55                   	push   %ebp
40030665:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
4003066a:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
4003066c:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
40030671:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
40030673:	85 d2                	test   %edx,%edx
40030675:	74 11                	je     40030688 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
40030677:	0f bd d2             	bsr    %edx,%edx
4003067a:	75 05                	jne    40030681 <__irq_controller_isr_vector_get+0x1d>
4003067c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
40030681:	c1 e0 05             	shl    $0x5,%eax
40030684:	01 d0                	add    %edx,%eax
40030686:	eb 09                	jmp    40030691 <__irq_controller_isr_vector_get+0x2d>
40030688:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
4003068b:	48                   	dec    %eax
4003068c:	75 e3                	jne    40030671 <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
4003068e:	83 c8 ff             	or     $0xffffffff,%eax
}
40030691:	5d                   	pop    %ebp
40030692:	c3                   	ret    

40030693 <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
40030693:	55                   	push   %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
40030694:	83 fa 3f             	cmp    $0x3f,%edx
{
40030697:	89 e5                	mov    %esp,%ebp
40030699:	53                   	push   %ebx
4003069a:	89 c3                	mov    %eax,%ebx
4003069c:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
4003069e:	77 09                	ja     400306a9 <__irq_controller_irq_config+0x16>
		_ioapic_irq_set(irq, vector, flags);
400306a0:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
400306a2:	5b                   	pop    %ebx
400306a3:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
400306a4:	e9 a9 00 00 00       	jmp    40030752 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
400306a9:	89 da                	mov    %ebx,%edx
400306ab:	83 e8 40             	sub    $0x40,%eax
}
400306ae:	5b                   	pop    %ebx
400306af:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
400306b0:	e9 6d ff ff ff       	jmp    40030622 <_loapic_int_vec_set>

400306b5 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
400306b5:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
400306b6:	83 f8 3f             	cmp    $0x3f,%eax
{
400306b9:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
400306bb:	77 06                	ja     400306c3 <_arch_irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
400306bd:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
400306be:	e9 7f 00 00 00       	jmp    40030742 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
400306c3:	83 e8 40             	sub    $0x40,%eax
}
400306c6:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
400306c7:	e9 77 ff ff ff       	jmp    40030643 <_loapic_irq_enable>

400306cc <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
400306cc:	55                   	push   %ebp
400306cd:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
400306cf:	9c                   	pushf  
400306d0:	fa                   	cli    
400306d1:	59                   	pop    %ecx
400306d2:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
400306d6:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
400306db:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
400306e1:	73 01                	jae    400306e4 <__IoApicSet+0x18>
	__asm__ volatile (
400306e3:	fb                   	sti    

	irq_unlock(key);
}
400306e4:	5d                   	pop    %ebp
400306e5:	c3                   	ret    

400306e6 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
400306e6:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
400306e7:	01 c0                	add    %eax,%eax
{
400306e9:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
400306eb:	83 c0 10             	add    $0x10,%eax
{
400306ee:	56                   	push   %esi
400306ef:	53                   	push   %ebx
	__asm__ volatile (
400306f0:	9c                   	pushf  
400306f1:	fa                   	cli    
400306f2:	5e                   	pop    %esi
400306f3:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
400306f7:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
400306fc:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
40030702:	73 01                	jae    40030705 <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
40030704:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
40030705:	31 da                	xor    %ebx,%edx
40030707:	21 ca                	and    %ecx,%edx
40030709:	31 da                	xor    %ebx,%edx
}
4003070b:	5b                   	pop    %ebx
4003070c:	5e                   	pop    %esi
4003070d:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
4003070e:	e9 b9 ff ff ff       	jmp    400306cc <__IoApicSet>

40030713 <_ioapic_init>:
{
40030713:	55                   	push   %ebp
40030714:	89 e5                	mov    %esp,%ebp
40030716:	53                   	push   %ebx
40030717:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
4003071c:	31 d2                	xor    %edx,%edx
4003071e:	89 d8                	mov    %ebx,%eax
40030720:	e8 a7 ff ff ff       	call   400306cc <__IoApicSet>
	__IoApicSet(offset, lower32);
40030725:	8d 43 ff             	lea    -0x1(%ebx),%eax
40030728:	ba 00 00 01 00       	mov    $0x10000,%edx
4003072d:	83 c3 02             	add    $0x2,%ebx
40030730:	e8 97 ff ff ff       	call   400306cc <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
40030735:	81 fb 91 00 00 00    	cmp    $0x91,%ebx
4003073b:	75 df                	jne    4003071c <_ioapic_init+0x9>
}
4003073d:	31 c0                	xor    %eax,%eax
4003073f:	5b                   	pop    %ebx
40030740:	5d                   	pop    %ebp
40030741:	c3                   	ret    

40030742 <_ioapic_irq_enable>:
{
40030742:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030743:	b9 00 00 01 00       	mov    $0x10000,%ecx
40030748:	31 d2                	xor    %edx,%edx
{
4003074a:	89 e5                	mov    %esp,%ebp
}
4003074c:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
4003074d:	e9 94 ff ff ff       	jmp    400306e6 <_IoApicRedUpdateLo>

40030752 <_ioapic_irq_set>:
{
40030752:	55                   	push   %ebp
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030753:	81 c9 00 00 01 00    	or     $0x10000,%ecx
{
40030759:	89 e5                	mov    %esp,%ebp
4003075b:	56                   	push   %esi
4003075c:	53                   	push   %ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
4003075d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
40030760:	0f b6 f2             	movzbl %dl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030763:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
40030766:	31 d2                	xor    %edx,%edx
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030768:	09 ce                	or     %ecx,%esi
	__IoApicSet(offset, upper32);
4003076a:	e8 5d ff ff ff       	call   400306cc <__IoApicSet>
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
4003076f:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
40030772:	89 f2                	mov    %esi,%edx
}
40030774:	5b                   	pop    %ebx
40030775:	5e                   	pop    %esi
40030776:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
40030777:	e9 50 ff ff ff       	jmp    400306cc <__IoApicSet>

4003077c <spi_qmsi_configure>:
	gpio_pin_write(gpio, config->cs_pin, !active);
}

static int spi_qmsi_configure(struct device *dev,
				struct spi_config *config)
{
4003077c:	55                   	push   %ebp
4003077d:	89 e5                	mov    %esp,%ebp
4003077f:	56                   	push   %esi
40030780:	53                   	push   %ebx
40030781:	51                   	push   %ecx
	struct spi_qmsi_runtime *context = dev->driver_data;
40030782:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_spi_config_t *cfg = &context->cfg;

	cfg->frame_size = SPI_WORD_SIZE_GET(config->config) - 1;
40030785:	8b 02                	mov    (%edx),%eax
40030787:	89 c1                	mov    %eax,%ecx
40030789:	c1 e9 04             	shr    $0x4,%ecx
4003078c:	0f b6 c9             	movzbl %cl,%ecx
4003078f:	49                   	dec    %ecx
40030790:	89 4b 14             	mov    %ecx,0x14(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030793:	89 c1                	mov    %eax,%ecx
40030795:	83 e1 07             	and    $0x7,%ecx
40030798:	49                   	dec    %ecx
40030799:	88 4d f7             	mov    %cl,-0x9(%ebp)
4003079c:	31 c9                	xor    %ecx,%ecx
4003079e:	80 7d f7 02          	cmpb   $0x2,-0x9(%ebp)
400307a2:	77 0a                	ja     400307ae <spi_qmsi_configure+0x32>
400307a4:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
400307a8:	8a 89 70 52 03 40    	mov    0x40035270(%ecx),%cl
	/* As loopback is implemented inside the controller,
	 * the bus mode doesn't matter.
	 */
	context->loopback = SPI_MODE(config->config) & SPI_MODE_LOOP;
400307ae:	c1 e8 02             	shr    $0x2,%eax
400307b1:	83 e0 01             	and    $0x1,%eax
400307b4:	88 43 2c             	mov    %al,0x2c(%ebx)
	cfg->clk_divider = config->max_sys_freq;
400307b7:	8b 42 04             	mov    0x4(%edx),%eax
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
400307ba:	0f b6 f1             	movzbl %cl,%esi
	cfg->clk_divider = config->max_sys_freq;
400307bd:	66 89 43 24          	mov    %ax,0x24(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
400307c1:	89 73 1c             	mov    %esi,0x1c(%ebx)

	/* Will set the configuration before the transfer starts */
	return 0;
}
400307c4:	5a                   	pop    %edx
400307c5:	31 c0                	xor    %eax,%eax
400307c7:	5b                   	pop    %ebx
400307c8:	5e                   	pop    %esi
400307c9:	5d                   	pop    %ebp
400307ca:	c3                   	ret    

400307cb <spi_qmsi_slave_select>:
	context->rc = error;
	k_sem_give(&context->device_sync_sem);
}

static int spi_qmsi_slave_select(struct device *dev, uint32_t slave)
{
400307cb:	55                   	push   %ebp
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
	qm_spi_t spi = spi_config->spi;

	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
400307cc:	8d 4a ff             	lea    -0x1(%edx),%ecx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
400307cf:	8b 00                	mov    (%eax),%eax
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
400307d1:	ba 01 00 00 00       	mov    $0x1,%edx
400307d6:	d3 e2                	shl    %cl,%edx
	qm_spi_t spi = spi_config->spi;
400307d8:	8b 40 08             	mov    0x8(%eax),%eax
{
400307db:	89 e5                	mov    %esp,%ebp
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
400307dd:	8b 00                	mov    (%eax),%eax
400307df:	e8 4e 10 00 00       	call   40031832 <qm_spi_slave_select>
400307e4:	85 c0                	test   %eax,%eax
400307e6:	74 05                	je     400307ed <spi_qmsi_slave_select+0x22>
400307e8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400307ed:	5d                   	pop    %ebp
400307ee:	c3                   	ret    

400307ef <spi_qmsi_init>:
#else
#define spi_master_set_power_state(...)
#endif

static int spi_qmsi_init(struct device *dev)
{
400307ef:	55                   	push   %ebp
400307f0:	89 e5                	mov    %esp,%ebp
400307f2:	57                   	push   %edi
400307f3:	56                   	push   %esi
400307f4:	53                   	push   %ebx
400307f5:	83 ec 08             	sub    $0x8,%esp
400307f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
400307fb:	8b 00                	mov    (%eax),%eax
400307fd:	8b 70 08             	mov    0x8(%eax),%esi
	struct spi_qmsi_runtime *context = dev->driver_data;
40030800:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030803:	8b 40 08             	mov    0x8(%eax),%eax
40030806:	89 45 f0             	mov    %eax,-0x10(%ebp)

	switch (spi_config->spi) {
40030809:	8b 06                	mov    (%esi),%eax
4003080b:	85 c0                	test   %eax,%eax
4003080d:	74 40                	je     4003084f <spi_qmsi_init+0x60>
4003080f:	48                   	dec    %eax
40030810:	0f 85 ea 00 00 00    	jne    40030900 <spi_qmsi_init+0x111>
40030816:	0f b6 05 eb 68 03 40 	movzbl 0x400368eb,%eax
4003081d:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030822:	ba 03 00 00 00       	mov    $0x3,%edx
40030827:	e8 67 fe ff ff       	call   40030693 <__irq_controller_irq_config>
#ifdef CONFIG_SPI_1
	case QM_SPI_MST_1:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT),
			    CONFIG_SPI_1_IRQ_PRI, qm_spi_master_1_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT));
4003082c:	b8 03 00 00 00       	mov    $0x3,%eax
40030831:	e8 7f fe ff ff       	call   400306b5 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M1_REGISTER);
40030836:	b8 02 80 00 00       	mov    $0x8002,%eax
4003083b:	e8 90 0a 00 00       	call   400312d0 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030840:	a1 58 04 80 b0       	mov    0xb0800458,%eax
40030845:	83 e0 fe             	and    $0xfffffffe,%eax
40030848:	a3 58 04 80 b0       	mov    %eax,0xb0800458
				QM_INTERRUPT_ROUTER->spi_master_1_int_mask);
		break;
4003084d:	eb 37                	jmp    40030886 <spi_qmsi_init+0x97>
4003084f:	0f b6 05 ea 68 03 40 	movzbl 0x400368ea,%eax
40030856:	b9 00 80 00 00       	mov    $0x8000,%ecx
4003085b:	ba 02 00 00 00       	mov    $0x2,%edx
40030860:	e8 2e fe ff ff       	call   40030693 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_0_INT));
40030865:	b8 02 00 00 00       	mov    $0x2,%eax
4003086a:	e8 46 fe ff ff       	call   400306b5 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M0_REGISTER);
4003086f:	b8 02 40 00 00       	mov    $0x4002,%eax
40030874:	e8 57 0a 00 00       	call   400312d0 <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030879:	a1 54 04 80 b0       	mov    0xb0800454,%eax
4003087e:	83 e0 fe             	and    $0xfffffffe,%eax
40030881:	a3 54 04 80 b0       	mov    %eax,0xb0800454
	if (!config->cs_port)
40030886:	8b 46 04             	mov    0x4(%esi),%eax
40030889:	85 c0                	test   %eax,%eax
4003088b:	75 04                	jne    40030891 <spi_qmsi_init+0xa2>
		return NULL;
4003088d:	31 db                	xor    %ebx,%ebx
4003088f:	eb 35                	jmp    400308c6 <spi_qmsi_init+0xd7>
	gpio = device_get_binding(config->cs_port);
40030891:	e8 ce 2d 00 00       	call   40033664 <device_get_binding>
40030896:	89 c3                	mov    %eax,%ebx
	if (!gpio)
40030898:	85 c0                	test   %eax,%eax
4003089a:	74 f1                	je     4003088d <spi_qmsi_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
4003089c:	8b 40 04             	mov    0x4(%eax),%eax
4003089f:	31 d2                	xor    %edx,%edx
400308a1:	0f b6 4e 08          	movzbl 0x8(%esi),%ecx
400308a5:	89 c7                	mov    %eax,%edi
400308a7:	89 d8                	mov    %ebx,%eax
400308a9:	6a 01                	push   $0x1
400308ab:	ff 17                	call   *(%edi)
400308ad:	59                   	pop    %ecx
	if (gpio_pin_configure(gpio, config->cs_pin, GPIO_DIR_OUT) != 0) {
400308ae:	85 c0                	test   %eax,%eax
400308b0:	75 db                	jne    4003088d <spi_qmsi_init+0x9e>
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
400308b2:	8b 4e 08             	mov    0x8(%esi),%ecx
400308b5:	8b 73 04             	mov    0x4(%ebx),%esi
400308b8:	31 d2                	xor    %edx,%edx
400308ba:	89 d8                	mov    %ebx,%eax
400308bc:	6a 01                	push   $0x1
400308be:	ff 56 04             	call   *0x4(%esi)
400308c1:	5a                   	pop    %edx
	if (gpio_pin_write(gpio, config->cs_pin, 1) != 0) {
400308c2:	85 c0                	test   %eax,%eax
400308c4:	75 c7                	jne    4003088d <spi_qmsi_init+0x9e>

	default:
		return -EIO;
	}

	context->gpio_cs = gpio_cs_init(spi_config);
400308c6:	8b 45 f0             	mov    -0x10(%ebp),%eax

	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
400308c9:	83 c9 ff             	or     $0xffffffff,%ecx
400308cc:	83 c0 04             	add    $0x4,%eax
400308cf:	31 d2                	xor    %edx,%edx
	context->gpio_cs = gpio_cs_init(spi_config);
400308d1:	89 58 fc             	mov    %ebx,-0x4(%eax)
	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
400308d4:	e8 72 32 00 00       	call   40033b4b <k_sem_init>
	k_sem_init(&context->sem, 0, UINT_MAX);
400308d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400308dc:	8d 58 30             	lea    0x30(%eax),%ebx
400308df:	83 c9 ff             	or     $0xffffffff,%ecx
400308e2:	31 d2                	xor    %edx,%edx
400308e4:	89 d8                	mov    %ebx,%eax
400308e6:	e8 60 32 00 00       	call   40033b4b <k_sem_init>
	k_sem_give(&context->sem);
400308eb:	89 d8                	mov    %ebx,%eax
400308ed:	e8 69 32 00 00       	call   40033b5b <k_sem_give>

	spi_master_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	dev->driver_api = &spi_qmsi_api;
400308f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
400308f5:	c7 40 04 8c 52 03 40 	movl   $0x4003528c,0x4(%eax)
	return 0;
400308fc:	31 c0                	xor    %eax,%eax
400308fe:	eb 05                	jmp    40030905 <spi_qmsi_init+0x116>
		return -EIO;
40030900:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030905:	8d 65 f4             	lea    -0xc(%ebp),%esp
40030908:	5b                   	pop    %ebx
40030909:	5e                   	pop    %esi
4003090a:	5f                   	pop    %edi
4003090b:	5d                   	pop    %ebp
4003090c:	c3                   	ret    

4003090d <spi_control_cs>:
{
4003090d:	55                   	push   %ebp
4003090e:	89 e5                	mov    %esp,%ebp
40030910:	56                   	push   %esi
40030911:	53                   	push   %ebx
	struct device *gpio = context->gpio_cs;
40030912:	8b 48 08             	mov    0x8(%eax),%ecx
40030915:	8b 31                	mov    (%ecx),%esi
	if (!gpio)
40030917:	85 f6                	test   %esi,%esi
40030919:	74 1a                	je     40030935 <spi_control_cs+0x28>
	const struct spi_qmsi_config *config = dev->config->config_info;
4003091b:	8b 00                	mov    (%eax),%eax
	gpio_pin_write(gpio, config->cs_pin, !active);
4003091d:	83 f2 01             	xor    $0x1,%edx
40030920:	8b 5e 04             	mov    0x4(%esi),%ebx
40030923:	8b 40 08             	mov    0x8(%eax),%eax
40030926:	0f b6 d2             	movzbl %dl,%edx
40030929:	8b 48 08             	mov    0x8(%eax),%ecx
4003092c:	52                   	push   %edx
4003092d:	89 f0                	mov    %esi,%eax
4003092f:	31 d2                	xor    %edx,%edx
40030931:	ff 53 04             	call   *0x4(%ebx)
40030934:	58                   	pop    %eax
}
40030935:	8d 65 f8             	lea    -0x8(%ebp),%esp
40030938:	5b                   	pop    %ebx
40030939:	5e                   	pop    %esi
4003093a:	5d                   	pop    %ebp
4003093b:	c3                   	ret    

4003093c <transfer_complete>:
{
4003093c:	55                   	push   %ebp
4003093d:	89 e5                	mov    %esp,%ebp
4003093f:	57                   	push   %edi
40030940:	56                   	push   %esi
40030941:	53                   	push   %ebx
	const struct spi_qmsi_config *spi_config =
40030942:	8b 00                	mov    (%eax),%eax
	qm_spi_t spi = spi_config->spi;
40030944:	8b 40 08             	mov    0x8(%eax),%eax
	struct device *dev = pending->dev;
40030947:	6b 38 1c             	imul   $0x1c,(%eax),%edi
4003094a:	8b 87 80 68 00 a8    	mov    -0x57ff9780(%edi),%eax
	if (!dev)
40030950:	85 c0                	test   %eax,%eax
40030952:	74 25                	je     40030979 <transfer_complete+0x3d>
40030954:	89 d6                	mov    %edx,%esi
	spi_control_cs(dev, false);
40030956:	31 d2                	xor    %edx,%edx
	context = dev->driver_data;
40030958:	8b 58 08             	mov    0x8(%eax),%ebx
	spi_control_cs(dev, false);
4003095b:	e8 ad ff ff ff       	call   4003090d <spi_control_cs>
	pending->dev = NULL;
40030960:	c7 87 80 68 00 a8 00 	movl   $0x0,-0x57ff9780(%edi)
40030967:	00 00 00 
	k_sem_give(&context->device_sync_sem);
4003096a:	8d 43 04             	lea    0x4(%ebx),%eax
	context->rc = error;
4003096d:	89 73 28             	mov    %esi,0x28(%ebx)
}
40030970:	5b                   	pop    %ebx
40030971:	5e                   	pop    %esi
40030972:	5f                   	pop    %edi
40030973:	5d                   	pop    %ebp
	k_sem_give(&context->device_sync_sem);
40030974:	e9 e2 31 00 00       	jmp    40033b5b <k_sem_give>
}
40030979:	5b                   	pop    %ebx
4003097a:	5e                   	pop    %esi
4003097b:	5f                   	pop    %edi
4003097c:	5d                   	pop    %ebp
4003097d:	c3                   	ret    

4003097e <spi_qmsi_transceive>:
{
4003097e:	55                   	push   %ebp
4003097f:	89 e5                	mov    %esp,%ebp
40030981:	57                   	push   %edi
40030982:	56                   	push   %esi
40030983:	53                   	push   %ebx
40030984:	83 ec 14             	sub    $0x14,%esp
40030987:	89 c3                	mov    %eax,%ebx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030989:	8b 00                	mov    (%eax),%eax
{
4003098b:	89 55 e0             	mov    %edx,-0x20(%ebp)
	struct spi_qmsi_runtime *context = dev->driver_data;
4003098e:	8b 73 08             	mov    0x8(%ebx),%esi
{
40030991:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	qm_spi_t spi = spi_config->spi;
40030994:	8b 40 08             	mov    0x8(%eax),%eax
40030997:	8b 00                	mov    (%eax),%eax
40030999:	89 45 f0             	mov    %eax,-0x10(%ebp)
	qm_spi_config_t *cfg = &context->cfg;
4003099c:	8d 46 14             	lea    0x14(%esi),%eax
4003099f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8_t dfs = frame_size_to_dfs(cfg->frame_size);
400309a2:	8b 46 14             	mov    0x14(%esi),%eax
		return 1;
400309a5:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_8_BIT)
400309a9:	83 f8 07             	cmp    $0x7,%eax
400309ac:	76 15                	jbe    400309c3 <spi_qmsi_transceive+0x45>
		return 2;
400309ae:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_16_BIT)
400309b2:	83 f8 0f             	cmp    $0xf,%eax
400309b5:	76 0c                	jbe    400309c3 <spi_qmsi_transceive+0x45>
	return 0;
400309b7:	83 f8 20             	cmp    $0x20,%eax
400309ba:	0f 92 c0             	setb   %al
400309bd:	c1 e0 02             	shl    $0x2,%eax
400309c0:	88 45 ec             	mov    %al,-0x14(%ebp)
	k_sem_take(&context->sem, K_FOREVER);
400309c3:	8d 4e 30             	lea    0x30(%esi),%ecx
400309c6:	83 ca ff             	or     $0xffffffff,%edx
400309c9:	89 c8                	mov    %ecx,%eax
400309cb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
400309ce:	e8 fd 31 00 00       	call   40033bd0 <k_sem_take>
	if (pending_transfers[spi].dev) {
400309d3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400309d6:	6b 55 f0 1c          	imul   $0x1c,-0x10(%ebp),%edx
400309da:	8d ba 80 68 00 a8    	lea    -0x57ff9780(%edx),%edi
400309e0:	83 ba 80 68 00 a8 00 	cmpl   $0x0,-0x57ff9780(%edx)
400309e7:	74 11                	je     400309fa <spi_qmsi_transceive+0x7c>
		k_sem_give(&context->sem);
400309e9:	89 c8                	mov    %ecx,%eax
400309eb:	e8 6b 31 00 00       	call   40033b5b <k_sem_give>
		return -EBUSY;
400309f0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
400309f5:	e9 ed 00 00 00       	jmp    40030ae7 <spi_qmsi_transceive+0x169>
	k_sem_give(&context->sem);
400309fa:	89 c8                	mov    %ecx,%eax
	pending_transfers[spi].dev = dev;
400309fc:	89 9a 80 68 00 a8    	mov    %ebx,-0x57ff9780(%edx)
40030a02:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_sem_give(&context->sem);
40030a05:	e8 51 31 00 00       	call   40033b5b <k_sem_give>
	device_busy_set(dev);
40030a0a:	89 d8                	mov    %ebx,%eax
40030a0c:	e8 8b 2c 00 00       	call   4003369c <device_busy_set>
	xfer = &pending_transfers[spi].xfer;
40030a11:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40030a14:	8d 82 84 68 00 a8    	lea    -0x57ff977c(%edx),%eax
	xfer->rx_len = rx_buf_len / dfs;
40030a1a:	31 d2                	xor    %edx,%edx
40030a1c:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
	xfer = &pending_transfers[spi].xfer;
40030a20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	xfer->rx = rx_buf;
40030a23:	8b 45 08             	mov    0x8(%ebp),%eax
40030a26:	89 47 08             	mov    %eax,0x8(%edi)
	xfer->rx_len = rx_buf_len / dfs;
40030a29:	8b 45 0c             	mov    0xc(%ebp),%eax
40030a2c:	f7 f1                	div    %ecx
40030a2e:	66 89 47 0e          	mov    %ax,0xe(%edi)
	xfer->tx = (uint8_t *)tx_buf;
40030a32:	8b 45 e0             	mov    -0x20(%ebp),%eax
	xfer->tx_len = tx_buf_len / dfs;
40030a35:	31 d2                	xor    %edx,%edx
	xfer->tx = (uint8_t *)tx_buf;
40030a37:	89 47 04             	mov    %eax,0x4(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030a3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
	xfer->callback_data = dev;
40030a3d:	89 5f 18             	mov    %ebx,0x18(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030a40:	f7 f1                	div    %ecx
40030a42:	66 89 47 0c          	mov    %ax,0xc(%edi)
	xfer->callback = transfer_complete;
40030a46:	c7 47 14 3c 09 03 40 	movl   $0x4003093c,0x14(%edi)
	if (tx_buf_len == 0)
40030a4d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030a51:	75 09                	jne    40030a5c <spi_qmsi_transceive+0xde>
		cfg->transfer_mode = QM_SPI_TMOD_RX;
40030a53:	c7 46 18 02 00 00 00 	movl   $0x2,0x18(%esi)
40030a5a:	eb 0c                	jmp    40030a68 <spi_qmsi_transceive+0xea>
		cfg->transfer_mode = QM_SPI_TMOD_TX;
40030a5c:	31 c0                	xor    %eax,%eax
40030a5e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40030a62:	0f 94 c0             	sete   %al
40030a65:	89 46 18             	mov    %eax,0x18(%esi)
	if (context->loopback)
40030a68:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
40030a6c:	74 11                	je     40030a7f <spi_qmsi_transceive+0x101>
		QM_SPI[spi]->ctrlr0 |= BIT(11);
40030a6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030a71:	8b 14 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edx
40030a78:	8b 02                	mov    (%edx),%eax
40030a7a:	80 cc 08             	or     $0x8,%ah
40030a7d:	89 02                	mov    %eax,(%edx)
	rc = qm_spi_set_config(spi, cfg);
40030a7f:	8d 56 14             	lea    0x14(%esi),%edx
40030a82:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030a85:	e8 3b 0d 00 00       	call   400317c5 <qm_spi_set_config>
	if (rc != 0) {
40030a8a:	85 c0                	test   %eax,%eax
40030a8c:	74 0e                	je     40030a9c <spi_qmsi_transceive+0x11e>
		device_busy_clear(dev);
40030a8e:	89 d8                	mov    %ebx,%eax
40030a90:	e8 0c 2c 00 00       	call   400336a1 <device_busy_clear>
		return -EINVAL;
40030a95:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
40030a9a:	eb 4b                	jmp    40030ae7 <spi_qmsi_transceive+0x169>
	spi_control_cs(dev, true);
40030a9c:	ba 01 00 00 00       	mov    $0x1,%edx
40030aa1:	89 d8                	mov    %ebx,%eax
40030aa3:	e8 65 fe ff ff       	call   4003090d <spi_control_cs>
	rc = qm_spi_irq_transfer(spi, xfer);
40030aa8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40030aab:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030aae:	e8 01 0e 00 00       	call   400318b4 <qm_spi_irq_transfer>
	if (rc != 0) {
40030ab3:	85 c0                	test   %eax,%eax
40030ab5:	74 12                	je     40030ac9 <spi_qmsi_transceive+0x14b>
		spi_control_cs(dev, false);
40030ab7:	89 d8                	mov    %ebx,%eax
40030ab9:	31 d2                	xor    %edx,%edx
40030abb:	e8 4d fe ff ff       	call   4003090d <spi_control_cs>
		device_busy_clear(dev);
40030ac0:	89 d8                	mov    %ebx,%eax
40030ac2:	e8 da 2b 00 00       	call   400336a1 <device_busy_clear>
40030ac7:	eb 19                	jmp    40030ae2 <spi_qmsi_transceive+0x164>
	k_sem_take(&context->device_sync_sem, K_FOREVER);
40030ac9:	83 ca ff             	or     $0xffffffff,%edx
40030acc:	8d 46 04             	lea    0x4(%esi),%eax
40030acf:	e8 fc 30 00 00       	call   40033bd0 <k_sem_take>
	device_busy_clear(dev);
40030ad4:	89 d8                	mov    %ebx,%eax
40030ad6:	e8 c6 2b 00 00       	call   400336a1 <device_busy_clear>
	return context->rc ? -EIO : 0;
40030adb:	8b 46 28             	mov    0x28(%esi),%eax
40030ade:	85 c0                	test   %eax,%eax
40030ae0:	74 05                	je     40030ae7 <spi_qmsi_transceive+0x169>
40030ae2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030ae7:	83 c4 14             	add    $0x14,%esp
40030aea:	5b                   	pop    %ebx
40030aeb:	5e                   	pop    %esi
40030aec:	5f                   	pop    %edi
40030aed:	5d                   	pop    %ebp
40030aee:	c3                   	ret    

40030aef <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
40030aef:	55                   	push   %ebp
40030af0:	89 e5                	mov    %esp,%ebp
40030af2:	57                   	push   %edi
40030af3:	56                   	push   %esi
40030af4:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
40030af5:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
40030af8:	89 d6                	mov    %edx,%esi
40030afa:	23 71 08             	and    0x8(%ecx),%esi
40030afd:	74 1c                	je     40030b1b <gpio_qmsi_callback+0x2c>
40030aff:	8b 19                	mov    (%ecx),%ebx
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
40030b01:	85 db                	test   %ebx,%ebx
40030b03:	74 16                	je     40030b1b <gpio_qmsi_callback+0x2c>
40030b05:	89 c7                	mov    %eax,%edi
		if (cb->pin_mask & pins) {
40030b07:	85 73 08             	test   %esi,0x8(%ebx)
40030b0a:	74 09                	je     40030b15 <gpio_qmsi_callback+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
40030b0c:	89 f1                	mov    %esi,%ecx
40030b0e:	89 da                	mov    %ebx,%edx
40030b10:	89 f8                	mov    %edi,%eax
40030b12:	ff 53 04             	call   *0x4(%ebx)
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
40030b15:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
40030b17:	85 db                	test   %ebx,%ebx
40030b19:	75 ec                	jne    40030b07 <gpio_qmsi_callback+0x18>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
40030b1b:	5b                   	pop    %ebx
40030b1c:	5e                   	pop    %esi
40030b1d:	5f                   	pop    %edi
40030b1e:	5d                   	pop    %ebp
40030b1f:	c3                   	ret    

40030b20 <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
40030b20:	55                   	push   %ebp
	if (value) {
40030b21:	84 c9                	test   %cl,%cl
{
40030b23:	89 e5                	mov    %esp,%ebp
40030b25:	0f b6 d2             	movzbl %dl,%edx
	if (value) {
40030b28:	74 05                	je     40030b2f <qmsi_write_bit+0xf>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
40030b2a:	0f ab 10             	bts    %edx,(%eax)
40030b2d:	eb 03                	jmp    40030b32 <qmsi_write_bit+0x12>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
40030b2f:	0f b3 10             	btr    %edx,(%eax)
		sys_set_bit((uintptr_t) target, bit);
	} else {
		sys_clear_bit((uintptr_t) target, bit);
	}
}
40030b32:	5d                   	pop    %ebp
40030b33:	c3                   	ret    

40030b34 <gpio_qmsi_manage_callback>:

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
40030b34:	8b 40 08             	mov    0x8(%eax),%eax
	if (set) {
40030b37:	84 c9                	test   %cl,%cl
40030b39:	74 11                	je     40030b4c <gpio_qmsi_manage_callback+0x18>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
40030b3b:	8b 08                	mov    (%eax),%ecx
40030b3d:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
40030b3f:	89 10                	mov    %edx,(%eax)

	if (!list->tail) {
40030b41:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
40030b45:	75 44                	jne    40030b8b <gpio_qmsi_manage_callback+0x57>
		list->tail = list->head;
40030b47:	89 50 04             	mov    %edx,0x4(%eax)
40030b4a:	eb 3f                	jmp    40030b8b <gpio_qmsi_manage_callback+0x57>
{
40030b4c:	55                   	push   %ebp
40030b4d:	89 e5                	mov    %esp,%ebp
40030b4f:	53                   	push   %ebx
40030b50:	8b 08                	mov    (%eax),%ecx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
40030b52:	31 db                	xor    %ebx,%ebx
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
40030b54:	85 c9                	test   %ecx,%ecx
40030b56:	74 2e                	je     40030b86 <gpio_qmsi_manage_callback+0x52>
		if (test == node) {
40030b58:	39 ca                	cmp    %ecx,%edx
40030b5a:	75 24                	jne    40030b80 <gpio_qmsi_manage_callback+0x4c>
	if (!prev_node) {
40030b5c:	85 db                	test   %ebx,%ebx
40030b5e:	8b 0a                	mov    (%edx),%ecx
40030b60:	75 0c                	jne    40030b6e <gpio_qmsi_manage_callback+0x3a>
		list->head = node->next;
40030b62:	89 08                	mov    %ecx,(%eax)
		if (list->tail == node) {
40030b64:	3b 50 04             	cmp    0x4(%eax),%edx
40030b67:	75 0f                	jne    40030b78 <gpio_qmsi_manage_callback+0x44>
			list->tail = list->head;
40030b69:	89 48 04             	mov    %ecx,0x4(%eax)
40030b6c:	eb 0a                	jmp    40030b78 <gpio_qmsi_manage_callback+0x44>
		prev_node->next = node->next;
40030b6e:	89 0b                	mov    %ecx,(%ebx)
		if (list->tail == node) {
40030b70:	3b 50 04             	cmp    0x4(%eax),%edx
40030b73:	75 03                	jne    40030b78 <gpio_qmsi_manage_callback+0x44>
			list->tail = prev_node;
40030b75:	89 58 04             	mov    %ebx,0x4(%eax)
	node->next = NULL;
40030b78:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
40030b7e:	eb 06                	jmp    40030b86 <gpio_qmsi_manage_callback+0x52>
	SYS_SLIST_FOR_EACH_NODE(list, test) {
40030b80:	89 cb                	mov    %ecx,%ebx
40030b82:	8b 09                	mov    (%ecx),%ecx
40030b84:	eb ce                	jmp    40030b54 <gpio_qmsi_manage_callback+0x20>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
40030b86:	31 c0                	xor    %eax,%eax
40030b88:	5b                   	pop    %ebx
40030b89:	5d                   	pop    %ebp
40030b8a:	c3                   	ret    
40030b8b:	31 c0                	xor    %eax,%eax
40030b8d:	c3                   	ret    

40030b8e <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
40030b8e:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40030b8f:	85 d2                	test   %edx,%edx
{
40030b91:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40030b93:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030b96:	75 0c                	jne    40030ba4 <gpio_qmsi_enable_callback+0x16>
		context->pin_callbacks |= BIT(pin);
40030b98:	ba 01 00 00 00       	mov    $0x1,%edx
40030b9d:	d3 e2                	shl    %cl,%edx
40030b9f:	09 50 08             	or     %edx,0x8(%eax)
40030ba2:	eb 07                	jmp    40030bab <gpio_qmsi_enable_callback+0x1d>
	} else {
		context->pin_callbacks = 0xffffffff;
40030ba4:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
40030bab:	31 c0                	xor    %eax,%eax
40030bad:	5d                   	pop    %ebp
40030bae:	c3                   	ret    

40030baf <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
40030baf:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40030bb0:	85 d2                	test   %edx,%edx
{
40030bb2:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40030bb4:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030bb7:	75 0c                	jne    40030bc5 <gpio_qmsi_disable_callback+0x16>
		context->pin_callbacks &= ~BIT(pin);
40030bb9:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
40030bbe:	d3 c2                	rol    %cl,%edx
40030bc0:	21 50 08             	and    %edx,0x8(%eax)
40030bc3:	eb 07                	jmp    40030bcc <gpio_qmsi_disable_callback+0x1d>
	} else {
		context->pin_callbacks = 0;
40030bc5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
40030bcc:	31 c0                	xor    %eax,%eax
40030bce:	5d                   	pop    %ebp
40030bcf:	c3                   	ret    

40030bd0 <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
40030bd0:	55                   	push   %ebp
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
40030bd1:	8b 00                	mov    (%eax),%eax
{
40030bd3:	89 e5                	mov    %esp,%ebp
	qm_gpio_t gpio = gpio_config->gpio;

	return QM_GPIO[gpio]->gpio_intstatus;
}
40030bd5:	5d                   	pop    %ebp
	qm_gpio_t gpio = gpio_config->gpio;
40030bd6:	8b 40 08             	mov    0x8(%eax),%eax
	return QM_GPIO[gpio]->gpio_intstatus;
40030bd9:	8b 00                	mov    (%eax),%eax
40030bdb:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40030be2:	8b 40 40             	mov    0x40(%eax),%eax
}
40030be5:	c3                   	ret    

40030be6 <gpio_qmsi_read>:
{
40030be6:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030be7:	85 d2                	test   %edx,%edx
{
40030be9:	89 e5                	mov    %esp,%ebp
40030beb:	53                   	push   %ebx
40030bec:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030bed:	8b 00                	mov    (%eax),%eax
{
40030bef:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40030bf2:	8b 40 08             	mov    0x8(%eax),%eax
40030bf5:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030bf7:	75 12                	jne    40030c0b <gpio_qmsi_read+0x25>
		qm_gpio_read_pin(gpio, pin, &state);
40030bf9:	0f b6 d1             	movzbl %cl,%edx
40030bfc:	8d 4d f8             	lea    -0x8(%ebp),%ecx
40030bff:	e8 90 07 00 00       	call   40031394 <qm_gpio_read_pin>
		*value = state;
40030c04:	8b 45 f8             	mov    -0x8(%ebp),%eax
40030c07:	89 03                	mov    %eax,(%ebx)
40030c09:	eb 07                	jmp    40030c12 <gpio_qmsi_read+0x2c>
		qm_gpio_read_port(gpio, (uint32_t *const) value);
40030c0b:	89 da                	mov    %ebx,%edx
40030c0d:	e8 e2 07 00 00       	call   400313f4 <qm_gpio_read_port>
}
40030c12:	5a                   	pop    %edx
40030c13:	31 c0                	xor    %eax,%eax
40030c15:	5b                   	pop    %ebx
40030c16:	5d                   	pop    %ebp
40030c17:	c3                   	ret    

40030c18 <gpio_qmsi_write>:
{
40030c18:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030c19:	85 d2                	test   %edx,%edx
{
40030c1b:	89 e5                	mov    %esp,%ebp
40030c1d:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030c1e:	8b 00                	mov    (%eax),%eax
{
40030c20:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40030c23:	8b 40 08             	mov    0x8(%eax),%eax
40030c26:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030c28:	75 15                	jne    40030c3f <gpio_qmsi_write+0x27>
		if (value) {
40030c2a:	85 db                	test   %ebx,%ebx
40030c2c:	0f b6 d1             	movzbl %cl,%edx
40030c2f:	74 07                	je     40030c38 <gpio_qmsi_write+0x20>
			qm_gpio_set_pin(gpio, pin);
40030c31:	e8 7c 07 00 00       	call   400313b2 <qm_gpio_set_pin>
40030c36:	eb 0e                	jmp    40030c46 <gpio_qmsi_write+0x2e>
			qm_gpio_clear_pin(gpio, pin);
40030c38:	e8 96 07 00 00       	call   400313d3 <qm_gpio_clear_pin>
40030c3d:	eb 07                	jmp    40030c46 <gpio_qmsi_write+0x2e>
		qm_gpio_write_port(gpio, value);
40030c3f:	89 da                	mov    %ebx,%edx
40030c41:	e8 c1 07 00 00       	call   40031407 <qm_gpio_write_port>
}
40030c46:	31 c0                	xor    %eax,%eax
40030c48:	5b                   	pop    %ebx
40030c49:	5d                   	pop    %ebp
40030c4a:	c3                   	ret    

40030c4b <qmsi_pin_config>:
{
40030c4b:	55                   	push   %ebp
40030c4c:	89 e5                	mov    %esp,%ebp
40030c4e:	57                   	push   %edi
40030c4f:	56                   	push   %esi
40030c50:	53                   	push   %ebx
40030c51:	83 ec 24             	sub    $0x24,%esp
40030c54:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030c56:	8b 00                	mov    (%eax),%eax
{
40030c58:	89 ce                	mov    %ecx,%esi
	qm_gpio_port_config_t cfg = { 0 };
40030c5a:	8d 7d d4             	lea    -0x2c(%ebp),%edi
40030c5d:	b9 08 00 00 00       	mov    $0x8,%ecx
	qm_gpio_t gpio = gpio_config->gpio;
40030c62:	8b 40 08             	mov    0x8(%eax),%eax
40030c65:	8b 00                	mov    (%eax),%eax
40030c67:	89 45 d0             	mov    %eax,-0x30(%ebp)
	qm_gpio_port_config_t cfg = { 0 };
40030c6a:	31 c0                	xor    %eax,%eax
40030c6c:	f3 ab                	rep stos %eax,%es:(%edi)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40030c6e:	8b 45 d0             	mov    -0x30(%ebp),%eax
40030c71:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40030c78:	8b 48 04             	mov    0x4(%eax),%ecx
	cfg.callback_data = port;
40030c7b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40030c7e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
40030c81:	8b 48 30             	mov    0x30(%eax),%ecx
40030c84:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
40030c87:	8b 48 38             	mov    0x38(%eax),%ecx
40030c8a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
40030c8d:	8b 48 3c             	mov    0x3c(%eax),%ecx
40030c90:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
40030c93:	8b 48 48             	mov    0x48(%eax),%ecx
40030c96:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40030c99:	8b 40 68             	mov    0x68(%eax),%eax
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030c9c:	0f b6 da             	movzbl %dl,%ebx
40030c9f:	89 f1                	mov    %esi,%ecx
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40030ca1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030ca4:	83 e1 01             	and    $0x1,%ecx
40030ca7:	89 da                	mov    %ebx,%edx
40030ca9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	cfg.callback = gpio_qmsi_callback;
40030cac:	c7 45 ec ef 0a 03 40 	movl   $0x40030aef,-0x14(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40030cb3:	e8 68 fe ff ff       	call   40030b20 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 0);
40030cb8:	31 c9                	xor    %ecx,%ecx
	if (flags & GPIO_INT) {
40030cba:	f7 c6 02 00 00 00    	test   $0x2,%esi
40030cc0:	74 41                	je     40030d03 <qmsi_pin_config+0xb8>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
40030cc2:	89 f1                	mov    %esi,%ecx
40030cc4:	89 da                	mov    %ebx,%edx
40030cc6:	83 e1 20             	and    $0x20,%ecx
40030cc9:	8d 45 dc             	lea    -0x24(%ebp),%eax
40030ccc:	e8 4f fe ff ff       	call   40030b20 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
40030cd1:	89 f1                	mov    %esi,%ecx
40030cd3:	83 e1 04             	and    $0x4,%ecx
40030cd6:	89 da                	mov    %ebx,%edx
40030cd8:	8d 45 e0             	lea    -0x20(%ebp),%eax
40030cdb:	e8 40 fe ff ff       	call   40030b20 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_debounce, pin,
40030ce0:	89 f1                	mov    %esi,%ecx
40030ce2:	83 e1 10             	and    $0x10,%ecx
40030ce5:	89 da                	mov    %ebx,%edx
40030ce7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		qmsi_write_bit(&cfg.int_bothedge, pin,
40030cea:	83 e6 40             	and    $0x40,%esi
		qmsi_write_bit(&cfg.int_debounce, pin,
40030ced:	e8 2e fe ff ff       	call   40030b20 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_bothedge, pin,
40030cf2:	89 f1                	mov    %esi,%ecx
40030cf4:	89 da                	mov    %ebx,%edx
40030cf6:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030cf9:	e8 22 fe ff ff       	call   40030b20 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 1);
40030cfe:	b9 01 00 00 00       	mov    $0x1,%ecx
		qmsi_write_bit(&cfg.int_en, pin, 0);
40030d03:	89 da                	mov    %ebx,%edx
40030d05:	8d 45 d8             	lea    -0x28(%ebp),%eax
40030d08:	e8 13 fe ff ff       	call   40030b20 <qmsi_write_bit>
	qm_gpio_set_config(gpio, &cfg);
40030d0d:	8d 55 d4             	lea    -0x2c(%ebp),%edx
40030d10:	8b 45 d0             	mov    -0x30(%ebp),%eax
40030d13:	e8 1d 06 00 00       	call   40031335 <qm_gpio_set_config>
}
40030d18:	83 c4 24             	add    $0x24,%esp
40030d1b:	5b                   	pop    %ebx
40030d1c:	5e                   	pop    %esi
40030d1d:	5f                   	pop    %edi
40030d1e:	5d                   	pop    %ebp
40030d1f:	c3                   	ret    

40030d20 <gpio_qmsi_config>:
{
40030d20:	55                   	push   %ebp
40030d21:	89 e5                	mov    %esp,%ebp
40030d23:	57                   	push   %edi
40030d24:	56                   	push   %esi
40030d25:	89 c6                	mov    %eax,%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030d27:	8b 45 08             	mov    0x8(%ebp),%eax
{
40030d2a:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030d2b:	83 e0 03             	and    $0x3,%eax
		return -EINVAL;
40030d2e:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40030d33:	83 f8 03             	cmp    $0x3,%eax
40030d36:	74 34                	je     40030d6c <gpio_qmsi_config+0x4c>
40030d38:	89 d3                	mov    %edx,%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
40030d3a:	85 d2                	test   %edx,%edx
40030d3c:	75 0e                	jne    40030d4c <gpio_qmsi_config+0x2c>
40030d3e:	89 ca                	mov    %ecx,%edx
		qmsi_pin_config(port, pin, flags);
40030d40:	89 f0                	mov    %esi,%eax
40030d42:	8b 4d 08             	mov    0x8(%ebp),%ecx
40030d45:	e8 01 ff ff ff       	call   40030c4b <qmsi_pin_config>
40030d4a:	eb 20                	jmp    40030d6c <gpio_qmsi_config+0x4c>
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030d4c:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < num_pins; i++) {
40030d4e:	31 db                	xor    %ebx,%ebx
	uint8_t num_pins = gpio_config->num_pins;
40030d50:	8b 40 08             	mov    0x8(%eax),%eax
	for (i = 0; i < num_pins; i++) {
40030d53:	0f b6 78 04          	movzbl 0x4(%eax),%edi
40030d57:	39 fb                	cmp    %edi,%ebx
40030d59:	7d 0f                	jge    40030d6a <gpio_qmsi_config+0x4a>
		qmsi_pin_config(port, i, flags);
40030d5b:	89 da                	mov    %ebx,%edx
40030d5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
40030d60:	89 f0                	mov    %esi,%eax
	for (i = 0; i < num_pins; i++) {
40030d62:	43                   	inc    %ebx
		qmsi_pin_config(port, i, flags);
40030d63:	e8 e3 fe ff ff       	call   40030c4b <qmsi_pin_config>
40030d68:	eb ed                	jmp    40030d57 <gpio_qmsi_config+0x37>
	return 0;
40030d6a:	31 db                	xor    %ebx,%ebx
}
40030d6c:	89 d8                	mov    %ebx,%eax
40030d6e:	5b                   	pop    %ebx
40030d6f:	5e                   	pop    %esi
40030d70:	5f                   	pop    %edi
40030d71:	5d                   	pop    %ebp
40030d72:	c3                   	ret    

40030d73 <gpio_qmsi_init>:
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
40030d73:	55                   	push   %ebp
40030d74:	89 e5                	mov    %esp,%ebp
40030d76:	53                   	push   %ebx
40030d77:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40030d79:	8b 00                	mov    (%eax),%eax
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
40030d7b:	8b 40 08             	mov    0x8(%eax),%eax
40030d7e:	8b 00                	mov    (%eax),%eax
40030d80:	85 c0                	test   %eax,%eax
40030d82:	74 32                	je     40030db6 <gpio_qmsi_init+0x43>
40030d84:	48                   	dec    %eax
40030d85:	75 71                	jne    40030df8 <gpio_qmsi_init+0x85>
40030d87:	0f b6 05 07 69 03 40 	movzbl 0x40036907,%eax
40030d8e:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030d93:	ba 1f 00 00 00       	mov    $0x1f,%edx
40030d98:	e8 f6 f8 ff ff       	call   40030693 <__irq_controller_irq_config>
#ifdef CONFIG_GPIO_QMSI_1
	case QM_AON_GPIO_0:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_1_IRQ_PRI, qm_aon_gpio_0_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT));
40030d9d:	b8 1f 00 00 00       	mov    $0x1f,%eax
40030da2:	e8 0e f9 ff ff       	call   400306b5 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030da7:	a1 d4 04 80 b0       	mov    0xb08004d4,%eax
40030dac:	83 e0 fe             	and    $0xfffffffe,%eax
40030daf:	a3 d4 04 80 b0       	mov    %eax,0xb08004d4
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
40030db4:	eb 37                	jmp    40030ded <gpio_qmsi_init+0x7a>
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
40030db6:	b8 82 21 00 00       	mov    $0x2182,%eax
40030dbb:	e8 10 05 00 00       	call   400312d0 <clk_periph_enable>
40030dc0:	0f b6 05 f0 68 03 40 	movzbl 0x400368f0,%eax
40030dc7:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030dcc:	ba 08 00 00 00       	mov    $0x8,%edx
40030dd1:	e8 bd f8 ff ff       	call   40030693 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
40030dd6:	b8 08 00 00 00       	mov    $0x8,%eax
40030ddb:	e8 d5 f8 ff ff       	call   400306b5 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
40030de0:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
40030de5:	83 e0 fe             	and    $0xfffffffe,%eax
40030de8:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
40030ded:	c7 43 04 98 52 03 40 	movl   $0x40035298,0x4(%ebx)
	return 0;
40030df4:	31 c0                	xor    %eax,%eax
40030df6:	eb 05                	jmp    40030dfd <gpio_qmsi_init+0x8a>
		return -EIO;
40030df8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030dfd:	5b                   	pop    %ebx
40030dfe:	5d                   	pop    %ebp
40030dff:	c3                   	ret    

40030e00 <pinmux_get>:
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
40030e00:	89 d0                	mov    %edx,%eax
{
40030e02:	55                   	push   %ebp
	uint32_t reg_offset = pin >> 4;
40030e03:	c1 e8 04             	shr    $0x4,%eax
{
40030e06:	89 e5                	mov    %esp,%ebp
40030e08:	53                   	push   %ebx
40030e09:	89 cb                	mov    %ecx,%ebx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
40030e0b:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
	uint32_t mode_mask = *mux_register & pin_mask;
40030e0e:	8b 14 85 30 09 80 b0 	mov    -0x4f7ff6d0(,%eax,4),%edx
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
40030e15:	83 e1 1e             	and    $0x1e,%ecx
40030e18:	b8 03 00 00 00       	mov    $0x3,%eax
40030e1d:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
40030e1f:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
40030e21:	d3 e8                	shr    %cl,%eax
40030e23:	89 03                	mov    %eax,(%ebx)

	*func = mode;

	return 0;
}
40030e25:	31 c0                	xor    %eax,%eax
40030e27:	5b                   	pop    %ebx
40030e28:	5d                   	pop    %ebp
40030e29:	c3                   	ret    

40030e2a <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(struct device *port)
{
40030e2a:	55                   	push   %ebp
	return 0;
}
40030e2b:	31 c0                	xor    %eax,%eax
{
40030e2d:	89 e5                	mov    %esp,%ebp
}
40030e2f:	5d                   	pop    %ebp
40030e30:	c3                   	ret    

40030e31 <pinmux_input>:
{
40030e31:	55                   	push   %ebp
40030e32:	89 d0                	mov    %edx,%eax
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
40030e34:	31 d2                	xor    %edx,%edx
{
40030e36:	89 e5                	mov    %esp,%ebp
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
40030e38:	84 c9                	test   %cl,%cl
40030e3a:	0f 95 c2             	setne  %dl
40030e3d:	e8 be 0b 00 00       	call   40031a00 <qm_pmux_input_en>
40030e42:	85 c0                	test   %eax,%eax
40030e44:	74 05                	je     40030e4b <pinmux_input+0x1a>
40030e46:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030e4b:	5d                   	pop    %ebp
40030e4c:	c3                   	ret    

40030e4d <pinmux_pullup>:
{
40030e4d:	55                   	push   %ebp
40030e4e:	89 d0                	mov    %edx,%eax
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
40030e50:	31 d2                	xor    %edx,%edx
{
40030e52:	89 e5                	mov    %esp,%ebp
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
40030e54:	84 c9                	test   %cl,%cl
40030e56:	0f 95 c2             	setne  %dl
40030e59:	e8 d2 0b 00 00       	call   40031a30 <qm_pmux_pullup_en>
40030e5e:	85 c0                	test   %eax,%eax
40030e60:	74 05                	je     40030e67 <pinmux_pullup+0x1a>
40030e62:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030e67:	5d                   	pop    %ebp
40030e68:	c3                   	ret    

40030e69 <pinmux_set>:
{
40030e69:	55                   	push   %ebp
40030e6a:	89 d0                	mov    %edx,%eax
40030e6c:	89 e5                	mov    %esp,%ebp
40030e6e:	89 ca                	mov    %ecx,%edx
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
40030e70:	e8 54 0b 00 00       	call   400319c9 <qm_pmux_select>
40030e75:	85 c0                	test   %eax,%eax
40030e77:	74 05                	je     40030e7e <pinmux_set+0x15>
40030e79:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030e7e:	5d                   	pop    %ebp
40030e7f:	c3                   	ret    

40030e80 <_stdin_hook_default>:
{
	_stdout_hook = hook;
}

static unsigned char _stdin_hook_default(void)
{
40030e80:	55                   	push   %ebp
	return 0;
}
40030e81:	31 c0                	xor    %eax,%eax
{
40030e83:	89 e5                	mov    %esp,%ebp
}
40030e85:	5d                   	pop    %ebp
40030e86:	c3                   	ret    

40030e87 <_stdout_hook_default>:
40030e87:	55                   	push   %ebp
40030e88:	83 c8 ff             	or     $0xffffffff,%eax
40030e8b:	89 e5                	mov    %esp,%ebp
40030e8d:	5d                   	pop    %ebp
40030e8e:	c3                   	ret    

40030e8f <__stdout_hook_install>:
{
40030e8f:	55                   	push   %ebp
	_stdout_hook = hook;
40030e90:	a3 c4 66 00 a8       	mov    %eax,0xa80066c4
{
40030e95:	89 e5                	mov    %esp,%ebp
}
40030e97:	5d                   	pop    %ebp
40030e98:	c3                   	ret    

40030e99 <_read>:
{
	_stdin_hook = hook;
}

int _read(int fd, char *buf, int nbytes)
{
40030e99:	55                   	push   %ebp
40030e9a:	89 e5                	mov    %esp,%ebp
40030e9c:	57                   	push   %edi
40030e9d:	89 d7                	mov    %edx,%edi
40030e9f:	56                   	push   %esi
40030ea0:	89 ce                	mov    %ecx,%esi
40030ea2:	53                   	push   %ebx
	int i = 0;

	for (i = 0; i < nbytes; i++) {
40030ea3:	31 db                	xor    %ebx,%ebx
40030ea5:	39 f3                	cmp    %esi,%ebx
40030ea7:	7d 14                	jge    40030ebd <_read+0x24>
		*(buf + i) = _stdin_hook();
40030ea9:	ff 15 c0 66 00 a8    	call   *0xa80066c0
40030eaf:	88 04 1f             	mov    %al,(%edi,%ebx,1)
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
40030eb2:	3c 0a                	cmp    $0xa,%al
40030eb4:	8d 5b 01             	lea    0x1(%ebx),%ebx
40030eb7:	74 04                	je     40030ebd <_read+0x24>
40030eb9:	3c 0d                	cmp    $0xd,%al
40030ebb:	75 e8                	jne    40030ea5 <_read+0xc>
			i++;
			break;
		}
	}
	return i;
}
40030ebd:	89 d8                	mov    %ebx,%eax
40030ebf:	5b                   	pop    %ebx
40030ec0:	5e                   	pop    %esi
40030ec1:	5f                   	pop    %edi
40030ec2:	5d                   	pop    %ebp
40030ec3:	c3                   	ret    

40030ec4 <_write>:
FUNC_ALIAS(_read, read, int);

int _write(int fd, char *buf, int nbytes)
{
40030ec4:	55                   	push   %ebp
40030ec5:	89 e5                	mov    %esp,%ebp
40030ec7:	57                   	push   %edi
40030ec8:	89 d7                	mov    %edx,%edi
40030eca:	56                   	push   %esi
40030ecb:	89 ce                	mov    %ecx,%esi
40030ecd:	53                   	push   %ebx
	int i;

	for (i = 0; i < nbytes; i++) {
40030ece:	31 db                	xor    %ebx,%ebx
40030ed0:	39 f3                	cmp    %esi,%ebx
40030ed2:	7d 1e                	jge    40030ef2 <_write+0x2e>
		if (*(buf + i) == '\n') {
40030ed4:	80 3c 1f 0a          	cmpb   $0xa,(%edi,%ebx,1)
40030ed8:	75 0b                	jne    40030ee5 <_write+0x21>
			_stdout_hook('\r');
40030eda:	b8 0d 00 00 00       	mov    $0xd,%eax
40030edf:	ff 15 c4 66 00 a8    	call   *0xa80066c4
		}
		_stdout_hook(*(buf + i));
40030ee5:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
	for (i = 0; i < nbytes; i++) {
40030ee9:	43                   	inc    %ebx
		_stdout_hook(*(buf + i));
40030eea:	ff 15 c4 66 00 a8    	call   *0xa80066c4
40030ef0:	eb de                	jmp    40030ed0 <_write+0xc>
	}
	return nbytes;
}
40030ef2:	5b                   	pop    %ebx
40030ef3:	89 f0                	mov    %esi,%eax
40030ef5:	5e                   	pop    %esi
40030ef6:	5f                   	pop    %edi
40030ef7:	5d                   	pop    %ebp
40030ef8:	c3                   	ret    

40030ef9 <_isatty>:
FUNC_ALIAS(_write, write, int);

int _isatty(int file)
{
40030ef9:	55                   	push   %ebp
	return 1;
}
40030efa:	b8 01 00 00 00       	mov    $0x1,%eax
{
40030eff:	89 e5                	mov    %esp,%ebp
}
40030f01:	5d                   	pop    %ebp
40030f02:	c3                   	ret    

40030f03 <_fstat>:
	return 0;
}
FUNC_ALIAS(_getpid, getpid, int);

int _fstat(int file, struct stat *st)
{
40030f03:	55                   	push   %ebp
	st->st_mode = S_IFCHR;
	return 0;
}
40030f04:	31 c0                	xor    %eax,%eax
{
40030f06:	89 e5                	mov    %esp,%ebp
	st->st_mode = S_IFCHR;
40030f08:	c7 42 04 00 20 00 00 	movl   $0x2000,0x4(%edx)
}
40030f0f:	5d                   	pop    %ebp
40030f10:	c3                   	ret    

40030f11 <_close>:
	return -1;
}
FUNC_ALIAS(_open, open, int);

int _close(int file)
{
40030f11:	55                   	push   %ebp
	return -1;
}
40030f12:	83 c8 ff             	or     $0xffffffff,%eax
{
40030f15:	89 e5                	mov    %esp,%ebp
}
40030f17:	5d                   	pop    %ebp
40030f18:	c3                   	ret    

40030f19 <_lseek>:
FUNC_ALIAS(_close, close, int);

int _lseek(int file, int ptr, int dir)
{
40030f19:	55                   	push   %ebp
	return 0;
}
40030f1a:	31 c0                	xor    %eax,%eax
{
40030f1c:	89 e5                	mov    %esp,%ebp
}
40030f1e:	5d                   	pop    %ebp
40030f1f:	c3                   	ret    

40030f20 <_sbrk>:
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
	void *ptr = heap_base + heap_sz;
40030f20:	8b 15 ec 68 00 a8    	mov    0xa80068ec,%edx
{
40030f26:	55                   	push   %ebp
40030f27:	89 e5                	mov    %esp,%ebp

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
40030f29:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40030f2c:	b8 00 40 01 a8       	mov    $0xa8014000,%eax
40030f31:	2d bc 85 00 a8       	sub    $0xa80085bc,%eax
40030f36:	39 c1                	cmp    %eax,%ecx
40030f38:	73 0e                	jae    40030f48 <_sbrk+0x28>
	void *ptr = heap_base + heap_sz;
40030f3a:	8d 82 bc 85 00 a8    	lea    -0x57ff7a44(%edx),%eax
		heap_sz += count;
40030f40:	89 0d ec 68 00 a8    	mov    %ecx,0xa80068ec
		return ptr;
40030f46:	eb 03                	jmp    40030f4b <_sbrk+0x2b>
	} else {
		return (void *)-1;
40030f48:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
40030f4b:	5d                   	pop    %ebp
40030f4c:	c3                   	ret    

40030f4d <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
40030f4d:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40030f4e:	31 c0                	xor    %eax,%eax
{
40030f50:	89 e5                	mov    %esp,%ebp
}
40030f52:	5d                   	pop    %ebp
40030f53:	c3                   	ret    

40030f54 <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
40030f54:	ff 02                	incl   (%edx)
{
40030f56:	55                   	push   %ebp
40030f57:	89 e5                	mov    %esp,%ebp
	return _char_out(c);
}
40030f59:	5d                   	pop    %ebp
	return _char_out(c);
40030f5a:	ff 25 c8 66 00 a8    	jmp    *0xa80066c8

40030f60 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
40030f60:	55                   	push   %ebp
40030f61:	89 e5                	mov    %esp,%ebp
40030f63:	57                   	push   %edi
40030f64:	56                   	push   %esi
40030f65:	53                   	push   %ebx
40030f66:	83 ec 14             	sub    $0x14,%esp
40030f69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030f6c:	8b 75 0c             	mov    0xc(%ebp),%esi
40030f6f:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030f72:	8b 45 08             	mov    0x8(%ebp),%eax
40030f75:	89 75 ec             	mov    %esi,-0x14(%ebp)
40030f78:	85 f6                	test   %esi,%esi
40030f7a:	7f 07                	jg     40030f83 <_printk_dec_ulong+0x23>
40030f7c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40030f83:	83 f8 01             	cmp    $0x1,%eax
40030f86:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030f89:	19 f6                	sbb    %esi,%esi
40030f8b:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
40030f92:	83 e6 f0             	and    $0xfffffff0,%esi
40030f95:	31 ff                	xor    %edi,%edi
40030f97:	83 c6 30             	add    $0x30,%esi
40030f9a:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
40030f9f:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
40030fa2:	72 04                	jb     40030fa8 <_printk_dec_ulong+0x48>
40030fa4:	85 ff                	test   %edi,%edi
40030fa6:	74 1c                	je     40030fc4 <_printk_dec_ulong+0x64>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
40030fa8:	8d 4b 01             	lea    0x1(%ebx),%ecx
40030fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030fae:	31 d2                	xor    %edx,%edx
40030fb0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40030fb3:	f7 f1                	div    %ecx
40030fb5:	83 c0 30             	add    $0x30,%eax
40030fb8:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030fbb:	ff d7                	call   *%edi
			found_largest_digit = 1;
40030fbd:	bf 01 00 00 00       	mov    $0x1,%edi
40030fc2:	eb 14                	jmp    40030fd8 <_printk_dec_ulong+0x78>
		} else if (remaining <= min_width) {
40030fc4:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030fc7:	31 ff                	xor    %edi,%edi
40030fc9:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40030fcc:	7c 0a                	jl     40030fd8 <_printk_dec_ulong+0x78>
			out((int)(pad_zero ? '0' : ' '), ctx);
40030fce:	8b 55 e0             	mov    -0x20(%ebp),%edx
40030fd1:	89 f0                	mov    %esi,%eax
40030fd3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030fd6:	ff d1                	call   *%ecx
		}
		remaining--;
		remainder %= (pos + 1);
40030fd8:	8d 4b 01             	lea    0x1(%ebx),%ecx
40030fdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030fde:	31 d2                	xor    %edx,%edx
		remaining--;
40030fe0:	ff 4d e8             	decl   -0x18(%ebp)
		remainder %= (pos + 1);
40030fe3:	f7 f1                	div    %ecx
40030fe5:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
40030fe8:	89 d8                	mov    %ebx,%eax
40030fea:	31 d2                	xor    %edx,%edx
40030fec:	b9 0a 00 00 00       	mov    $0xa,%ecx
40030ff1:	f7 f1                	div    %ecx
40030ff3:	89 c3                	mov    %eax,%ebx
	while (pos >= 9) {
40030ff5:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40030ff9:	75 a4                	jne    40030f9f <_printk_dec_ulong+0x3f>
	}
	out((int)(remainder + 48), ctx);
40030ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030ffe:	8b 55 e0             	mov    -0x20(%ebp),%edx
40031001:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}
40031004:	83 c4 14             	add    $0x14,%esp
	out((int)(remainder + 48), ctx);
40031007:	83 c0 30             	add    $0x30,%eax
}
4003100a:	5b                   	pop    %ebx
4003100b:	5e                   	pop    %esi
4003100c:	5f                   	pop    %edi
4003100d:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
4003100e:	ff e1                	jmp    *%ecx

40031010 <__printk_hook_install>:
{
40031010:	55                   	push   %ebp
	_char_out = fn;
40031011:	a3 c8 66 00 a8       	mov    %eax,0xa80066c8
{
40031016:	89 e5                	mov    %esp,%ebp
}
40031018:	5d                   	pop    %ebp
40031019:	c3                   	ret    

4003101a <_vprintk>:
{
4003101a:	55                   	push   %ebp
4003101b:	89 e5                	mov    %esp,%ebp
4003101d:	57                   	push   %edi
4003101e:	56                   	push   %esi
4003101f:	53                   	push   %ebx
40031020:	83 ec 20             	sub    $0x20,%esp
40031023:	89 c7                	mov    %eax,%edi
40031025:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031028:	89 4d e0             	mov    %ecx,-0x20(%ebp)
4003102b:	8b 75 08             	mov    0x8(%ebp),%esi
	int min_width = -1;
4003102e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	int pad_zero = 0;
40031035:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
4003103c:	31 db                	xor    %ebx,%ebx
	while (*fmt) {
4003103e:	8b 45 e0             	mov    -0x20(%ebp),%eax
40031041:	0f be 00             	movsbl (%eax),%eax
40031044:	84 c0                	test   %al,%al
40031046:	0f 84 0d 02 00 00    	je     40031259 <_vprintk+0x23f>
		if (!might_format) {
4003104c:	85 db                	test   %ebx,%ebx
4003104e:	75 12                	jne    40031062 <_vprintk+0x48>
			if (*fmt != '%') {
40031050:	3c 25                	cmp    $0x25,%al
40031052:	0f 84 e1 01 00 00    	je     40031239 <_vprintk+0x21f>
				out((int)*fmt, ctx);
40031058:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003105b:	ff d7                	call   *%edi
4003105d:	e9 ef 01 00 00       	jmp    40031251 <_vprintk+0x237>
			switch (*fmt) {
40031062:	3c 68                	cmp    $0x68,%al
40031064:	0f 84 e7 01 00 00    	je     40031251 <_vprintk+0x237>
4003106a:	7f 3a                	jg     400310a6 <_vprintk+0x8c>
4003106c:	3c 39                	cmp    $0x39,%al
4003106e:	7f 19                	jg     40031089 <_vprintk+0x6f>
40031070:	3c 31                	cmp    $0x31,%al
40031072:	0f 8d 89 00 00 00    	jge    40031101 <_vprintk+0xe7>
40031078:	3c 25                	cmp    $0x25,%al
4003107a:	0f 84 96 01 00 00    	je     40031216 <_vprintk+0x1fc>
40031080:	3c 30                	cmp    $0x30,%al
40031082:	74 6b                	je     400310ef <_vprintk+0xd5>
40031084:	e9 97 01 00 00       	jmp    40031220 <_vprintk+0x206>
40031089:	3c 63                	cmp    $0x63,%al
4003108b:	0f 84 76 01 00 00    	je     40031207 <_vprintk+0x1ed>
40031091:	3c 64                	cmp    $0x64,%al
40031093:	0f 84 83 00 00 00    	je     4003111c <_vprintk+0x102>
40031099:	3c 58                	cmp    $0x58,%al
4003109b:	0f 85 7f 01 00 00    	jne    40031220 <_vprintk+0x206>
400310a1:	e9 c7 00 00 00       	jmp    4003116d <_vprintk+0x153>
400310a6:	3c 73                	cmp    $0x73,%al
400310a8:	0f 84 41 01 00 00    	je     400311ef <_vprintk+0x1d5>
400310ae:	7f 1a                	jg     400310ca <_vprintk+0xb0>
400310b0:	3c 6c                	cmp    $0x6c,%al
400310b2:	0f 84 99 01 00 00    	je     40031251 <_vprintk+0x237>
400310b8:	3c 70                	cmp    $0x70,%al
400310ba:	0f 84 8f 00 00 00    	je     4003114f <_vprintk+0x135>
400310c0:	3c 69                	cmp    $0x69,%al
400310c2:	0f 85 58 01 00 00    	jne    40031220 <_vprintk+0x206>
400310c8:	eb 52                	jmp    4003111c <_vprintk+0x102>
400310ca:	3c 78                	cmp    $0x78,%al
400310cc:	0f 84 9b 00 00 00    	je     4003116d <_vprintk+0x153>
400310d2:	3c 7a                	cmp    $0x7a,%al
400310d4:	0f 84 77 01 00 00    	je     40031251 <_vprintk+0x237>
400310da:	3c 75                	cmp    $0x75,%al
400310dc:	0f 85 3e 01 00 00    	jne    40031220 <_vprintk+0x206>
				_printk_dec_ulong(out, ctx, u, pad_zero,
400310e2:	ff 75 ec             	pushl  -0x14(%ebp)
				unsigned long u = va_arg(
400310e5:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
400310e8:	8b 0e                	mov    (%esi),%ecx
400310ea:	ff 75 e8             	pushl  -0x18(%ebp)
400310ed:	eb 4d                	jmp    4003113c <_vprintk+0x122>
				if (min_width < 0 && pad_zero == 0) {
400310ef:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400310f2:	c1 e9 1f             	shr    $0x1f,%ecx
400310f5:	74 0a                	je     40031101 <_vprintk+0xe7>
400310f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
400310fb:	0f 84 4d 01 00 00    	je     4003124e <_vprintk+0x234>
				if (min_width < 0) {
40031101:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
40031105:	79 05                	jns    4003110c <_vprintk+0xf2>
					min_width = *fmt - '0';
40031107:	83 e8 30             	sub    $0x30,%eax
4003110a:	eb 08                	jmp    40031114 <_vprintk+0xfa>
					min_width = 10 * min_width + *fmt - '0';
4003110c:	6b 55 ec 0a          	imul   $0xa,-0x14(%ebp),%edx
40031110:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
40031114:	89 45 ec             	mov    %eax,-0x14(%ebp)
40031117:	e9 35 01 00 00       	jmp    40031251 <_vprintk+0x237>
				long d = va_arg(ap, long);
4003111c:	8d 5e 04             	lea    0x4(%esi),%ebx
4003111f:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
40031121:	85 f6                	test   %esi,%esi
40031123:	79 0f                	jns    40031134 <_vprintk+0x11a>
					out((int)'-', ctx);
40031125:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031128:	b8 2d 00 00 00       	mov    $0x2d,%eax
4003112d:	ff d7                	call   *%edi
					min_width--;
4003112f:	ff 4d ec             	decl   -0x14(%ebp)
					d = -d;
40031132:	f7 de                	neg    %esi
				_printk_dec_ulong(out, ctx, d, pad_zero,
40031134:	ff 75 ec             	pushl  -0x14(%ebp)
40031137:	ff 75 e8             	pushl  -0x18(%ebp)
4003113a:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
4003113c:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003113f:	89 f8                	mov    %edi,%eax
40031141:	e8 1a fe ff ff       	call   40030f60 <_printk_dec_ulong>
40031146:	58                   	pop    %eax
40031147:	5a                   	pop    %edx
				unsigned long u = va_arg(
40031148:	89 de                	mov    %ebx,%esi
4003114a:	e9 e6 00 00 00       	jmp    40031235 <_vprintk+0x21b>
				  out('0', ctx);
4003114f:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031152:	b8 30 00 00 00       	mov    $0x30,%eax
40031157:	ff d7                	call   *%edi
				  out('x', ctx);
40031159:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003115c:	b8 78 00 00 00       	mov    $0x78,%eax
40031161:	ff d7                	call   *%edi
				  pad_zero = 1;
40031163:	89 5d e8             	mov    %ebx,-0x18(%ebp)
				  min_width = 8;
40031166:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
4003116d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
				unsigned long x = va_arg(
40031171:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
40031174:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
				unsigned long x = va_arg(
4003117b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
4003117e:	8b 06                	mov    (%esi),%eax
40031180:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int size = sizeof(num) * 2;
40031183:	be 08 00 00 00       	mov    $0x8,%esi
40031188:	19 c0                	sbb    %eax,%eax
	int found_largest_digit = 0;
4003118a:	31 d2                	xor    %edx,%edx
4003118c:	89 45 dc             	mov    %eax,-0x24(%ebp)
4003118f:	83 65 dc f0          	andl   $0xfffffff0,-0x24(%ebp)
40031193:	83 45 dc 30          	addl   $0x30,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
40031197:	4e                   	dec    %esi
40031198:	8b 45 d8             	mov    -0x28(%ebp),%eax
4003119b:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
400311a2:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
400311a4:	24 0f                	and    $0xf,%al
400311a6:	75 0c                	jne    400311b4 <_vprintk+0x19a>
400311a8:	85 d2                	test   %edx,%edx
400311aa:	75 08                	jne    400311b4 <_vprintk+0x19a>
400311ac:	85 f6                	test   %esi,%esi
400311ae:	75 1e                	jne    400311ce <_vprintk+0x1b4>
			nibble += nibble > 9 ? 87 : 48;
400311b0:	b2 30                	mov    $0x30,%dl
400311b2:	eb 0c                	jmp    400311c0 <_vprintk+0x1a6>
400311b4:	3c 09                	cmp    $0x9,%al
400311b6:	0f 9f c2             	setg   %dl
400311b9:	4a                   	dec    %edx
400311ba:	83 e2 d9             	and    $0xffffffd9,%edx
400311bd:	83 c2 57             	add    $0x57,%edx
400311c0:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
400311c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
400311c5:	0f b6 c0             	movzbl %al,%eax
400311c8:	ff d7                	call   *%edi
			found_largest_digit = 1;
400311ca:	89 da                	mov    %ebx,%edx
400311cc:	eb 18                	jmp    400311e6 <_vprintk+0x1cc>
		if (remaining-- <= min_width) {
400311ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400311d1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
400311d4:	8d 48 ff             	lea    -0x1(%eax),%ecx
400311d7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
400311da:	7c 08                	jl     400311e4 <_vprintk+0x1ca>
			out((int)(pad_zero ? '0' : ' '), ctx);
400311dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
400311df:	8b 45 dc             	mov    -0x24(%ebp),%eax
400311e2:	ff d7                	call   *%edi
		if (remaining-- <= min_width) {
400311e4:	31 d2                	xor    %edx,%edx
	for (; size; size--) {
400311e6:	85 f6                	test   %esi,%esi
400311e8:	75 ad                	jne    40031197 <_vprintk+0x17d>
				unsigned long x = va_arg(
400311ea:	8b 75 d4             	mov    -0x2c(%ebp),%esi
400311ed:	eb 46                	jmp    40031235 <_vprintk+0x21b>
				char *s = va_arg(ap, char *);
400311ef:	8d 5e 04             	lea    0x4(%esi),%ebx
400311f2:	8b 36                	mov    (%esi),%esi
				while (*s)
400311f4:	0f be 06             	movsbl (%esi),%eax
400311f7:	84 c0                	test   %al,%al
400311f9:	0f 84 49 ff ff ff    	je     40031148 <_vprintk+0x12e>
					out((int)(*s++), ctx);
400311ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031202:	46                   	inc    %esi
40031203:	ff d7                	call   *%edi
40031205:	eb ed                	jmp    400311f4 <_vprintk+0x1da>
				out(c, ctx);
40031207:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003120a:	8b 06                	mov    (%esi),%eax
				int c = va_arg(ap, int);
4003120c:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
4003120f:	ff d7                	call   *%edi
40031211:	e9 32 ff ff ff       	jmp    40031148 <_vprintk+0x12e>
				out((int)'%', ctx);
40031216:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031219:	b8 25 00 00 00       	mov    $0x25,%eax
4003121e:	eb 13                	jmp    40031233 <_vprintk+0x219>
				out((int)'%', ctx);
40031220:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031223:	b8 25 00 00 00       	mov    $0x25,%eax
40031228:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
4003122a:	8b 45 e0             	mov    -0x20(%ebp),%eax
4003122d:	0f be 00             	movsbl (%eax),%eax
40031230:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031233:	ff d7                	call   *%edi
			might_format = 0;
40031235:	31 db                	xor    %ebx,%ebx
				break;
40031237:	eb 18                	jmp    40031251 <_vprintk+0x237>
				pad_zero = 0;
40031239:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
40031240:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				might_format = 1;
40031247:	bb 01 00 00 00       	mov    $0x1,%ebx
4003124c:	eb 03                	jmp    40031251 <_vprintk+0x237>
					pad_zero = 1;
4003124e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		++fmt;
40031251:	ff 45 e0             	incl   -0x20(%ebp)
40031254:	e9 e5 fd ff ff       	jmp    4003103e <_vprintk+0x24>
}
40031259:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003125c:	5b                   	pop    %ebx
4003125d:	5e                   	pop    %esi
4003125e:	5f                   	pop    %edi
4003125f:	5d                   	pop    %ebp
40031260:	c3                   	ret    

40031261 <printk>:
{
40031261:	55                   	push   %ebp
40031262:	89 e5                	mov    %esp,%ebp
40031264:	50                   	push   %eax
	va_start(ap, fmt);
40031265:	8d 45 0c             	lea    0xc(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031268:	8d 55 fc             	lea    -0x4(%ebp),%edx
4003126b:	50                   	push   %eax
4003126c:	8b 4d 08             	mov    0x8(%ebp),%ecx
4003126f:	b8 54 0f 03 40       	mov    $0x40030f54,%eax
	struct out_context ctx = { 0 };
40031274:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
4003127b:	e8 9a fd ff ff       	call   4003101a <_vprintk>
}
40031280:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031283:	5a                   	pop    %edx
}
40031284:	c9                   	leave  
40031285:	c3                   	ret    

40031286 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40031286:	55                   	push   %ebp
40031287:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
40031289:	5d                   	pop    %ebp
4003128a:	c3                   	ret    

4003128b <pinmux_initialize>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static int pinmux_initialize(struct device *port)
{
4003128b:	55                   	push   %ebp
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
4003128c:	b8 30 09 80 b0       	mov    $0xb0800930,%eax
{
40031291:	89 e5                	mov    %esp,%ebp
40031293:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  9, PINMUX_FUNC_C);
40031296:	c7 45 ec 55 00 0a 00 	movl   $0xa0055,-0x14(%ebp)
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
4003129d:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
	PIN_CONFIG(mux_config, 41, PINMUX_FUNC_B);
400312a4:	c7 45 f4 04 00 05 00 	movl   $0x50004,-0xc(%ebp)
	PIN_CONFIG(mux_config, 63, PINMUX_FUNC_B);
400312ab:	c7 45 f8 00 40 15 40 	movl   $0x40154000,-0x8(%ebp)
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
400312b2:	c7 45 fc 15 00 00 00 	movl   $0x15,-0x4(%ebp)
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
400312b9:	8b 94 05 bc f6 7f 4f 	mov    0x4f7ff6bc(%ebp,%eax,1),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
400312c0:	89 10                	mov    %edx,(%eax)
400312c2:	83 c0 04             	add    $0x4,%eax
	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
400312c5:	3d 44 09 80 b0       	cmp    $0xb0800944,%eax
400312ca:	75 ed                	jne    400312b9 <pinmux_initialize+0x2e>
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);

	return 0;
}
400312cc:	31 c0                	xor    %eax,%eax
400312ce:	c9                   	leave  
400312cf:	c3                   	ret    

400312d0 <clk_periph_enable>:

	return 0;
}

int clk_periph_enable(const clk_periph_t clocks)
{
400312d0:	55                   	push   %ebp
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
400312d1:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
{
400312d7:	89 e5                	mov    %esp,%ebp
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
400312d9:	09 d0                	or     %edx,%eax
400312db:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
400312e0:	31 c0                	xor    %eax,%eax
400312e2:	5d                   	pop    %ebp
400312e3:	c3                   	ret    

400312e4 <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
400312e4:	55                   	push   %ebp
400312e5:	89 e5                	mov    %esp,%ebp
400312e7:	56                   	push   %esi
400312e8:	53                   	push   %ebx
400312e9:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
400312eb:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
		qm_power_soc_restore();
	}
#endif

	if (callback[gpio]) {
400312f2:	8b 0c 9d f8 68 00 a8 	mov    -0x57ff9708(,%ebx,4),%ecx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
400312f9:	8b 70 40             	mov    0x40(%eax),%esi
	if (callback[gpio]) {
400312fc:	85 c9                	test   %ecx,%ecx
400312fe:	74 0b                	je     4003130b <gpio_isr+0x27>
		(*callback[gpio])(callback_data[gpio], int_status);
40031300:	8b 04 9d f0 68 00 a8 	mov    -0x57ff9710(,%ebx,4),%eax
40031307:	89 f2                	mov    %esi,%edx
40031309:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
4003130b:	8b 04 9d cc 66 00 a8 	mov    -0x57ff9934(,%ebx,4),%eax
40031312:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
}
40031315:	5b                   	pop    %ebx
	QM_GPIO[gpio]->gpio_porta_eoi;
40031316:	8b 40 4c             	mov    0x4c(%eax),%eax
}
40031319:	5e                   	pop    %esi
4003131a:	5d                   	pop    %ebp
4003131b:	c3                   	ret    

4003131c <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
4003131c:	55                   	push   %ebp
	gpio_isr(QM_GPIO_0);
4003131d:	31 c0                	xor    %eax,%eax
{
4003131f:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_GPIO_0_INT_VECTOR);
}
40031321:	5d                   	pop    %ebp
	gpio_isr(QM_GPIO_0);
40031322:	e9 bd ff ff ff       	jmp    400312e4 <gpio_isr>

40031327 <qm_aon_gpio_0_isr>:

#if (HAS_AON_GPIO)
QM_ISR_DECLARE(qm_aon_gpio_0_isr)
{
40031327:	55                   	push   %ebp
	gpio_isr(QM_AON_GPIO_0);
40031328:	b8 01 00 00 00       	mov    $0x1,%eax
{
4003132d:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_AON_GPIO_0_INT_VECTOR);
}
4003132f:	5d                   	pop    %ebp
	gpio_isr(QM_AON_GPIO_0);
40031330:	e9 af ff ff ff       	jmp    400312e4 <gpio_isr>

40031335 <qm_gpio_set_config>:
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
40031335:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
40031336:	8b 0c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ecx
{
4003133d:	89 e5                	mov    %esp,%ebp
4003133f:	56                   	push   %esi
40031340:	53                   	push   %ebx

	uint32_t mask = controller->gpio_intmask;
	controller->gpio_intmask = 0xffffffff;

	controller->gpio_swporta_ddr = cfg->direction;
40031341:	8b 1a                	mov    (%edx),%ebx
	uint32_t mask = controller->gpio_intmask;
40031343:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
40031346:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)
	controller->gpio_swporta_ddr = cfg->direction;
4003134d:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
40031350:	8b 5a 04             	mov    0x4(%edx),%ebx
40031353:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
40031356:	8b 5a 08             	mov    0x8(%edx),%ebx
40031359:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
4003135c:	8b 5a 0c             	mov    0xc(%edx),%ebx
4003135f:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
40031362:	8b 5a 10             	mov    0x10(%edx),%ebx
40031365:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
40031368:	8b 5a 14             	mov    0x14(%edx),%ebx
4003136b:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
4003136e:	8b 59 60             	mov    0x60(%ecx),%ebx
40031371:	83 cb 01             	or     $0x1,%ebx
40031374:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
40031377:	8b 5a 18             	mov    0x18(%edx),%ebx
	callback_data[gpio] = cfg->callback_data;
4003137a:	8b 52 1c             	mov    0x1c(%edx),%edx

	controller->gpio_intmask = mask;
4003137d:	89 71 34             	mov    %esi,0x34(%ecx)
	callback[gpio] = cfg->callback;
40031380:	89 1c 85 f8 68 00 a8 	mov    %ebx,-0x57ff9708(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
40031387:	89 14 85 f0 68 00 a8 	mov    %edx,-0x57ff9710(,%eax,4)

	return 0;
}
4003138e:	5b                   	pop    %ebx
4003138f:	31 c0                	xor    %eax,%eax
40031391:	5e                   	pop    %esi
40031392:	5d                   	pop    %ebp
40031393:	c3                   	ret    

40031394 <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
40031394:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031395:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
4003139c:	89 e5                	mov    %esp,%ebp
4003139e:	53                   	push   %ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
4003139f:	8b 40 50             	mov    0x50(%eax),%eax
{
400313a2:	89 cb                	mov    %ecx,%ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
400313a4:	88 d1                	mov    %dl,%cl
400313a6:	d3 e8                	shr    %cl,%eax
400313a8:	83 e0 01             	and    $0x1,%eax
400313ab:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400313ad:	31 c0                	xor    %eax,%eax
400313af:	5b                   	pop    %ebx
400313b0:	5d                   	pop    %ebp
400313b1:	c3                   	ret    

400313b2 <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
400313b2:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
400313b3:	88 d1                	mov    %dl,%cl
{
400313b5:	89 e5                	mov    %esp,%ebp
400313b7:	56                   	push   %esi
400313b8:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
400313b9:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
400313c0:	b8 01 00 00 00       	mov    $0x1,%eax
400313c5:	8b 33                	mov    (%ebx),%esi
400313c7:	d3 e0                	shl    %cl,%eax
400313c9:	09 f0                	or     %esi,%eax
400313cb:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400313cd:	31 c0                	xor    %eax,%eax
400313cf:	5b                   	pop    %ebx
400313d0:	5e                   	pop    %esi
400313d1:	5d                   	pop    %ebp
400313d2:	c3                   	ret    

400313d3 <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
400313d3:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
400313d4:	88 d1                	mov    %dl,%cl
{
400313d6:	89 e5                	mov    %esp,%ebp
400313d8:	56                   	push   %esi
400313d9:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
400313da:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
400313e1:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
400313e6:	8b 33                	mov    (%ebx),%esi
400313e8:	d3 c0                	rol    %cl,%eax
400313ea:	21 f0                	and    %esi,%eax
400313ec:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400313ee:	31 c0                	xor    %eax,%eax
400313f0:	5b                   	pop    %ebx
400313f1:	5e                   	pop    %esi
400313f2:	5d                   	pop    %ebp
400313f3:	c3                   	ret    

400313f4 <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
400313f4:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400313fb:	55                   	push   %ebp
400313fc:	89 e5                	mov    %esp,%ebp

	return 0;
}
400313fe:	5d                   	pop    %ebp
	*port = QM_GPIO[gpio]->gpio_ext_porta;
400313ff:	8b 40 50             	mov    0x50(%eax),%eax
40031402:	89 02                	mov    %eax,(%edx)
}
40031404:	31 c0                	xor    %eax,%eax
40031406:	c3                   	ret    

40031407 <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
40031407:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
4003140e:	55                   	push   %ebp
4003140f:	89 e5                	mov    %esp,%ebp
	QM_GPIO[gpio]->gpio_swporta_dr = val;
40031411:	89 10                	mov    %edx,(%eax)

	return 0;
}
40031413:	31 c0                	xor    %eax,%eax
40031415:	5d                   	pop    %ebp
40031416:	c3                   	ret    

40031417 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
40031417:	55                   	push   %ebp
40031418:	89 e5                	mov    %esp,%ebp
4003141a:	53                   	push   %ebx
4003141b:	51                   	push   %ecx
	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
4003141c:	8b 4a 04             	mov    0x4(%edx),%ecx
	qm_uart_reg_t *const regs = QM_UART[uart];
4003141f:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40031426:	89 cb                	mov    %ecx,%ebx
40031428:	c1 eb 10             	shr    $0x10,%ebx
	regs->lcr = 0;
4003142b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40031432:	0f b6 db             	movzbl %bl,%ebx
	regs->lcr = QM_UART_LCR_DLAB;
40031435:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
4003143c:	89 58 04             	mov    %ebx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
4003143f:	0f b6 dd             	movzbl %ch,%ebx
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
40031442:	0f b6 c9             	movzbl %cl,%ecx
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
40031445:	89 18                	mov    %ebx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
40031447:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
4003144d:	8b 0a                	mov    (%edx),%ecx
4003144f:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
40031452:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
40031459:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
4003145d:	74 09                	je     40031468 <qm_uart_set_config+0x51>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
4003145f:	8b 50 10             	mov    0x10(%eax),%edx
40031462:	83 ca 22             	or     $0x22,%edx
40031465:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
40031468:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
4003146f:	8b 50 04             	mov    0x4(%eax),%edx
40031472:	80 ca 80             	or     $0x80,%dl
40031475:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
40031478:	8b 40 14             	mov    0x14(%eax),%eax
4003147b:	89 45 f8             	mov    %eax,-0x8(%ebp)

	return 0;
}
4003147e:	5a                   	pop    %edx
4003147f:	31 c0                	xor    %eax,%eax
40031481:	5b                   	pop    %ebx
40031482:	5d                   	pop    %ebp
40031483:	c3                   	ret    

40031484 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
40031484:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
40031485:	8b 0c 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%ecx
{
4003148c:	89 e5                	mov    %esp,%ebp
4003148e:	56                   	push   %esi
4003148f:	53                   	push   %ebx
	uint32_t lsr = regs->lsr;
40031490:	8b 59 14             	mov    0x14(%ecx),%ebx

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
40031493:	8b 71 1c             	mov    0x1c(%ecx),%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031496:	89 d8                	mov    %ebx,%eax
40031498:	83 e0 1e             	and    $0x1e,%eax
	if (regs->scr & BIT(0)) {
4003149b:	83 e6 01             	and    $0x1,%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
4003149e:	89 02                	mov    %eax,(%edx)
	if (regs->scr & BIT(0)) {
400314a0:	74 0b                	je     400314ad <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
400314a2:	8b 41 1c             	mov    0x1c(%ecx),%eax
400314a5:	83 e0 fe             	and    $0xfffffffe,%eax
400314a8:	89 41 1c             	mov    %eax,0x1c(%ecx)
400314ab:	eb 0a                	jmp    400314b7 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
400314ad:	f6 c3 40             	test   $0x40,%bl
400314b0:	75 05                	jne    400314b7 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
400314b2:	83 c8 20             	or     $0x20,%eax
400314b5:	89 02                	mov    %eax,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
400314b7:	80 e3 01             	and    $0x1,%bl
400314ba:	74 03                	je     400314bf <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
400314bc:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
400314bf:	5b                   	pop    %ebx
400314c0:	31 c0                	xor    %eax,%eax
400314c2:	5e                   	pop    %esi
400314c3:	5d                   	pop    %ebp
400314c4:	c3                   	ret    

400314c5 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
400314c5:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
400314c6:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
{
400314cd:	89 e5                	mov    %esp,%ebp

	while (regs->lsr & QM_UART_LSR_THRE) {
400314cf:	8b 48 14             	mov    0x14(%eax),%ecx
400314d2:	80 e1 20             	and    $0x20,%cl
400314d5:	75 f8                	jne    400314cf <qm_uart_write+0xa>
	}
	regs->rbr_thr_dll = data;
400314d7:	0f b6 d2             	movzbl %dl,%edx
400314da:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
400314dc:	8b 50 14             	mov    0x14(%eax),%edx
400314df:	80 e2 40             	and    $0x40,%dl
400314e2:	74 f8                	je     400314dc <qm_uart_write+0x17>
	}

	return 0;
}
400314e4:	31 c0                	xor    %eax,%eax
400314e6:	5d                   	pop    %ebp
400314e7:	c3                   	ret    

400314e8 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
400314e8:	55                   	push   %ebp
400314e9:	89 e5                	mov    %esp,%ebp
400314eb:	56                   	push   %esi
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
400314ec:	8b 34 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%esi
{
400314f3:	53                   	push   %ebx

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
		lsr = regs->lsr;
400314f4:	8b 46 14             	mov    0x14(%esi),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
400314f7:	a8 01                	test   $0x1,%al
400314f9:	74 f9                	je     400314f4 <qm_uart_read+0xc>
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
400314fb:	83 e0 1e             	and    $0x1e,%eax
400314fe:	89 c3                	mov    %eax,%ebx
40031500:	74 0d                	je     4003150f <qm_uart_read+0x27>
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
40031502:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		if (status) {
40031507:	85 c9                	test   %ecx,%ecx
40031509:	74 0a                	je     40031515 <qm_uart_read+0x2d>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
4003150b:	89 19                	mov    %ebx,(%ecx)
4003150d:	eb 06                	jmp    40031515 <qm_uart_read+0x2d>
	}
	*data = regs->rbr_thr_dll;
4003150f:	8b 06                	mov    (%esi),%eax
40031511:	88 02                	mov    %al,(%edx)

	return 0;
40031513:	31 c0                	xor    %eax,%eax
}
40031515:	5b                   	pop    %ebx
40031516:	5e                   	pop    %esi
40031517:	5d                   	pop    %ebp
40031518:	c3                   	ret    

40031519 <read_frame>:
static dma_context_t dma_context_rx[QM_SPI_NUM];
/* DMA core being used by each SPI controller. */
static qm_dma_t dma_core[QM_SPI_NUM];

static void read_frame(const qm_spi_t spi, uint8_t *const rx_buffer)
{
40031519:	55                   	push   %ebp
	const qm_spi_reg_t *const controller = QM_SPI[spi];
4003151a:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40031521:	8a 80 18 69 00 a8    	mov    -0x57ff96e8(%eax),%al
{
40031527:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031529:	3c 01                	cmp    $0x1,%al
4003152b:	75 07                	jne    40031534 <read_frame+0x1b>
		*(uint8_t *)rx_buffer = controller->dr[0];
4003152d:	8b 41 60             	mov    0x60(%ecx),%eax
40031530:	88 02                	mov    %al,(%edx)
40031532:	eb 0e                	jmp    40031542 <read_frame+0x29>
	} else if (frame_size == 2) {
40031534:	3c 02                	cmp    $0x2,%al
		*(uint16_t *)rx_buffer = controller->dr[0];
40031536:	8b 41 60             	mov    0x60(%ecx),%eax
	} else if (frame_size == 2) {
40031539:	75 05                	jne    40031540 <read_frame+0x27>
		*(uint16_t *)rx_buffer = controller->dr[0];
4003153b:	66 89 02             	mov    %ax,(%edx)
4003153e:	eb 02                	jmp    40031542 <read_frame+0x29>
	} else {
		*(uint32_t *)rx_buffer = controller->dr[0];
40031540:	89 02                	mov    %eax,(%edx)
	}
}
40031542:	5d                   	pop    %ebp
40031543:	c3                   	ret    

40031544 <write_frame>:

static void write_frame(const qm_spi_t spi, const uint8_t *const tx_buffer)
{
40031544:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031545:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
4003154c:	8a 80 18 69 00 a8    	mov    -0x57ff96e8(%eax),%al
{
40031552:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031554:	3c 01                	cmp    $0x1,%al
40031556:	75 05                	jne    4003155d <write_frame+0x19>
		controller->dr[0] = *(uint8_t *)tx_buffer;
40031558:	0f b6 02             	movzbl (%edx),%eax
4003155b:	eb 0b                	jmp    40031568 <write_frame+0x24>
	} else if (frame_size == 2) {
4003155d:	3c 02                	cmp    $0x2,%al
4003155f:	75 05                	jne    40031566 <write_frame+0x22>
		controller->dr[0] = *(uint16_t *)tx_buffer;
40031561:	0f b7 02             	movzwl (%edx),%eax
40031564:	eb 02                	jmp    40031568 <write_frame+0x24>
	} else {
		controller->dr[0] = *(uint32_t *)tx_buffer;
40031566:	8b 02                	mov    (%edx),%eax
40031568:	89 41 60             	mov    %eax,0x60(%ecx)
	}
}
4003156b:	5d                   	pop    %ebp
4003156c:	c3                   	ret    

4003156d <handle_spi_overflow_interrupt>:
		controller->txftlr = 0;
	}
}

static void handle_spi_overflow_interrupt(const qm_spi_t spi)
{
4003156d:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
	const volatile qm_spi_async_transfer_t *transfer =
4003156e:	8b 0c 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%ecx
{
40031575:	89 e5                	mov    %esp,%ebp
40031577:	56                   	push   %esi
40031578:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031579:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	    spi_async_transfer[spi];

	if (transfer->callback) {
40031580:	8b 51 10             	mov    0x10(%ecx),%edx
40031583:	85 d2                	test   %edx,%edx
40031585:	74 1c                	je     400315a3 <handle_spi_overflow_interrupt+0x36>
		transfer->callback(transfer->callback_data, -EIO,
40031587:	8b 71 10             	mov    0x10(%ecx),%esi
				   QM_SPI_RX_OVERFLOW, rx_counter[spi]);
4003158a:	0f b7 94 00 1c 69 00 	movzwl -0x57ff96e4(%eax,%eax,1),%edx
40031591:	a8 
		transfer->callback(transfer->callback_data, -EIO,
40031592:	8b 41 14             	mov    0x14(%ecx),%eax
40031595:	52                   	push   %edx
40031596:	b9 02 00 00 00       	mov    $0x2,%ecx
4003159b:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
400315a0:	ff d6                	call   *%esi
400315a2:	58                   	pop    %eax
	}

	/* Clear RX FIFO Overflow interrupt. */
	controller->rxoicr;
400315a3:	8b 43 3c             	mov    0x3c(%ebx),%eax
	controller->imr = QM_SPI_IMR_MASK_ALL;
400315a6:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	controller->ssienr = 0;
400315ad:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
400315b4:	8d 65 f8             	lea    -0x8(%ebp),%esp
400315b7:	5b                   	pop    %ebx
400315b8:	5e                   	pop    %esi
400315b9:	5d                   	pop    %ebp
400315ba:	c3                   	ret    

400315bb <handle_spi_mst_interrupt>:

static void handle_spi_mst_interrupt(const qm_spi_t spi)
{
400315bb:	55                   	push   %ebp
400315bc:	89 e5                	mov    %esp,%ebp
400315be:	57                   	push   %edi
400315bf:	56                   	push   %esi
400315c0:	53                   	push   %ebx
400315c1:	83 ec 0c             	sub    $0xc,%esp
	qm_spi_reg_t *const controller = QM_SPI[spi];
400315c4:	8b 3c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edi
400315cb:	89 7d f0             	mov    %edi,-0x10(%ebp)
	const volatile qm_spi_async_transfer_t *transfer =
	    spi_async_transfer[spi];
	const uint32_t int_status = controller->isr;
400315ce:	8b 4f 30             	mov    0x30(%edi),%ecx
400315d1:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	QM_ASSERT((int_status & (QM_SPI_ISR_TXOIS | QM_SPI_ISR_RXUIS)) == 0);

	/* RX FIFO Overflow interrupt. */
	if (int_status & QM_SPI_ISR_RXOIS) {
400315d4:	80 e1 08             	and    $0x8,%cl
400315d7:	74 0c                	je     400315e5 <handle_spi_mst_interrupt+0x2a>

	if (int_status & QM_SPI_ISR_TXEIS &&
	    transfer->tx_len > tx_counter[spi]) {
		handle_mst_tx_interrupt(spi);
	}
}
400315d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
400315dc:	5b                   	pop    %ebx
400315dd:	5e                   	pop    %esi
400315de:	5f                   	pop    %edi
400315df:	5d                   	pop    %ebp
		handle_spi_overflow_interrupt(spi);
400315e0:	e9 88 ff ff ff       	jmp    4003156d <handle_spi_overflow_interrupt>
400315e5:	89 c3                	mov    %eax,%ebx
	const volatile qm_spi_async_transfer_t *transfer =
400315e7:	8b 34 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%esi
	if (int_status & QM_SPI_ISR_RXFIS) {
400315ee:	f6 45 ec 10          	testb  $0x10,-0x14(%ebp)
400315f2:	0f 84 b6 00 00 00    	je     400316ae <handle_spi_mst_interrupt+0xf3>
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
400315f8:	8b 56 04             	mov    0x4(%esi),%edx
400315fb:	0f b7 8c 00 1c 69 00 	movzwl -0x57ff96e4(%eax,%eax,1),%ecx
40031602:	a8 
40031603:	0f b6 80 18 69 00 a8 	movzbl -0x57ff96e8(%eax),%eax
4003160a:	0f af c8             	imul   %eax,%ecx
		rx_buffer += dfs[spi];
4003160d:	89 c7                	mov    %eax,%edi
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
4003160f:	01 d1                	add    %edx,%ecx
	while (controller->rxflr) {
40031611:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031614:	8b 40 24             	mov    0x24(%eax),%eax
40031617:	85 c0                	test   %eax,%eax
40031619:	74 77                	je     40031692 <handle_spi_mst_interrupt+0xd7>
		read_frame(spi, rx_buffer);
4003161b:	89 ca                	mov    %ecx,%edx
4003161d:	89 d8                	mov    %ebx,%eax
4003161f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031622:	e8 f2 fe ff ff       	call   40031519 <read_frame>
		rx_counter[spi]++;
40031627:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
4003162e:	a8 
4003162f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40031632:	40                   	inc    %eax
40031633:	01 f9                	add    %edi,%ecx
40031635:	66 89 84 1b 1c 69 00 	mov    %ax,-0x57ff96e4(%ebx,%ebx,1)
4003163c:	a8 
		if (transfer->rx_len == rx_counter[spi]) {
4003163d:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031641:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
40031648:	a8 
40031649:	66 39 c2             	cmp    %ax,%dx
4003164c:	75 c3                	jne    40031611 <handle_spi_mst_interrupt+0x56>
				controller->imr = QM_SPI_IMR_MASK_ALL;
4003164e:	8b 45 f0             	mov    -0x10(%ebp),%eax
			if (tmode[spi] == QM_SPI_TMOD_RX) {
40031651:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
40031658:	02 
40031659:	75 2b                	jne    40031686 <handle_spi_mst_interrupt+0xcb>
				controller->imr = QM_SPI_IMR_MASK_ALL;
4003165b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				controller->ssienr = 0;
40031662:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				if (transfer->callback) {
40031669:	8b 46 10             	mov    0x10(%esi),%eax
4003166c:	85 c0                	test   %eax,%eax
4003166e:	74 22                	je     40031692 <handle_spi_mst_interrupt+0xd7>
					transfer->callback(
40031670:	8b 46 10             	mov    0x10(%esi),%eax
40031673:	31 c9                	xor    %ecx,%ecx
					    QM_SPI_IDLE, transfer->rx_len);
40031675:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
					transfer->callback(
40031679:	89 c7                	mov    %eax,%edi
4003167b:	8b 46 14             	mov    0x14(%esi),%eax
4003167e:	52                   	push   %edx
4003167f:	31 d2                	xor    %edx,%edx
40031681:	ff d7                	call   *%edi
40031683:	5a                   	pop    %edx
40031684:	eb 0c                	jmp    40031692 <handle_spi_mst_interrupt+0xd7>
				controller->imr &=
40031686:	8b 40 2c             	mov    0x2c(%eax),%eax
40031689:	8b 7d f0             	mov    -0x10(%ebp),%edi
4003168c:	83 e0 e3             	and    $0xffffffe3,%eax
4003168f:	89 47 2c             	mov    %eax,0x2c(%edi)
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031692:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (frames_left <= controller->rxftlr) {
40031696:	8b 7d f0             	mov    -0x10(%ebp),%edi
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031699:	0f b7 94 1b 1c 69 00 	movzwl -0x57ff96e4(%ebx,%ebx,1),%edx
400316a0:	a8 
400316a1:	29 d0                	sub    %edx,%eax
	if (frames_left <= controller->rxftlr) {
400316a3:	8b 57 1c             	mov    0x1c(%edi),%edx
400316a6:	39 d0                	cmp    %edx,%eax
400316a8:	77 04                	ja     400316ae <handle_spi_mst_interrupt+0xf3>
		controller->rxftlr = frames_left - 1;
400316aa:	48                   	dec    %eax
400316ab:	89 47 1c             	mov    %eax,0x1c(%edi)
	if (transfer->rx_len == rx_counter[spi] &&
400316ae:	66 8b 56 0a          	mov    0xa(%esi),%dx
400316b2:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
400316b9:	a8 
400316ba:	66 39 c2             	cmp    %ax,%dx
400316bd:	75 66                	jne    40031725 <handle_spi_mst_interrupt+0x16a>
	    transfer->tx_len == tx_counter[spi] &&
400316bf:	66 8b 56 08          	mov    0x8(%esi),%dx
400316c3:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
400316ca:	a8 
	if (transfer->rx_len == rx_counter[spi] &&
400316cb:	66 39 c2             	cmp    %ax,%dx
400316ce:	75 55                	jne    40031725 <handle_spi_mst_interrupt+0x16a>
	    (controller->sr & QM_SPI_SR_TFE) &&
400316d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400316d3:	8b 40 28             	mov    0x28(%eax),%eax
	    transfer->tx_len == tx_counter[spi] &&
400316d6:	a8 04                	test   $0x4,%al
400316d8:	74 4b                	je     40031725 <handle_spi_mst_interrupt+0x16a>
	    !(controller->sr & QM_SPI_SR_BUSY)) {
400316da:	8b 45 f0             	mov    -0x10(%ebp),%eax
400316dd:	8b 40 28             	mov    0x28(%eax),%eax
	    (controller->sr & QM_SPI_SR_TFE) &&
400316e0:	a8 01                	test   $0x1,%al
400316e2:	75 41                	jne    40031725 <handle_spi_mst_interrupt+0x16a>
		controller->imr = QM_SPI_IMR_MASK_ALL;
400316e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400316e7:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
		controller->ssienr = 0;
400316ee:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (transfer->callback && tmode[spi] != QM_SPI_TMOD_RX) {
400316f5:	8b 46 10             	mov    0x10(%esi),%eax
400316f8:	85 c0                	test   %eax,%eax
400316fa:	0f 84 bd 00 00 00    	je     400317bd <handle_spi_mst_interrupt+0x202>
40031700:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
40031707:	02 
40031708:	0f 84 af 00 00 00    	je     400317bd <handle_spi_mst_interrupt+0x202>
			transfer->callback(transfer->callback_data, 0,
4003170e:	8b 5e 10             	mov    0x10(%esi),%ebx
40031711:	31 c9                	xor    %ecx,%ecx
					   QM_SPI_IDLE, transfer->tx_len);
40031713:	0f b7 56 08          	movzwl 0x8(%esi),%edx
			transfer->callback(transfer->callback_data, 0,
40031717:	8b 46 14             	mov    0x14(%esi),%eax
4003171a:	52                   	push   %edx
4003171b:	31 d2                	xor    %edx,%edx
4003171d:	ff d3                	call   *%ebx
4003171f:	58                   	pop    %eax
40031720:	e9 98 00 00 00       	jmp    400317bd <handle_spi_mst_interrupt+0x202>
	if (int_status & QM_SPI_ISR_TXEIS &&
40031725:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
40031729:	0f 84 8e 00 00 00    	je     400317bd <handle_spi_mst_interrupt+0x202>
	    transfer->tx_len > tx_counter[spi]) {
4003172f:	66 8b 56 08          	mov    0x8(%esi),%dx
40031733:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
4003173a:	a8 
	if (int_status & QM_SPI_ISR_TXEIS &&
4003173b:	66 39 c2             	cmp    %ax,%dx
4003173e:	76 7d                	jbe    400317bd <handle_spi_mst_interrupt+0x202>
	const volatile qm_spi_async_transfer_t *const transfer =
40031740:	8b 0c 9d 2c 69 00 a8 	mov    -0x57ff96d4(,%ebx,4),%ecx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031747:	8b 3c 9d dc 66 00 a8 	mov    -0x57ff9924(,%ebx,4),%edi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
4003174e:	0f b6 93 18 69 00 a8 	movzbl -0x57ff96e8(%ebx),%edx
40031755:	8b 31                	mov    (%ecx),%esi
		tx_buffer += dfs[spi];
40031757:	89 55 ec             	mov    %edx,-0x14(%ebp)
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
4003175a:	0f b7 84 1b 24 69 00 	movzwl -0x57ff96dc(%ebx,%ebx,1),%eax
40031761:	a8 
40031762:	0f af c2             	imul   %edx,%eax
40031765:	01 f0                	add    %esi,%eax
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031767:	8b 77 20             	mov    0x20(%edi),%esi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
4003176a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
4003176d:	8b 47 24             	mov    0x24(%edi),%eax
40031770:	01 f0                	add    %esi,%eax
40031772:	be 07 00 00 00       	mov    $0x7,%esi
40031777:	29 c6                	sub    %eax,%esi
	while (frames > 0) {
40031779:	85 f6                	test   %esi,%esi
4003177b:	7e 40                	jle    400317bd <handle_spi_mst_interrupt+0x202>
		write_frame(spi, tx_buffer);
4003177d:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031780:	89 d8                	mov    %ebx,%eax
40031782:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031785:	e8 ba fd ff ff       	call   40031544 <write_frame>
		tx_counter[spi]++;
4003178a:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
40031791:	a8 
40031792:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40031795:	40                   	inc    %eax
40031796:	01 4d f0             	add    %ecx,-0x10(%ebp)
		if (transfer->tx_len == tx_counter[spi]) {
40031799:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		tx_counter[spi]++;
4003179c:	66 89 84 1b 24 69 00 	mov    %ax,-0x57ff96dc(%ebx,%ebx,1)
400317a3:	a8 
		frames--;
400317a4:	4e                   	dec    %esi
		if (transfer->tx_len == tx_counter[spi]) {
400317a5:	66 8b 51 08          	mov    0x8(%ecx),%dx
400317a9:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
400317b0:	a8 
400317b1:	66 39 c2             	cmp    %ax,%dx
400317b4:	75 c3                	jne    40031779 <handle_spi_mst_interrupt+0x1be>
			controller->txftlr = 0;
400317b6:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
}
400317bd:	8d 65 f4             	lea    -0xc(%ebp),%esp
400317c0:	5b                   	pop    %ebx
400317c1:	5e                   	pop    %esi
400317c2:	5f                   	pop    %edi
400317c3:	5d                   	pop    %ebp
400317c4:	c3                   	ret    

400317c5 <qm_spi_set_config>:
		handle_slv_tx_interrupt(spi);
	}
}

int qm_spi_set_config(const qm_spi_t spi, const qm_spi_config_t *cfg)
{
400317c5:	55                   	push   %ebp
400317c6:	89 e5                	mov    %esp,%ebp
400317c8:	57                   	push   %edi
400317c9:	56                   	push   %esi
400317ca:	53                   	push   %ebx
400317cb:	51                   	push   %ecx
	QM_CHECK(QM_SPI_SLV_0 == spi
		     ? cfg->transfer_mode != QM_SPI_TMOD_EEPROM_READ
		     : 1,
		 -EINVAL);

	if (0 != QM_SPI[spi]->ssienr) {
400317cc:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi
400317d3:	8b 4e 08             	mov    0x8(%esi),%ecx
400317d6:	85 c9                	test   %ecx,%ecx
400317d8:	75 4d                	jne    40031827 <qm_spi_set_config+0x62>
	}

	qm_spi_reg_t *const controller = QM_SPI[spi];

	/* Apply the selected cfg options. */
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
400317da:	8b 3a                	mov    (%edx),%edi
400317dc:	89 7d f0             	mov    %edi,-0x10(%ebp)
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
400317df:	8b 7a 04             	mov    0x4(%edx),%edi
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
400317e2:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
400317e5:	89 f9                	mov    %edi,%ecx
400317e7:	c1 e1 08             	shl    $0x8,%ecx
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
400317ea:	c1 e3 10             	shl    $0x10,%ebx
400317ed:	09 cb                	or     %ecx,%ebx
			     (cfg->bus_mode << QM_SPI_CTRLR0_SCPOL_SCPH_OFFSET);
400317ef:	8b 4a 08             	mov    0x8(%edx),%ecx
400317f2:	c1 e1 06             	shl    $0x6,%ecx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
400317f5:	09 cb                	or     %ecx,%ebx

	/*
	 * If the device is configured as a slave, an external master will
	 * set the baud rate.
	 */
	if (QM_SPI_SLV_0 != spi) {
400317f7:	83 f8 02             	cmp    $0x2,%eax
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
400317fa:	89 1e                	mov    %ebx,(%esi)
	if (QM_SPI_SLV_0 != spi) {
400317fc:	74 07                	je     40031805 <qm_spi_set_config+0x40>
		controller->baudr = cfg->clk_divider;
400317fe:	0f b7 5a 10          	movzwl 0x10(%edx),%ebx
40031802:	89 5e 14             	mov    %ebx,0x14(%esi)
	 * - 1 byte for DFS set from 4 to 8 bits;
	 * - 2 bytes for DFS set from 9 to 16 bits;
	 * - 3 bytes for DFS set from 17 to 24 bits;
	 * - 4 bytes for DFS set from 25 to 32 bits.
	 */
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031805:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	tmode[spi] = cfg->transfer_mode;
	frf[spi] = cfg->frame_format;
40031808:	8b 52 0c             	mov    0xc(%edx),%edx
	dfs[spi] = (cfg->frame_size / 8) + 1;
4003180b:	c1 e9 03             	shr    $0x3,%ecx
	tmode[spi] = cfg->transfer_mode;
4003180e:	89 3c 85 0c 69 00 a8 	mov    %edi,-0x57ff96f4(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031815:	41                   	inc    %ecx
	frf[spi] = cfg->frame_format;
40031816:	89 14 85 00 69 00 a8 	mov    %edx,-0x57ff9700(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
4003181d:	88 88 18 69 00 a8    	mov    %cl,-0x57ff96e8(%eax)

	return 0;
40031823:	31 c0                	xor    %eax,%eax
40031825:	eb 05                	jmp    4003182c <qm_spi_set_config+0x67>
		return -EBUSY;
40031827:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
4003182c:	5a                   	pop    %edx
4003182d:	5b                   	pop    %ebx
4003182e:	5e                   	pop    %esi
4003182f:	5f                   	pop    %edi
40031830:	5d                   	pop    %ebp
40031831:	c3                   	ret    

40031832 <qm_spi_slave_select>:
int qm_spi_slave_select(const qm_spi_t spi, const qm_spi_slave_select_t ss)
{
	QM_CHECK((spi < QM_SPI_NUM) && (spi != QM_SPI_SLV_0), -EINVAL);

	/* Check if the device reports as busy. */
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
40031832:	8b 04 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%eax
{
40031839:	55                   	push   %ebp
4003183a:	89 e5                	mov    %esp,%ebp
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
4003183c:	8b 48 28             	mov    0x28(%eax),%ecx
4003183f:	80 e1 01             	and    $0x1,%cl
40031842:	75 07                	jne    4003184b <qm_spi_slave_select+0x19>
		return -EBUSY;
	}

	QM_SPI[spi]->ser = ss;
40031844:	89 50 10             	mov    %edx,0x10(%eax)

	return 0;
40031847:	31 c0                	xor    %eax,%eax
40031849:	eb 05                	jmp    40031850 <qm_spi_slave_select+0x1e>
		return -EBUSY;
4003184b:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031850:	5d                   	pop    %ebp
40031851:	c3                   	ret    

40031852 <qm_spi_irq_update>:
}

int qm_spi_irq_update(const qm_spi_t spi,
		      const volatile qm_spi_async_transfer_t *const xfer,
		      const qm_spi_update_t update)
{
40031852:	55                   	push   %ebp
	QM_CHECK((update & QM_SPI_UPDATE_RX) ? (tmode[spi] != QM_SPI_TMOD_TX)
					     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
	spi_async_transfer[spi] = xfer;
40031853:	89 14 85 2c 69 00 a8 	mov    %edx,-0x57ff96d4(,%eax,4)
{
4003185a:	89 e5                	mov    %esp,%ebp

	if (update == QM_SPI_UPDATE_RX) {
4003185c:	83 f9 01             	cmp    $0x1,%ecx
{
4003185f:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031860:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	if (update == QM_SPI_UPDATE_RX) {
40031867:	75 13                	jne    4003187c <qm_spi_irq_update+0x2a>
		rx_counter[spi] = 0;
40031869:	66 c7 84 00 1c 69 00 	movw   $0x0,-0x57ff96e4(%eax,%eax,1)
40031870:	a8 00 00 
		/* Unmask RX interrupt sources. */
		controller->imr =
40031873:	c7 43 2c 1c 00 00 00 	movl   $0x1c,0x2c(%ebx)
4003187a:	eb 33                	jmp    400318af <qm_spi_irq_update+0x5d>
		    QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM | QM_SPI_IMR_RXFIM;
	} else if (update == QM_SPI_UPDATE_TX) {
4003187c:	83 f9 02             	cmp    $0x2,%ecx
4003187f:	75 13                	jne    40031894 <qm_spi_irq_update+0x42>
		tx_counter[spi] = 0;
40031881:	66 c7 84 00 24 69 00 	movw   $0x0,-0x57ff96dc(%eax,%eax,1)
40031888:	a8 00 00 
		/* Unmask TX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM;
4003188b:	c7 43 2c 03 00 00 00 	movl   $0x3,0x2c(%ebx)
40031892:	eb 1b                	jmp    400318af <qm_spi_irq_update+0x5d>
	} else {
		rx_counter[spi] = 0;
40031894:	66 c7 84 00 1c 69 00 	movw   $0x0,-0x57ff96e4(%eax,%eax,1)
4003189b:	a8 00 00 
		tx_counter[spi] = 0;
4003189e:	66 c7 84 00 24 69 00 	movw   $0x0,-0x57ff96dc(%eax,%eax,1)
400318a5:	a8 00 00 
		/* Unmask both TX and RX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM |
400318a8:	c7 43 2c 1f 00 00 00 	movl   $0x1f,0x2c(%ebx)
				  QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM |
				  QM_SPI_IMR_RXFIM;
	}

	return 0;
}
400318af:	31 c0                	xor    %eax,%eax
400318b1:	5b                   	pop    %ebx
400318b2:	5d                   	pop    %ebp
400318b3:	c3                   	ret    

400318b4 <qm_spi_irq_transfer>:

int qm_spi_irq_transfer(const qm_spi_t spi,
			const volatile qm_spi_async_transfer_t *const xfer)
{
400318b4:	55                   	push   %ebp
400318b5:	89 e5                	mov    %esp,%ebp
400318b7:	57                   	push   %edi
400318b8:	56                   	push   %esi
400318b9:	53                   	push   %ebx
400318ba:	51                   	push   %ecx
400318bb:	89 c3                	mov    %eax,%ebx
	QM_CHECK(tmode[spi] == QM_SPI_TMOD_TX_RX
		     ? (xfer->tx_len == xfer->rx_len)
		     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
400318bd:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi

	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
400318c4:	8b 04 85 0c 69 00 a8 	mov    -0x57ff96f4(,%eax,4),%eax
400318cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
400318ce:	83 e8 02             	sub    $0x2,%eax
400318d1:	83 f8 01             	cmp    $0x1,%eax
{
400318d4:	89 d7                	mov    %edx,%edi
	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
400318d6:	0f 96 c1             	setbe  %cl
400318d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
400318dd:	0f 94 c0             	sete   %al
	qm_spi_update_t update = 0;
400318e0:	09 c1                	or     %eax,%ecx
400318e2:	0f b6 c9             	movzbl %cl,%ecx
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_RX;
	}
	if ((tmode[spi] == QM_SPI_TMOD_TX) ||
400318e5:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
400318e9:	76 06                	jbe    400318f1 <qm_spi_irq_transfer+0x3d>
400318eb:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
400318ef:	75 03                	jne    400318f4 <qm_spi_irq_transfer+0x40>
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_TX;
400318f1:	83 c9 02             	or     $0x2,%ecx
	}

	rx_counter[spi] = 0;
	tx_counter[spi] = 0;
	qm_spi_irq_update(spi, xfer, update);
400318f4:	89 fa                	mov    %edi,%edx
400318f6:	89 d8                	mov    %ebx,%eax
	rx_counter[spi] = 0;
400318f8:	66 c7 84 1b 1c 69 00 	movw   $0x0,-0x57ff96e4(%ebx,%ebx,1)
400318ff:	a8 00 00 
	tx_counter[spi] = 0;
40031902:	66 c7 84 1b 24 69 00 	movw   $0x0,-0x57ff96dc(%ebx,%ebx,1)
40031909:	a8 00 00 
	qm_spi_irq_update(spi, xfer, update);
4003190c:	e8 41 ff ff ff       	call   40031852 <qm_spi_irq_update>
		 * holds how many bytes the controller solicits, minus 1.
		 * We also set the same into rxftlr, so the controller only
		 * triggers a RX_FIFO_FULL interrupt when all frames are
		 * available at the FIFO for consumption.
		 */
		if (xfer->rx_len) {
40031911:	66 8b 47 0a          	mov    0xa(%edi),%ax
	if (QM_SPI_SLV_0 != spi) {
40031915:	83 fb 02             	cmp    $0x2,%ebx
40031918:	74 2d                	je     40031947 <qm_spi_irq_transfer+0x93>
		if (xfer->rx_len) {
4003191a:	66 85 c0             	test   %ax,%ax
4003191d:	74 1f                	je     4003193e <qm_spi_irq_transfer+0x8a>
			controller->ctrlr1 = xfer->rx_len - 1;
4003191f:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031923:	48                   	dec    %eax
40031924:	89 46 04             	mov    %eax,0x4(%esi)
40031927:	b8 05 00 00 00       	mov    $0x5,%eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
4003192c:	66 8b 57 0a          	mov    0xa(%edi),%dx
						 ? xfer->rx_len - 1
						 : SPI_MST_DEFAULT_RX_THRESHOLD;
40031930:	66 83 fa 07          	cmp    $0x7,%dx
40031934:	77 05                	ja     4003193b <qm_spi_irq_transfer+0x87>
						 ? xfer->rx_len - 1
40031936:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
4003193a:	48                   	dec    %eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
4003193b:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_MST_DEFAULT_TX_THRESHOLD;
4003193e:	c7 46 18 05 00 00 00 	movl   $0x5,0x18(%esi)
40031945:	eb 35                	jmp    4003197c <qm_spi_irq_transfer+0xc8>
	} else {
		if (xfer->rx_len) {
40031947:	66 85 c0             	test   %ax,%ax
4003194a:	74 17                	je     40031963 <qm_spi_irq_transfer+0xaf>
			controller->rxftlr =
			    (xfer->rx_len < SPI_SLV_DEFAULT_RX_THRESHOLD)
4003194c:	66 8b 57 0a          	mov    0xa(%edi),%dx
40031950:	b8 03 00 00 00       	mov    $0x3,%eax
				? xfer->rx_len - 1
				: SPI_SLV_DEFAULT_RX_THRESHOLD;
40031955:	66 83 fa 02          	cmp    $0x2,%dx
40031959:	77 05                	ja     40031960 <qm_spi_irq_transfer+0xac>
				? xfer->rx_len - 1
4003195b:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
4003195f:	48                   	dec    %eax
			controller->rxftlr =
40031960:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_SLV_DEFAULT_TX_THRESHOLD;
40031963:	c7 46 18 04 00 00 00 	movl   $0x4,0x18(%esi)

		if (QM_SPI_TMOD_RX != tmode[spi]) {
4003196a:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
			/* Enable MISO line. */
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
4003196e:	8b 06                	mov    (%esi),%eax
		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031970:	74 05                	je     40031977 <qm_spi_irq_transfer+0xc3>
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031972:	80 e4 fb             	and    $0xfb,%ah
40031975:	eb 03                	jmp    4003197a <qm_spi_irq_transfer+0xc6>
		} else {
			/* Disable MISO line. */
			controller->ctrlr0 |= QM_SPI_CTRLR0_SLV_OE;
40031977:	80 cc 04             	or     $0x4,%ah
4003197a:	89 06                	mov    %eax,(%esi)
		}
	}

	/* Enable SPI controller. */
	controller->ssienr = QM_SPI_SSIENR_SSIENR;
4003197c:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)

	if ((QM_SPI_SLV_0 != spi && QM_SPI_TMOD_RX == tmode[spi]) &&
40031983:	83 fb 02             	cmp    $0x2,%ebx
40031986:	74 20                	je     400319a8 <qm_spi_irq_transfer+0xf4>
40031988:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
4003198f:	02 
40031990:	75 16                	jne    400319a8 <qm_spi_irq_transfer+0xf4>
40031992:	83 3c 9d 00 69 00 a8 	cmpl   $0x0,-0x57ff9700(,%ebx,4)
40031999:	00 
4003199a:	75 0c                	jne    400319a8 <qm_spi_irq_transfer+0xf4>
		/*
		 * In RX only, master is required to send
		 * a dummy frame in order to start the
		 * communication.
		 */
		write_frame(spi, (uint8_t *)&tx_dummy_frame);
4003199c:	ba c4 52 03 40       	mov    $0x400352c4,%edx
400319a1:	89 d8                	mov    %ebx,%eax
400319a3:	e8 9c fb ff ff       	call   40031544 <write_frame>
	}

	return 0;
}
400319a8:	5a                   	pop    %edx
400319a9:	31 c0                	xor    %eax,%eax
400319ab:	5b                   	pop    %ebx
400319ac:	5e                   	pop    %esi
400319ad:	5f                   	pop    %edi
400319ae:	5d                   	pop    %ebp
400319af:	c3                   	ret    

400319b0 <qm_spi_master_0_isr>:

QM_ISR_DECLARE(qm_spi_master_0_isr)
{
400319b0:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
400319b1:	31 c0                	xor    %eax,%eax
{
400319b3:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_0_INT_VECTOR);
}
400319b5:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
400319b6:	e9 00 fc ff ff       	jmp    400315bb <handle_spi_mst_interrupt>

400319bb <qm_spi_master_1_isr>:

#if (QUARK_SE)
QM_ISR_DECLARE(qm_spi_master_1_isr)
{
400319bb:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
400319bc:	b8 01 00 00 00       	mov    $0x1,%eax
{
400319c1:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_1_INT_VECTOR);
}
400319c3:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
400319c4:	e9 f2 fb ff ff       	jmp    400315bb <handle_spi_mst_interrupt>

400319c9 <qm_pmux_select>:
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
	return ((pin % (32 / width)) * width);
400319c9:	89 c1                	mov    %eax,%ecx
}

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
400319cb:	55                   	push   %ebp
	return (pin / (32 / width));
400319cc:	c1 e8 04             	shr    $0x4,%eax
	return ((pin % (32 / width)) * width);
400319cf:	83 e1 0f             	and    $0xf,%ecx
{
400319d2:	89 e5                	mov    %esp,%ebp
	return ((pin % (32 / width)) * width);
400319d4:	01 c9                	add    %ecx,%ecx
{
400319d6:	56                   	push   %esi
400319d7:	53                   	push   %ebx
400319d8:	8d 1c 85 00 09 80 b0 	lea    -0x4f7ff700(,%eax,4),%ebx
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
	uint32_t offs = pin_to_offset(pin, 2);

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
400319df:	b8 03 00 00 00       	mov    $0x3,%eax
400319e4:	d3 e0                	shl    %cl,%eax
400319e6:	8b 73 30             	mov    0x30(%ebx),%esi
400319e9:	f7 d0                	not    %eax
400319eb:	21 f0                	and    %esi,%eax
400319ed:	89 43 30             	mov    %eax,0x30(%ebx)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
400319f0:	8b 43 30             	mov    0x30(%ebx),%eax
400319f3:	d3 e2                	shl    %cl,%edx
400319f5:	09 c2                	or     %eax,%edx

	return 0;
}
400319f7:	31 c0                	xor    %eax,%eax
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
400319f9:	89 53 30             	mov    %edx,0x30(%ebx)
}
400319fc:	5b                   	pop    %ebx
400319fd:	5e                   	pop    %esi
400319fe:	5d                   	pop    %ebp
400319ff:	c3                   	ret    

40031a00 <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
40031a00:	55                   	push   %ebp
40031a01:	89 c1                	mov    %eax,%ecx
40031a03:	89 e5                	mov    %esp,%ebp
40031a05:	53                   	push   %ebx
	return (pin / (32 / width));
40031a06:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031a08:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031a0d:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031a10:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031a12:	84 d2                	test   %dl,%dl
40031a14:	8d 14 9d 00 09 80 b0 	lea    -0x4f7ff700(,%ebx,4),%edx
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031a1b:	8b 4a 20             	mov    0x20(%edx),%ecx
	if (enable == false) {
40031a1e:	75 06                	jne    40031a26 <qm_pmux_input_en+0x26>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031a20:	f7 d0                	not    %eax
40031a22:	21 c8                	and    %ecx,%eax
40031a24:	eb 02                	jmp    40031a28 <qm_pmux_input_en+0x28>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
40031a26:	09 c8                	or     %ecx,%eax
40031a28:	89 42 20             	mov    %eax,0x20(%edx)
	}
	return 0;
}
40031a2b:	31 c0                	xor    %eax,%eax
40031a2d:	5b                   	pop    %ebx
40031a2e:	5d                   	pop    %ebp
40031a2f:	c3                   	ret    

40031a30 <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
40031a30:	55                   	push   %ebp
40031a31:	89 c1                	mov    %eax,%ecx
40031a33:	89 e5                	mov    %esp,%ebp
40031a35:	53                   	push   %ebx
	return (pin / (32 / width));
40031a36:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031a38:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031a3d:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031a40:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031a42:	84 d2                	test   %dl,%dl
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031a44:	8b 14 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edx
	if (enable == false) {
40031a4b:	75 06                	jne    40031a53 <qm_pmux_pullup_en+0x23>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031a4d:	f7 d0                	not    %eax
40031a4f:	21 d0                	and    %edx,%eax
40031a51:	eb 02                	jmp    40031a55 <qm_pmux_pullup_en+0x25>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
40031a53:	09 d0                	or     %edx,%eax
40031a55:	89 04 9d 00 09 80 b0 	mov    %eax,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
40031a5c:	31 c0                	xor    %eax,%eax
40031a5e:	5b                   	pop    %ebx
40031a5f:	5d                   	pop    %ebp
40031a60:	c3                   	ret    

40031a61 <mraa_init>:
mraa_board_t* plat = NULL;
struct _gpio _internalgpios[4];

mraa_result_t
mraa_init()
{
40031a61:	55                   	push   %ebp
40031a62:	89 e5                	mov    %esp,%ebp
#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
    plat = mraa_intel_arduino_101_sss();
#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
    plat = mraa_intel_d2k_crb();
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    plat = mraa_intel_quark_se_devboard();
40031a64:	e8 3d 05 00 00       	call   40031fa6 <mraa_intel_quark_se_devboard>
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
    plat = mraa_intel_quark_se_ss_devboard();
#endif
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
}
40031a69:	5d                   	pop    %ebp
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40031a6a:	83 f8 01             	cmp    $0x1,%eax
    plat = mraa_intel_quark_se_devboard();
40031a6d:	a3 38 69 00 a8       	mov    %eax,0xa8006938
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40031a72:	19 c0                	sbb    %eax,%eax
40031a74:	83 e0 06             	and    $0x6,%eax
}
40031a77:	c3                   	ret    

40031a78 <mraa_setup_mux_mapped>:
    return false;
}

mraa_result_t
mraa_setup_mux_mapped(mraa_pin_t meta)
{
40031a78:	55                   	push   %ebp
    int mi;
    mraa_result_t ret;
    mraa_gpio_context mux_i = NULL;
    int last_pin = -1;
40031a79:	83 c8 ff             	or     $0xffffffff,%eax
{
40031a7c:	89 e5                	mov    %esp,%ebp
40031a7e:	57                   	push   %edi
40031a7f:	56                   	push   %esi
40031a80:	53                   	push   %ebx
40031a81:	83 ec 08             	sub    $0x8,%esp
40031a84:	8d 7d 08             	lea    0x8(%ebp),%edi
    mraa_gpio_context mux_i = NULL;
40031a87:	31 db                	xor    %ebx,%ebx

    for (mi = 0; mi < meta.mux_total; mi++) {
40031a89:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40031a90:	0f b6 55 0a          	movzbl 0xa(%ebp),%edx
40031a94:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40031a97:	0f 8d 8a 01 00 00    	jge    40031c27 <mraa_setup_mux_mapped+0x1af>

        switch (meta.mux[mi].pincmd) {
40031a9d:	80 7f 03 05          	cmpb   $0x5,0x3(%edi)
40031aa1:	0f 87 6f 01 00 00    	ja     40031c16 <mraa_setup_mux_mapped+0x19e>
40031aa7:	0f b6 57 03          	movzbl 0x3(%edi),%edx
40031aab:	0f b6 77 04          	movzbl 0x4(%edi),%esi
                    return MRAA_ERROR_INVALID_RESOURCE;
                }
                break;

            case PINCMD_SET_MODE:
                if (meta.mux[mi].pin != last_pin) {
40031aaf:	89 75 f0             	mov    %esi,-0x10(%ebp)
40031ab2:	39 f0                	cmp    %esi,%eax
        switch (meta.mux[mi].pincmd) {
40031ab4:	ff 24 95 c8 52 03 40 	jmp    *0x400352c8(,%edx,4)
                if (meta.mux[mi].pin != last_pin) {
40031abb:	74 2b                	je     40031ae8 <mraa_setup_mux_mapped+0x70>
                    if (mux_i != NULL) {
40031abd:	85 db                	test   %ebx,%ebx
40031abf:	74 10                	je     40031ad1 <mraa_setup_mux_mapped+0x59>
                        mraa_gpio_owner(mux_i, 0);
40031ac1:	31 d2                	xor    %edx,%edx
40031ac3:	89 d8                	mov    %ebx,%eax
40031ac5:	e8 b7 03 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031aca:	89 d8                	mov    %ebx,%eax
40031acc:	e8 cc 03 00 00       	call   40031e9d <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031ad1:	89 f0                	mov    %esi,%eax
40031ad3:	e8 dc 01 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031ad8:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031ada:	85 c0                	test   %eax,%eax
40031adc:	75 0a                	jne    40031ae8 <mraa_setup_mux_mapped+0x70>
                        return MRAA_ERROR_INVALID_HANDLE;
40031ade:	b8 05 00 00 00       	mov    $0x5,%eax
40031ae3:	e9 57 01 00 00       	jmp    40031c3f <mraa_setup_mux_mapped+0x1c7>
                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40031ae8:	31 d2                	xor    %edx,%edx
40031aea:	89 d8                	mov    %ebx,%eax
40031aec:	e8 f1 02 00 00       	call   40031de2 <mraa_gpio_dir>
40031af1:	e9 c2 00 00 00       	jmp    40031bb8 <mraa_setup_mux_mapped+0x140>
                if (meta.mux[mi].pin != last_pin) {
40031af6:	0f 84 bc 00 00 00    	je     40031bb8 <mraa_setup_mux_mapped+0x140>
                    if (mux_i != NULL) {
40031afc:	85 db                	test   %ebx,%ebx
40031afe:	74 10                	je     40031b10 <mraa_setup_mux_mapped+0x98>
                        mraa_gpio_owner(mux_i, 0);
40031b00:	31 d2                	xor    %edx,%edx
40031b02:	89 d8                	mov    %ebx,%eax
40031b04:	e8 78 03 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031b09:	89 d8                	mov    %ebx,%eax
40031b0b:	e8 8d 03 00 00       	call   40031e9d <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031b10:	89 f0                	mov    %esi,%eax
40031b12:	e8 9d 01 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031b17:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031b19:	85 c0                	test   %eax,%eax
40031b1b:	0f 85 97 00 00 00    	jne    40031bb8 <mraa_setup_mux_mapped+0x140>
40031b21:	eb bb                	jmp    40031ade <mraa_setup_mux_mapped+0x66>
                if (meta.mux[mi].pin != last_pin) {
40031b23:	74 21                	je     40031b46 <mraa_setup_mux_mapped+0xce>
                    if (mux_i != NULL) {
40031b25:	85 db                	test   %ebx,%ebx
40031b27:	74 10                	je     40031b39 <mraa_setup_mux_mapped+0xc1>
                        mraa_gpio_owner(mux_i, 0);
40031b29:	31 d2                	xor    %edx,%edx
40031b2b:	89 d8                	mov    %ebx,%eax
40031b2d:	e8 4f 03 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031b32:	89 d8                	mov    %ebx,%eax
40031b34:	e8 64 03 00 00       	call   40031e9d <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031b39:	89 f0                	mov    %esi,%eax
40031b3b:	e8 74 01 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031b40:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031b42:	85 c0                	test   %eax,%eax
40031b44:	74 98                	je     40031ade <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
40031b46:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40031b4a:	89 d8                	mov    %ebx,%eax
40031b4c:	e8 91 02 00 00       	call   40031de2 <mraa_gpio_dir>
40031b51:	e9 a1 00 00 00       	jmp    40031bf7 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40031b56:	74 25                	je     40031b7d <mraa_setup_mux_mapped+0x105>
                    if (mux_i != NULL) {
40031b58:	85 db                	test   %ebx,%ebx
40031b5a:	74 10                	je     40031b6c <mraa_setup_mux_mapped+0xf4>
                        mraa_gpio_owner(mux_i, 0);
40031b5c:	31 d2                	xor    %edx,%edx
40031b5e:	89 d8                	mov    %ebx,%eax
40031b60:	e8 1c 03 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031b65:	89 d8                	mov    %ebx,%eax
40031b67:	e8 31 03 00 00       	call   40031e9d <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031b6c:	89 f0                	mov    %esi,%eax
40031b6e:	e8 41 01 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031b73:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031b75:	85 c0                	test   %eax,%eax
40031b77:	0f 84 61 ff ff ff    	je     40031ade <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
40031b7d:	ba 01 00 00 00       	mov    $0x1,%edx
40031b82:	eb 29                	jmp    40031bad <mraa_setup_mux_mapped+0x135>
                if (meta.mux[mi].pin != last_pin) {
40031b84:	74 25                	je     40031bab <mraa_setup_mux_mapped+0x133>
                    if (mux_i != NULL) {
40031b86:	85 db                	test   %ebx,%ebx
40031b88:	74 10                	je     40031b9a <mraa_setup_mux_mapped+0x122>
                        mraa_gpio_owner(mux_i, 0);
40031b8a:	31 d2                	xor    %edx,%edx
40031b8c:	89 d8                	mov    %ebx,%eax
40031b8e:	e8 ee 02 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031b93:	89 d8                	mov    %ebx,%eax
40031b95:	e8 03 03 00 00       	call   40031e9d <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031b9a:	89 f0                	mov    %esi,%eax
40031b9c:	e8 13 01 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031ba1:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031ba3:	85 c0                	test   %eax,%eax
40031ba5:	0f 84 33 ff ff ff    	je     40031ade <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40031bab:	31 d2                	xor    %edx,%edx
40031bad:	89 d8                	mov    %ebx,%eax
40031baf:	e8 2e 02 00 00       	call   40031de2 <mraa_gpio_dir>
                if (ret == MRAA_SUCCESS)
40031bb4:	85 c0                	test   %eax,%eax
40031bb6:	75 43                	jne    40031bfb <mraa_setup_mux_mapped+0x183>
                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
40031bb8:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40031bbc:	89 d8                	mov    %ebx,%eax
40031bbe:	e8 95 02 00 00       	call   40031e58 <mraa_gpio_write>
40031bc3:	eb 32                	jmp    40031bf7 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40031bc5:	74 25                	je     40031bec <mraa_setup_mux_mapped+0x174>
                    if (mux_i != NULL) {
40031bc7:	85 db                	test   %ebx,%ebx
40031bc9:	74 10                	je     40031bdb <mraa_setup_mux_mapped+0x163>
                        mraa_gpio_owner(mux_i, 0);
40031bcb:	31 d2                	xor    %edx,%edx
40031bcd:	89 d8                	mov    %ebx,%eax
40031bcf:	e8 ad 02 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031bd4:	89 d8                	mov    %ebx,%eax
40031bd6:	e8 c2 02 00 00       	call   40031e9d <mraa_gpio_close>
                    }
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031bdb:	89 f0                	mov    %esi,%eax
40031bdd:	e8 d2 00 00 00       	call   40031cb4 <mraa_gpio_init_raw>
40031be2:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031be4:	85 c0                	test   %eax,%eax
40031be6:	0f 84 f2 fe ff ff    	je     40031ade <mraa_setup_mux_mapped+0x66>
                        return MRAA_ERROR_INVALID_HANDLE;
                    last_pin = meta.mux[mi].pin;
                }

                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
40031bec:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40031bf0:	89 d8                	mov    %ebx,%eax
40031bf2:	e8 9f 02 00 00       	call   40031e96 <mraa_gpio_mode>

                if (ret != MRAA_SUCCESS) {
40031bf7:	85 c0                	test   %eax,%eax
40031bf9:	74 1e                	je     40031c19 <mraa_setup_mux_mapped+0x1a1>
                    if (mux_i != NULL) {
40031bfb:	85 db                	test   %ebx,%ebx
40031bfd:	74 10                	je     40031c0f <mraa_setup_mux_mapped+0x197>
                        mraa_gpio_owner(mux_i, 0);
40031bff:	31 d2                	xor    %edx,%edx
40031c01:	89 d8                	mov    %ebx,%eax
40031c03:	e8 79 02 00 00       	call   40031e81 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031c08:	89 d8                	mov    %ebx,%eax
40031c0a:	e8 8e 02 00 00       	call   40031e9d <mraa_gpio_close>
                    return MRAA_ERROR_INVALID_RESOURCE;
40031c0f:	b8 07 00 00 00       	mov    $0x7,%eax
40031c14:	eb 29                	jmp    40031c3f <mraa_setup_mux_mapped+0x1c7>
        switch (meta.mux[mi].pincmd) {
40031c16:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (mi = 0; mi < meta.mux_total; mi++) {
40031c19:	ff 45 ec             	incl   -0x14(%ebp)
40031c1c:	83 c7 03             	add    $0x3,%edi
40031c1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031c22:	e9 69 fe ff ff       	jmp    40031a90 <mraa_setup_mux_mapped+0x18>

    if (mux_i != NULL) {
        mraa_gpio_owner(mux_i, 0);
        mraa_gpio_close(mux_i);
    }
    return MRAA_SUCCESS;
40031c27:	31 c0                	xor    %eax,%eax
    if (mux_i != NULL) {
40031c29:	85 db                	test   %ebx,%ebx
40031c2b:	74 12                	je     40031c3f <mraa_setup_mux_mapped+0x1c7>
        mraa_gpio_owner(mux_i, 0);
40031c2d:	31 d2                	xor    %edx,%edx
40031c2f:	89 d8                	mov    %ebx,%eax
40031c31:	e8 4b 02 00 00       	call   40031e81 <mraa_gpio_owner>
        mraa_gpio_close(mux_i);
40031c36:	89 d8                	mov    %ebx,%eax
40031c38:	e8 60 02 00 00       	call   40031e9d <mraa_gpio_close>
    return MRAA_SUCCESS;
40031c3d:	31 c0                	xor    %eax,%eax
}
40031c3f:	5a                   	pop    %edx
40031c40:	59                   	pop    %ecx
40031c41:	5b                   	pop    %ebx
40031c42:	5e                   	pop    %esi
40031c43:	5f                   	pop    %edi
40031c44:	5d                   	pop    %ebp
40031c45:	c3                   	ret    

40031c46 <mraa_set_pininfo>:


// Internal functions
mraa_result_t
mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
{
40031c46:	55                   	push   %ebp
40031c47:	89 e5                	mov    %esp,%ebp
40031c49:	53                   	push   %ebx
    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
    pin_info->gpio.pinmap = zephyr_pin;
40031c4a:	6b da 44             	imul   $0x44,%edx,%ebx
#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB) || defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    pin_info->uart.pinmap = zephyr_pin;
#endif
    pin_info->pwm.pinmap = zephyr_pin;
    pin_info->gpio.mux_total = 0;
    pin_info->name = name;
40031c4d:	42                   	inc    %edx
    pin_info->gpio.pinmap = zephyr_pin;
40031c4e:	01 c3                	add    %eax,%ebx
    pin_info->name = name;
40031c50:	6b d2 44             	imul   $0x44,%edx,%edx
    pin_info->gpio.pinmap = zephyr_pin;
40031c53:	88 4b 4c             	mov    %cl,0x4c(%ebx)
    pin_info->uart.pinmap = zephyr_pin;
40031c56:	88 4b 7c             	mov    %cl,0x7c(%ebx)
    pin_info->pwm.pinmap = zephyr_pin;
40031c59:	88 4b 58             	mov    %cl,0x58(%ebx)
    pin_info->name = name;
40031c5c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    pin_info->gpio.mux_total = 0;
40031c5f:	c6 43 4e 00          	movb   $0x0,0x4e(%ebx)
    pin_info->name = name;
40031c63:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
    pin_info->capabilites = caps;
40031c66:	8a 45 0c             	mov    0xc(%ebp),%al
40031c69:	88 43 48             	mov    %al,0x48(%ebx)
    return MRAA_SUCCESS;
}
40031c6c:	31 c0                	xor    %eax,%eax
40031c6e:	5b                   	pop    %ebx
40031c6f:	5d                   	pop    %ebp
40031c70:	c3                   	ret    

40031c71 <mraa_set_board_config>:


void
mraa_set_board_config(mraa_board_t* board)
{
40031c71:	55                   	push   %ebp
    memset(board, 0, sizeof(mraa_board_t));
40031c72:	b9 48 0d 00 00       	mov    $0xd48,%ecx
{
40031c77:	89 e5                	mov    %esp,%ebp
40031c79:	53                   	push   %ebx
40031c7a:	89 c3                	mov    %eax,%ebx
    memset(board, 0, sizeof(mraa_board_t));
40031c7c:	31 d2                	xor    %edx,%edx
40031c7e:	e8 e7 e3 ff ff       	call   4003006a <memset>
    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
40031c83:	c6 03 31             	movb   $0x31,(%ebx)
    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
40031c86:	c6 43 01 1f          	movb   $0x1f,0x1(%ebx)
    board->aio_count = CONFIG_MRAA_AIO_COUNT;
40031c8a:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
40031c8e:	c6 43 03 02          	movb   $0x2,0x3(%ebx)
    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
40031c92:	c6 43 0b 02          	movb   $0x2,0xb(%ebx)
    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
40031c96:	c6 43 1e 01          	movb   $0x1,0x1e(%ebx)
}
40031c9a:	5b                   	pop    %ebx
40031c9b:	5d                   	pop    %ebp
40031c9c:	c3                   	ret    

40031c9d <gpio_pin_configure>:
{
40031c9d:	55                   	push   %ebp
40031c9e:	89 e5                	mov    %esp,%ebp
40031ca0:	53                   	push   %ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40031ca1:	8b 58 04             	mov    0x4(%eax),%ebx
40031ca4:	51                   	push   %ecx
40031ca5:	0f b6 d2             	movzbl %dl,%edx
40031ca8:	89 d1                	mov    %edx,%ecx
40031caa:	31 d2                	xor    %edx,%edx
40031cac:	ff 13                	call   *(%ebx)
40031cae:	5a                   	pop    %edx
}
40031caf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031cb2:	c9                   	leave  
40031cb3:	c3                   	ret    

40031cb4 <mraa_gpio_init_raw>:
    return dev;
}

mraa_gpio_context
mraa_gpio_init_raw(int gpiopin)
{
40031cb4:	55                   	push   %ebp
40031cb5:	89 e5                	mov    %esp,%ebp
40031cb7:	56                   	push   %esi
40031cb8:	89 c6                	mov    %eax,%esi
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40031cba:	b8 20 00 00 00       	mov    $0x20,%eax
{
40031cbf:	53                   	push   %ebx
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40031cc0:	e8 a3 24 00 00       	call   40034168 <malloc>
40031cc5:	89 c3                	mov    %eax,%ebx
    if (!dev) {
40031cc7:	85 c0                	test   %eax,%eax
40031cc9:	75 13                	jne    40031cde <mraa_gpio_init_raw+0x2a>
        printf("%s: context allocation failed\n", __FUNCTION__);
40031ccb:	68 ac 53 03 40       	push   $0x400353ac
40031cd0:	68 e0 52 03 40       	push   $0x400352e0
40031cd5:	e8 3a 26 00 00       	call   40034314 <iprintf>
40031cda:	58                   	pop    %eax
40031cdb:	5a                   	pop    %edx
40031cdc:	eb 49                	jmp    40031d27 <mraa_gpio_init_raw+0x73>
        return NULL;
    }

    dev->phy_pin = gpiopin;
40031cde:	89 f0                	mov    %esi,%eax
40031ce0:	88 43 01             	mov    %al,0x1(%ebx)
    dev->zdev = device_get_binding(GPIO_DRV_NAME);
40031ce3:	b8 36 52 03 40       	mov    $0x40035236,%eax
40031ce8:	e8 77 19 00 00       	call   40033664 <device_get_binding>
40031ced:	89 43 04             	mov    %eax,0x4(%ebx)
//printf("GPIO : %s", GPIO_DRV_NAME);
    if (dev->zdev == NULL) {
40031cf0:	85 c0                	test   %eax,%eax
40031cf2:	74 2a                	je     40031d1e <mraa_gpio_init_raw+0x6a>
        free(dev);
        return NULL;
    }
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
40031cf4:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
40031cf8:	b9 01 00 00 00       	mov    $0x1,%ecx
40031cfd:	e8 9b ff ff ff       	call   40031c9d <gpio_pin_configure>
    if (ret) {
40031d02:	85 c0                	test   %eax,%eax
40031d04:	74 21                	je     40031d27 <mraa_gpio_init_raw+0x73>
        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
40031d06:	0f be 53 01          	movsbl 0x1(%ebx),%edx
40031d0a:	52                   	push   %edx
40031d0b:	68 36 52 03 40       	push   $0x40035236
40031d10:	50                   	push   %eax
40031d11:	68 ff 52 03 40       	push   $0x400352ff
40031d16:	e8 f9 25 00 00       	call   40034314 <iprintf>
40031d1b:	83 c4 10             	add    $0x10,%esp
        free(dev);
40031d1e:	89 d8                	mov    %ebx,%eax
        return NULL;
40031d20:	31 db                	xor    %ebx,%ebx
        free(dev);
40031d22:	e8 51 24 00 00       	call   40034178 <free>
    }
    return dev;
}
40031d27:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031d2a:	89 d8                	mov    %ebx,%eax
40031d2c:	5b                   	pop    %ebx
40031d2d:	5e                   	pop    %esi
40031d2e:	5d                   	pop    %ebp
40031d2f:	c3                   	ret    

40031d30 <mraa_gpio_init>:
{
40031d30:	55                   	push   %ebp
40031d31:	89 e5                	mov    %esp,%ebp
40031d33:	57                   	push   %edi
40031d34:	56                   	push   %esi
40031d35:	53                   	push   %ebx
40031d36:	53                   	push   %ebx
    mraa_board_t* board = plat;
40031d37:	8b 15 38 69 00 a8    	mov    0xa8006938,%edx
    if (board == NULL) {
40031d3d:	85 d2                	test   %edx,%edx
40031d3f:	75 07                	jne    40031d48 <mraa_gpio_init+0x18>
        printf("gpio: platform not initialised\n");
40031d41:	68 1f 53 03 40       	push   $0x4003531f
40031d46:	eb 37                	jmp    40031d7f <mraa_gpio_init+0x4f>
40031d48:	89 c3                	mov    %eax,%ebx
    if (pin < 0 || pin >= board->phy_pin_count) {
40031d4a:	85 c0                	test   %eax,%eax
40031d4c:	78 07                	js     40031d55 <mraa_gpio_init+0x25>
40031d4e:	0f b6 02             	movzbl (%edx),%eax
40031d51:	39 c3                	cmp    %eax,%ebx
40031d53:	7c 11                	jl     40031d66 <mraa_gpio_init+0x36>
        printf("gpio: pin %i beyond platform definition\n", pin);
40031d55:	53                   	push   %ebx
40031d56:	68 3f 53 03 40       	push   $0x4003533f
40031d5b:	e8 b4 25 00 00       	call   40034314 <iprintf>
40031d60:	5a                   	pop    %edx
40031d61:	59                   	pop    %ecx
        return NULL;
40031d62:	31 c0                	xor    %eax,%eax
40031d64:	eb 74                	jmp    40031dda <mraa_gpio_init+0xaa>
    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
40031d66:	b8 3d 52 03 40       	mov    $0x4003523d,%eax
40031d6b:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031d6e:	e8 f1 18 00 00       	call   40033664 <device_get_binding>
    if (pinmux_dev == NULL) {
40031d73:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031d76:	85 c0                	test   %eax,%eax
40031d78:	75 0d                	jne    40031d87 <mraa_gpio_init+0x57>
        printf("Failed to get binding for pinmux\n");
40031d7a:	68 68 53 03 40       	push   $0x40035368
40031d7f:	e8 90 25 00 00       	call   40034314 <iprintf>
40031d84:	58                   	pop    %eax
40031d85:	eb db                	jmp    40031d62 <mraa_gpio_init+0x32>
    if (board->pins[pin].capabilites.gpio != 1) {
40031d87:	6b f3 44             	imul   $0x44,%ebx,%esi
40031d8a:	01 d6                	add    %edx,%esi
40031d8c:	f6 46 48 02          	testb  $0x2,0x48(%esi)
40031d90:	75 08                	jne    40031d9a <mraa_gpio_init+0x6a>
        printf("gpio: pin %i not capable of gpio\n", pin);
40031d92:	53                   	push   %ebx
40031d93:	68 8a 53 03 40       	push   $0x4003538a
40031d98:	eb c1                	jmp    40031d5b <mraa_gpio_init+0x2b>
    if (board->pins[pin].gpio.mux_total > 0) {
40031d9a:	80 7e 4e 00          	cmpb   $0x0,0x4e(%esi)
40031d9e:	75 15                	jne    40031db5 <mraa_gpio_init+0x85>
    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
40031da0:	6b c3 44             	imul   $0x44,%ebx,%eax
40031da3:	0f b6 44 02 4c       	movzbl 0x4c(%edx,%eax,1),%eax
40031da8:	e8 07 ff ff ff       	call   40031cb4 <mraa_gpio_init_raw>
    if (dev) {
40031dad:	85 c0                	test   %eax,%eax
40031daf:	74 29                	je     40031dda <mraa_gpio_init+0xaa>
        dev->pin = pin;
40031db1:	88 18                	mov    %bl,(%eax)
40031db3:	eb 25                	jmp    40031dda <mraa_gpio_init+0xaa>
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40031db5:	83 ec 0c             	sub    $0xc,%esp
40031db8:	83 c6 4c             	add    $0x4c,%esi
40031dbb:	89 e7                	mov    %esp,%edi
40031dbd:	b9 03 00 00 00       	mov    $0x3,%ecx
40031dc2:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031dc5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40031dc7:	e8 ac fc ff ff       	call   40031a78 <mraa_setup_mux_mapped>
40031dcc:	83 c4 0c             	add    $0xc,%esp
40031dcf:	89 c1                	mov    %eax,%ecx
40031dd1:	8b 55 f0             	mov    -0x10(%ebp),%edx
            return NULL;
40031dd4:	31 c0                	xor    %eax,%eax
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40031dd6:	85 c9                	test   %ecx,%ecx
40031dd8:	74 c6                	je     40031da0 <mraa_gpio_init+0x70>
}
40031dda:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031ddd:	5b                   	pop    %ebx
40031dde:	5e                   	pop    %esi
40031ddf:	5f                   	pop    %edi
40031de0:	5d                   	pop    %ebp
40031de1:	c3                   	ret    

40031de2 <mraa_gpio_dir>:

mraa_result_t
mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
{
40031de2:	55                   	push   %ebp
    int flags = 0;
    uint32_t value = 0;
    switch (dir) {
40031de3:	83 fa 01             	cmp    $0x1,%edx
{
40031de6:	89 e5                	mov    %esp,%ebp
40031de8:	57                   	push   %edi
40031de9:	56                   	push   %esi
40031dea:	53                   	push   %ebx
    switch (dir) {
40031deb:	74 0e                	je     40031dfb <mraa_gpio_dir+0x19>
40031ded:	72 19                	jb     40031e08 <mraa_gpio_dir+0x26>
40031def:	83 fa 02             	cmp    $0x2,%edx
40031df2:	74 0d                	je     40031e01 <mraa_gpio_dir+0x1f>
40031df4:	83 fa 03             	cmp    $0x3,%edx
40031df7:	75 52                	jne    40031e4b <mraa_gpio_dir+0x69>
40031df9:	eb 0d                	jmp    40031e08 <mraa_gpio_dir+0x26>
    uint32_t value = 0;
40031dfb:	31 ff                	xor    %edi,%edi
        case MRAA_GPIO_OUT:
            flags = GPIO_DIR_OUT;
            break;
        case MRAA_GPIO_IN:
            flags = GPIO_DIR_IN;
40031dfd:	31 c9                	xor    %ecx,%ecx
40031dff:	eb 0e                	jmp    40031e0f <mraa_gpio_dir+0x2d>
            break;
        case MRAA_GPIO_OUT_HIGH:
            flags = GPIO_DIR_OUT;
            value = 1;
40031e01:	bf 01 00 00 00       	mov    $0x1,%edi
40031e06:	eb 02                	jmp    40031e0a <mraa_gpio_dir+0x28>
    uint32_t value = 0;
40031e08:	31 ff                	xor    %edi,%edi
            flags = GPIO_DIR_OUT;
40031e0a:	b9 01 00 00 00       	mov    $0x1,%ecx
40031e0f:	89 d3                	mov    %edx,%ebx
40031e11:	89 c6                	mov    %eax,%esi
            value = 0;
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }
    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
40031e13:	0f b6 50 01          	movzbl 0x1(%eax),%edx
40031e17:	8b 40 04             	mov    0x4(%eax),%eax
40031e1a:	e8 7e fe ff ff       	call   40031c9d <gpio_pin_configure>
40031e1f:	85 c0                	test   %eax,%eax
40031e21:	74 07                	je     40031e2a <mraa_gpio_dir+0x48>
        return MRAA_ERROR_UNSPECIFIED;
40031e23:	b8 63 00 00 00       	mov    $0x63,%eax
40031e28:	eb 26                	jmp    40031e50 <mraa_gpio_dir+0x6e>
    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
40031e2a:	83 eb 02             	sub    $0x2,%ebx
40031e2d:	83 fb 01             	cmp    $0x1,%ebx
40031e30:	77 15                	ja     40031e47 <mraa_gpio_dir+0x65>
        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
40031e32:	8b 46 04             	mov    0x4(%esi),%eax
	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40031e35:	31 d2                	xor    %edx,%edx
40031e37:	0f be 4e 01          	movsbl 0x1(%esi),%ecx
40031e3b:	8b 58 04             	mov    0x4(%eax),%ebx
40031e3e:	57                   	push   %edi
40031e3f:	ff 53 04             	call   *0x4(%ebx)
40031e42:	5a                   	pop    %edx
40031e43:	85 c0                	test   %eax,%eax
40031e45:	75 dc                	jne    40031e23 <mraa_gpio_dir+0x41>
            return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
40031e47:	31 c0                	xor    %eax,%eax
40031e49:	eb 05                	jmp    40031e50 <mraa_gpio_dir+0x6e>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
40031e4b:	b8 01 00 00 00       	mov    $0x1,%eax
}
40031e50:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031e53:	5b                   	pop    %ebx
40031e54:	5e                   	pop    %esi
40031e55:	5f                   	pop    %edi
40031e56:	5d                   	pop    %ebp
40031e57:	c3                   	ret    

40031e58 <mraa_gpio_write>:
        return (int) value;
}

mraa_result_t
mraa_gpio_write(mraa_gpio_context dev, int value)
{
40031e58:	55                   	push   %ebp
40031e59:	89 e5                	mov    %esp,%ebp
40031e5b:	56                   	push   %esi
40031e5c:	53                   	push   %ebx
    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
40031e5d:	8b 58 04             	mov    0x4(%eax),%ebx
40031e60:	0f be 48 01          	movsbl 0x1(%eax),%ecx
40031e64:	8b 73 04             	mov    0x4(%ebx),%esi
40031e67:	89 d8                	mov    %ebx,%eax
40031e69:	52                   	push   %edx
40031e6a:	31 d2                	xor    %edx,%edx
40031e6c:	ff 56 04             	call   *0x4(%esi)
40031e6f:	5a                   	pop    %edx
        return MRAA_ERROR_UNSPECIFIED;
    return MRAA_SUCCESS;
40031e70:	83 f8 01             	cmp    $0x1,%eax
40031e73:	19 c0                	sbb    %eax,%eax
}
40031e75:	8d 65 f8             	lea    -0x8(%ebp),%esp
    return MRAA_SUCCESS;
40031e78:	f7 d0                	not    %eax
}
40031e7a:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40031e7b:	83 e0 63             	and    $0x63,%eax
}
40031e7e:	5e                   	pop    %esi
40031e7f:	5d                   	pop    %ebp
40031e80:	c3                   	ret    

40031e81 <mraa_gpio_owner>:
}


mraa_result_t
mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
{
40031e81:	55                   	push   %ebp
    if (dev == NULL) {
40031e82:	85 c0                	test   %eax,%eax
{
40031e84:	89 e5                	mov    %esp,%ebp
    if (dev == NULL) {
40031e86:	74 07                	je     40031e8f <mraa_gpio_owner+0xe>
        return MRAA_ERROR_INVALID_RESOURCE;
    }
    dev->owner = own;
40031e88:	88 50 14             	mov    %dl,0x14(%eax)
    return MRAA_SUCCESS;
40031e8b:	31 c0                	xor    %eax,%eax
40031e8d:	eb 05                	jmp    40031e94 <mraa_gpio_owner+0x13>
        return MRAA_ERROR_INVALID_RESOURCE;
40031e8f:	b8 07 00 00 00       	mov    $0x7,%eax
}
40031e94:	5d                   	pop    %ebp
40031e95:	c3                   	ret    

40031e96 <mraa_gpio_mode>:

mraa_result_t
mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
{
40031e96:	55                   	push   %ebp
    return MRAA_SUCCESS;
}
40031e97:	31 c0                	xor    %eax,%eax
{
40031e99:	89 e5                	mov    %esp,%ebp
}
40031e9b:	5d                   	pop    %ebp
40031e9c:	c3                   	ret    

40031e9d <mraa_gpio_close>:
    return dev->pin;
}

mraa_result_t
mraa_gpio_close(mraa_gpio_context dev)
{
40031e9d:	55                   	push   %ebp
40031e9e:	89 e5                	mov    %esp,%ebp
    free(dev);
40031ea0:	e8 d3 22 00 00       	call   40034178 <free>

    return MRAA_SUCCESS;
}
40031ea5:	31 c0                	xor    %eax,%eax
40031ea7:	5d                   	pop    %ebp
40031ea8:	c3                   	ret    

40031ea9 <spi_configure>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
40031ea9:	55                   	push   %ebp
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
40031eaa:	8b 48 04             	mov    0x4(%eax),%ecx
{
40031ead:	89 e5                	mov    %esp,%ebp
}
40031eaf:	5d                   	pop    %ebp
	return api->configure(dev, config);
40031eb0:	8b 09                	mov    (%ecx),%ecx
40031eb2:	ff e1                	jmp    *%ecx

40031eb4 <spi_transceive>:
 * @retval Negative errno code if failure.
 */
static inline int spi_transceive(struct device *dev,
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
40031eb4:	55                   	push   %ebp
40031eb5:	89 e5                	mov    %esp,%ebp
40031eb7:	53                   	push   %ebx
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
40031eb8:	8b 58 04             	mov    0x4(%eax),%ebx
40031ebb:	ff 75 0c             	pushl  0xc(%ebp)
40031ebe:	ff 75 08             	pushl  0x8(%ebp)
40031ec1:	ff 53 08             	call   *0x8(%ebx)
40031ec4:	5a                   	pop    %edx
40031ec5:	59                   	pop    %ecx
}
40031ec6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031ec9:	c9                   	leave  
40031eca:	c3                   	ret    

40031ecb <mraa_spi_init>:

typedef struct spi_config* spi_config_ptr;

mraa_spi_context
mraa_spi_init(int bus)
{
40031ecb:	55                   	push   %ebp
40031ecc:	89 e5                	mov    %esp,%ebp
40031ece:	56                   	push   %esi
40031ecf:	89 c6                	mov    %eax,%esi
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40031ed1:	b8 10 00 00 00       	mov    $0x10,%eax
{
40031ed6:	53                   	push   %ebx
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40031ed7:	e8 8c 22 00 00       	call   40034168 <malloc>
40031edc:	89 c3                	mov    %eax,%ebx
    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);

    dev->pinmux_dev = pinmux_dev;
#endif

    dev->busnum = bus;
40031ede:	89 f0                	mov    %esi,%eax
40031ee0:	88 03                	mov    %al,(%ebx)
    dev->zdev = device_get_binding(SPI_DRV_NAME);
40031ee2:	b8 29 52 03 40       	mov    $0x40035229,%eax
40031ee7:	e8 78 17 00 00       	call   40033664 <device_get_binding>
40031eec:	89 43 08             	mov    %eax,0x8(%ebx)
    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
40031eef:	b8 08 00 00 00       	mov    $0x8,%eax
40031ef4:	e8 6f 22 00 00       	call   40034168 <malloc>
40031ef9:	89 c6                	mov    %eax,%esi
    // only default settings, can be changed by using the other functions provided
    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
40031efb:	c7 00 83 00 00 00    	movl   $0x83,(%eax)
    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
40031f01:	c7 40 04 80 00 00 00 	movl   $0x80,0x4(%eax)
    dev->config = conf;

    if (spi_configure(dev->zdev, dev->config) != 0) {
40031f08:	89 f2                	mov    %esi,%edx
    dev->config = conf;
40031f0a:	89 43 04             	mov    %eax,0x4(%ebx)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40031f0d:	8b 43 08             	mov    0x8(%ebx),%eax
40031f10:	e8 94 ff ff ff       	call   40031ea9 <spi_configure>
40031f15:	85 c0                	test   %eax,%eax
40031f17:	74 1d                	je     40031f36 <mraa_spi_init+0x6b>
        printf("Unable to configure the SPI Driver\n");
40031f19:	68 bf 53 03 40       	push   $0x400353bf
40031f1e:	e8 f1 23 00 00       	call   40034314 <iprintf>
40031f23:	58                   	pop    %eax
        free(conf);
40031f24:	89 f0                	mov    %esi,%eax
40031f26:	e8 4d 22 00 00       	call   40034178 <free>
        free(dev);
40031f2b:	89 d8                	mov    %ebx,%eax
40031f2d:	e8 46 22 00 00       	call   40034178 <free>
        return NULL;
40031f32:	31 db                	xor    %ebx,%ebx
40031f34:	eb 14                	jmp    40031f4a <mraa_spi_init+0x7f>
    }

    spi_slave_select(dev->zdev, SPI_SLAVE);
40031f36:	8b 43 08             	mov    0x8(%ebx),%eax
	if (!api->slave_select) {
40031f39:	8b 50 04             	mov    0x4(%eax),%edx
40031f3c:	8b 4a 04             	mov    0x4(%edx),%ecx
40031f3f:	85 c9                	test   %ecx,%ecx
40031f41:	74 07                	je     40031f4a <mraa_spi_init+0x7f>
	return api->slave_select(dev, slave);
40031f43:	ba 01 00 00 00       	mov    $0x1,%edx
40031f48:	ff d1                	call   *%ecx

    return dev;
}
40031f4a:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031f4d:	89 d8                	mov    %ebx,%eax
40031f4f:	5b                   	pop    %ebx
40031f50:	5e                   	pop    %esi
40031f51:	5d                   	pop    %ebp
40031f52:	c3                   	ret    

40031f53 <mraa_spi_frequency>:

mraa_result_t
mraa_spi_frequency(mraa_spi_context dev, int hz)
{
    uint32_t freq = 0;
    if (hz > 0) {
40031f53:	85 d2                	test   %edx,%edx
40031f55:	7e 2f                	jle    40031f86 <mraa_spi_frequency+0x33>
{
40031f57:	55                   	push   %ebp
40031f58:	89 d1                	mov    %edx,%ecx
40031f5a:	89 e5                	mov    %esp,%ebp
40031f5c:	56                   	push   %esi
40031f5d:	53                   	push   %ebx
40031f5e:	89 c3                	mov    %eax,%ebx
        freq = sys_clock_hw_cycles_per_sec / hz;
    } else {
        return MRAA_ERROR_INVALID_PARAMETER;
    }

    dev->config->max_sys_freq = freq;
40031f60:	8b 70 04             	mov    0x4(%eax),%esi
        freq = sys_clock_hw_cycles_per_sec / hz;
40031f63:	b8 00 48 e8 01       	mov    $0x1e84800,%eax
40031f68:	99                   	cltd   
40031f69:	f7 f9                	idiv   %ecx
    dev->config->max_sys_freq = freq;
40031f6b:	89 46 04             	mov    %eax,0x4(%esi)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40031f6e:	89 f2                	mov    %esi,%edx
40031f70:	8b 43 08             	mov    0x8(%ebx),%eax
40031f73:	e8 31 ff ff ff       	call   40031ea9 <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
40031f78:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40031f79:	83 f8 01             	cmp    $0x1,%eax
}
40031f7c:	5e                   	pop    %esi
    return MRAA_SUCCESS;
40031f7d:	19 c0                	sbb    %eax,%eax
}
40031f7f:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
40031f80:	f7 d0                	not    %eax
40031f82:	83 e0 63             	and    $0x63,%eax
}
40031f85:	c3                   	ret    
        return MRAA_ERROR_INVALID_PARAMETER;
40031f86:	b8 04 00 00 00       	mov    $0x4,%eax
40031f8b:	c3                   	ret    

40031f8c <mraa_spi_transfer_buf>:
    return MRAA_SUCCESS;
}

mraa_result_t
mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
{
40031f8c:	55                   	push   %ebp
40031f8d:	89 e5                	mov    %esp,%ebp
40031f8f:	53                   	push   %ebx
    mraa_result_t ret;
//printf("data %x %x\n", data[0], data[1]);
//k_busy_wait(1000);
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40031f90:	8b 40 08             	mov    0x8(%eax),%eax
{
40031f93:	8b 5d 08             	mov    0x8(%ebp),%ebx
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40031f96:	53                   	push   %ebx
40031f97:	51                   	push   %ecx
40031f98:	89 d9                	mov    %ebx,%ecx
40031f9a:	e8 15 ff ff ff       	call   40031eb4 <spi_transceive>
40031f9f:	5a                   	pop    %edx
40031fa0:	59                   	pop    %ecx

    return ret;
}
40031fa1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40031fa4:	c9                   	leave  
40031fa5:	c3                   	ret    

40031fa6 <mraa_intel_quark_se_devboard>:
#include "mraa/gpio.h"

static mraa_board_t _board;

mraa_board_t* mraa_intel_quark_se_devboard()
{
40031fa6:	55                   	push   %ebp
    mraa_board_t* b = &_board;
    mraa_set_board_config(b);
40031fa7:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
{
40031fac:	89 e5                	mov    %esp,%ebp
40031fae:	57                   	push   %edi
40031faf:	56                   	push   %esi
40031fb0:	53                   	push   %ebx
40031fb1:	83 ec 10             	sub    $0x10,%esp
    mraa_set_board_config(b);
40031fb4:	e8 b8 fc ff ff       	call   40031c71 <mraa_set_board_config>
b->phy_pin_count = 94;
    //b->platform_type = MRAA_INTEL_QUARK_SE_DEVBOARD;

// header - J14
#if 1
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fb9:	b9 01 00 00 00       	mov    $0x1,%ecx
40031fbe:	ba 01 00 00 00       	mov    $0x1,%edx
40031fc3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40031fc8:	6a 00                	push   $0x0
    b->platform_name = "Quark SE Devboard/C1000 x86";
40031fca:	c7 05 7c 69 00 a8 e3 	movl   $0x400353e3,0xa800697c
40031fd1:	53 03 40 
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fd4:	68 ff 53 03 40       	push   $0x400353ff
b->phy_pin_count = 94;
40031fd9:	c6 05 40 69 00 a8 5e 	movb   $0x5e,0xa8006940
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031fe0:	e8 61 fc ff ff       	call   40031c46 <mraa_set_pininfo>
40031fe5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40031fe6:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40031feb:	59                   	pop    %ecx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40031fec:	ba 02 00 00 00       	mov    $0x2,%edx
40031ff1:	b9 02 00 00 00       	mov    $0x2,%ecx
40031ff6:	6a 00                	push   $0x0
40031ff8:	68 ff 53 03 40       	push   $0x400353ff
40031ffd:	e8 44 fc ff ff       	call   40031c46 <mraa_set_pininfo>
40032002:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032003:	b9 1f 00 00 00       	mov    $0x1f,%ecx
40032008:	8a 1d a0 51 03 40    	mov    0x400351a0,%bl
4003200e:	ba 03 00 00 00       	mov    $0x3,%edx
40032013:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40032018:	5e                   	pop    %esi
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032019:	53                   	push   %ebx
4003201a:	68 07 54 03 40       	push   $0x40035407
4003201f:	e8 22 fc ff ff       	call   40031c46 <mraa_set_pininfo>
40032024:	5f                   	pop    %edi
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032025:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032027:	58                   	pop    %eax
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032028:	ba 04 00 00 00       	mov    $0x4,%edx
4003202d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032032:	53                   	push   %ebx
40032033:	68 1b 54 03 40       	push   $0x4003541b
40032038:	e8 09 fc ff ff       	call   40031c46 <mraa_set_pininfo>
4003203d:	58                   	pop    %eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003203e:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032043:	5a                   	pop    %edx
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032044:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032049:	ba 05 00 00 00       	mov    $0x5,%edx
4003204e:	53                   	push   %ebx
4003204f:	68 31 54 03 40       	push   $0x40035431
40032054:	e8 ed fb ff ff       	call   40031c46 <mraa_set_pininfo>
40032059:	59                   	pop    %ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003205a:	ba 06 00 00 00       	mov    $0x6,%edx
4003205f:	b9 12 00 00 00       	mov    $0x12,%ecx
40032064:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032069:	5e                   	pop    %esi
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003206a:	53                   	push   %ebx
4003206b:	68 44 54 03 40       	push   $0x40035444
40032070:	e8 d1 fb ff ff       	call   40031c46 <mraa_set_pininfo>
40032075:	5f                   	pop    %edi
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032076:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003207b:	58                   	pop    %eax
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003207c:	ba 07 00 00 00       	mov    $0x7,%edx
40032081:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032086:	53                   	push   %ebx
40032087:	68 5a 54 03 40       	push   $0x4003545a
4003208c:	e8 b5 fb ff ff       	call   40031c46 <mraa_set_pininfo>
40032091:	58                   	pop    %eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032092:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032097:	5a                   	pop    %edx
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032098:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003209d:	ba 08 00 00 00       	mov    $0x8,%edx
400320a2:	53                   	push   %ebx
400320a3:	68 77 54 03 40       	push   $0x40035477
400320a8:	e8 99 fb ff ff       	call   40031c46 <mraa_set_pininfo>
400320ad:	59                   	pop    %ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320ae:	ba 09 00 00 00       	mov    $0x9,%edx
400320b3:	b9 03 00 00 00       	mov    $0x3,%ecx
400320b8:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320bd:	5e                   	pop    %esi
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320be:	53                   	push   %ebx
400320bf:	68 83 54 03 40       	push   $0x40035483
400320c4:	e8 7d fb ff ff       	call   40031c46 <mraa_set_pininfo>
400320c9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320ca:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320cf:	58                   	pop    %eax
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320d0:	ba 0a 00 00 00       	mov    $0xa,%edx
400320d5:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400320da:	53                   	push   %ebx
400320db:	68 a0 54 03 40       	push   $0x400354a0
400320e0:	e8 61 fb ff ff       	call   40031c46 <mraa_set_pininfo>
400320e5:	58                   	pop    %eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400320e6:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400320eb:	5a                   	pop    %edx
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400320ec:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400320f1:	ba 0b 00 00 00       	mov    $0xb,%edx
400320f6:	6a 00                	push   $0x0
400320f8:	68 ac 54 03 40       	push   $0x400354ac
400320fd:	e8 44 fb ff ff       	call   40031c46 <mraa_set_pininfo>
40032102:	59                   	pop    %ecx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032103:	ba 0c 00 00 00       	mov    $0xc,%edx
40032108:	b9 0c 00 00 00       	mov    $0xc,%ecx
4003210d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032112:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032113:	6a 00                	push   $0x0
40032115:	68 ac 54 03 40       	push   $0x400354ac
4003211a:	e8 27 fb ff ff       	call   40031c46 <mraa_set_pininfo>
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003211f:	8a 1d a1 51 03 40    	mov    0x400351a1,%bl
40032125:	b9 04 00 00 00       	mov    $0x4,%ecx
4003212a:	ba 0d 00 00 00       	mov    $0xd,%edx
4003212f:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032134:	5e                   	pop    %esi
40032135:	5f                   	pop    %edi
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032136:	53                   	push   %ebx
40032137:	68 b0 54 03 40       	push   $0x400354b0
4003213c:	e8 05 fb ff ff       	call   40031c46 <mraa_set_pininfo>
40032141:	58                   	pop    %eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032142:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032147:	5a                   	pop    %edx
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032148:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003214d:	ba 0e 00 00 00       	mov    $0xe,%edx
40032152:	6a 01                	push   $0x1
40032154:	68 be 54 03 40       	push   $0x400354be
40032159:	e8 e8 fa ff ff       	call   40031c46 <mraa_set_pininfo>
4003215e:	59                   	pop    %ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003215f:	ba 0f 00 00 00       	mov    $0xf,%edx
40032164:	b9 05 00 00 00       	mov    $0x5,%ecx
40032169:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003216e:	5e                   	pop    %esi
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003216f:	53                   	push   %ebx
40032170:	68 d0 54 03 40       	push   $0x400354d0
40032175:	e8 cc fa ff ff       	call   40031c46 <mraa_set_pininfo>
4003217a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003217b:	b9 10 00 00 00       	mov    $0x10,%ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032180:	58                   	pop    %eax
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032181:	ba 10 00 00 00       	mov    $0x10,%edx
40032186:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003218b:	6a 01                	push   $0x1
4003218d:	68 de 54 03 40       	push   $0x400354de
40032192:	e8 af fa ff ff       	call   40031c46 <mraa_set_pininfo>
40032197:	58                   	pop    %eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032198:	b9 06 00 00 00       	mov    $0x6,%ecx
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003219d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003219e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400321a3:	ba 11 00 00 00       	mov    $0x11,%edx
400321a8:	53                   	push   %ebx
400321a9:	68 f0 54 03 40       	push   $0x400354f0
400321ae:	e8 93 fa ff ff       	call   40031c46 <mraa_set_pininfo>
400321b3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400321b4:	ba 12 00 00 00       	mov    $0x12,%edx
400321b9:	b9 12 00 00 00       	mov    $0x12,%ecx
400321be:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400321c3:	5e                   	pop    %esi
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400321c4:	6a 01                	push   $0x1
400321c6:	68 02 55 03 40       	push   $0x40035502
400321cb:	e8 76 fa ff ff       	call   40031c46 <mraa_set_pininfo>
400321d0:	5f                   	pop    %edi
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400321d1:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400321d6:	58                   	pop    %eax
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400321d7:	ba 13 00 00 00       	mov    $0x13,%edx
400321dc:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400321e1:	53                   	push   %ebx
400321e2:	68 14 55 03 40       	push   $0x40035514
400321e7:	e8 5a fa ff ff       	call   40031c46 <mraa_set_pininfo>
400321ec:	58                   	pop    %eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400321ed:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400321f2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400321f3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400321f8:	ba 14 00 00 00       	mov    $0x14,%edx
400321fd:	6a 01                	push   $0x1
400321ff:	68 2b 55 03 40       	push   $0x4003552b
40032204:	e8 3d fa ff ff       	call   40031c46 <mraa_set_pininfo>
40032209:	59                   	pop    %ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
4003220a:	ba 15 00 00 00       	mov    $0x15,%edx
4003220f:	b9 0f 00 00 00       	mov    $0xf,%ecx
40032214:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032219:	5e                   	pop    %esi
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
4003221a:	53                   	push   %ebx
4003221b:	68 3d 55 03 40       	push   $0x4003553d
40032220:	e8 21 fa ff ff       	call   40031c46 <mraa_set_pininfo>
40032225:	5f                   	pop    %edi
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40032226:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
4003222b:	58                   	pop    %eax
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
4003222c:	ba 16 00 00 00       	mov    $0x16,%edx
40032231:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032236:	6a 01                	push   $0x1
40032238:	68 54 55 03 40       	push   $0x40035554
4003223d:	e8 04 fa ff ff       	call   40031c46 <mraa_set_pininfo>
40032242:	58                   	pop    %eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032243:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40032248:	5a                   	pop    %edx
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032249:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003224e:	ba 17 00 00 00       	mov    $0x17,%edx
40032253:	6a 00                	push   $0x0
40032255:	68 ff 53 03 40       	push   $0x400353ff
4003225a:	e8 e7 f9 ff ff       	call   40031c46 <mraa_set_pininfo>
4003225f:	59                   	pop    %ecx
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032260:	ba 18 00 00 00       	mov    $0x18,%edx
40032265:	b9 14 00 00 00       	mov    $0x14,%ecx
4003226a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003226f:	5e                   	pop    %esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032270:	6a 01                	push   $0x1
40032272:	68 66 55 03 40       	push   $0x40035566
40032277:	e8 ca f9 ff ff       	call   40031c46 <mraa_set_pininfo>
4003227c:	5f                   	pop    %edi
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003227d:	0f b6 35 a2 51 03 40 	movzbl 0x400351a2,%esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032284:	58                   	pop    %eax
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032285:	31 c9                	xor    %ecx,%ecx
40032287:	ba 19 00 00 00       	mov    $0x19,%edx
4003228c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032291:	56                   	push   %esi
40032292:	68 78 55 03 40       	push   $0x40035578
40032297:	e8 aa f9 ff ff       	call   40031c46 <mraa_set_pininfo>
4003229c:	58                   	pop    %eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003229d:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400322a2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400322a3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400322a8:	ba 1a 00 00 00       	mov    $0x1a,%edx
400322ad:	6a 00                	push   $0x0
400322af:	68 ff 53 03 40       	push   $0x400353ff
400322b4:	e8 8d f9 ff ff       	call   40031c46 <mraa_set_pininfo>
400322b9:	59                   	pop    %ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400322ba:	ba 1b 00 00 00       	mov    $0x1b,%edx
400322bf:	b9 01 00 00 00       	mov    $0x1,%ecx
400322c4:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400322c9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400322ca:	56                   	push   %esi
400322cb:	68 8a 55 03 40       	push   $0x4003558a
400322d0:	e8 71 f9 ff ff       	call   40031c46 <mraa_set_pininfo>
400322d5:	58                   	pop    %eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400322d6:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400322db:	5a                   	pop    %edx
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400322dc:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400322e1:	ba 1c 00 00 00       	mov    $0x1c,%edx
400322e6:	53                   	push   %ebx
400322e7:	68 9c 55 03 40       	push   $0x4003559c
400322ec:	e8 55 f9 ff ff       	call   40031c46 <mraa_set_pininfo>
400322f1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400322f2:	ba 1d 00 00 00       	mov    $0x1d,%edx
400322f7:	b9 02 00 00 00       	mov    $0x2,%ecx
400322fc:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032301:	5f                   	pop    %edi
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032302:	56                   	push   %esi
40032303:	68 ae 55 03 40       	push   $0x400355ae
40032308:	e8 39 f9 ff ff       	call   40031c46 <mraa_set_pininfo>
4003230d:	58                   	pop    %eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003230e:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032313:	5a                   	pop    %edx
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032314:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032319:	ba 1e 00 00 00       	mov    $0x1e,%edx
4003231e:	53                   	push   %ebx
4003231f:	68 c0 55 03 40       	push   $0x400355c0
40032324:	e8 1d f9 ff ff       	call   40031c46 <mraa_set_pininfo>
40032329:	59                   	pop    %ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003232a:	ba 1f 00 00 00       	mov    $0x1f,%edx
4003232f:	b9 03 00 00 00       	mov    $0x3,%ecx
40032334:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032339:	5f                   	pop    %edi
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003233a:	56                   	push   %esi
4003233b:	68 d3 55 03 40       	push   $0x400355d3
40032340:	e8 01 f9 ff ff       	call   40031c46 <mraa_set_pininfo>
40032345:	58                   	pop    %eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032346:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003234b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003234c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032351:	ba 20 00 00 00       	mov    $0x20,%edx
40032356:	53                   	push   %ebx
40032357:	68 e5 55 03 40       	push   $0x400355e5
4003235c:	e8 e5 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
40032361:	59                   	pop    %ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032362:	ba 21 00 00 00       	mov    $0x21,%edx
40032367:	b9 21 00 00 00       	mov    $0x21,%ecx
4003236c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032371:	5e                   	pop    %esi
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032372:	6a 00                	push   $0x0
40032374:	68 ac 54 03 40       	push   $0x400354ac
40032379:	e8 c8 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
4003237e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003237f:	b9 12 00 00 00       	mov    $0x12,%ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032384:	58                   	pop    %eax
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032385:	ba 22 00 00 00       	mov    $0x22,%edx
4003238a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003238f:	53                   	push   %ebx
40032390:	68 f7 55 03 40       	push   $0x400355f7
40032395:	e8 ac f8 ff ff       	call   40031c46 <mraa_set_pininfo>
4003239a:	58                   	pop    %eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003239b:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003239d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003239e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400323a3:	ba 23 00 00 00       	mov    $0x23,%edx
400323a8:	53                   	push   %ebx
400323a9:	68 0a 56 03 40       	push   $0x4003560a
400323ae:	e8 93 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
400323b3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323b4:	ba 24 00 00 00       	mov    $0x24,%edx
400323b9:	b9 13 00 00 00       	mov    $0x13,%ecx
400323be:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400323c3:	5e                   	pop    %esi
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323c4:	53                   	push   %ebx
400323c5:	68 17 56 03 40       	push   $0x40035617
400323ca:	e8 77 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
400323cf:	5f                   	pop    %edi
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400323d0:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323d5:	58                   	pop    %eax
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400323d6:	ba 25 00 00 00       	mov    $0x25,%edx
400323db:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400323e0:	53                   	push   %ebx
400323e1:	68 29 56 03 40       	push   $0x40035629
400323e6:	e8 5b f8 ff ff       	call   40031c46 <mraa_set_pininfo>
400323eb:	58                   	pop    %eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323ec:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400323f1:	5a                   	pop    %edx
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400323f2:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400323f7:	ba 26 00 00 00       	mov    $0x26,%edx
400323fc:	53                   	push   %ebx
400323fd:	68 36 56 03 40       	push   $0x40035636
40032402:	e8 3f f8 ff ff       	call   40031c46 <mraa_set_pininfo>
40032407:	59                   	pop    %ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032408:	ba 27 00 00 00       	mov    $0x27,%edx
4003240d:	b9 02 00 00 00       	mov    $0x2,%ecx
40032412:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032417:	5e                   	pop    %esi
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032418:	53                   	push   %ebx
40032419:	68 48 56 03 40       	push   $0x40035648
4003241e:	e8 23 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
40032423:	5f                   	pop    %edi
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032424:	b9 28 00 00 00       	mov    $0x28,%ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032429:	58                   	pop    %eax
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003242a:	ba 28 00 00 00       	mov    $0x28,%edx
4003242f:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032434:	6a 00                	push   $0x0
40032436:	68 ac 54 03 40       	push   $0x400354ac
4003243b:	e8 06 f8 ff ff       	call   40031c46 <mraa_set_pininfo>
40032440:	58                   	pop    %eax
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032441:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032446:	5a                   	pop    %edx
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032447:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003244c:	ba 29 00 00 00       	mov    $0x29,%edx
40032451:	53                   	push   %ebx
40032452:	68 55 56 03 40       	push   $0x40035655
40032457:	e8 ea f7 ff ff       	call   40031c46 <mraa_set_pininfo>
4003245c:	59                   	pop    %ecx
4003245d:	5e                   	pop    %esi
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003245e:	b9 01 00 00 00       	mov    $0x1,%ecx
40032463:	0f b6 35 a3 51 03 40 	movzbl 0x400351a3,%esi
4003246a:	ba 2a 00 00 00       	mov    $0x2a,%edx
4003246f:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032474:	56                   	push   %esi
40032475:	68 62 56 03 40       	push   $0x40035662
4003247a:	e8 c7 f7 ff ff       	call   40031c46 <mraa_set_pininfo>
4003247f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032480:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032485:	58                   	pop    %eax
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032486:	ba 2b 00 00 00       	mov    $0x2b,%edx
4003248b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032490:	53                   	push   %ebx
40032491:	68 71 56 03 40       	push   $0x40035671
40032496:	e8 ab f7 ff ff       	call   40031c46 <mraa_set_pininfo>
4003249b:	58                   	pop    %eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003249c:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400324a1:	5a                   	pop    %edx
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
400324a2:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400324a7:	ba 2c 00 00 00       	mov    $0x2c,%edx
400324ac:	56                   	push   %esi
400324ad:	68 7e 56 03 40       	push   $0x4003567e
400324b2:	e8 8f f7 ff ff       	call   40031c46 <mraa_set_pininfo>
400324b7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400324b8:	ba 2d 00 00 00       	mov    $0x2d,%edx
400324bd:	b9 05 00 00 00       	mov    $0x5,%ecx
400324c2:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
400324c7:	5f                   	pop    %edi
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400324c8:	53                   	push   %ebx
400324c9:	68 8d 56 03 40       	push   $0x4003568d
400324ce:	e8 73 f7 ff ff       	call   40031c46 <mraa_set_pininfo>
400324d3:	58                   	pop    %eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324d4:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400324d6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324d7:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400324dc:	ba 2e 00 00 00       	mov    $0x2e,%edx
400324e1:	6a 00                	push   $0x0
400324e3:	68 9a 56 03 40       	push   $0x4003569a
400324e8:	e8 59 f7 ff ff       	call   40031c46 <mraa_set_pininfo>
400324ed:	59                   	pop    %ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400324ee:	ba 2f 00 00 00       	mov    $0x2f,%edx
400324f3:	b9 07 00 00 00       	mov    $0x7,%ecx
400324f8:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324fd:	5f                   	pop    %edi
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400324fe:	53                   	push   %ebx
400324ff:	68 a0 56 03 40       	push   $0x400356a0
40032504:	e8 3d f7 ff ff       	call   40031c46 <mraa_set_pininfo>
40032509:	58                   	pop    %eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003250a:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003250c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003250d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032512:	ba 30 00 00 00       	mov    $0x30,%edx
40032517:	6a 00                	push   $0x0
40032519:	68 ae 56 03 40       	push   $0x400356ae
4003251e:	e8 23 f7 ff ff       	call   40031c46 <mraa_set_pininfo>
40032523:	59                   	pop    %ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032524:	ba 31 00 00 00       	mov    $0x31,%edx
40032529:	b9 31 00 00 00       	mov    $0x31,%ecx
4003252e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032533:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032534:	6a 00                	push   $0x0
40032536:	68 ff 53 03 40       	push   $0x400353ff
4003253b:	e8 06 f7 ff ff       	call   40031c46 <mraa_set_pininfo>
40032540:	5f                   	pop    %edi
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032541:	b9 32 00 00 00       	mov    $0x32,%ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032546:	58                   	pop    %eax
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032547:	ba 32 00 00 00       	mov    $0x32,%edx
4003254c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032551:	6a 00                	push   $0x0
40032553:	68 ff 53 03 40       	push   $0x400353ff
40032558:	e8 e9 f6 ff ff       	call   40031c46 <mraa_set_pininfo>
4003255d:	58                   	pop    %eax
#endif
// the other big header - J15
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003255e:	b9 33 00 00 00       	mov    $0x33,%ecx
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032563:	5a                   	pop    %edx
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032564:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032569:	ba 33 00 00 00       	mov    $0x33,%edx
4003256e:	6a 00                	push   $0x0
40032570:	68 ff 53 03 40       	push   $0x400353ff
40032575:	e8 cc f6 ff ff       	call   40031c46 <mraa_set_pininfo>
4003257a:	59                   	pop    %ecx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003257b:	ba 34 00 00 00       	mov    $0x34,%edx
40032580:	b9 34 00 00 00       	mov    $0x34,%ecx
40032585:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003258a:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003258b:	6a 00                	push   $0x0
4003258d:	68 ff 53 03 40       	push   $0x400353ff
40032592:	e8 af f6 ff ff       	call   40031c46 <mraa_set_pininfo>
40032597:	5f                   	pop    %edi
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032598:	0f b6 3d a4 51 03 40 	movzbl 0x400351a4,%edi
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003259f:	58                   	pop    %eax
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400325a0:	31 c9                	xor    %ecx,%ecx
400325a2:	ba 35 00 00 00       	mov    $0x35,%edx
400325a7:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325ac:	57                   	push   %edi
400325ad:	68 bc 56 03 40       	push   $0x400356bc
400325b2:	e8 8f f6 ff ff       	call   40031c46 <mraa_set_pininfo>
400325b7:	58                   	pop    %eax
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325b8:	8a 1d a5 51 03 40    	mov    0x400351a5,%bl
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400325be:	5a                   	pop    %edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325bf:	b9 15 00 00 00       	mov    $0x15,%ecx
400325c4:	ba 36 00 00 00       	mov    $0x36,%edx
400325c9:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325ce:	53                   	push   %ebx
400325cf:	68 cb 56 03 40       	push   $0x400356cb
400325d4:	e8 6d f6 ff ff       	call   40031c46 <mraa_set_pininfo>
400325d9:	59                   	pop    %ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400325da:	ba 37 00 00 00       	mov    $0x37,%edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325df:	58                   	pop    %eax
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400325e0:	31 c9                	xor    %ecx,%ecx
400325e2:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325e7:	57                   	push   %edi
400325e8:	68 e0 56 03 40       	push   $0x400356e0
400325ed:	e8 54 f6 ff ff       	call   40031c46 <mraa_set_pininfo>
400325f2:	58                   	pop    %eax
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325f3:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400325f8:	5a                   	pop    %edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400325f9:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325fe:	ba 38 00 00 00       	mov    $0x38,%edx
40032603:	53                   	push   %ebx
40032604:	68 f0 56 03 40       	push   $0x400356f0
40032609:	e8 38 f6 ff ff       	call   40031c46 <mraa_set_pininfo>
4003260e:	59                   	pop    %ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003260f:	ba 39 00 00 00       	mov    $0x39,%edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032614:	58                   	pop    %eax
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032615:	31 c9                	xor    %ecx,%ecx
40032617:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003261c:	57                   	push   %edi
4003261d:	68 06 57 03 40       	push   $0x40035706
40032622:	e8 1f f6 ff ff       	call   40031c46 <mraa_set_pininfo>
40032627:	58                   	pop    %eax
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032628:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003262d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003262e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032633:	ba 3a 00 00 00       	mov    $0x3a,%edx
40032638:	53                   	push   %ebx
40032639:	68 16 57 03 40       	push   $0x40035716
4003263e:	e8 03 f6 ff ff       	call   40031c46 <mraa_set_pininfo>
40032643:	59                   	pop    %ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032644:	ba 3b 00 00 00       	mov    $0x3b,%edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032649:	58                   	pop    %eax
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003264a:	31 c9                	xor    %ecx,%ecx
4003264c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032651:	57                   	push   %edi
40032652:	68 2c 57 03 40       	push   $0x4003572c
40032657:	e8 ea f5 ff ff       	call   40031c46 <mraa_set_pininfo>
4003265c:	58                   	pop    %eax
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003265d:	b9 18 00 00 00       	mov    $0x18,%ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032662:	5a                   	pop    %edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032663:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032668:	ba 3c 00 00 00       	mov    $0x3c,%edx
4003266d:	53                   	push   %ebx
4003266e:	68 3d 57 03 40       	push   $0x4003573d
40032673:	e8 ce f5 ff ff       	call   40031c46 <mraa_set_pininfo>
40032678:	59                   	pop    %ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032679:	ba 3d 00 00 00       	mov    $0x3d,%edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003267e:	58                   	pop    %eax
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003267f:	31 c9                	xor    %ecx,%ecx
40032681:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032686:	57                   	push   %edi
40032687:	68 54 57 03 40       	push   $0x40035754
4003268c:	e8 b5 f5 ff ff       	call   40031c46 <mraa_set_pininfo>
40032691:	58                   	pop    %eax
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032692:	b9 19 00 00 00       	mov    $0x19,%ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032697:	5a                   	pop    %edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032698:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003269d:	ba 3e 00 00 00       	mov    $0x3e,%edx
400326a2:	53                   	push   %ebx
400326a3:	68 65 57 03 40       	push   $0x40035765
400326a8:	e8 99 f5 ff ff       	call   40031c46 <mraa_set_pininfo>
400326ad:	59                   	pop    %ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326ae:	ba 3f 00 00 00       	mov    $0x3f,%edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326b3:	58                   	pop    %eax
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326b4:	b9 1d 00 00 00       	mov    $0x1d,%ecx
400326b9:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400326be:	53                   	push   %ebx
400326bf:	68 7c 57 03 40       	push   $0x4003577c
400326c4:	e8 7d f5 ff ff       	call   40031c46 <mraa_set_pininfo>
400326c9:	58                   	pop    %eax
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326ca:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326cf:	5a                   	pop    %edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326d0:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400326d5:	ba 40 00 00 00       	mov    $0x40,%edx
400326da:	53                   	push   %ebx
400326db:	68 94 57 03 40       	push   $0x40035794
400326e0:	e8 61 f5 ff ff       	call   40031c46 <mraa_set_pininfo>
400326e5:	59                   	pop    %ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326e6:	ba 41 00 00 00       	mov    $0x41,%edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326eb:	58                   	pop    %eax
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400326ec:	b9 1e 00 00 00       	mov    $0x1e,%ecx
400326f1:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400326f6:	53                   	push   %ebx
400326f7:	68 ab 57 03 40       	push   $0x400357ab
400326fc:	e8 45 f5 ff ff       	call   40031c46 <mraa_set_pininfo>
40032701:	58                   	pop    %eax
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032702:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032707:	5a                   	pop    %edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032708:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003270d:	ba 42 00 00 00       	mov    $0x42,%edx
40032712:	53                   	push   %ebx
40032713:	68 c3 57 03 40       	push   $0x400357c3
40032718:	e8 29 f5 ff ff       	call   40031c46 <mraa_set_pininfo>
4003271d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003271e:	ba 43 00 00 00       	mov    $0x43,%edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032723:	58                   	pop    %eax
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032724:	b9 43 00 00 00       	mov    $0x43,%ecx
40032729:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003272e:	6a 00                	push   $0x0
40032730:	68 ac 54 03 40       	push   $0x400354ac
40032735:	e8 0c f5 ff ff       	call   40031c46 <mraa_set_pininfo>
4003273a:	58                   	pop    %eax
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003273b:	b9 44 00 00 00       	mov    $0x44,%ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032740:	5a                   	pop    %edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032741:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032746:	ba 44 00 00 00       	mov    $0x44,%edx
4003274b:	6a 00                	push   $0x0
4003274d:	68 ac 54 03 40       	push   $0x400354ac
40032752:	e8 ef f4 ff ff       	call   40031c46 <mraa_set_pininfo>
40032757:	59                   	pop    %ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032758:	ba 45 00 00 00       	mov    $0x45,%edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003275d:	58                   	pop    %eax
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003275e:	31 c9                	xor    %ecx,%ecx
40032760:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032765:	57                   	push   %edi
40032766:	68 de 57 03 40       	push   $0x400357de
4003276b:	e8 d6 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
40032770:	58                   	pop    %eax
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032771:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032776:	5a                   	pop    %edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032777:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003277c:	ba 46 00 00 00       	mov    $0x46,%edx
40032781:	53                   	push   %ebx
40032782:	68 ed 57 03 40       	push   $0x400357ed
40032787:	e8 ba f4 ff ff       	call   40031c46 <mraa_set_pininfo>
4003278c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003278d:	ba 47 00 00 00       	mov    $0x47,%edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032792:	58                   	pop    %eax
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032793:	31 c9                	xor    %ecx,%ecx
40032795:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003279a:	57                   	push   %edi
4003279b:	68 01 58 03 40       	push   $0x40035801
400327a0:	e8 a1 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
400327a5:	58                   	pop    %eax
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327a6:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327ab:	5a                   	pop    %edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327ac:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400327b1:	ba 48 00 00 00       	mov    $0x48,%edx
400327b6:	53                   	push   %ebx
400327b7:	68 11 58 03 40       	push   $0x40035811
400327bc:	e8 85 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
400327c1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327c2:	ba 49 00 00 00       	mov    $0x49,%edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327c7:	58                   	pop    %eax
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327c8:	31 c9                	xor    %ecx,%ecx
400327ca:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400327cf:	57                   	push   %edi
400327d0:	68 26 58 03 40       	push   $0x40035826
400327d5:	e8 6c f4 ff ff       	call   40031c46 <mraa_set_pininfo>
400327da:	58                   	pop    %eax
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327db:	b9 0a 00 00 00       	mov    $0xa,%ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327e0:	5a                   	pop    %edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327e1:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400327e6:	ba 4a 00 00 00       	mov    $0x4a,%edx
400327eb:	53                   	push   %ebx
400327ec:	68 36 58 03 40       	push   $0x40035836
400327f1:	e8 50 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
400327f6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327f7:	ba 4b 00 00 00       	mov    $0x4b,%edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400327fc:	58                   	pop    %eax
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
400327fd:	31 c9                	xor    %ecx,%ecx
400327ff:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032804:	57                   	push   %edi
40032805:	68 4c 58 03 40       	push   $0x4003584c
4003280a:	e8 37 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
4003280f:	58                   	pop    %eax
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032810:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032815:	5a                   	pop    %edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032816:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003281b:	ba 4c 00 00 00       	mov    $0x4c,%edx
40032820:	53                   	push   %ebx
40032821:	68 5d 58 03 40       	push   $0x4003585d
40032826:	e8 1b f4 ff ff       	call   40031c46 <mraa_set_pininfo>
4003282b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003282c:	ba 4d 00 00 00       	mov    $0x4d,%edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032831:	58                   	pop    %eax
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032832:	31 c9                	xor    %ecx,%ecx
40032834:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032839:	57                   	push   %edi
4003283a:	68 74 58 03 40       	push   $0x40035874
4003283f:	e8 02 f4 ff ff       	call   40031c46 <mraa_set_pininfo>
40032844:	58                   	pop    %eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032845:	b9 0c 00 00 00       	mov    $0xc,%ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
4003284a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003284b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032850:	ba 4e 00 00 00       	mov    $0x4e,%edx
40032855:	53                   	push   %ebx
40032856:	68 85 58 03 40       	push   $0x40035885
4003285b:	e8 e6 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
40032860:	59                   	pop    %ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032861:	ba 4f 00 00 00       	mov    $0x4f,%edx
40032866:	b9 4f 00 00 00       	mov    $0x4f,%ecx
4003286b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032870:	5f                   	pop    %edi
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032871:	6a 00                	push   $0x0
40032873:	68 ff 53 03 40       	push   $0x400353ff
40032878:	e8 c9 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
4003287d:	58                   	pop    %eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003287e:	b9 0d 00 00 00       	mov    $0xd,%ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032883:	5a                   	pop    %edx
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032884:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032889:	ba 50 00 00 00       	mov    $0x50,%edx
4003288e:	53                   	push   %ebx
4003288f:	68 9c 58 03 40       	push   $0x4003589c
40032894:	e8 ad f3 ff ff       	call   40031c46 <mraa_set_pininfo>
40032899:	59                   	pop    %ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003289a:	ba 51 00 00 00       	mov    $0x51,%edx
4003289f:	31 c9                	xor    %ecx,%ecx
400328a1:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400328a6:	5f                   	pop    %edi
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400328a7:	56                   	push   %esi
400328a8:	68 b3 58 03 40       	push   $0x400358b3
400328ad:	e8 94 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
400328b2:	58                   	pop    %eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400328b3:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400328b8:	5a                   	pop    %edx
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400328b9:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400328be:	ba 52 00 00 00       	mov    $0x52,%edx
400328c3:	53                   	push   %ebx
400328c4:	68 bf 58 03 40       	push   $0x400358bf
400328c9:	e8 78 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
400328ce:	59                   	pop    %ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400328cf:	ba 53 00 00 00       	mov    $0x53,%edx
400328d4:	31 c9                	xor    %ecx,%ecx
400328d6:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400328db:	5f                   	pop    %edi
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400328dc:	56                   	push   %esi
400328dd:	68 d6 58 03 40       	push   $0x400358d6
400328e2:	e8 5f f3 ff ff       	call   40031c46 <mraa_set_pininfo>
400328e7:	58                   	pop    %eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400328e8:	b9 54 00 00 00       	mov    $0x54,%ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400328ed:	5a                   	pop    %edx
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400328ee:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400328f3:	ba 54 00 00 00       	mov    $0x54,%edx
400328f8:	6a 00                	push   $0x0
400328fa:	68 ff 53 03 40       	push   $0x400353ff
400328ff:	e8 42 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
40032904:	59                   	pop    %ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032905:	ba 55 00 00 00       	mov    $0x55,%edx
4003290a:	31 c9                	xor    %ecx,%ecx
4003290c:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032911:	5f                   	pop    %edi
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032912:	56                   	push   %esi
40032913:	68 e2 58 03 40       	push   $0x400358e2
40032918:	e8 29 f3 ff ff       	call   40031c46 <mraa_set_pininfo>
4003291d:	58                   	pop    %eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003291e:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032923:	5a                   	pop    %edx
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032924:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032929:	ba 56 00 00 00       	mov    $0x56,%edx
4003292e:	53                   	push   %ebx
4003292f:	68 f1 58 03 40       	push   $0x400358f1
40032934:	e8 0d f3 ff ff       	call   40031c46 <mraa_set_pininfo>
40032939:	59                   	pop    %ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003293a:	ba 57 00 00 00       	mov    $0x57,%edx
4003293f:	31 c9                	xor    %ecx,%ecx
40032941:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032946:	5f                   	pop    %edi
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032947:	56                   	push   %esi
40032948:	68 09 59 03 40       	push   $0x40035909
4003294d:	e8 f4 f2 ff ff       	call   40031c46 <mraa_set_pininfo>
40032952:	58                   	pop    %eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032953:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032958:	5a                   	pop    %edx
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032959:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003295e:	ba 58 00 00 00       	mov    $0x58,%edx
40032963:	53                   	push   %ebx
40032964:	68 18 59 03 40       	push   $0x40035918
40032969:	e8 d8 f2 ff ff       	call   40031c46 <mraa_set_pininfo>
4003296e:	59                   	pop    %ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003296f:	ba 59 00 00 00       	mov    $0x59,%edx
40032974:	31 c9                	xor    %ecx,%ecx
40032976:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003297b:	5f                   	pop    %edi
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003297c:	56                   	push   %esi
4003297d:	68 31 59 03 40       	push   $0x40035931
40032982:	e8 bf f2 ff ff       	call   40031c46 <mraa_set_pininfo>
40032987:	58                   	pop    %eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032988:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
4003298d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
4003298e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032993:	ba 5a 00 00 00       	mov    $0x5a,%edx
40032998:	53                   	push   %ebx
40032999:	68 3d 59 03 40       	push   $0x4003593d
4003299e:	e8 a3 f2 ff ff       	call   40031c46 <mraa_set_pininfo>
400329a3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400329a4:	ba 5b 00 00 00       	mov    $0x5b,%edx
400329a9:	31 c9                	xor    %ecx,%ecx
400329ab:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329b0:	5f                   	pop    %edi
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400329b1:	56                   	push   %esi
400329b2:	68 56 59 03 40       	push   $0x40035956
400329b7:	e8 8a f2 ff ff       	call   40031c46 <mraa_set_pininfo>
400329bc:	58                   	pop    %eax
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329bd:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
400329bf:	5a                   	pop    %edx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329c0:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400329c5:	ba 5c 00 00 00       	mov    $0x5c,%edx
400329ca:	53                   	push   %ebx
    b->spi_bus[0].sclk = 13;
    b->spi_bus[0].mosi = 11;
    b->spi_bus[0].miso = 12;
    b->spi_bus[0].cs = 10;

    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
400329cb:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329ce:	68 62 59 03 40       	push   $0x40035962
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
400329d3:	be a8 51 03 40       	mov    $0x400351a8,%esi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329d8:	e8 69 f2 ff ff       	call   40031c46 <mraa_set_pininfo>
400329dd:	59                   	pop    %ecx
    struct device* zdev = device_get_binding("GPIO_0");
400329de:	b8 36 52 03 40       	mov    $0x40035236,%eax
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
400329e3:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
400329e8:	5b                   	pop    %ebx
    b->def_i2c_bus = 0;
400329e9:	c6 05 4a 69 00 a8 00 	movb   $0x0,0xa800694a
    b->i2c_bus[0].bus_id = 0;
400329f0:	c6 05 44 69 00 a8 00 	movb   $0x0,0xa8006944
    b->pins[18].i2c.mux_total = 0;
400329f7:	c6 05 6e 6e 00 a8 00 	movb   $0x0,0xa8006e6e
    b->pins[19].i2c.mux_total = 0;
400329fe:	c6 05 b2 6e 00 a8 00 	movb   $0x0,0xa8006eb2
    b->i2c_bus[0].sda = 18;
40032a05:	c6 05 46 69 00 a8 12 	movb   $0x12,0xa8006946
    b->i2c_bus[0].scl = 19;
40032a0c:	c6 05 45 69 00 a8 13 	movb   $0x13,0xa8006945
    b->spi_bus[0].bus_id = 0;
40032a13:	c6 05 4c 69 00 a8 00 	movb   $0x0,0xa800694c
    b->spi_bus[0].sclk = 13;
40032a1a:	c6 05 4f 69 00 a8 0d 	movb   $0xd,0xa800694f
    b->spi_bus[0].mosi = 11;
40032a21:	c6 05 50 69 00 a8 0b 	movb   $0xb,0xa8006950
    b->spi_bus[0].miso = 12;
40032a28:	c6 05 51 69 00 a8 0c 	movb   $0xc,0xa8006951
    b->spi_bus[0].cs = 10;
40032a2f:	c6 05 52 69 00 a8 0a 	movb   $0xa,0xa8006952
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032a36:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    struct device* zdev = device_get_binding("GPIO_0");
40032a38:	e8 27 0c 00 00       	call   40033664 <device_get_binding>
    if (zdev != NULL) {
40032a3d:	85 c0                	test   %eax,%eax
40032a3f:	74 1e                	je     40032a5f <mraa_intel_quark_se_devboard+0xab9>
40032a41:	89 c6                	mov    %eax,%esi
40032a43:	31 db                	xor    %ebx,%ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40032a45:	0f b6 4c 9d e4       	movzbl -0x1c(%ebp,%ebx,4),%ecx
40032a4a:	8b 7e 04             	mov    0x4(%esi),%edi
40032a4d:	31 d2                	xor    %edx,%edx
40032a4f:	89 f0                	mov    %esi,%eax
        for (int i = 0; i<4; ++i) {
40032a51:	43                   	inc    %ebx
40032a52:	68 00 01 00 00       	push   $0x100
40032a57:	ff 17                	call   *(%edi)
40032a59:	58                   	pop    %eax
40032a5a:	83 fb 04             	cmp    $0x4,%ebx
40032a5d:	75 e6                	jne    40032a45 <mraa_intel_quark_se_devboard+0xa9f>
        return NULL;
    }
#endif

    return b;
}
40032a5f:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032a62:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032a67:	5b                   	pop    %ebx
40032a68:	5e                   	pop    %esi
40032a69:	5f                   	pop    %edi
40032a6a:	5d                   	pop    %ebp
40032a6b:	c3                   	ret    

40032a6c <upm_clock_init>:

#endif
}

void upm_clock_init(upm_clock_t *clock)
{
40032a6c:	55                   	push   %ebp
40032a6d:	89 e5                	mov    %esp,%ebp
40032a6f:	53                   	push   %ebx
40032a70:	89 c3                	mov    %eax,%ebx
#if defined(UPM_PLATFORM_LINUX)

    gettimeofday(clock, NULL);

#elif defined(UPM_PLATFORM_ZEPHYR)
    *clock = k_cycle_get_32();
40032a72:	e8 eb da ff ff       	call   40030562 <_timer_cycle_get_32>
40032a77:	89 03                	mov    %eax,(%ebx)
#endif
}
40032a79:	5b                   	pop    %ebx
40032a7a:	5d                   	pop    %ebp
40032a7b:	c3                   	ret    

40032a7c <upm_elapsed_us>:
    return elapsed;
#endif
}

uint32_t upm_elapsed_us(upm_clock_t *clock)
{
40032a7c:	55                   	push   %ebp
40032a7d:	89 e5                	mov    %esp,%ebp
40032a7f:	56                   	push   %esi
40032a80:	89 c6                	mov    %eax,%esi
40032a82:	53                   	push   %ebx
        elapse = 1;

    return elapse;

#elif defined(UPM_PLATFORM_ZEPHYR)
    uint32_t now = k_cycle_get_32();
40032a83:	e8 da da ff ff       	call   40030562 <_timer_cycle_get_32>

    uint32_t elapsed =
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40032a88:	2b 06                	sub    (%esi),%eax
40032a8a:	89 c3                	mov    %eax,%ebx
40032a8c:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032a91:	f7 2d f0 66 00 a8    	imull  0xa80066f0
40032a97:	89 d1                	mov    %edx,%ecx
40032a99:	0f af cb             	imul   %ebx,%ecx
40032a9c:	f7 e3                	mul    %ebx
40032a9e:	01 ca                	add    %ecx,%edx
40032aa0:	8b 0d ec 66 00 a8    	mov    0xa80066ec,%ecx
40032aa6:	89 cb                	mov    %ecx,%ebx
40032aa8:	c1 fb 1f             	sar    $0x1f,%ebx
40032aab:	53                   	push   %ebx
40032aac:	51                   	push   %ecx
40032aad:	e8 de d5 ff ff       	call   40030090 <__udivdi3>
40032ab2:	59                   	pop    %ecx
40032ab3:	5b                   	pop    %ebx
40032ab4:	6a 00                	push   $0x0
40032ab6:	68 e8 03 00 00       	push   $0x3e8
40032abb:	e8 d0 d5 ff ff       	call   40030090 <__udivdi3>
40032ac0:	5e                   	pop    %esi
//printf("hello\n");
    // never return 0
    if (elapsed == 0)
40032ac1:	85 c0                	test   %eax,%eax
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40032ac3:	5a                   	pop    %edx
    if (elapsed == 0)
40032ac4:	75 05                	jne    40032acb <upm_elapsed_us+0x4f>
        elapsed = 1;
40032ac6:	b8 01 00 00 00       	mov    $0x1,%eax

    return elapsed;
#endif
}
40032acb:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032ace:	5b                   	pop    %ebx
40032acf:	5e                   	pop    %esi
40032ad0:	5d                   	pop    %ebp
40032ad1:	c3                   	ret    

40032ad2 <upm_delay_us>:
{
40032ad2:	55                   	push   %ebp
40032ad3:	85 c0                	test   %eax,%eax
40032ad5:	89 e5                	mov    %esp,%ebp
40032ad7:	53                   	push   %ebx
40032ad8:	bb 01 00 00 00       	mov    $0x1,%ebx
40032add:	52                   	push   %edx
40032ade:	7e 02                	jle    40032ae2 <upm_delay_us+0x10>
40032ae0:	89 c3                	mov    %eax,%ebx
    upm_clock_init(&timer);
40032ae2:	8d 45 f8             	lea    -0x8(%ebp),%eax
40032ae5:	e8 82 ff ff ff       	call   40032a6c <upm_clock_init>
    while (upm_elapsed_us(&timer) < time)
40032aea:	8d 45 f8             	lea    -0x8(%ebp),%eax
40032aed:	e8 8a ff ff ff       	call   40032a7c <upm_elapsed_us>
40032af2:	39 d8                	cmp    %ebx,%eax
40032af4:	72 f4                	jb     40032aea <upm_delay_us+0x18>
}
40032af6:	58                   	pop    %eax
40032af7:	5b                   	pop    %ebx
40032af8:	5d                   	pop    %ebp
40032af9:	c3                   	ret    

40032afa <LoRaClass>:
  //_ss(LORA_DEFAULT_SS_PIN), _reset(LORA_DEFAULT_RESET_PIN), _dio0(LORA_DEFAULT_DIO0_PIN),
  //_frequency(0),
  //_packetIndex(0),
  //_implicitHeaderMode(0),
  //_onReceive(NULL)
{
40032afa:	55                   	push   %ebp
40032afb:	89 e5                	mov    %esp,%ebp
    // initialize MRAA
    int mraa_rv;
    if((mraa_rv = mraa_init()) != MRAA_SUCCESS) {
40032afd:	e8 5f ef ff ff       	call   40031a61 <mraa_init>
40032b02:	85 c0                	test   %eax,%eax
40032b04:	74 13                	je     40032b19 <LoRaClass+0x1f>
        printf("%s: mraa_init failed (%d).\n", __FUNCTION__, mraa_rv);
40032b06:	50                   	push   %eax
40032b07:	68 04 5e 03 40       	push   $0x40035e04
40032b0c:	68 7b 59 03 40       	push   $0x4003597b
40032b11:	e8 fe 17 00 00       	call   40034314 <iprintf>
40032b16:	83 c4 0c             	add    $0xc,%esp
    }

    if(!(SX1276.spi = mraa_spi_init(0)))
40032b19:	31 c0                	xor    %eax,%eax
40032b1b:	e8 ab f3 ff ff       	call   40031ecb <mraa_spi_init>
40032b20:	a3 74 78 00 a8       	mov    %eax,0xa8007874
40032b25:	85 c0                	test   %eax,%eax
40032b27:	75 0b                	jne    40032b34 <LoRaClass+0x3a>
        printf("Unable to Initialize Spi bus\n");
40032b29:	68 97 59 03 40       	push   $0x40035997
40032b2e:	e8 e1 17 00 00       	call   40034314 <iprintf>
40032b33:	5a                   	pop    %edx

    if(mraa_spi_frequency(SX1276.spi, 4000000) != MRAA_SUCCESS) {
40032b34:	ba 00 09 3d 00       	mov    $0x3d0900,%edx
40032b39:	a1 74 78 00 a8       	mov    0xa8007874,%eax
40032b3e:	e8 10 f4 ff ff       	call   40031f53 <mraa_spi_frequency>
40032b43:	85 c0                	test   %eax,%eax
40032b45:	74 0b                	je     40032b52 <LoRaClass+0x58>
        printf("sx1276: Unable to set higher frequency\n");
40032b47:	68 b5 59 03 40       	push   $0x400359b5
40032b4c:	e8 c3 17 00 00       	call   40034314 <iprintf>
40032b51:	58                   	pop    %eax
    }

    SX1276._frequency  = 0;
40032b52:	c7 05 78 78 00 a8 00 	movl   $0x0,0xa8007878
40032b59:	00 00 00 
    SX1276._packetIndex = 0;
40032b5c:	c7 05 7c 78 00 a8 00 	movl   $0x0,0xa800787c
40032b63:	00 00 00 
    SX1276._implicitHeaderMode = 0;
40032b66:	c7 05 80 78 00 a8 00 	movl   $0x0,0xa8007880
40032b6d:	00 00 00 

    SX1276._ss = LORA_DEFAULT_SS_PIN;
40032b70:	c6 05 6c 78 00 a8 0a 	movb   $0xa,0xa800786c
    SX1276._reset = LORA_DEFAULT_RESET_PIN;
40032b77:	c6 05 6d 78 00 a8 09 	movb   $0x9,0xa800786d
    SX1276._dio0 = LORA_DEFAULT_DIO0_PIN;
40032b7e:	c6 05 6e 78 00 a8 02 	movb   $0x2,0xa800786e
}
40032b85:	c9                   	leave  
40032b86:	c3                   	ret    

40032b87 <setPins>:

int8_t random() {
    return readRegister(REG_RSSI_WIDEBAND);
}

void setPins(int ss, int reset, int dio0) {
40032b87:	55                   	push   %ebp
    SX1276._ss = ss;
40032b88:	a2 6c 78 00 a8       	mov    %al,0xa800786c
void setPins(int ss, int reset, int dio0) {
40032b8d:	89 e5                	mov    %esp,%ebp
    SX1276._reset = reset;
40032b8f:	88 15 6d 78 00 a8    	mov    %dl,0xa800786d
    SX1276._dio0 = dio0;
40032b95:	88 0d 6e 78 00 a8    	mov    %cl,0xa800786e
}
40032b9b:	5d                   	pop    %ebp
40032b9c:	c3                   	ret    

40032b9d <readRegister>:
        // reset FIFO address
        writeRegister(REG_FIFO_ADDR_PTR, 0);
    }
}

uint8_t readRegister(uint8_t address) {
40032b9d:	55                   	push   %ebp
    //return singleTransfer(address & 0x7f, 0x00);

    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032b9e:	83 e0 7f             	and    $0x7f,%eax
uint8_t readRegister(uint8_t address) {
40032ba1:	89 e5                	mov    %esp,%ebp
40032ba3:	52                   	push   %edx
    uint8_t rx_buf[2];

    mraa_gpio_write(SX1276.gpio_ss, 0);
40032ba4:	31 d2                	xor    %edx,%edx
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032ba6:	88 45 fc             	mov    %al,-0x4(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40032ba9:	a1 60 78 00 a8       	mov    0xa8007860,%eax
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40032bae:	c6 45 fd 00          	movb   $0x0,-0x3(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40032bb2:	e8 a1 f2 ff ff       	call   40031e58 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, tx_buf, rx_buf, 2) != MRAA_SUCCESS) {
40032bb7:	8d 4d fe             	lea    -0x2(%ebp),%ecx
40032bba:	8d 55 fc             	lea    -0x4(%ebp),%edx
40032bbd:	a1 74 78 00 a8       	mov    0xa8007874,%eax
40032bc2:	6a 02                	push   $0x2
40032bc4:	e8 c3 f3 ff ff       	call   40031f8c <mraa_spi_transfer_buf>
40032bc9:	59                   	pop    %ecx
40032bca:	85 c0                	test   %eax,%eax
40032bcc:	74 2a                	je     40032bf8 <readRegister+0x5b>
        printf("Unable to transfer data over the SPI bus\n");
40032bce:	68 dd 59 03 40       	push   $0x400359dd
40032bd3:	e8 3c 17 00 00       	call   40034314 <iprintf>
        printf("SPI operation failed\n");
40032bd8:	c7 04 24 07 5a 03 40 	movl   $0x40035a07,(%esp)
40032bdf:	e8 30 17 00 00       	call   40034314 <iprintf>
40032be4:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40032be5:	ba 01 00 00 00       	mov    $0x1,%edx
40032bea:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032bef:	e8 64 f2 ff ff       	call   40031e58 <mraa_gpio_write>
40032bf4:	b0 ff                	mov    $0xff,%al
40032bf6:	eb 12                	jmp    40032c0a <readRegister+0x6d>
        return -1;
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032bf8:	ba 01 00 00 00       	mov    $0x1,%edx
40032bfd:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032c02:	e8 51 f2 ff ff       	call   40031e58 <mraa_gpio_write>

    return rx_buf[1];
40032c07:	8a 45 ff             	mov    -0x1(%ebp),%al
}
40032c0a:	c9                   	leave  
40032c0b:	c3                   	ret    

40032c0c <packetRssi>:
{
40032c0c:	55                   	push   %ebp
    return (readRegister(REG_PKT_RSSI_VALUE) - (SX1276._frequency < 868E6 ? 164 : 157));
40032c0d:	b8 1a 00 00 00       	mov    $0x1a,%eax
{
40032c12:	89 e5                	mov    %esp,%ebp
40032c14:	53                   	push   %ebx
    return (readRegister(REG_PKT_RSSI_VALUE) - (SX1276._frequency < 868E6 ? 164 : 157));
40032c15:	e8 83 ff ff ff       	call   40032b9d <readRegister>
40032c1a:	0f b6 d8             	movzbl %al,%ebx
40032c1d:	a1 78 78 00 a8       	mov    0xa8007878,%eax
40032c22:	e8 70 d6 ff ff       	call   40030297 <__floatsidf>
40032c27:	68 50 de c9 41       	push   $0x41c9de50
40032c2c:	68 00 00 00 80       	push   $0x80000000
40032c31:	e8 50 d5 ff ff       	call   40030186 <__ledf2>
40032c36:	c1 f8 1f             	sar    $0x1f,%eax
40032c39:	5a                   	pop    %edx
40032c3a:	83 e0 07             	and    $0x7,%eax
40032c3d:	59                   	pop    %ecx
40032c3e:	05 9d 00 00 00       	add    $0x9d,%eax
40032c43:	29 c3                	sub    %eax,%ebx
40032c45:	89 d8                	mov    %ebx,%eax
}
40032c47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032c4a:	c9                   	leave  
40032c4b:	c3                   	ret    

40032c4c <available>:
{
40032c4c:	55                   	push   %ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
40032c4d:	b8 13 00 00 00       	mov    $0x13,%eax
{
40032c52:	89 e5                	mov    %esp,%ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
40032c54:	e8 44 ff ff ff       	call   40032b9d <readRegister>
}
40032c59:	5d                   	pop    %ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
40032c5a:	0f b6 c0             	movzbl %al,%eax
40032c5d:	2b 05 7c 78 00 a8    	sub    0xa800787c,%eax
}
40032c63:	c3                   	ret    

40032c64 <SX1276read>:
int SX1276read() {
40032c64:	55                   	push   %ebp
40032c65:	89 e5                	mov    %esp,%ebp
    if (!available()) {
40032c67:	e8 e0 ff ff ff       	call   40032c4c <available>
40032c6c:	83 ca ff             	or     $0xffffffff,%edx
40032c6f:	85 c0                	test   %eax,%eax
40032c71:	74 10                	je     40032c83 <SX1276read+0x1f>
    return readRegister(REG_FIFO);
40032c73:	31 c0                	xor    %eax,%eax
    SX1276._packetIndex++;
40032c75:	ff 05 7c 78 00 a8    	incl   0xa800787c
    return readRegister(REG_FIFO);
40032c7b:	e8 1d ff ff ff       	call   40032b9d <readRegister>
40032c80:	0f b6 d0             	movzbl %al,%edx
}
40032c83:	89 d0                	mov    %edx,%eax
40032c85:	5d                   	pop    %ebp
40032c86:	c3                   	ret    

40032c87 <dumpRegisters>:
{
40032c87:	55                   	push   %ebp
40032c88:	89 e5                	mov    %esp,%ebp
40032c8a:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40032c8b:	31 db                	xor    %ebx,%ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
40032c8d:	89 d8                	mov    %ebx,%eax
40032c8f:	e8 09 ff ff ff       	call   40032b9d <readRegister>
40032c94:	0f b6 c0             	movzbl %al,%eax
40032c97:	50                   	push   %eax
40032c98:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40032c99:	43                   	inc    %ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
40032c9a:	68 1d 5a 03 40       	push   $0x40035a1d
40032c9f:	e8 70 16 00 00       	call   40034314 <iprintf>
40032ca4:	83 c4 0c             	add    $0xc,%esp
  for (int i = 0; i < 128; i++) {
40032ca7:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
40032cad:	75 de                	jne    40032c8d <dumpRegisters+0x6>
}
40032caf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032cb2:	c9                   	leave  
40032cb3:	c3                   	ret    

40032cb4 <writeRegister>:

void writeRegister(uint8_t address, uint8_t value) {
40032cb4:	55                   	push   %ebp
    //singleTransfer(address | 0x80, value);

    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40032cb5:	83 c8 80             	or     $0xffffff80,%eax
void writeRegister(uint8_t address, uint8_t value) {
40032cb8:	89 e5                	mov    %esp,%ebp
40032cba:	51                   	push   %ecx
    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40032cbb:	88 45 fe             	mov    %al,-0x2(%ebp)
40032cbe:	88 55 ff             	mov    %dl,-0x1(%ebp)

    mraa_gpio_write(SX1276.gpio_ss, 0);
40032cc1:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032cc6:	31 d2                	xor    %edx,%edx
40032cc8:	e8 8b f1 ff ff       	call   40031e58 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, pkt, NULL, 2) != MRAA_SUCCESS) {
40032ccd:	31 c9                	xor    %ecx,%ecx
40032ccf:	8d 55 fe             	lea    -0x2(%ebp),%edx
40032cd2:	a1 74 78 00 a8       	mov    0xa8007874,%eax
40032cd7:	6a 02                	push   $0x2
40032cd9:	e8 ae f2 ff ff       	call   40031f8c <mraa_spi_transfer_buf>
40032cde:	5a                   	pop    %edx
40032cdf:	85 c0                	test   %eax,%eax
40032ce1:	74 26                	je     40032d09 <writeRegister+0x55>
        printf("Unable to transfer data over the SPI bus\n");
40032ce3:	68 dd 59 03 40       	push   $0x400359dd
40032ce8:	e8 27 16 00 00       	call   40034314 <iprintf>
        printf("SPI operation failed\n");
40032ced:	c7 04 24 07 5a 03 40 	movl   $0x40035a07,(%esp)
40032cf4:	e8 1b 16 00 00       	call   40034314 <iprintf>
40032cf9:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40032cfa:	ba 01 00 00 00       	mov    $0x1,%edx
40032cff:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032d04:	e8 4f f1 ff ff       	call   40031e58 <mraa_gpio_write>
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032d09:	ba 01 00 00 00       	mov    $0x1,%edx
40032d0e:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032d13:	e8 40 f1 ff ff       	call   40031e58 <mraa_gpio_write>
}
40032d18:	c9                   	leave  
40032d19:	c3                   	ret    

40032d1a <idle>:
void idle() {
40032d1a:	55                   	push   %ebp
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d1b:	b8 01 00 00 00       	mov    $0x1,%eax
void idle() {
40032d20:	89 e5                	mov    %esp,%ebp
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d22:	e8 76 fe ff ff       	call   40032b9d <readRegister>
40032d27:	0f b6 c0             	movzbl %al,%eax
40032d2a:	50                   	push   %eax
40032d2b:	68 70 5b 03 40       	push   $0x40035b70
40032d30:	e8 df 15 00 00       	call   40034314 <iprintf>
40032d35:	58                   	pop    %eax
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_STDBY);
40032d36:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("previous value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d3b:	5a                   	pop    %edx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_STDBY);
40032d3c:	ba 81 00 00 00       	mov    $0x81,%edx
40032d41:	e8 6e ff ff ff       	call   40032cb4 <writeRegister>
    printf("next value of REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d46:	b8 01 00 00 00       	mov    $0x1,%eax
40032d4b:	e8 4d fe ff ff       	call   40032b9d <readRegister>
40032d50:	0f b6 c0             	movzbl %al,%eax
40032d53:	50                   	push   %eax
40032d54:	68 c6 5a 03 40       	push   $0x40035ac6
40032d59:	e8 b6 15 00 00       	call   40034314 <iprintf>
40032d5e:	59                   	pop    %ecx
40032d5f:	58                   	pop    %eax
}
40032d60:	c9                   	leave  
40032d61:	c3                   	ret    

40032d62 <SX1276sleep>:
void SX1276sleep() {
40032d62:	55                   	push   %ebp
40032d63:	89 e5                	mov    %esp,%ebp
    printf("Sleep function\n");
40032d65:	68 93 5b 03 40       	push   $0x40035b93
40032d6a:	e8 a5 15 00 00       	call   40034314 <iprintf>
40032d6f:	58                   	pop    %eax
    printf("before: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d70:	b8 01 00 00 00       	mov    $0x1,%eax
40032d75:	e8 23 fe ff ff       	call   40032b9d <readRegister>
40032d7a:	0f b6 c0             	movzbl %al,%eax
40032d7d:	50                   	push   %eax
40032d7e:	68 a3 5b 03 40       	push   $0x40035ba3
40032d83:	e8 8c 15 00 00       	call   40034314 <iprintf>
40032d88:	5a                   	pop    %edx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_SLEEP);
40032d89:	b8 01 00 00 00       	mov    $0x1,%eax
40032d8e:	ba 80 00 00 00       	mov    $0x80,%edx
    printf("before: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d93:	59                   	pop    %ecx
    writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_SLEEP);
40032d94:	e8 1b ff ff ff       	call   40032cb4 <writeRegister>
    printf("after: REG_OP_MODE: %x\n", readRegister(REG_OP_MODE));
40032d99:	b8 01 00 00 00       	mov    $0x1,%eax
40032d9e:	e8 fa fd ff ff       	call   40032b9d <readRegister>
40032da3:	0f b6 c0             	movzbl %al,%eax
40032da6:	50                   	push   %eax
40032da7:	68 bc 5b 03 40       	push   $0x40035bbc
40032dac:	e8 63 15 00 00       	call   40034314 <iprintf>
40032db1:	58                   	pop    %eax
40032db2:	5a                   	pop    %edx
}
40032db3:	c9                   	leave  
40032db4:	c3                   	ret    

40032db5 <setTxPower.part.1>:
void setTxPower(int level, int outputPin) {
40032db5:	55                   	push   %ebp
40032db6:	83 f8 11             	cmp    $0x11,%eax
40032db9:	89 e5                	mov    %esp,%ebp
40032dbb:	53                   	push   %ebx
40032dbc:	7e 05                	jle    40032dc3 <setTxPower.part.1+0xe>
40032dbe:	b8 11 00 00 00       	mov    $0x11,%eax
40032dc3:	89 c3                	mov    %eax,%ebx
40032dc5:	83 f8 02             	cmp    $0x2,%eax
40032dc8:	7d 05                	jge    40032dcf <setTxPower.part.1+0x1a>
40032dca:	bb 02 00 00 00       	mov    $0x2,%ebx
        printf("value to be written to REG_PA_CONFIG; %x\n", PA_BOOST | (level - 2));
40032dcf:	8d 43 fe             	lea    -0x2(%ebx),%eax
40032dd2:	0c 80                	or     $0x80,%al
40032dd4:	50                   	push   %eax
40032dd5:	68 d4 5b 03 40       	push   $0x40035bd4
40032dda:	e8 35 15 00 00       	call   40034314 <iprintf>
40032ddf:	58                   	pop    %eax
40032de0:	5a                   	pop    %edx
        writeRegister(REG_PA_CONFIG, PA_BOOST | (level - 2));
40032de1:	8d 53 fe             	lea    -0x2(%ebx),%edx
40032de4:	83 ca 80             	or     $0xffffff80,%edx
40032de7:	b8 09 00 00 00       	mov    $0x9,%eax
40032dec:	0f b6 d2             	movzbl %dl,%edx
40032def:	e8 c0 fe ff ff       	call   40032cb4 <writeRegister>
        printf("REG_PA_CONFIG: %x\n", readRegister(REG_PA_CONFIG));
40032df4:	b8 09 00 00 00       	mov    $0x9,%eax
40032df9:	e8 9f fd ff ff       	call   40032b9d <readRegister>
40032dfe:	0f b6 c0             	movzbl %al,%eax
40032e01:	50                   	push   %eax
40032e02:	68 fe 5b 03 40       	push   $0x40035bfe
40032e07:	e8 08 15 00 00       	call   40034314 <iprintf>
40032e0c:	59                   	pop    %ecx
40032e0d:	5b                   	pop    %ebx
}
40032e0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032e11:	c9                   	leave  
40032e12:	c3                   	ret    

40032e13 <setFrequency>:
void setFrequency(long frequency) {
40032e13:	55                   	push   %ebp
    SX1276._frequency = frequency;
40032e14:	a3 78 78 00 a8       	mov    %eax,0xa8007878
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032e19:	99                   	cltd   
void setFrequency(long frequency) {
40032e1a:	89 e5                	mov    %esp,%ebp
40032e1c:	57                   	push   %edi
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032e1d:	0f a4 c2 13          	shld   $0x13,%eax,%edx
40032e21:	c1 e0 13             	shl    $0x13,%eax
void setFrequency(long frequency) {
40032e24:	56                   	push   %esi
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032e25:	6a 00                	push   $0x0
40032e27:	68 00 48 e8 01       	push   $0x1e84800
40032e2c:	e8 5f d2 ff ff       	call   40030090 <__udivdi3>
40032e31:	59                   	pop    %ecx
40032e32:	5e                   	pop    %esi
40032e33:	89 c6                	mov    %eax,%esi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40032e35:	0f ac d0 10          	shrd   $0x10,%edx,%eax
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40032e39:	89 d7                	mov    %edx,%edi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40032e3b:	0f b6 d0             	movzbl %al,%edx
40032e3e:	b8 06 00 00 00       	mov    $0x6,%eax
40032e43:	e8 6c fe ff ff       	call   40032cb4 <writeRegister>
    writeRegister(REG_FRF_MID, (uint8_t)(frf >> 8));
40032e48:	89 fa                	mov    %edi,%edx
40032e4a:	89 f0                	mov    %esi,%eax
40032e4c:	0f ac d0 08          	shrd   $0x8,%edx,%eax
40032e50:	0f b6 d0             	movzbl %al,%edx
40032e53:	b8 07 00 00 00       	mov    $0x7,%eax
40032e58:	e8 57 fe ff ff       	call   40032cb4 <writeRegister>
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
40032e5d:	89 f0                	mov    %esi,%eax
40032e5f:	0f b6 d0             	movzbl %al,%edx
40032e62:	b8 08 00 00 00       	mov    $0x8,%eax
40032e67:	e8 48 fe ff ff       	call   40032cb4 <writeRegister>
    printf("REG_FRF_MSB: %x\n", readRegister(REG_FRF_MSB));
40032e6c:	b8 06 00 00 00       	mov    $0x6,%eax
40032e71:	e8 27 fd ff ff       	call   40032b9d <readRegister>
40032e76:	0f b6 c0             	movzbl %al,%eax
40032e79:	50                   	push   %eax
40032e7a:	68 11 5c 03 40       	push   $0x40035c11
40032e7f:	e8 90 14 00 00       	call   40034314 <iprintf>
40032e84:	5f                   	pop    %edi
40032e85:	58                   	pop    %eax
    printf("REG_FRF_MID: %x\n", readRegister(REG_FRF_MID));
40032e86:	b8 07 00 00 00       	mov    $0x7,%eax
40032e8b:	e8 0d fd ff ff       	call   40032b9d <readRegister>
40032e90:	0f b6 c0             	movzbl %al,%eax
40032e93:	50                   	push   %eax
40032e94:	68 22 5c 03 40       	push   $0x40035c22
40032e99:	e8 76 14 00 00       	call   40034314 <iprintf>
40032e9e:	58                   	pop    %eax
    printf("REG_FRF_LSB: %x\n", readRegister(REG_FRF_LSB));
40032e9f:	b8 08 00 00 00       	mov    $0x8,%eax
    printf("REG_FRF_MID: %x\n", readRegister(REG_FRF_MID));
40032ea4:	5a                   	pop    %edx
    printf("REG_FRF_LSB: %x\n", readRegister(REG_FRF_LSB));
40032ea5:	e8 f3 fc ff ff       	call   40032b9d <readRegister>
40032eaa:	0f b6 c0             	movzbl %al,%eax
40032ead:	50                   	push   %eax
40032eae:	68 33 5c 03 40       	push   $0x40035c33
40032eb3:	e8 5c 14 00 00       	call   40034314 <iprintf>
40032eb8:	59                   	pop    %ecx
40032eb9:	5e                   	pop    %esi
}
40032eba:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032ebd:	5e                   	pop    %esi
40032ebe:	5f                   	pop    %edi
40032ebf:	5d                   	pop    %ebp
40032ec0:	c3                   	ret    

40032ec1 <begin>:
{
40032ec1:	55                   	push   %ebp
40032ec2:	89 e5                	mov    %esp,%ebp
40032ec4:	56                   	push   %esi
40032ec5:	89 c6                	mov    %eax,%esi
40032ec7:	53                   	push   %ebx
    if(!(SX1276.gpio_ss = mraa_gpio_init(SX1276._ss))) {
40032ec8:	0f b6 05 6c 78 00 a8 	movzbl 0xa800786c,%eax
40032ecf:	e8 5c ee ff ff       	call   40031d30 <mraa_gpio_init>
40032ed4:	a3 60 78 00 a8       	mov    %eax,0xa8007860
40032ed9:	85 c0                	test   %eax,%eax
40032edb:	75 0b                	jne    40032ee8 <begin+0x27>
        printf("sx1276: unable to init SPI CS\n");
40032edd:	68 44 5c 03 40       	push   $0x40035c44
40032ee2:	e8 2d 14 00 00       	call   40034314 <iprintf>
40032ee7:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_ss, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
40032ee8:	31 d2                	xor    %edx,%edx
40032eea:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032eef:	e8 ee ee ff ff       	call   40031de2 <mraa_gpio_dir>
40032ef4:	85 c0                	test   %eax,%eax
40032ef6:	74 0b                	je     40032f03 <begin+0x42>
        printf("sx1276: unable to set direction on SPI CS\n");
40032ef8:	68 63 5c 03 40       	push   $0x40035c63
40032efd:	e8 12 14 00 00       	call   40034314 <iprintf>
40032f02:	58                   	pop    %eax
    if(!(SX1276.gpio_reset = mraa_gpio_init(SX1276._reset))) {
40032f03:	0f b6 05 6d 78 00 a8 	movzbl 0xa800786d,%eax
40032f0a:	e8 21 ee ff ff       	call   40031d30 <mraa_gpio_init>
40032f0f:	a3 64 78 00 a8       	mov    %eax,0xa8007864
40032f14:	85 c0                	test   %eax,%eax
40032f16:	75 0b                	jne    40032f23 <begin+0x62>
        printf("sx1276: unable to init chip reset\n");
40032f18:	68 8e 5c 03 40       	push   $0x40035c8e
40032f1d:	e8 f2 13 00 00       	call   40034314 <iprintf>
40032f22:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_reset, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
40032f23:	31 d2                	xor    %edx,%edx
40032f25:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40032f2a:	e8 b3 ee ff ff       	call   40031de2 <mraa_gpio_dir>
40032f2f:	85 c0                	test   %eax,%eax
40032f31:	74 0b                	je     40032f3e <begin+0x7d>
        printf("sx1276: unable to set direction on reset pin\n");
40032f33:	68 b1 5c 03 40       	push   $0x40035cb1
40032f38:	e8 d7 13 00 00       	call   40034314 <iprintf>
40032f3d:	5b                   	pop    %ebx
    mraa_gpio_write(SX1276.gpio_reset, 1);
40032f3e:	ba 01 00 00 00       	mov    $0x1,%edx
40032f43:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40032f48:	e8 0b ef ff ff       	call   40031e58 <mraa_gpio_write>
    upm_delay_us(1000);
40032f4d:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032f52:	e8 7b fb ff ff       	call   40032ad2 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 0);
40032f57:	31 d2                	xor    %edx,%edx
40032f59:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40032f5e:	e8 f5 ee ff ff       	call   40031e58 <mraa_gpio_write>
    upm_delay_us(1000);
40032f63:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032f68:	e8 65 fb ff ff       	call   40032ad2 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 1);
40032f6d:	ba 01 00 00 00       	mov    $0x1,%edx
40032f72:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40032f77:	e8 dc ee ff ff       	call   40031e58 <mraa_gpio_write>
    upm_delay_us(15000);
40032f7c:	b8 98 3a 00 00       	mov    $0x3a98,%eax
40032f81:	e8 4c fb ff ff       	call   40032ad2 <upm_delay_us>
    dumpRegisters();
40032f86:	e8 fc fc ff ff       	call   40032c87 <dumpRegisters>
    mraa_gpio_write(SX1276.gpio_ss, 1);
40032f8b:	ba 01 00 00 00       	mov    $0x1,%edx
40032f90:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40032f95:	e8 be ee ff ff       	call   40031e58 <mraa_gpio_write>
    uint8_t version = readRegister(REG_VERSION);
40032f9a:	b8 42 00 00 00       	mov    $0x42,%eax
40032f9f:	e8 f9 fb ff ff       	call   40032b9d <readRegister>
40032fa4:	0f b6 d8             	movzbl %al,%ebx
    if (version != 0x12) {
40032fa7:	80 fb 12             	cmp    $0x12,%bl
40032faa:	74 0b                	je     40032fb7 <begin+0xf6>
        printf("wrong version\n");
40032fac:	68 df 5c 03 40       	push   $0x40035cdf
40032fb1:	e8 5e 13 00 00       	call   40034314 <iprintf>
40032fb6:	59                   	pop    %ecx
    printf("chip version: %x\n", version);
40032fb7:	53                   	push   %ebx
40032fb8:	68 ee 5c 03 40       	push   $0x40035cee
40032fbd:	e8 52 13 00 00       	call   40034314 <iprintf>
40032fc2:	58                   	pop    %eax
40032fc3:	5a                   	pop    %edx
    SX1276sleep();
40032fc4:	e8 99 fd ff ff       	call   40032d62 <SX1276sleep>
    setFrequency(frequency);
40032fc9:	89 f0                	mov    %esi,%eax
40032fcb:	e8 43 fe ff ff       	call   40032e13 <setFrequency>
    printf("setting rx and tx base addresses\n");
40032fd0:	68 00 5d 03 40       	push   $0x40035d00
40032fd5:	e8 3a 13 00 00       	call   40034314 <iprintf>
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
40032fda:	31 d2                	xor    %edx,%edx
40032fdc:	b8 0e 00 00 00       	mov    $0xe,%eax
    printf("setting rx and tx base addresses\n");
40032fe1:	59                   	pop    %ecx
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
40032fe2:	e8 cd fc ff ff       	call   40032cb4 <writeRegister>
    writeRegister(REG_FIFO_RX_BASE_ADDR, 0);
40032fe7:	31 d2                	xor    %edx,%edx
40032fe9:	b8 0f 00 00 00       	mov    $0xf,%eax
40032fee:	e8 c1 fc ff ff       	call   40032cb4 <writeRegister>
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
40032ff3:	b8 0e 00 00 00       	mov    $0xe,%eax
40032ff8:	e8 a0 fb ff ff       	call   40032b9d <readRegister>
40032ffd:	0f b6 c0             	movzbl %al,%eax
40033000:	50                   	push   %eax
40033001:	68 22 5d 03 40       	push   $0x40035d22
40033006:	e8 09 13 00 00       	call   40034314 <iprintf>
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
4003300b:	b8 0f 00 00 00       	mov    $0xf,%eax
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
40033010:	5b                   	pop    %ebx
40033011:	5e                   	pop    %esi
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40033012:	e8 86 fb ff ff       	call   40032b9d <readRegister>
40033017:	0f b6 c0             	movzbl %al,%eax
4003301a:	50                   	push   %eax
4003301b:	68 3d 5d 03 40       	push   $0x40035d3d
40033020:	e8 ef 12 00 00       	call   40034314 <iprintf>
40033025:	58                   	pop    %eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40033026:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
4003302b:	5a                   	pop    %edx
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
4003302c:	e8 6c fb ff ff       	call   40032b9d <readRegister>
40033031:	0f b6 c0             	movzbl %al,%eax
40033034:	50                   	push   %eax
40033035:	68 58 5d 03 40       	push   $0x40035d58
4003303a:	e8 d5 12 00 00       	call   40034314 <iprintf>
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
4003303f:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40033044:	59                   	pop    %ecx
40033045:	5b                   	pop    %ebx
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
40033046:	e8 52 fb ff ff       	call   40032b9d <readRegister>
4003304b:	83 c8 23             	or     $0x23,%eax
4003304e:	0f b6 d0             	movzbl %al,%edx
40033051:	b8 0c 00 00 00       	mov    $0xc,%eax
40033056:	e8 59 fc ff ff       	call   40032cb4 <writeRegister>
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
4003305b:	b8 0c 00 00 00       	mov    $0xc,%eax
40033060:	e8 38 fb ff ff       	call   40032b9d <readRegister>
40033065:	0f b6 c0             	movzbl %al,%eax
40033068:	50                   	push   %eax
40033069:	68 6c 5d 03 40       	push   $0x40035d6c
4003306e:	e8 a1 12 00 00       	call   40034314 <iprintf>
40033073:	5e                   	pop    %esi
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
40033074:	ba 04 00 00 00       	mov    $0x4,%edx
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
40033079:	58                   	pop    %eax
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
4003307a:	b8 26 00 00 00       	mov    $0x26,%eax
4003307f:	e8 30 fc ff ff       	call   40032cb4 <writeRegister>
    printf("REG_MODEM_CONFIG_3; %x\n", readRegister(REG_MODEM_CONFIG_3));
40033084:	b8 26 00 00 00       	mov    $0x26,%eax
40033089:	e8 0f fb ff ff       	call   40032b9d <readRegister>
4003308e:	0f b6 c0             	movzbl %al,%eax
40033091:	50                   	push   %eax
40033092:	68 7f 5d 03 40       	push   $0x40035d7f
40033097:	e8 78 12 00 00       	call   40034314 <iprintf>
4003309c:	58                   	pop    %eax
4003309d:	b8 11 00 00 00       	mov    $0x11,%eax
400330a2:	5a                   	pop    %edx
400330a3:	e8 0d fd ff ff       	call   40032db5 <setTxPower.part.1>
    idle();
400330a8:	e8 6d fc ff ff       	call   40032d1a <idle>
}
400330ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
400330b0:	b8 01 00 00 00       	mov    $0x1,%eax
400330b5:	5b                   	pop    %ebx
400330b6:	5e                   	pop    %esi
400330b7:	5d                   	pop    %ebp
400330b8:	c3                   	ret    

400330b9 <explicitHeaderMode>:
void explicitHeaderMode() {
400330b9:	55                   	push   %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400330ba:	b8 1d 00 00 00       	mov    $0x1d,%eax
void explicitHeaderMode() {
400330bf:	89 e5                	mov    %esp,%ebp
    SX1276._implicitHeaderMode = 0;
400330c1:	c7 05 80 78 00 a8 00 	movl   $0x0,0xa8007880
400330c8:	00 00 00 
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400330cb:	e8 cd fa ff ff       	call   40032b9d <readRegister>
}
400330d0:	5d                   	pop    %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400330d1:	89 c2                	mov    %eax,%edx
400330d3:	b8 1d 00 00 00       	mov    $0x1d,%eax
400330d8:	81 e2 fe 00 00 00    	and    $0xfe,%edx
400330de:	e9 d1 fb ff ff       	jmp    40032cb4 <writeRegister>

400330e3 <implicitHeaderMode>:
void implicitHeaderMode() {
400330e3:	55                   	push   %ebp
400330e4:	89 e5                	mov    %esp,%ebp
    printf("inside implicit header mode\n");
400330e6:	68 97 5d 03 40       	push   $0x40035d97
400330eb:	e8 24 12 00 00       	call   40034314 <iprintf>
400330f0:	58                   	pop    %eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400330f1:	b8 1d 00 00 00       	mov    $0x1d,%eax
    SX1276._implicitHeaderMode = 1;
400330f6:	c7 05 80 78 00 a8 01 	movl   $0x1,0xa8007880
400330fd:	00 00 00 
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033100:	e8 98 fa ff ff       	call   40032b9d <readRegister>
40033105:	0f b6 c0             	movzbl %al,%eax
40033108:	50                   	push   %eax
40033109:	68 b4 5d 03 40       	push   $0x40035db4
4003310e:	e8 01 12 00 00       	call   40034314 <iprintf>
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
40033113:	b8 1d 00 00 00       	mov    $0x1d,%eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033118:	5a                   	pop    %edx
40033119:	59                   	pop    %ecx
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
4003311a:	e8 7e fa ff ff       	call   40032b9d <readRegister>
4003311f:	83 c8 01             	or     $0x1,%eax
40033122:	0f b6 d0             	movzbl %al,%edx
40033125:	b8 1d 00 00 00       	mov    $0x1d,%eax
4003312a:	e8 85 fb ff ff       	call   40032cb4 <writeRegister>
    printf("next value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
4003312f:	b8 1d 00 00 00       	mov    $0x1d,%eax
40033134:	e8 64 fa ff ff       	call   40032b9d <readRegister>
40033139:	0f b6 c0             	movzbl %al,%eax
4003313c:	50                   	push   %eax
4003313d:	68 dd 5d 03 40       	push   $0x40035ddd
40033142:	e8 cd 11 00 00       	call   40034314 <iprintf>
40033147:	58                   	pop    %eax
40033148:	5a                   	pop    %edx
}
40033149:	c9                   	leave  
4003314a:	c3                   	ret    

4003314b <parsePacket>:
int parsePacket(int size) {
4003314b:	55                   	push   %ebp
4003314c:	89 e5                	mov    %esp,%ebp
4003314e:	57                   	push   %edi
4003314f:	56                   	push   %esi
40033150:	89 c6                	mov    %eax,%esi
    int irqFlags = readRegister(REG_IRQ_FLAGS);
40033152:	b8 12 00 00 00       	mov    $0x12,%eax
int parsePacket(int size) {
40033157:	53                   	push   %ebx
    int irqFlags = readRegister(REG_IRQ_FLAGS);
40033158:	e8 40 fa ff ff       	call   40032b9d <readRegister>
    if (size > 0) {
4003315d:	85 f6                	test   %esi,%esi
    int irqFlags = readRegister(REG_IRQ_FLAGS);
4003315f:	0f b6 f8             	movzbl %al,%edi
40033162:	89 fb                	mov    %edi,%ebx
    if (size > 0) {
40033164:	7e 16                	jle    4003317c <parsePacket+0x31>
        implicitHeaderMode();
40033166:	e8 78 ff ff ff       	call   400330e3 <implicitHeaderMode>
        writeRegister(REG_PAYLOAD_LENGTH, size & 0xff);
4003316b:	89 f0                	mov    %esi,%eax
4003316d:	0f b6 d0             	movzbl %al,%edx
40033170:	b8 22 00 00 00       	mov    $0x22,%eax
40033175:	e8 3a fb ff ff       	call   40032cb4 <writeRegister>
4003317a:	eb 05                	jmp    40033181 <parsePacket+0x36>
        explicitHeaderMode();
4003317c:	e8 38 ff ff ff       	call   400330b9 <explicitHeaderMode>
    writeRegister(REG_IRQ_FLAGS, irqFlags);
40033181:	89 fa                	mov    %edi,%edx
40033183:	b8 12 00 00 00       	mov    $0x12,%eax
    if ((irqFlags & IRQ_RX_DONE_MASK) && (irqFlags & IRQ_PAYLOAD_CRC_ERROR_MASK) == 0) {
40033188:	83 e3 60             	and    $0x60,%ebx
    writeRegister(REG_IRQ_FLAGS, irqFlags);
4003318b:	e8 24 fb ff ff       	call   40032cb4 <writeRegister>
    if ((irqFlags & IRQ_RX_DONE_MASK) && (irqFlags & IRQ_PAYLOAD_CRC_ERROR_MASK) == 0) {
40033190:	80 fb 40             	cmp    $0x40,%bl
40033193:	75 43                	jne    400331d8 <parsePacket+0x8d>
        SX1276._packetIndex = 0;
40033195:	c7 05 7c 78 00 a8 00 	movl   $0x0,0xa800787c
4003319c:	00 00 00 
            packetLength = readRegister(REG_PAYLOAD_LENGTH);
4003319f:	b8 22 00 00 00       	mov    $0x22,%eax
        if (SX1276._implicitHeaderMode) {
400331a4:	83 3d 80 78 00 a8 00 	cmpl   $0x0,0xa8007880
400331ab:	75 05                	jne    400331b2 <parsePacket+0x67>
            packetLength = readRegister(REG_RX_NB_BYTES);
400331ad:	b8 13 00 00 00       	mov    $0x13,%eax
400331b2:	e8 e6 f9 ff ff       	call   40032b9d <readRegister>
400331b7:	0f b6 d8             	movzbl %al,%ebx
        writeRegister(REG_FIFO_ADDR_PTR, readRegister(REG_FIFO_RX_CURRENT_ADDR));
400331ba:	b8 10 00 00 00       	mov    $0x10,%eax
400331bf:	e8 d9 f9 ff ff       	call   40032b9d <readRegister>
400331c4:	0f b6 d0             	movzbl %al,%edx
400331c7:	b8 0d 00 00 00       	mov    $0xd,%eax
400331cc:	e8 e3 fa ff ff       	call   40032cb4 <writeRegister>
        idle();
400331d1:	e8 44 fb ff ff       	call   40032d1a <idle>
400331d6:	eb 2b                	jmp    40033203 <parsePacket+0xb8>
    } else if (readRegister(REG_OP_MODE) != (MODE_LONG_RANGE_MODE | MODE_RX_SINGLE)) {
400331d8:	b8 01 00 00 00       	mov    $0x1,%eax
    int packetLength = 0;
400331dd:	31 db                	xor    %ebx,%ebx
    } else if (readRegister(REG_OP_MODE) != (MODE_LONG_RANGE_MODE | MODE_RX_SINGLE)) {
400331df:	e8 b9 f9 ff ff       	call   40032b9d <readRegister>
400331e4:	3c 86                	cmp    $0x86,%al
400331e6:	74 1b                	je     40033203 <parsePacket+0xb8>
        writeRegister(REG_FIFO_ADDR_PTR, 0);
400331e8:	31 d2                	xor    %edx,%edx
400331ea:	b8 0d 00 00 00       	mov    $0xd,%eax
400331ef:	e8 c0 fa ff ff       	call   40032cb4 <writeRegister>
        writeRegister(REG_OP_MODE, MODE_LONG_RANGE_MODE | MODE_RX_SINGLE);
400331f4:	ba 86 00 00 00       	mov    $0x86,%edx
400331f9:	b8 01 00 00 00       	mov    $0x1,%eax
400331fe:	e8 b1 fa ff ff       	call   40032cb4 <writeRegister>
}
40033203:	89 d8                	mov    %ebx,%eax
40033205:	5b                   	pop    %ebx
40033206:	5e                   	pop    %esi
40033207:	5f                   	pop    %edi
40033208:	5d                   	pop    %ebp
40033209:	c3                   	ret    

4003320a <_arc_init>:
{
	uint32_t *reset_vector;

	ARG_UNUSED(arg);

	if (!SCSS_REG_VAL(SCSS_SS_STS)) {
4003320a:	a1 04 06 80 b0       	mov    0xb0800604,%eax
4003320f:	85 c0                	test   %eax,%eax
40033211:	75 15                	jne    40033228 <_arc_init+0x1e>
{
40033213:	55                   	push   %ebp
40033214:	89 e5                	mov    %esp,%ebp
		/* ARC shouldn't already be running! */
		printk("ARC core already running!");
40033216:	68 0e 5e 03 40       	push   $0x40035e0e
4003321b:	e8 41 e0 ff ff       	call   40031261 <printk>
40033220:	58                   	pop    %eax
		return -EIO;
40033221:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}

skip_arc_init:

	return 0;
}
40033226:	c9                   	leave  
40033227:	c3                   	ret    
	shared_data->arc_start = *reset_vector;
40033228:	a1 00 00 00 40       	mov    0x40000000,%eax
4003322d:	a3 00 00 00 a8       	mov    %eax,0xa8000000
	shared_data->flags = 0;
40033232:	c7 05 04 00 00 a8 00 	movl   $0x0,0xa8000004
40033239:	00 00 00 
	if (!shared_data->arc_start) {
4003323c:	a1 00 00 00 a8       	mov    0xa8000000,%eax
40033241:	85 c0                	test   %eax,%eax
40033243:	75 03                	jne    40033248 <_arc_init+0x3e>
	return 0;
40033245:	31 c0                	xor    %eax,%eax
40033247:	c3                   	ret    
	SCSS_REG_VAL(SCSS_SS_CFG) |= ARC_RUN_REQ_A;
40033248:	a1 00 06 80 b0       	mov    0xb0800600,%eax
4003324d:	0d 00 00 00 01       	or     $0x1000000,%eax
40033252:	a3 00 06 80 b0       	mov    %eax,0xb0800600
	while (SCSS_REG_VAL(SCSS_SS_STS) & 0x4000) {
40033257:	a1 04 06 80 b0       	mov    0xb0800604,%eax
4003325c:	0f ba e0 0e          	bt     $0xe,%eax
40033260:	72 f5                	jb     40033257 <_arc_init+0x4d>
	while (!(shared_data->flags & ARC_READY)) {
40033262:	a1 04 00 00 a8       	mov    0xa8000004,%eax
40033267:	a8 01                	test   $0x1,%al
40033269:	74 f7                	je     40033262 <_arc_init+0x58>
4003326b:	eb d8                	jmp    40033245 <_arc_init+0x3b>

4003326d <_lakemont_eoi>:
#include <arch/x86/irq_controller.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
4003326d:	55                   	push   %ebp
4003326e:	89 e5                	mov    %esp,%ebp
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
40033270:	e8 ef d3 ff ff       	call   40030664 <__irq_controller_isr_vector_get>
40033275:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
4003327a:	31 c0                	xor    %eax,%eax
4003327c:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	sys_write32(_irq_controller_isr_vector_get(),
		    CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);

	/* Send EOI to the LOAPIC as well */
	sys_write32(0, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI);
}
40033281:	5d                   	pop    %ebp
40033282:	c3                   	ret    

40033283 <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
40033283:	55                   	push   %ebp
40033284:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
40033286:	e8 61 0c 00 00       	call   40033eec <k_is_in_isr>
4003328b:	85 c0                	test   %eax,%eax
4003328d:	74 15                	je     400332a4 <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
4003328f:	e8 58 0c 00 00       	call   40033eec <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
40033294:	ba 28 5e 03 40       	mov    $0x40035e28,%edx
40033299:	85 c0                	test   %eax,%eax
4003329b:	75 2c                	jne    400332c9 <_SysFatalErrorHandler+0x46>
4003329d:	ba 2c 5e 03 40       	mov    $0x40035e2c,%edx
400332a2:	eb 25                	jmp    400332c9 <_SysFatalErrorHandler+0x46>
	if (k_is_in_isr() || _is_thread_essential()) {
400332a4:	e8 54 0c 00 00       	call   40033efd <_is_thread_essential>
400332a9:	85 c0                	test   %eax,%eax
400332ab:	75 e2                	jne    4003328f <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
400332ad:	ff 35 a8 76 00 a8    	pushl  0xa80076a8
400332b3:	68 5d 5e 03 40       	push   $0x40035e5d
400332b8:	e8 a4 df ff ff       	call   40031261 <printk>
400332bd:	58                   	pop    %eax
	k_thread_abort(_current);
400332be:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
	printk("Fatal fault in thread %p! Aborting.\n", _current);
400332c3:	5a                   	pop    %edx
	k_thread_abort(_current);
400332c4:	e8 6f 0d 00 00       	call   40034038 <k_thread_abort>
		printk("Fatal fault in %s! Spinning...\n",
400332c9:	52                   	push   %edx
400332ca:	68 3d 5e 03 40       	push   $0x40035e3d
400332cf:	e8 8d df ff ff       	call   40031261 <printk>
400332d4:	59                   	pop    %ecx
400332d5:	58                   	pop    %eax
400332d6:	eb fe                	jmp    400332d6 <_SysFatalErrorHandler+0x53>

400332d8 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
400332d8:	53                   	push   %ebx
	movl $1, %eax
400332d9:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
400332de:	0f a2                	cpuid  
	movl %ebx, %eax
400332e0:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
400332e2:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
400332e7:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
400332ea:	5b                   	pop    %ebx
	ret
400332eb:	c3                   	ret    

400332ec <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
400332ec:	55                   	push   %ebp
400332ed:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
400332ef:	e8 e4 ff ff ff       	call   400332d8 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
400332f4:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
400332f5:	a3 9c 78 00 a8       	mov    %eax,0xa800789c
}
400332fa:	31 c0                	xor    %eax,%eax
400332fc:	c3                   	ret    

400332fd <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
400332fd:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
400332fe:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
40033301:	50                   	push   %eax
	pushl	%edx
40033302:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
40033303:	57                   	push   %edi
	pushl	%esi
40033304:	56                   	push   %esi
	pushl	%ebx
40033305:	53                   	push   %ebx
	pushl	%ebp
40033306:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
40033307:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
4003330b:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
4003330c:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
40033313:	00 
	je	allDone
40033314:	74 01                	je     40033317 <allDone>
	sti
40033316:	fb                   	sti    

40033317 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
40033317:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
40033319:	ff d1                	call   *%ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
4003331b:	5d                   	pop    %ebp
	popl	%ebp
4003331c:	5d                   	pop    %ebp
	popl	%ebx
4003331d:	5b                   	pop    %ebx
	popl	%esi
4003331e:	5e                   	pop    %esi
	popl	%edi
4003331f:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
40033320:	5a                   	pop    %edx
	popl	%eax
40033321:	58                   	pop    %eax
	popl	%ecx
40033322:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
40033323:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033326:	cf                   	iret   

40033327 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
40033327:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
40033328:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
4003332c:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
4003332f:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
40033330:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
40033331:	b9 a0 76 00 a8       	mov    $0xa80076a0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
40033336:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
40033338:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
4003333b:	75 06                	jne    40033343 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
4003333d:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
4003333f:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
40033342:	57                   	push   %edi

40033343 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
40033343:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
40033344:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
40033346:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
40033347:	e8 21 ff ff ff       	call   4003326d <_lakemont_eoi>
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
4003334c:	b9 a0 76 00 a8       	mov    $0xa80076a0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
40033351:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
40033353:	75 1e                	jne    40033373 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
40033355:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
40033358:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
4003335e:	73 12                	jae    40033372 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
40033360:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
40033363:	74 0d                	je     40033372 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
40033365:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
40033366:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
40033367:	58                   	pop    %eax
#endif
	call	_Swap
40033368:	e8 27 00 00 00       	call   40033394 <_Swap>

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
4003336d:	5f                   	pop    %edi
	popl	%ecx
4003336e:	59                   	pop    %ecx
	popl	%edx
4003336f:	5a                   	pop    %edx
	popl	%eax
40033370:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033371:	cf                   	iret   

40033372 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
40033372:	5c                   	pop    %esp

40033373 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
40033373:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
40033374:	59                   	pop    %ecx
	popl	%edx
40033375:	5a                   	pop    %edx
	popl	%eax
40033376:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033377:	cf                   	iret   

40033378 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
40033378:	6a 00                	push   $0x0

4003337a <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
4003337a:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
4003337b:	50                   	push   %eax
	pushl %ecx
4003337c:	51                   	push   %ecx
	pushl %edx
4003337d:	52                   	push   %edx
	pushl %edi
4003337e:	57                   	push   %edi
	pushl %esi
4003337f:	56                   	push   %esi
	pushl %ebx
40033380:	53                   	push   %ebx
	pushl %ebp
40033381:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
40033382:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
40033386:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
40033387:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
40033389:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
4003338a:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
4003338f:	e8 9b 00 00 00       	call   4003342f <_NanoFatalErrorHandler>

40033394 <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
40033394:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
40033397:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
4003339b:	57                   	push   %edi

	movl	$_kernel, %edi
4003339c:	bf a0 76 00 a8       	mov    $0xa80076a0,%edi

	pushl	%esi
400333a1:	56                   	push   %esi
	pushl	%ebx
400333a2:	53                   	push   %ebx
	pushl	%ebp
400333a3:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
400333a4:	ff 35 64 60 03 40    	pushl  0x40036064


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
400333aa:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
400333ad:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
400333b0:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
400333b3:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
400333b6:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
400333b9:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
400333ba:	5d                   	pop    %ebp
	popl	%ebx
400333bb:	5b                   	pop    %ebx
	popl	%esi
400333bc:	5e                   	pop    %esi
	popl	%edi
400333bd:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
400333be:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
400333c2:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
400333c3:	5a                   	pop    %edx
	movl	%edx, (%esp)
400333c4:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
400333c7:	c3                   	ret    

400333c8 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
400333c8:	55                   	push   %ebp
400333c9:	89 e5                	mov    %esp,%ebp
400333cb:	56                   	push   %esi
400333cc:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
400333cd:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
400333d0:	83 e3 fc             	and    $0xfffffffc,%ebx
{
400333d3:	89 c6                	mov    %eax,%esi
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
400333d5:	8b 45 10             	mov    0x10(%ebp),%eax
400333d8:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
400333db:	8b 45 0c             	mov    0xc(%ebp),%eax
400333de:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
400333e1:	8b 45 08             	mov    0x8(%ebp),%eax
400333e4:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
400333e7:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
400333ea:	9c                   	pushf  
400333eb:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400333ec:	80 e4 cd             	and    $0xcd,%ah
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
400333ef:	c7 43 e8 60 00 03 40 	movl   $0x40030060,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400333f6:	80 cc 02             	or     $0x2,%ah
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400333f9:	8b 55 14             	mov    0x14(%ebp),%edx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400333fc:	89 43 ec             	mov    %eax,-0x14(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
400333ff:	b9 04 00 00 00       	mov    $0x4,%ecx
40033404:	ff 75 18             	pushl  0x18(%ebp)
40033407:	89 f0                	mov    %esi,%eax
	pInitialCtx -= 11;
40033409:	83 eb 2c             	sub    $0x2c,%ebx
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
4003340c:	e8 f4 0b 00 00       	call   40034005 <_init_thread_base>
	pInitialCtx -= 11;
40033411:	89 5e 28             	mov    %ebx,0x28(%esi)
	thread->init_data = NULL;
40033414:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
4003341b:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033422:	58                   	pop    %eax
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
40033423:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033426:	5b                   	pop    %ebx
40033427:	5e                   	pop    %esi
40033428:	5d                   	pop    %ebp
40033429:	c3                   	ret    

4003342a <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
4003342a:	55                   	push   %ebp
4003342b:	89 e5                	mov    %esp,%ebp
4003342d:	5d                   	pop    %ebp
4003342e:	c3                   	ret    

4003342f <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
4003342f:	55                   	push   %ebp
40033430:	89 e5                	mov    %esp,%ebp
40033432:	57                   	push   %edi
40033433:	56                   	push   %esi
40033434:	53                   	push   %ebx
40033435:	83 ec 28             	sub    $0x28,%esp
40033438:	89 c6                	mov    %eax,%esi
	_debug_fatal_hook(pEsf);
4003343a:	89 d0                	mov    %edx,%eax
{
4003343c:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
4003343e:	e8 e7 ff ff ff       	call   4003342a <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
40033443:	83 fe 03             	cmp    $0x3,%esi
40033446:	74 3e                	je     40033486 <_NanoFatalErrorHandler+0x57>
40033448:	77 06                	ja     40033450 <_NanoFatalErrorHandler+0x21>
4003344a:	85 f6                	test   %esi,%esi
4003344c:	74 0e                	je     4003345c <_NanoFatalErrorHandler+0x2d>
4003344e:	eb 4a                	jmp    4003349a <_NanoFatalErrorHandler+0x6b>
40033450:	83 fe 05             	cmp    $0x5,%esi
40033453:	74 3e                	je     40033493 <_NanoFatalErrorHandler+0x64>
40033455:	83 fe 06             	cmp    $0x6,%esi
40033458:	74 4d                	je     400334a7 <_NanoFatalErrorHandler+0x78>
4003345a:	eb 3e                	jmp    4003349a <_NanoFatalErrorHandler+0x6b>
4003345c:	e8 03 d2 ff ff       	call   40030664 <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
40033461:	68 82 5e 03 40       	push   $0x40035e82
40033466:	89 c3                	mov    %eax,%ebx
40033468:	e8 f4 dd ff ff       	call   40031261 <printk>
4003346d:	58                   	pop    %eax
		if (vector >= 0) {
4003346e:	85 db                	test   %ebx,%ebx
40033470:	78 0d                	js     4003347f <_NanoFatalErrorHandler+0x50>
			printk("%d ", vector);
40033472:	53                   	push   %ebx
40033473:	68 a4 5e 03 40       	push   $0x40035ea4
40033478:	e8 e4 dd ff ff       	call   40031261 <printk>
4003347d:	5b                   	pop    %ebx
4003347e:	58                   	pop    %eax
		}
		printk("*****\n");
4003347f:	68 cb 5e 03 40       	push   $0x40035ecb
40033484:	eb 05                	jmp    4003348b <_NanoFatalErrorHandler+0x5c>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
40033486:	68 a8 5e 03 40       	push   $0x40035ea8
4003348b:	e8 d1 dd ff ff       	call   40031261 <printk>
40033490:	59                   	pop    %ecx
		break;
40033491:	eb 14                	jmp    400334a7 <_NanoFatalErrorHandler+0x78>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40033493:	68 d2 5e 03 40       	push   $0x40035ed2
40033498:	eb f1                	jmp    4003348b <_NanoFatalErrorHandler+0x5c>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
4003349a:	56                   	push   %esi
4003349b:	68 f8 5e 03 40       	push   $0x40035ef8
400334a0:	e8 bc dd ff ff       	call   40031261 <printk>
400334a5:	58                   	pop    %eax
400334a6:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
400334a7:	8b 47 04             	mov    0x4(%edi),%eax
400334aa:	8b 4f 2c             	mov    0x2c(%edi),%ecx
400334ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
400334b0:	8b 47 10             	mov    0x10(%edi),%eax
400334b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400334b6:	8b 47 0c             	mov    0xc(%edi),%eax
400334b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
400334bc:	8b 47 14             	mov    0x14(%edi),%eax
400334bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400334c2:	8b 47 1c             	mov    0x1c(%edi),%eax
400334c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
400334c8:	8b 47 08             	mov    0x8(%edi),%eax
400334cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
400334ce:	8b 47 18             	mov    0x18(%edi),%eax
400334d1:	8b 17                	mov    (%edi),%edx
400334d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
400334d6:	8b 47 24             	mov    0x24(%edi),%eax
400334d9:	89 4d cc             	mov    %ecx,-0x34(%ebp)
400334dc:	89 55 d0             	mov    %edx,-0x30(%ebp)
400334df:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400334e2:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
400334e6:	e8 b3 05 00 00       	call   40033a9e <k_current_get>
400334eb:	8b 55 d0             	mov    -0x30(%ebp),%edx
400334ee:	8b 4d cc             	mov    -0x34(%ebp),%ecx
400334f1:	51                   	push   %ecx
400334f2:	52                   	push   %edx
400334f3:	ff 75 f0             	pushl  -0x10(%ebp)
400334f6:	ff 75 ec             	pushl  -0x14(%ebp)
400334f9:	ff 75 e8             	pushl  -0x18(%ebp)
400334fc:	ff 75 e4             	pushl  -0x1c(%ebp)
400334ff:	ff 75 e0             	pushl  -0x20(%ebp)
40033502:	ff 75 dc             	pushl  -0x24(%ebp)
40033505:	ff 75 d8             	pushl  -0x28(%ebp)
40033508:	ff 75 d4             	pushl  -0x2c(%ebp)
4003350b:	53                   	push   %ebx
4003350c:	50                   	push   %eax
4003350d:	68 1b 5f 03 40       	push   $0x40035f1b
40033512:	e8 4a dd ff ff       	call   40031261 <printk>
40033517:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
4003351a:	89 fa                	mov    %edi,%edx
4003351c:	89 f0                	mov    %esi,%eax
4003351e:	e8 60 fd ff ff       	call   40033283 <_SysFatalErrorHandler>

40033523 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
40033523:	55                   	push   %ebp
40033524:	89 e5                	mov    %esp,%ebp
40033526:	56                   	push   %esi
40033527:	89 c6                	mov    %eax,%esi
40033529:	53                   	push   %ebx
4003352a:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
4003352c:	50                   	push   %eax
4003352d:	68 ba 5f 03 40       	push   $0x40035fba
40033532:	e8 2a dd ff ff       	call   40031261 <printk>
40033537:	59                   	pop    %ecx
40033538:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
40033539:	b8 00 7d 02 00       	mov    $0x27d00,%eax
4003353e:	0f a3 f0             	bt     %esi,%eax
40033541:	73 0f                	jae    40033552 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
40033543:	ff 73 20             	pushl  0x20(%ebx)
40033546:	68 d2 5f 03 40       	push   $0x40035fd2
4003354b:	e8 11 dd ff ff       	call   40031261 <printk>
40033550:	58                   	pop    %eax
40033551:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
40033552:	89 da                	mov    %ebx,%edx
40033554:	b8 06 00 00 00       	mov    $0x6,%eax
40033559:	e8 d1 fe ff ff       	call   4003342f <_NanoFatalErrorHandler>

4003355e <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
4003355e:	55                   	push   %ebp
4003355f:	89 c2                	mov    %eax,%edx
40033561:	89 e5                	mov    %esp,%ebp
40033563:	31 c0                	xor    %eax,%eax
40033565:	e8 b9 ff ff ff       	call   40033523 <generic_exc_handle>

4003356a <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
4003356a:	55                   	push   %ebp
4003356b:	89 c2                	mov    %eax,%edx
4003356d:	89 e5                	mov    %esp,%ebp
4003356f:	b8 02 00 00 00       	mov    $0x2,%eax
40033574:	e8 aa ff ff ff       	call   40033523 <generic_exc_handle>

40033579 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
40033579:	55                   	push   %ebp
4003357a:	89 c2                	mov    %eax,%edx
4003357c:	89 e5                	mov    %esp,%ebp
4003357e:	b8 04 00 00 00       	mov    $0x4,%eax
40033583:	e8 9b ff ff ff       	call   40033523 <generic_exc_handle>

40033588 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
40033588:	55                   	push   %ebp
40033589:	89 c2                	mov    %eax,%edx
4003358b:	89 e5                	mov    %esp,%ebp
4003358d:	b8 05 00 00 00       	mov    $0x5,%eax
40033592:	e8 8c ff ff ff       	call   40033523 <generic_exc_handle>

40033597 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
40033597:	55                   	push   %ebp
40033598:	89 c2                	mov    %eax,%edx
4003359a:	89 e5                	mov    %esp,%ebp
4003359c:	b8 06 00 00 00       	mov    $0x6,%eax
400335a1:	e8 7d ff ff ff       	call   40033523 <generic_exc_handle>

400335a6 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
400335a6:	55                   	push   %ebp
400335a7:	89 c2                	mov    %eax,%edx
400335a9:	89 e5                	mov    %esp,%ebp
400335ab:	b8 07 00 00 00       	mov    $0x7,%eax
400335b0:	e8 6e ff ff ff       	call   40033523 <generic_exc_handle>

400335b5 <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
400335b5:	55                   	push   %ebp
400335b6:	89 c2                	mov    %eax,%edx
400335b8:	89 e5                	mov    %esp,%ebp
400335ba:	b8 08 00 00 00       	mov    $0x8,%eax
400335bf:	e8 5f ff ff ff       	call   40033523 <generic_exc_handle>

400335c4 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
400335c4:	55                   	push   %ebp
400335c5:	89 c2                	mov    %eax,%edx
400335c7:	89 e5                	mov    %esp,%ebp
400335c9:	b8 0a 00 00 00       	mov    $0xa,%eax
400335ce:	e8 50 ff ff ff       	call   40033523 <generic_exc_handle>

400335d3 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
400335d3:	55                   	push   %ebp
400335d4:	89 c2                	mov    %eax,%edx
400335d6:	89 e5                	mov    %esp,%ebp
400335d8:	b8 0b 00 00 00       	mov    $0xb,%eax
400335dd:	e8 41 ff ff ff       	call   40033523 <generic_exc_handle>

400335e2 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
400335e2:	55                   	push   %ebp
400335e3:	89 c2                	mov    %eax,%edx
400335e5:	89 e5                	mov    %esp,%ebp
400335e7:	b8 0c 00 00 00       	mov    $0xc,%eax
400335ec:	e8 32 ff ff ff       	call   40033523 <generic_exc_handle>

400335f1 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
400335f1:	55                   	push   %ebp
400335f2:	89 c2                	mov    %eax,%edx
400335f4:	89 e5                	mov    %esp,%ebp
400335f6:	b8 0d 00 00 00       	mov    $0xd,%eax
400335fb:	e8 23 ff ff ff       	call   40033523 <generic_exc_handle>

40033600 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
40033600:	55                   	push   %ebp
40033601:	89 c2                	mov    %eax,%edx
40033603:	89 e5                	mov    %esp,%ebp
40033605:	b8 0e 00 00 00       	mov    $0xe,%eax
4003360a:	e8 14 ff ff ff       	call   40033523 <generic_exc_handle>

4003360f <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
4003360f:	55                   	push   %ebp
40033610:	89 c2                	mov    %eax,%edx
40033612:	89 e5                	mov    %esp,%ebp
40033614:	b8 10 00 00 00       	mov    $0x10,%eax
40033619:	e8 05 ff ff ff       	call   40033523 <generic_exc_handle>

4003361e <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
4003361e:	55                   	push   %ebp
4003361f:	89 c2                	mov    %eax,%edx
40033621:	89 e5                	mov    %esp,%ebp
40033623:	b8 11 00 00 00       	mov    $0x11,%eax
40033628:	e8 f6 fe ff ff       	call   40033523 <generic_exc_handle>

4003362d <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
4003362d:	55                   	push   %ebp
4003362e:	89 c2                	mov    %eax,%edx
40033630:	89 e5                	mov    %esp,%ebp
40033632:	b8 12 00 00 00       	mov    $0x12,%eax
40033637:	e8 e7 fe ff ff       	call   40033523 <generic_exc_handle>

4003363c <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
4003363c:	55                   	push   %ebp
4003363d:	89 e5                	mov    %esp,%ebp
4003363f:	56                   	push   %esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033640:	8d 70 01             	lea    0x1(%eax),%esi
{
40033643:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033644:	8b 1c 85 40 60 03 40 	mov    0x40036040(,%eax,4),%ebx
4003364b:	3b 1c b5 40 60 03 40 	cmp    0x40036040(,%esi,4),%ebx
40033652:	73 0c                	jae    40033660 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
40033654:	8b 13                	mov    (%ebx),%edx
40033656:	89 d8                	mov    %ebx,%eax
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033658:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
4003365b:	ff 52 04             	call   *0x4(%edx)
4003365e:	eb eb                	jmp    4003364b <_sys_device_do_config_level+0xf>
	}
}
40033660:	5b                   	pop    %ebx
40033661:	5e                   	pop    %esi
40033662:	5d                   	pop    %ebp
40033663:	c3                   	ret    

40033664 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
40033664:	55                   	push   %ebp
40033665:	89 e5                	mov    %esp,%ebp
40033667:	56                   	push   %esi
40033668:	89 c6                	mov    %eax,%esi
4003366a:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
4003366b:	bb f4 66 00 a8       	mov    $0xa80066f4,%ebx
40033670:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033676:	74 1c                	je     40033694 <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033678:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
4003367c:	75 05                	jne    40033683 <device_get_binding+0x1f>
	for (info = __device_init_start; info != __device_init_end; info++) {
4003367e:	83 c3 0c             	add    $0xc,%ebx
40033681:	eb ed                	jmp    40033670 <device_get_binding+0xc>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033683:	8b 03                	mov    (%ebx),%eax
40033685:	8b 10                	mov    (%eax),%edx
40033687:	89 f0                	mov    %esi,%eax
40033689:	e8 c5 0c 00 00       	call   40034353 <strcmp>
4003368e:	85 c0                	test   %eax,%eax
40033690:	75 ec                	jne    4003367e <device_get_binding+0x1a>
40033692:	eb 02                	jmp    40033696 <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
40033694:	31 db                	xor    %ebx,%ebx
}
40033696:	89 d8                	mov    %ebx,%eax
40033698:	5b                   	pop    %ebx
40033699:	5e                   	pop    %esi
4003369a:	5d                   	pop    %ebp
4003369b:	c3                   	ret    

4003369c <device_busy_set>:
4003369c:	55                   	push   %ebp
4003369d:	89 e5                	mov    %esp,%ebp
4003369f:	5d                   	pop    %ebp
400336a0:	c3                   	ret    

400336a1 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
400336a1:	55                   	push   %ebp
400336a2:	89 e5                	mov    %esp,%ebp
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
400336a4:	5d                   	pop    %ebp
400336a5:	c3                   	ret    

400336a6 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
400336a6:	55                   	push   %ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
400336a7:	b8 02 00 00 00       	mov    $0x2,%eax
{
400336ac:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
400336ae:	e8 89 ff ff ff       	call   4003363c <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
400336b3:	b8 05 00 00 00       	mov    $0x5,%eax
400336b8:	e8 7f ff ff ff       	call   4003363c <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
400336bd:	b8 06 00 00 00       	mov    $0x6,%eax
400336c2:	e8 75 ff ff ff       	call   4003363c <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
400336c7:	b8 07 00 00 00       	mov    $0x7,%eax
400336cc:	e8 6b ff ff ff       	call   4003363c <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
400336d1:	b8 03 00 00 00       	mov    $0x3,%eax
400336d6:	e8 61 ff ff ff       	call   4003363c <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
400336db:	e8 ac 08 00 00       	call   40033f8c <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
400336e0:	e8 3f cc ff ff       	call   40030324 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}
400336e5:	5d                   	pop    %ebp
	_main_thread->base.user_options &= ~K_ESSENTIAL;
400336e6:	80 25 c4 81 00 a8 fe 	andb   $0xfe,0xa80081c4
}
400336ed:	c3                   	ret    

400336ee <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
400336ee:	55                   	push   %ebp
400336ef:	89 e5                	mov    %esp,%ebp
400336f1:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
400336f4:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
400336f7:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
400336fb:	a3 a8 76 00 a8       	mov    %eax,0xa80076a8
	dummy_thread->base.user_options = K_ESSENTIAL;
40033700:	b8 1c 00 00 00       	mov    $0x1c,%eax
40033705:	8d 90 a0 76 00 a8    	lea    -0x57ff8960(%eax),%edx
4003370b:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
4003370e:	89 90 98 76 00 a8    	mov    %edx,-0x57ff8968(%eax)
	list->tail = (sys_dnode_t *)list;
40033714:	89 90 9c 76 00 a8    	mov    %edx,-0x57ff8964(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
4003371a:	3d 1c 01 00 00       	cmp    $0x11c,%eax
4003371f:	75 e4                	jne    40033705 <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033721:	6a 01                	push   $0x1
40033723:	b9 a6 36 03 40       	mov    $0x400336a6,%ecx
40033728:	6a 00                	push   $0x0
4003372a:	ba 00 04 00 00       	mov    $0x400,%edx
4003372f:	6a 00                	push   $0x0
40033731:	b8 bc 81 00 a8       	mov    $0xa80081bc,%eax
40033736:	6a 00                	push   $0x0
40033738:	6a 00                	push   $0x0
	_ready_q.cache = _main_thread;
4003373a:	c7 05 b4 76 00 a8 bc 	movl   $0xa80081bc,0xa80076b4
40033741:	81 00 a8 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033744:	e8 7f fc ff ff       	call   400333c8 <_new_thread>
40033749:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_main_thread);
4003374c:	b8 bc 81 00 a8       	mov    $0xa80081bc,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033751:	80 25 c5 81 00 a8 fb 	andb   $0xfb,0xa80081c5
40033758:	e8 2c 01 00 00       	call   40033889 <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
4003375d:	b9 1a 2d 03 40       	mov    $0x40032d1a,%ecx
40033762:	ba 00 01 00 00       	mov    $0x100,%edx
40033767:	6a 01                	push   $0x1
40033769:	b8 bc 80 00 a8       	mov    $0xa80080bc,%eax
4003376e:	6a 0f                	push   $0xf
40033770:	6a 00                	push   $0x0
40033772:	6a 00                	push   $0x0
40033774:	6a 00                	push   $0x0
40033776:	e8 4d fc ff ff       	call   400333c8 <_new_thread>
4003377b:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_idle_thread);
4003377e:	b8 bc 80 00 a8       	mov    $0xa80080bc,%eax
40033783:	80 25 c5 80 00 a8 fb 	andb   $0xfb,0xa80080c5
4003378a:	e8 fa 00 00 00       	call   40033889 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
4003378f:	b8 04 00 00 00       	mov    $0x4,%eax
	list->head = (sys_dnode_t *)list;
40033794:	c7 05 ac 76 00 a8 ac 	movl   $0xa80076ac,0xa80076ac
4003379b:	76 00 a8 
	list->tail = (sys_dnode_t *)list;
4003379e:	c7 05 b0 76 00 a8 ac 	movl   $0xa80076ac,0xa80076b0
400337a5:	76 00 a8 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
400337a8:	c7 05 a0 76 00 a8 00 	movl   $0x0,0xa80076a0
400337af:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
400337b2:	c7 05 a4 76 00 a8 bc 	movl   $0xa80080bc,0xa80076a4
400337b9:	80 00 a8 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
400337bc:	c7 05 a0 78 00 a8 00 	movl   $0x800,0xa80078a0
400337c3:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
400337c6:	c7 05 84 78 00 a8 fd 	movl   $0x400332fd,0xa8007884
400337cd:	32 03 40 
400337d0:	e8 67 fe ff ff       	call   4003363c <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
400337d5:	31 c0                	xor    %eax,%eax
400337d7:	e8 60 fe ff ff       	call   4003363c <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
400337dc:	b8 01 00 00 00       	mov    $0x1,%eax
400337e1:	e8 56 fe ff ff       	call   4003363c <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
400337e6:	68 68 60 03 40       	push   $0x40036068
400337eb:	68 84 60 03 40       	push   $0x40036084
400337f0:	e8 6c da ff ff       	call   40031261 <printk>
400337f5:	58                   	pop    %eax
400337f6:	5a                   	pop    %edx
	__asm__ volatile (
400337f7:	9c                   	pushf  
400337f8:	fa                   	cli    
400337f9:	58                   	pop    %eax
	_Swap(irq_lock());
400337fa:	e8 95 fb ff ff       	call   40033394 <_Swap>

400337ff <_get_highest_ready_prio>:
{
400337ff:	55                   	push   %ebp
40033800:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40033802:	0f bc 05 b8 76 00 a8 	bsf    0xa80076b8,%eax
40033809:	75 05                	jne    40033810 <_get_highest_ready_prio+0x11>
4003380b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
40033810:	83 e8 10             	sub    $0x10,%eax
}
40033813:	5d                   	pop    %ebp
40033814:	c3                   	ret    

40033815 <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
40033815:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
40033816:	89 42 08             	mov    %eax,0x8(%edx)
{
40033819:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003381b:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
4003381e:	53                   	push   %ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
4003381f:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033824:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033827:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033829:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003382c:	74 07                	je     40033835 <_add_timeout+0x20>
4003382e:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40033833:	75 1d                	jne    40033852 <_add_timeout+0x3d>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
40033835:	c7 02 ac 76 00 a8    	movl   $0xa80076ac,(%edx)
	node->prev = list->tail;
4003383b:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40033840:	89 42 04             	mov    %eax,0x4(%edx)

	list->tail->next = node;
40033843:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40033848:	89 10                	mov    %edx,(%eax)
	list->tail = node;
4003384a:	89 15 b0 76 00 a8    	mov    %edx,0xa80076b0
40033850:	eb 34                	jmp    40033886 <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
40033852:	8b 4a 10             	mov    0x10(%edx),%ecx
40033855:	8b 58 10             	mov    0x10(%eax),%ebx
40033858:	39 d9                	cmp    %ebx,%ecx
4003385a:	7f 17                	jg     40033873 <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
4003385c:	29 cb                	sub    %ecx,%ebx
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
4003385e:	8b 48 04             	mov    0x4(%eax),%ecx
40033861:	89 58 10             	mov    %ebx,0x10(%eax)
40033864:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
40033867:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
40033869:	8b 48 04             	mov    0x4(%eax),%ecx
4003386c:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
4003386e:	89 50 04             	mov    %edx,0x4(%eax)
40033871:	eb 13                	jmp    40033886 <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
40033873:	29 d9                	sub    %ebx,%ecx
40033875:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
40033878:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
4003387e:	74 b5                	je     40033835 <_add_timeout+0x20>
40033880:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033882:	85 c0                	test   %eax,%eax
40033884:	eb ad                	jmp    40033833 <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
40033886:	5b                   	pop    %ebx
40033887:	5d                   	pop    %ebp
40033888:	c3                   	ret    

40033889 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
40033889:	55                   	push   %ebp
4003388a:	89 e5                	mov    %esp,%ebp
4003388c:	56                   	push   %esi
4003388d:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
4003388e:	bb 01 00 00 00       	mov    $0x1,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033893:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
40033897:	8d 4a 10             	lea    0x10(%edx),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
4003389a:	89 ce                	mov    %ecx,%esi
4003389c:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
4003389f:	d3 e3                	shl    %cl,%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
400338a1:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx
	node->prev = list->tail;
400338a8:	83 c2 14             	add    $0x14,%edx
	*bmap |= _get_ready_q_prio_bit(prio);
400338ab:	09 1c b5 b8 76 00 a8 	or     %ebx,-0x57ff8948(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
400338b2:	89 08                	mov    %ecx,(%eax)
400338b4:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
400338bb:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
400338be:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
400338c5:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
400338c7:	89 04 d5 a0 76 00 a8 	mov    %eax,-0x57ff8960(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
400338ce:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
400338d4:	8a 5a 0a             	mov    0xa(%edx),%bl
400338d7:	38 58 0a             	cmp    %bl,0xa(%eax)
400338da:	7c 02                	jl     400338de <_add_thread_to_ready_q+0x55>
400338dc:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
400338de:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
400338df:	a3 b4 76 00 a8       	mov    %eax,0xa80076b4
}
400338e4:	5e                   	pop    %esi
400338e5:	5d                   	pop    %ebp
400338e6:	c3                   	ret    

400338e7 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
400338e7:	55                   	push   %ebp
400338e8:	89 e5                	mov    %esp,%ebp
400338ea:	53                   	push   %ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
400338eb:	8b 48 04             	mov    0x4(%eax),%ecx
400338ee:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
400338f0:	0f be 50 0a          	movsbl 0xa(%eax),%edx
400338f4:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
400338f6:	8b 18                	mov    (%eax),%ebx
400338f8:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
400338fb:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
40033902:	3b 0c d5 3c 77 00 a8 	cmp    -0x57ff88c4(,%edx,8),%ecx
40033909:	75 1c                	jne    40033927 <_remove_thread_from_ready_q+0x40>
		_clear_ready_q_prio_bit(thread->base.prio);
4003390b:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
4003390f:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033912:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033917:	89 cb                	mov    %ecx,%ebx
40033919:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
4003391c:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
4003391e:	f7 d2                	not    %edx
40033920:	21 14 9d b8 76 00 a8 	and    %edx,-0x57ff8948(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033927:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
4003392d:	39 d0                	cmp    %edx,%eax
4003392f:	75 0c                	jne    4003393d <_remove_thread_from_ready_q+0x56>
	int prio = _get_highest_ready_prio();
40033931:	e8 c9 fe ff ff       	call   400337ff <_get_highest_ready_prio>
40033936:	8b 14 c5 3c 77 00 a8 	mov    -0x57ff88c4(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
4003393d:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
4003393e:	89 15 b4 76 00 a8    	mov    %edx,0xa80076b4
}
40033944:	5d                   	pop    %ebp
40033945:	c3                   	ret    

40033946 <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
40033946:	55                   	push   %ebp
40033947:	89 e5                	mov    %esp,%ebp
40033949:	57                   	push   %edi
4003394a:	56                   	push   %esi
4003394b:	53                   	push   %ebx
	return list->head == list;
4003394c:	8b 1a                	mov    (%edx),%ebx
4003394e:	89 cf                	mov    %ecx,%edi
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033950:	39 da                	cmp    %ebx,%edx
40033952:	75 0b                	jne    4003395f <_pend_thread+0x19>
40033954:	31 db                	xor    %ebx,%ebx
40033956:	eb 07                	jmp    4003395f <_pend_thread+0x19>
	return (node == list->tail) ? NULL : node->next;
40033958:	3b 5a 04             	cmp    0x4(%edx),%ebx
4003395b:	74 20                	je     4003397d <_pend_thread+0x37>
4003395d:	8b 1b                	mov    (%ebx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
4003395f:	85 db                	test   %ebx,%ebx
40033961:	74 1a                	je     4003397d <_pend_thread+0x37>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
40033963:	8a 4b 0a             	mov    0xa(%ebx),%cl
40033966:	38 48 0a             	cmp    %cl,0xa(%eax)
40033969:	7d ed                	jge    40033958 <_pend_thread+0x12>
		node->prev = insert_point->prev;
4003396b:	8b 73 04             	mov    0x4(%ebx),%esi
		node->next = insert_point;
4003396e:	89 18                	mov    %ebx,(%eax)
		node->prev = insert_point->prev;
40033970:	89 70 04             	mov    %esi,0x4(%eax)
		insert_point->prev->next = node;
40033973:	8b 73 04             	mov    0x4(%ebx),%esi
40033976:	89 06                	mov    %eax,(%esi)
		insert_point->prev = node;
40033978:	89 43 04             	mov    %eax,0x4(%ebx)
4003397b:	eb 10                	jmp    4003398d <_pend_thread+0x47>
	node->next = list;
4003397d:	89 10                	mov    %edx,(%eax)
	node->prev = list->tail;
4003397f:	8b 5a 04             	mov    0x4(%edx),%ebx
40033982:	89 58 04             	mov    %ebx,0x4(%eax)
	list->tail->next = node;
40033985:	8b 5a 04             	mov    0x4(%edx),%ebx
40033988:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
4003398a:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state |= _THREAD_PENDING;
4003398d:	80 48 09 02          	orb    $0x2,0x9(%eax)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
40033991:	83 ff ff             	cmp    $0xffffffff,%edi
40033994:	74 1f                	je     400339b5 <_pend_thread+0x6f>
40033996:	89 d1                	mov    %edx,%ecx
40033998:	89 c3                	mov    %eax,%ebx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
4003399a:	8d 70 10             	lea    0x10(%eax),%esi
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
4003399d:	31 d2                	xor    %edx,%edx
4003399f:	8d 47 09             	lea    0x9(%edi),%eax
400339a2:	bf 0a 00 00 00       	mov    $0xa,%edi
400339a7:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
400339a9:	40                   	inc    %eax
400339aa:	89 f2                	mov    %esi,%edx
400339ac:	50                   	push   %eax
400339ad:	89 d8                	mov    %ebx,%eax
400339af:	e8 61 fe ff ff       	call   40033815 <_add_timeout>
400339b4:	58                   	pop    %eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
400339b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
400339b8:	5b                   	pop    %ebx
400339b9:	5e                   	pop    %esi
400339ba:	5f                   	pop    %edi
400339bb:	5d                   	pop    %ebp
400339bc:	c3                   	ret    

400339bd <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
400339bd:	55                   	push   %ebp
400339be:	89 e5                	mov    %esp,%ebp
400339c0:	56                   	push   %esi
400339c1:	53                   	push   %ebx
400339c2:	89 c3                	mov    %eax,%ebx
	_remove_thread_from_ready_q(_current);
400339c4:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
400339c9:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
400339cb:	e8 17 ff ff ff       	call   400338e7 <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
400339d0:	89 f1                	mov    %esi,%ecx
400339d2:	89 da                	mov    %ebx,%edx
400339d4:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
}
400339d9:	5b                   	pop    %ebx
400339da:	5e                   	pop    %esi
400339db:	5d                   	pop    %ebp
	_pend_thread(_current, wait_q, timeout);
400339dc:	e9 65 ff ff ff       	jmp    40033946 <_pend_thread>

400339e1 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
400339e1:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
400339e2:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
400339e7:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
400339e9:	0f be 50 0a          	movsbl 0xa(%eax),%edx
400339ed:	e8 0d fe ff ff       	call   400337ff <_get_highest_ready_prio>
#else
	return 0;
#endif
}
400339f2:	5d                   	pop    %ebp
	return prio1 < prio2;
400339f3:	39 c2                	cmp    %eax,%edx
400339f5:	0f 9f c0             	setg   %al
400339f8:	0f b6 c0             	movzbl %al,%eax
400339fb:	c3                   	ret    

400339fc <_reschedule_threads>:
{
400339fc:	89 c1                	mov    %eax,%ecx
	return _is_preempt(_current) && __must_switch_threads();
400339fe:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033a03:	55                   	push   %ebp
40033a04:	89 e5                	mov    %esp,%ebp
40033a06:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40033a0b:	77 09                	ja     40033a16 <_reschedule_threads+0x1a>
40033a0d:	e8 cf ff ff ff       	call   400339e1 <__must_switch_threads>
40033a12:	85 c0                	test   %eax,%eax
40033a14:	75 09                	jne    40033a1f <_reschedule_threads+0x23>
40033a16:	0f ba e1 09          	bt     $0x9,%ecx
40033a1a:	73 0b                	jae    40033a27 <_reschedule_threads+0x2b>
	__asm__ volatile (
40033a1c:	fb                   	sti    
}
40033a1d:	eb 08                	jmp    40033a27 <_reschedule_threads+0x2b>
		_Swap(key);
40033a1f:	89 c8                	mov    %ecx,%eax
}
40033a21:	5d                   	pop    %ebp
		_Swap(key);
40033a22:	e9 6d f9 ff ff       	jmp    40033394 <_Swap>
}
40033a27:	5d                   	pop    %ebp
40033a28:	c3                   	ret    

40033a29 <k_sched_unlock>:
{
40033a29:	55                   	push   %ebp
40033a2a:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40033a2c:	9c                   	pushf  
40033a2d:	fa                   	cli    
40033a2e:	58                   	pop    %eax
	++_current->base.sched_locked;
40033a2f:	8b 15 a8 76 00 a8    	mov    0xa80076a8,%edx
40033a35:	fe 42 0b             	incb   0xb(%edx)
}
40033a38:	5d                   	pop    %ebp
	_reschedule_threads(key);
40033a39:	e9 be ff ff ff       	jmp    400339fc <_reschedule_threads>

40033a3e <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033a3e:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
40033a42:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
40033a49:	3b 41 04             	cmp    0x4(%ecx),%eax
40033a4c:	74 4f                	je     40033a9d <_move_thread_to_end_of_prio_q+0x5f>
{
40033a4e:	55                   	push   %ebp
	node->prev = list->tail;
40033a4f:	83 c2 14             	add    $0x14,%edx
40033a52:	89 e5                	mov    %esp,%ebp
40033a54:	56                   	push   %esi
40033a55:	53                   	push   %ebx
	node->prev->next = node->next;
40033a56:	8b 58 04             	mov    0x4(%eax),%ebx
40033a59:	8b 30                	mov    (%eax),%esi
40033a5b:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
40033a5d:	8b 30                	mov    (%eax),%esi
40033a5f:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
40033a62:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
40033a64:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
40033a6b:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40033a6e:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
40033a75:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40033a77:	89 04 d5 a0 76 00 a8 	mov    %eax,-0x57ff8960(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033a7e:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
40033a84:	39 d0                	cmp    %edx,%eax
40033a86:	75 0c                	jne    40033a94 <_move_thread_to_end_of_prio_q+0x56>
	int prio = _get_highest_ready_prio();
40033a88:	e8 72 fd ff ff       	call   400337ff <_get_highest_ready_prio>
40033a8d:	8b 14 c5 3c 77 00 a8 	mov    -0x57ff88c4(,%eax,8),%edx
#endif
}
40033a94:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033a95:	89 15 b4 76 00 a8    	mov    %edx,0xa80076b4
}
40033a9b:	5e                   	pop    %esi
40033a9c:	5d                   	pop    %ebp
40033a9d:	c3                   	ret    

40033a9e <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
40033a9e:	55                   	push   %ebp
	return _current;
}
40033a9f:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
40033aa4:	89 e5                	mov    %esp,%ebp
}
40033aa6:	5d                   	pop    %ebp
40033aa7:	c3                   	ret    

40033aa8 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033aa8:	8a 50 09             	mov    0x9(%eax),%dl
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
40033aab:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033aac:	88 d1                	mov    %dl,%cl
{
40033aae:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033ab0:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40033ab3:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033ab6:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40033ab9:	75 0c                	jne    40033ac7 <_ready_thread+0x1f>
40033abb:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033abf:	75 06                	jne    40033ac7 <_ready_thread+0x1f>
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
	}
}
40033ac1:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40033ac2:	e9 c2 fd ff ff       	jmp    40033889 <_add_thread_to_ready_q>
}
40033ac7:	5d                   	pop    %ebp
40033ac8:	c3                   	ret    

40033ac9 <_unpend_first_thread>:
}

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
40033ac9:	55                   	push   %ebp
	if (_handling_timeouts) {
40033aca:	8b 15 a4 78 00 a8    	mov    0xa80078a4,%edx
{
40033ad0:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
40033ad2:	85 d2                	test   %edx,%edx
40033ad4:	8b 08                	mov    (%eax),%ecx
40033ad6:	74 1f                	je     40033af7 <_unpend_first_thread+0x2e>
	return list->head == list;
40033ad8:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033ada:	39 c8                	cmp    %ecx,%eax
40033adc:	75 11                	jne    40033aef <_unpend_first_thread+0x26>
40033ade:	31 d2                	xor    %edx,%edx
40033ae0:	eb 0d                	jmp    40033aef <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
40033ae2:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
40033ae6:	75 1b                	jne    40033b03 <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
40033ae8:	3b 50 04             	cmp    0x4(%eax),%edx
40033aeb:	74 06                	je     40033af3 <_unpend_first_thread+0x2a>
40033aed:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
40033aef:	85 d2                	test   %edx,%edx
40033af1:	75 ef                	jne    40033ae2 <_unpend_first_thread+0x19>
40033af3:	31 d2                	xor    %edx,%edx
40033af5:	eb 1c                	jmp    40033b13 <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033af7:	31 d2                	xor    %edx,%edx
40033af9:	39 c8                	cmp    %ecx,%eax
40033afb:	74 16                	je     40033b13 <_unpend_first_thread+0x4a>
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
40033afd:	85 c9                	test   %ecx,%ecx
40033aff:	74 12                	je     40033b13 <_unpend_first_thread+0x4a>
40033b01:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
40033b03:	8b 42 04             	mov    0x4(%edx),%eax
40033b06:	8b 0a                	mov    (%edx),%ecx
40033b08:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40033b0a:	8b 0a                	mov    (%edx),%ecx
40033b0c:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033b0f:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
40033b13:	89 d0                	mov    %edx,%eax
40033b15:	5d                   	pop    %ebp
40033b16:	c3                   	ret    

40033b17 <_abort_timeout>:
{
40033b17:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033b18:	8b 48 10             	mov    0x10(%eax),%ecx
{
40033b1b:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033b1d:	83 f9 ff             	cmp    $0xffffffff,%ecx
40033b20:	74 24                	je     40033b46 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
40033b22:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
40033b28:	74 05                	je     40033b2f <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40033b2a:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40033b2c:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40033b2f:	8b 50 04             	mov    0x4(%eax),%edx
40033b32:	8b 08                	mov    (%eax),%ecx
40033b34:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033b36:	8b 08                	mov    (%eax),%ecx
40033b38:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40033b3b:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
40033b42:	31 c0                	xor    %eax,%eax
40033b44:	eb 03                	jmp    40033b49 <_abort_timeout+0x32>
		return _INACTIVE;
40033b46:	83 c8 ff             	or     $0xffffffff,%eax
}
40033b49:	5d                   	pop    %ebp
40033b4a:	c3                   	ret    

40033b4b <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
40033b4b:	55                   	push   %ebp
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
40033b4c:	89 50 08             	mov    %edx,0x8(%eax)
{
40033b4f:	89 e5                	mov    %esp,%ebp
	sem->limit = limit;
40033b51:	89 48 0c             	mov    %ecx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
40033b54:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
40033b56:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
40033b59:	5d                   	pop    %ebp
40033b5a:	c3                   	ret    

40033b5b <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
40033b5b:	55                   	push   %ebp
40033b5c:	89 e5                	mov    %esp,%ebp
40033b5e:	57                   	push   %edi
40033b5f:	56                   	push   %esi
40033b60:	89 c6                	mov    %eax,%esi
40033b62:	53                   	push   %ebx
40033b63:	9c                   	pushf  
40033b64:	fa                   	cli    
40033b65:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
40033b66:	e8 5e ff ff ff       	call   40033ac9 <_unpend_first_thread>
	if (!thread) {
40033b6b:	85 c0                	test   %eax,%eax
40033b6d:	75 12                	jne    40033b81 <k_sem_give+0x26>
	sem->count += (sem->count != sem->limit);
40033b6f:	8b 56 08             	mov    0x8(%esi),%edx
40033b72:	31 c0                	xor    %eax,%eax
40033b74:	39 56 0c             	cmp    %edx,0xc(%esi)
40033b77:	0f 95 c0             	setne  %al
40033b7a:	01 d0                	add    %edx,%eax
40033b7c:	89 46 08             	mov    %eax,0x8(%esi)
40033b7f:	eb 43                	jmp    40033bc4 <k_sem_give+0x69>
40033b81:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
40033b83:	8d 40 10             	lea    0x10(%eax),%eax
40033b86:	e8 8c ff ff ff       	call   40033b17 <_abort_timeout>
	_ready_thread(thread);
40033b8b:	89 d8                	mov    %ebx,%eax
40033b8d:	e8 16 ff ff ff       	call   40033aa8 <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
40033b92:	8b 43 28             	mov    0x28(%ebx),%eax
40033b95:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
40033b9b:	83 3d a0 76 00 a8 00 	cmpl   $0x0,0xa80076a0
40033ba2:	75 20                	jne    40033bc4 <k_sem_give+0x69>
	return _is_preempt(_current) && __must_switch_threads();
40033ba4:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033ba9:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40033bae:	77 14                	ja     40033bc4 <k_sem_give+0x69>
40033bb0:	e8 2c fe ff ff       	call   400339e1 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
40033bb5:	85 c0                	test   %eax,%eax
40033bb7:	74 0b                	je     40033bc4 <k_sem_give+0x69>
		_Swap(key);
40033bb9:	89 f8                	mov    %edi,%eax
	} else {
		irq_unlock(key);
	}
}
40033bbb:	5b                   	pop    %ebx
40033bbc:	5e                   	pop    %esi
40033bbd:	5f                   	pop    %edi
40033bbe:	5d                   	pop    %ebp
		_Swap(key);
40033bbf:	e9 d0 f7 ff ff       	jmp    40033394 <_Swap>
40033bc4:	0f ba e7 09          	bt     $0x9,%edi
40033bc8:	73 01                	jae    40033bcb <k_sem_give+0x70>
	__asm__ volatile (
40033bca:	fb                   	sti    
}
40033bcb:	5b                   	pop    %ebx
40033bcc:	5e                   	pop    %esi
40033bcd:	5f                   	pop    %edi
40033bce:	5d                   	pop    %ebp
40033bcf:	c3                   	ret    

40033bd0 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
40033bd0:	55                   	push   %ebp
40033bd1:	89 e5                	mov    %esp,%ebp
40033bd3:	53                   	push   %ebx
	__asm__ volatile (
40033bd4:	9c                   	pushf  
40033bd5:	fa                   	cli    
40033bd6:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
40033bd7:	8b 48 08             	mov    0x8(%eax),%ecx
40033bda:	85 c9                	test   %ecx,%ecx
40033bdc:	74 08                	je     40033be6 <k_sem_take+0x16>
		sem->count--;
40033bde:	49                   	dec    %ecx
40033bdf:	89 48 08             	mov    %ecx,0x8(%eax)
		irq_unlock(key);
		return 0;
40033be2:	31 c0                	xor    %eax,%eax
40033be4:	eb 09                	jmp    40033bef <k_sem_take+0x1f>
	}

	if (timeout == K_NO_WAIT) {
40033be6:	85 d2                	test   %edx,%edx
40033be8:	75 0e                	jne    40033bf8 <k_sem_take+0x28>
		irq_unlock(key);
		return -EBUSY;
40033bea:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
40033bef:	0f ba e3 09          	bt     $0x9,%ebx
40033bf3:	73 11                	jae    40033c06 <k_sem_take+0x36>
	__asm__ volatile (
40033bf5:	fb                   	sti    
40033bf6:	eb 0e                	jmp    40033c06 <k_sem_take+0x36>
	}

	_pend_current_thread(&sem->wait_q, timeout);
40033bf8:	e8 c0 fd ff ff       	call   400339bd <_pend_current_thread>

	return _Swap(key);
40033bfd:	89 d8                	mov    %ebx,%eax
}
40033bff:	5b                   	pop    %ebx
40033c00:	5d                   	pop    %ebp
	return _Swap(key);
40033c01:	e9 8e f7 ff ff       	jmp    40033394 <_Swap>
}
40033c06:	5b                   	pop    %ebx
40033c07:	5d                   	pop    %ebp
40033c08:	c3                   	ret    

40033c09 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
40033c09:	55                   	push   %ebp
40033c0a:	89 e5                	mov    %esp,%ebp
40033c0c:	57                   	push   %edi
40033c0d:	56                   	push   %esi
40033c0e:	53                   	push   %ebx
40033c0f:	83 ec 08             	sub    $0x8,%esp
40033c12:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
40033c14:	9c                   	pushf  
40033c15:	fa                   	cli    
40033c16:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
40033c17:	89 df                	mov    %ebx,%edi
40033c19:	c1 ff 1f             	sar    $0x1f,%edi
40033c1c:	01 1d ac 78 00 a8    	add    %ebx,0xa80078ac
40033c22:	11 3d b0 78 00 a8    	adc    %edi,0xa80078b0
40033c28:	0f ba e0 09          	bt     $0x9,%eax
40033c2c:	73 01                	jae    40033c2f <_nano_sys_clock_tick_announce+0x26>
	__asm__ volatile (
40033c2e:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
40033c2f:	8d 4d ec             	lea    -0x14(%ebp),%ecx
40033c32:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
40033c35:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
40033c38:	9c                   	pushf  
40033c39:	fa                   	cli    
40033c3a:	5e                   	pop    %esi
	return list->head == list;
40033c3b:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
40033c40:	89 f2                	mov    %esi,%edx
	if (!head) {
40033c42:	85 c0                	test   %eax,%eax
40033c44:	74 07                	je     40033c4d <_nano_sys_clock_tick_announce+0x44>
40033c46:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40033c4b:	75 10                	jne    40033c5d <_nano_sys_clock_tick_announce+0x54>
40033c4d:	0f ba e6 09          	bt     $0x9,%esi
40033c51:	0f 83 07 01 00 00    	jae    40033d5e <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
40033c57:	fb                   	sti    
40033c58:	e9 01 01 00 00       	jmp    40033d5e <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
40033c5d:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
40033c60:	c7 05 a4 78 00 a8 01 	movl   $0x1,0xa80078a4
40033c67:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40033c6a:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
40033c6e:	75 3e                	jne    40033cae <_nano_sys_clock_tick_announce+0xa5>
	node->prev->next = node->next;
40033c70:	8b 70 04             	mov    0x4(%eax),%esi
40033c73:	8b 38                	mov    (%eax),%edi
40033c75:	0f ba e2 09          	bt     $0x9,%edx
40033c79:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
40033c7b:	8b 38                	mov    (%eax),%edi
40033c7d:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
40033c80:	8b 75 ec             	mov    -0x14(%ebp),%esi
40033c83:	89 30                	mov    %esi,(%eax)
	node->prev = list;
40033c85:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
40033c88:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
40033c8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
40033c8e:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
40033c91:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
40033c98:	73 01                	jae    40033c9b <_nano_sys_clock_tick_announce+0x92>
40033c9a:	fb                   	sti    
	__asm__ volatile (
40033c9b:	9c                   	pushf  
40033c9c:	fa                   	cli    
40033c9d:	5a                   	pop    %edx
	return list->head == list;
40033c9e:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033ca3:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40033ca8:	74 04                	je     40033cae <_nano_sys_clock_tick_announce+0xa5>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40033caa:	85 c0                	test   %eax,%eax
40033cac:	75 bc                	jne    40033c6a <_nano_sys_clock_tick_announce+0x61>
40033cae:	0f ba e2 09          	bt     $0x9,%edx
40033cb2:	73 01                	jae    40033cb5 <_nano_sys_clock_tick_announce+0xac>
	__asm__ volatile (
40033cb4:	fb                   	sti    
	return list->head == list;
40033cb5:	8b 55 ec             	mov    -0x14(%ebp),%edx
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
40033cb8:	39 ca                	cmp    %ecx,%edx
40033cba:	74 04                	je     40033cc0 <_nano_sys_clock_tick_announce+0xb7>
40033cbc:	85 d2                	test   %edx,%edx
40033cbe:	75 0f                	jne    40033ccf <_nano_sys_clock_tick_announce+0xc6>
	_handling_timeouts = 0;
40033cc0:	c7 05 a4 78 00 a8 00 	movl   $0x0,0xa80078a4
40033cc7:	00 00 00 
40033cca:	e9 8f 00 00 00       	jmp    40033d5e <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
40033ccf:	31 f6                	xor    %esi,%esi
40033cd1:	3b 55 f0             	cmp    -0x10(%ebp),%edx
40033cd4:	74 4d                	je     40033d23 <_nano_sys_clock_tick_announce+0x11a>
40033cd6:	8b 32                	mov    (%edx),%esi
40033cd8:	eb 49                	jmp    40033d23 <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
40033cda:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
40033cde:	74 17                	je     40033cf7 <_nano_sys_clock_tick_announce+0xee>
	node->prev->next = node->next;
40033ce0:	8b 50 04             	mov    0x4(%eax),%edx
40033ce3:	8b 08                	mov    (%eax),%ecx
40033ce5:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033ce7:	8b 08                	mov    (%eax),%ecx
40033ce9:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
40033cec:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033cf3:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033cf7:	8a 50 09             	mov    0x9(%eax),%dl
40033cfa:	88 d1                	mov    %dl,%cl
40033cfc:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40033cff:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033d02:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40033d05:	74 3b                	je     40033d42 <_nano_sys_clock_tick_announce+0x139>
40033d07:	0f ba e7 09          	bt     $0x9,%edi
40033d0b:	73 01                	jae    40033d0e <_nano_sys_clock_tick_announce+0x105>
40033d0d:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
40033d0e:	85 f6                	test   %esi,%esi
40033d10:	74 ae                	je     40033cc0 <_nano_sys_clock_tick_announce+0xb7>
	return (node == list->tail) ? NULL : node->next;
40033d12:	31 c0                	xor    %eax,%eax
40033d14:	39 75 f0             	cmp    %esi,-0x10(%ebp)
40033d17:	74 02                	je     40033d1b <_nano_sys_clock_tick_announce+0x112>
40033d19:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
40033d1b:	85 f6                	test   %esi,%esi
40033d1d:	74 a1                	je     40033cc0 <_nano_sys_clock_tick_announce+0xb7>
40033d1f:	89 f2                	mov    %esi,%edx
40033d21:	89 c6                	mov    %eax,%esi
	node->prev->next = node->next;
40033d23:	8b 42 04             	mov    0x4(%edx),%eax
40033d26:	8b 0a                	mov    (%edx),%ecx
40033d28:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40033d2a:	8b 0a                	mov    (%edx),%ecx
40033d2c:	89 41 04             	mov    %eax,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
40033d2f:	8b 42 08             	mov    0x8(%edx),%eax
	__asm__ volatile (
40033d32:	9c                   	pushf  
40033d33:	fa                   	cli    
40033d34:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
40033d35:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
40033d3c:	85 c0                	test   %eax,%eax
40033d3e:	75 9a                	jne    40033cda <_nano_sys_clock_tick_announce+0xd1>
40033d40:	eb 08                	jmp    40033d4a <_nano_sys_clock_tick_announce+0x141>
40033d42:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033d46:	75 bf                	jne    40033d07 <_nano_sys_clock_tick_announce+0xfe>
40033d48:	eb 64                	jmp    40033dae <_nano_sys_clock_tick_announce+0x1a5>
40033d4a:	0f ba e7 09          	bt     $0x9,%edi
40033d4e:	73 01                	jae    40033d51 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
40033d50:	fb                   	sti    
		if (timeout->func) {
40033d51:	8b 4a 14             	mov    0x14(%edx),%ecx
40033d54:	85 c9                	test   %ecx,%ecx
40033d56:	74 b6                	je     40033d0e <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
40033d58:	89 d0                	mov    %edx,%eax
40033d5a:	ff d1                	call   *%ecx
40033d5c:	eb b0                	jmp    40033d0e <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
40033d5e:	a1 c0 77 00 a8       	mov    0xa80077c0,%eax
40033d63:	85 c0                	test   %eax,%eax
40033d65:	74 51                	je     40033db8 <_nano_sys_clock_tick_announce+0x1af>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
40033d67:	8b 15 a8 76 00 a8    	mov    0xa80076a8,%edx
40033d6d:	0f be 52 0a          	movsbl 0xa(%edx),%edx
40033d71:	39 15 bc 77 00 a8    	cmp    %edx,0xa80077bc
40033d77:	7f 3f                	jg     40033db8 <_nano_sys_clock_tick_announce+0x1af>
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
40033d79:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
40033d7c:	03 1d a8 78 00 a8    	add    0xa80078a8,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
40033d82:	39 d8                	cmp    %ebx,%eax
40033d84:	7e 08                	jle    40033d8e <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
40033d86:	89 1d a8 78 00 a8    	mov    %ebx,0xa80078a8
40033d8c:	eb 2a                	jmp    40033db8 <_nano_sys_clock_tick_announce+0x1af>
		_time_slice_elapsed = 0;
40033d8e:	c7 05 a8 78 00 a8 00 	movl   $0x0,0xa80078a8
40033d95:	00 00 00 
	__asm__ volatile (
40033d98:	9c                   	pushf  
40033d99:	fa                   	cli    
40033d9a:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
40033d9b:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033da0:	e8 99 fc ff ff       	call   40033a3e <_move_thread_to_end_of_prio_q>
40033da5:	0f ba e3 09          	bt     $0x9,%ebx
40033da9:	73 0d                	jae    40033db8 <_nano_sys_clock_tick_announce+0x1af>
	__asm__ volatile (
40033dab:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
40033dac:	eb 0a                	jmp    40033db8 <_nano_sys_clock_tick_announce+0x1af>
		_add_thread_to_ready_q(thread);
40033dae:	e8 d6 fa ff ff       	call   40033889 <_add_thread_to_ready_q>
40033db3:	e9 4f ff ff ff       	jmp    40033d07 <_nano_sys_clock_tick_announce+0xfe>
40033db8:	58                   	pop    %eax
40033db9:	5a                   	pop    %edx
40033dba:	5b                   	pop    %ebx
40033dbb:	5e                   	pop    %esi
40033dbc:	5f                   	pop    %edi
40033dbd:	5d                   	pop    %ebp
40033dbe:	c3                   	ret    

40033dbf <_is_thread_ready>:
{
40033dbf:	55                   	push   %ebp
40033dc0:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
40033dc2:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
40033dc6:	75 09                	jne    40033dd1 <_is_thread_ready+0x12>
40033dc8:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40033dcc:	0f 94 c0             	sete   %al
40033dcf:	eb 02                	jmp    40033dd3 <_is_thread_ready+0x14>
40033dd1:	31 c0                	xor    %eax,%eax
40033dd3:	0f b6 c0             	movzbl %al,%eax
}
40033dd6:	5d                   	pop    %ebp
40033dd7:	c3                   	ret    

40033dd8 <_abort_timeout>:
{
40033dd8:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033dd9:	8b 48 10             	mov    0x10(%eax),%ecx
{
40033ddc:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40033dde:	83 f9 ff             	cmp    $0xffffffff,%ecx
40033de1:	74 24                	je     40033e07 <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
40033de3:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
40033de9:	74 05                	je     40033df0 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40033deb:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40033ded:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40033df0:	8b 50 04             	mov    0x4(%eax),%edx
40033df3:	8b 08                	mov    (%eax),%ecx
40033df5:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
40033df7:	8b 08                	mov    (%eax),%ecx
40033df9:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40033dfc:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
40033e03:	31 c0                	xor    %eax,%eax
40033e05:	eb 03                	jmp    40033e0a <_abort_timeout+0x32>
		return _INACTIVE;
40033e07:	83 c8 ff             	or     $0xffffffff,%eax
}
40033e0a:	5d                   	pop    %ebp
40033e0b:	c3                   	ret    

40033e0c <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
40033e0c:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
40033e0d:	85 d2                	test   %edx,%edx
{
40033e0f:	89 e5                	mov    %esp,%ebp
40033e11:	57                   	push   %edi
40033e12:	56                   	push   %esi
40033e13:	53                   	push   %ebx
40033e14:	51                   	push   %ecx
40033e15:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
40033e17:	75 41                	jne    40033e5a <schedule_new_thread+0x4e>
	__asm__ volatile (
40033e19:	9c                   	pushf  
40033e1a:	fa                   	cli    
40033e1b:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033e1c:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
40033e20:	e8 9a ff ff ff       	call   40033dbf <_is_thread_ready>
40033e25:	85 c0                	test   %eax,%eax
40033e27:	75 09                	jne    40033e32 <schedule_new_thread+0x26>
40033e29:	0f ba e3 09          	bt     $0x9,%ebx
40033e2d:	e9 b1 00 00 00       	jmp    40033ee3 <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
40033e32:	89 c8                	mov    %ecx,%eax
40033e34:	e8 50 fa ff ff       	call   40033889 <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
40033e39:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033e3e:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40033e43:	77 e4                	ja     40033e29 <schedule_new_thread+0x1d>
40033e45:	e8 97 fb ff ff       	call   400339e1 <__must_switch_threads>
40033e4a:	85 c0                	test   %eax,%eax
40033e4c:	74 db                	je     40033e29 <schedule_new_thread+0x1d>
			_Swap(key);
40033e4e:	89 d8                	mov    %ebx,%eax
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
40033e50:	5a                   	pop    %edx
40033e51:	5b                   	pop    %ebx
40033e52:	5e                   	pop    %esi
40033e53:	5f                   	pop    %edi
40033e54:	5d                   	pop    %ebp
			_Swap(key);
40033e55:	e9 3a f5 ff ff       	jmp    40033394 <_Swap>
40033e5a:	9c                   	pushf  
40033e5b:	fa                   	cli    
40033e5c:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40033e5f:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40033e64:	8d 58 10             	lea    0x10(%eax),%ebx
40033e67:	8d 42 09             	lea    0x9(%edx),%eax
40033e6a:	31 d2                	xor    %edx,%edx
40033e6c:	f7 f6                	div    %esi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
40033e6e:	40                   	inc    %eax
	timeout->thread = thread;
40033e6f:	89 49 18             	mov    %ecx,0x18(%ecx)
40033e72:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
40033e75:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
40033e7a:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033e81:	85 c0                	test   %eax,%eax
40033e83:	74 0d                	je     40033e92 <schedule_new_thread+0x86>
40033e85:	8b 3d b0 76 00 a8    	mov    0xa80076b0,%edi
40033e8b:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40033e90:	75 19                	jne    40033eab <schedule_new_thread+0x9f>
	node->next = list;
40033e92:	c7 41 10 ac 76 00 a8 	movl   $0xa80076ac,0x10(%ecx)
	node->prev = list->tail;
40033e99:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40033e9e:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
40033ea1:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
40033ea3:	89 1d b0 76 00 a8    	mov    %ebx,0xa80076b0
40033ea9:	eb 31                	jmp    40033edc <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
40033eab:	8b 51 20             	mov    0x20(%ecx),%edx
40033eae:	8b 70 10             	mov    0x10(%eax),%esi
40033eb1:	39 f2                	cmp    %esi,%edx
40033eb3:	7f 18                	jg     40033ecd <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
40033eb5:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
40033eb7:	8b 50 04             	mov    0x4(%eax),%edx
40033eba:	89 70 10             	mov    %esi,0x10(%eax)
40033ebd:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
40033ec0:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
40033ec3:	8b 50 04             	mov    0x4(%eax),%edx
40033ec6:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
40033ec8:	89 58 04             	mov    %ebx,0x4(%eax)
40033ecb:	eb 0f                	jmp    40033edc <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
40033ecd:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
40033ecf:	39 f8                	cmp    %edi,%eax
40033ed1:	89 51 20             	mov    %edx,0x20(%ecx)
40033ed4:	74 bc                	je     40033e92 <schedule_new_thread+0x86>
40033ed6:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033ed8:	85 c0                	test   %eax,%eax
40033eda:	eb b4                	jmp    40033e90 <schedule_new_thread+0x84>
40033edc:	8b 45 f0             	mov    -0x10(%ebp),%eax
40033edf:	0f ba e0 09          	bt     $0x9,%eax
40033ee3:	73 01                	jae    40033ee6 <schedule_new_thread+0xda>
	__asm__ volatile (
40033ee5:	fb                   	sti    
}
40033ee6:	58                   	pop    %eax
40033ee7:	5b                   	pop    %ebx
40033ee8:	5e                   	pop    %esi
40033ee9:	5f                   	pop    %edi
40033eea:	5d                   	pop    %ebp
40033eeb:	c3                   	ret    

40033eec <k_is_in_isr>:
{
40033eec:	55                   	push   %ebp
	return _is_in_isr();
40033eed:	31 c0                	xor    %eax,%eax
{
40033eef:	89 e5                	mov    %esp,%ebp
}
40033ef1:	5d                   	pop    %ebp
	return _is_in_isr();
40033ef2:	83 3d a0 76 00 a8 00 	cmpl   $0x0,0xa80076a0
40033ef9:	0f 95 c0             	setne  %al
}
40033efc:	c3                   	ret    

40033efd <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
40033efd:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
40033f02:	55                   	push   %ebp
40033f03:	89 e5                	mov    %esp,%ebp
}
40033f05:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
40033f06:	8a 40 08             	mov    0x8(%eax),%al
40033f09:	83 e0 01             	and    $0x1,%eax
}
40033f0c:	c3                   	ret    

40033f0d <_thread_entry>:
{
40033f0d:	55                   	push   %ebp
40033f0e:	89 e5                	mov    %esp,%ebp
40033f10:	53                   	push   %ebx
40033f11:	89 c3                	mov    %eax,%ebx
40033f13:	89 d0                	mov    %edx,%eax
40033f15:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
40033f17:	8b 4d 08             	mov    0x8(%ebp),%ecx
40033f1a:	ff d3                	call   *%ebx
	if (_is_thread_essential()) {
40033f1c:	e8 dc ff ff ff       	call   40033efd <_is_thread_essential>
40033f21:	85 c0                	test   %eax,%eax
40033f23:	74 0f                	je     40033f34 <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
40033f25:	ba 00 60 03 40       	mov    $0x40036000,%edx
40033f2a:	b8 03 00 00 00       	mov    $0x3,%eax
40033f2f:	e8 fb f4 ff ff       	call   4003342f <_NanoFatalErrorHandler>
	k_thread_abort(_current);
40033f34:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033f39:	e8 fa 00 00 00       	call   40034038 <k_thread_abort>

40033f3e <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
40033f3e:	55                   	push   %ebp
40033f3f:	89 e5                	mov    %esp,%ebp
40033f41:	53                   	push   %ebx
40033f42:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
40033f44:	8b 40 30             	mov    0x30(%eax),%eax
40033f47:	85 c0                	test   %eax,%eax
40033f49:	74 02                	je     40033f4d <_k_thread_single_abort+0xf>
		thread->fn_abort();
40033f4b:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
40033f4d:	89 d8                	mov    %ebx,%eax
40033f4f:	e8 6b fe ff ff       	call   40033dbf <_is_thread_ready>
40033f54:	85 c0                	test   %eax,%eax
40033f56:	74 09                	je     40033f61 <_k_thread_single_abort+0x23>
		_remove_thread_from_ready_q(thread);
40033f58:	89 d8                	mov    %ebx,%eax
40033f5a:	e8 88 f9 ff ff       	call   400338e7 <_remove_thread_from_ready_q>
40033f5f:	eb 24                	jmp    40033f85 <_k_thread_single_abort+0x47>
	} else {
		if (_is_thread_pending(thread)) {
40033f61:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
40033f65:	74 10                	je     40033f77 <_k_thread_single_abort+0x39>
	node->prev->next = node->next;
40033f67:	8b 43 04             	mov    0x4(%ebx),%eax
40033f6a:	8b 13                	mov    (%ebx),%edx
40033f6c:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
40033f6e:	8b 13                	mov    (%ebx),%edx
40033f70:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40033f73:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
40033f77:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
40033f7b:	74 08                	je     40033f85 <_k_thread_single_abort+0x47>
	return _abort_timeout(&thread->base.timeout);
40033f7d:	8d 43 10             	lea    0x10(%ebx),%eax
40033f80:	e8 53 fe ff ff       	call   40033dd8 <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
40033f85:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
40033f89:	5b                   	pop    %ebx
40033f8a:	5d                   	pop    %ebp
40033f8b:	c3                   	ret    

40033f8c <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
40033f8c:	55                   	push   %ebp
40033f8d:	89 e5                	mov    %esp,%ebp
40033f8f:	56                   	push   %esi
40033f90:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
40033f91:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
40033f96:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033f9c:	73 29                	jae    40033fc7 <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
40033f9e:	ff 73 1c             	pushl  0x1c(%ebx)
40033fa1:	ff 73 18             	pushl  0x18(%ebx)
40033fa4:	ff 73 14             	pushl  0x14(%ebx)
40033fa7:	ff 73 10             	pushl  0x10(%ebx)
40033faa:	ff 73 0c             	pushl  0xc(%ebx)
40033fad:	8b 03                	mov    (%ebx),%eax
40033faf:	8b 4b 08             	mov    0x8(%ebx),%ecx
40033fb2:	8b 53 04             	mov    0x4(%ebx),%edx
40033fb5:	e8 0e f4 ff ff       	call   400333c8 <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
40033fba:	8b 03                	mov    (%ebx),%eax
		_new_thread(
40033fbc:	83 c4 14             	add    $0x14,%esp
		thread_data->thread->init_data = thread_data;
40033fbf:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
40033fc2:	83 c3 2c             	add    $0x2c,%ebx
40033fc5:	eb cf                	jmp    40033f96 <_init_static_threads+0xa>
	--_current->base.sched_locked;
40033fc7:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40033fcc:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
40033fcf:	9c                   	pushf  
40033fd0:	fa                   	cli    
40033fd1:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
40033fd2:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
40033fd7:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033fdd:	73 14                	jae    40033ff3 <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
40033fdf:	8b 53 20             	mov    0x20(%ebx),%edx
40033fe2:	83 fa ff             	cmp    $0xffffffff,%edx
40033fe5:	74 07                	je     40033fee <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
40033fe7:	8b 03                	mov    (%ebx),%eax
40033fe9:	e8 1e fe ff ff       	call   40033e0c <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
40033fee:	83 c3 2c             	add    $0x2c,%ebx
40033ff1:	eb e4                	jmp    40033fd7 <_init_static_threads+0x4b>
40033ff3:	0f ba e6 09          	bt     $0x9,%esi
40033ff7:	73 01                	jae    40033ffa <_init_static_threads+0x6e>
	__asm__ volatile (
40033ff9:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
40033ffa:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033ffd:	5b                   	pop    %ebx
40033ffe:	5e                   	pop    %esi
40033fff:	5d                   	pop    %ebp
	k_sched_unlock();
40034000:	e9 24 fa ff ff       	jmp    40033a29 <k_sched_unlock>

40034005 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
40034005:	55                   	push   %ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;
40034006:	88 48 09             	mov    %cl,0x9(%eax)
{
40034009:	89 e5                	mov    %esp,%ebp
4003400b:	53                   	push   %ebx

	thread_base->prio = priority;
4003400c:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
4003400f:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	thread_base->user_options = (uint8_t)options;
40034013:	8a 5d 08             	mov    0x8(%ebp),%bl
	t->delta_ticks_from_prev = _INACTIVE;
40034016:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
4003401d:	88 58 08             	mov    %bl,0x8(%eax)
	t->wait_q = NULL;
40034020:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
40034027:	5b                   	pop    %ebx
	t->thread = NULL;
40034028:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
4003402f:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
40034036:	5d                   	pop    %ebp
40034037:	c3                   	ret    

40034038 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
40034038:	55                   	push   %ebp
40034039:	89 e5                	mov    %esp,%ebp
4003403b:	56                   	push   %esi
4003403c:	89 c6                	mov    %eax,%esi
4003403e:	53                   	push   %ebx
	__asm__ volatile (
4003403f:	9c                   	pushf  
40034040:	fa                   	cli    
40034041:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
40034042:	e8 f7 fe ff ff       	call   40033f3e <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
		_Swap(key);
40034047:	89 d8                	mov    %ebx,%eax
	if (_current == thread) {
40034049:	3b 35 a8 76 00 a8    	cmp    0xa80076a8,%esi
4003404f:	75 05                	jne    40034056 <k_thread_abort+0x1e>
		_Swap(key);
40034051:	e8 3e f3 ff ff       	call   40033394 <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
}
40034056:	5b                   	pop    %ebx
40034057:	5e                   	pop    %esi
40034058:	5d                   	pop    %ebp
	_reschedule_threads(key);
40034059:	e9 9e f9 ff ff       	jmp    400339fc <_reschedule_threads>

4003405e <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003405e:	8a 50 09             	mov    0x9(%eax),%dl
{
40034061:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034062:	88 d1                	mov    %dl,%cl
{
40034064:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034066:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40034069:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003406c:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
4003406f:	75 0c                	jne    4003407d <_ready_thread+0x1f>
40034071:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40034075:	75 06                	jne    4003407d <_ready_thread+0x1f>
}
40034077:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40034078:	e9 0c f8 ff ff       	jmp    40033889 <_add_thread_to_ready_q>
}
4003407d:	5d                   	pop    %ebp
4003407e:	c3                   	ret    

4003407f <_add_timeout.constprop.7>:
	timeout->thread = thread;
4003407f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
40034086:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
40034089:	55                   	push   %ebp
	return list->head == list;
4003408a:	8b 15 ac 76 00 a8    	mov    0xa80076ac,%edx
40034090:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40034092:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
40034095:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40034096:	85 d2                	test   %edx,%edx
40034098:	74 08                	je     400340a2 <_add_timeout.constprop.7+0x23>
4003409a:	81 fa ac 76 00 a8    	cmp    $0xa80076ac,%edx
400340a0:	75 1e                	jne    400340c0 <_add_timeout.constprop.7+0x41>
	node->next = list;
400340a2:	c7 00 ac 76 00 a8    	movl   $0xa80076ac,(%eax)
	node->prev = list->tail;
400340a8:	8b 15 b0 76 00 a8    	mov    0xa80076b0,%edx
400340ae:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
400340b1:	8b 15 b0 76 00 a8    	mov    0xa80076b0,%edx
400340b7:	89 02                	mov    %eax,(%edx)
	list->tail = node;
400340b9:	a3 b0 76 00 a8       	mov    %eax,0xa80076b0
400340be:	eb 34                	jmp    400340f4 <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
400340c0:	8b 48 10             	mov    0x10(%eax),%ecx
400340c3:	8b 5a 10             	mov    0x10(%edx),%ebx
400340c6:	39 d9                	cmp    %ebx,%ecx
400340c8:	7f 17                	jg     400340e1 <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
400340ca:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
400340cc:	8b 4a 04             	mov    0x4(%edx),%ecx
400340cf:	89 5a 10             	mov    %ebx,0x10(%edx)
400340d2:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
400340d5:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
400340d7:	8b 4a 04             	mov    0x4(%edx),%ecx
400340da:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
400340dc:	89 42 04             	mov    %eax,0x4(%edx)
400340df:	eb 13                	jmp    400340f4 <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
400340e1:	29 d9                	sub    %ebx,%ecx
400340e3:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
400340e6:	3b 15 b0 76 00 a8    	cmp    0xa80076b0,%edx
400340ec:	74 b4                	je     400340a2 <_add_timeout.constprop.7+0x23>
400340ee:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
400340f0:	85 d2                	test   %edx,%edx
400340f2:	eb ac                	jmp    400340a0 <_add_timeout.constprop.7+0x21>
}
400340f4:	5b                   	pop    %ebx
400340f5:	5d                   	pop    %ebp
400340f6:	c3                   	ret    

400340f7 <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
400340f7:	55                   	push   %ebp
400340f8:	89 e5                	mov    %esp,%ebp
400340fa:	56                   	push   %esi
400340fb:	53                   	push   %ebx
400340fc:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
400340fe:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
40034102:	7e 15                	jle    40034119 <_timer_expiration_handler+0x22>
40034104:	9c                   	pushf  
40034105:	fa                   	cli    
40034106:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
40034107:	8b 48 28             	mov    0x28(%eax),%ecx
4003410a:	8d 50 18             	lea    0x18(%eax),%edx
4003410d:	e8 6d ff ff ff       	call   4003407f <_add_timeout.constprop.7>
40034112:	0f ba e6 09          	bt     $0x9,%esi
40034116:	73 01                	jae    40034119 <_timer_expiration_handler+0x22>
	__asm__ volatile (
40034118:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
40034119:	8b 53 20             	mov    0x20(%ebx),%edx
	timer->status += 1;
4003411c:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
4003411f:	85 d2                	test   %edx,%edx
40034121:	74 04                	je     40034127 <_timer_expiration_handler+0x30>
		timer->expiry_fn(timer);
40034123:	89 d8                	mov    %ebx,%eax
40034125:	ff d2                	call   *%edx
	return list->head == list;
40034127:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
4003412a:	85 f6                	test   %esi,%esi
4003412c:	74 31                	je     4003415f <_timer_expiration_handler+0x68>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
4003412e:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
40034131:	39 de                	cmp    %ebx,%esi
40034133:	74 2a                	je     4003415f <_timer_expiration_handler+0x68>
	node->prev->next = node->next;
40034135:	8b 46 04             	mov    0x4(%esi),%eax
40034138:	8b 16                	mov    (%esi),%edx
4003413a:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
4003413c:	8b 16                	mov    (%esi),%edx
4003413e:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40034141:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
40034145:	9c                   	pushf  
40034146:	fa                   	cli    
40034147:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
40034148:	89 f0                	mov    %esi,%eax
4003414a:	e8 0f ff ff ff       	call   4003405e <_ready_thread>
4003414f:	0f ba e3 09          	bt     $0x9,%ebx
40034153:	73 01                	jae    40034156 <_timer_expiration_handler+0x5f>
	__asm__ volatile (
40034155:	fb                   	sti    
40034156:	8b 46 28             	mov    0x28(%esi),%eax
40034159:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
4003415f:	5b                   	pop    %ebx
40034160:	5e                   	pop    %esi
40034161:	5d                   	pop    %ebp
40034162:	c3                   	ret    

40034163 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
40034163:	55                   	push   %ebp
40034164:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
40034166:	5d                   	pop    %ebp
40034167:	c3                   	ret    

40034168 <malloc>:
40034168:	53                   	push   %ebx
40034169:	89 c3                	mov    %eax,%ebx
4003416b:	e8 fa 01 00 00       	call   4003436a <__getreent>
40034170:	89 da                	mov    %ebx,%edx
40034172:	5b                   	pop    %ebx
40034173:	e9 c9 00 00 00       	jmp    40034241 <_malloc_r>

40034178 <free>:
40034178:	53                   	push   %ebx
40034179:	89 c3                	mov    %eax,%ebx
4003417b:	e8 ea 01 00 00       	call   4003436a <__getreent>
40034180:	89 da                	mov    %ebx,%edx
40034182:	5b                   	pop    %ebx
40034183:	e9 00 00 00 00       	jmp    40034188 <_free_r>

40034188 <_free_r>:
40034188:	85 d2                	test   %edx,%edx
4003418a:	0f 84 b0 00 00 00    	je     40034240 <_free_r+0xb8>
40034190:	8d 4a fc             	lea    -0x4(%edx),%ecx
40034193:	8b 52 fc             	mov    -0x4(%edx),%edx
40034196:	85 d2                	test   %edx,%edx
40034198:	79 02                	jns    4003419c <_free_r+0x14>
4003419a:	01 d1                	add    %edx,%ecx
4003419c:	8b 15 e4 67 00 a8    	mov    0xa80067e4,%edx
400341a2:	85 d2                	test   %edx,%edx
400341a4:	75 0e                	jne    400341b4 <_free_r+0x2c>
400341a6:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
400341ad:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
400341b3:	c3                   	ret    
400341b4:	57                   	push   %edi
400341b5:	39 ca                	cmp    %ecx,%edx
400341b7:	56                   	push   %esi
400341b8:	53                   	push   %ebx
400341b9:	53                   	push   %ebx
400341ba:	76 20                	jbe    400341dc <_free_r+0x54>
400341bc:	8b 01                	mov    (%ecx),%eax
400341be:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
400341c1:	39 da                	cmp    %ebx,%edx
400341c3:	75 0c                	jne    400341d1 <_free_r+0x49>
400341c5:	03 02                	add    (%edx),%eax
400341c7:	89 01                	mov    %eax,(%ecx)
400341c9:	8b 42 04             	mov    0x4(%edx),%eax
400341cc:	89 41 04             	mov    %eax,0x4(%ecx)
400341cf:	eb 03                	jmp    400341d4 <_free_r+0x4c>
400341d1:	89 51 04             	mov    %edx,0x4(%ecx)
400341d4:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
400341da:	eb 60                	jmp    4003423c <_free_r+0xb4>
400341dc:	8b 72 04             	mov    0x4(%edx),%esi
400341df:	85 f6                	test   %esi,%esi
400341e1:	0f 95 44 24 03       	setne  0x3(%esp)
400341e6:	39 ce                	cmp    %ecx,%esi
400341e8:	0f 96 c3             	setbe  %bl
400341eb:	84 5c 24 03          	test   %bl,0x3(%esp)
400341ef:	74 04                	je     400341f5 <_free_r+0x6d>
400341f1:	89 f2                	mov    %esi,%edx
400341f3:	eb e7                	jmp    400341dc <_free_r+0x54>
400341f5:	8b 1a                	mov    (%edx),%ebx
400341f7:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
400341fa:	39 cf                	cmp    %ecx,%edi
400341fc:	75 19                	jne    40034217 <_free_r+0x8f>
400341fe:	8b 01                	mov    (%ecx),%eax
40034200:	01 d8                	add    %ebx,%eax
40034202:	89 02                	mov    %eax,(%edx)
40034204:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
40034207:	39 ce                	cmp    %ecx,%esi
40034209:	75 31                	jne    4003423c <_free_r+0xb4>
4003420b:	03 06                	add    (%esi),%eax
4003420d:	89 02                	mov    %eax,(%edx)
4003420f:	8b 46 04             	mov    0x4(%esi),%eax
40034212:	89 42 04             	mov    %eax,0x4(%edx)
40034215:	eb 25                	jmp    4003423c <_free_r+0xb4>
40034217:	76 08                	jbe    40034221 <_free_r+0x99>
40034219:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
4003421f:	eb 1b                	jmp    4003423c <_free_r+0xb4>
40034221:	8b 01                	mov    (%ecx),%eax
40034223:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
40034226:	39 de                	cmp    %ebx,%esi
40034228:	75 0c                	jne    40034236 <_free_r+0xae>
4003422a:	03 06                	add    (%esi),%eax
4003422c:	89 01                	mov    %eax,(%ecx)
4003422e:	8b 46 04             	mov    0x4(%esi),%eax
40034231:	89 41 04             	mov    %eax,0x4(%ecx)
40034234:	eb 03                	jmp    40034239 <_free_r+0xb1>
40034236:	89 71 04             	mov    %esi,0x4(%ecx)
40034239:	89 4a 04             	mov    %ecx,0x4(%edx)
4003423c:	58                   	pop    %eax
4003423d:	5b                   	pop    %ebx
4003423e:	5e                   	pop    %esi
4003423f:	5f                   	pop    %edi
40034240:	c3                   	ret    

40034241 <_malloc_r>:
40034241:	57                   	push   %edi
40034242:	8d 7a 03             	lea    0x3(%edx),%edi
40034245:	83 e7 fc             	and    $0xfffffffc,%edi
40034248:	56                   	push   %esi
40034249:	83 c7 08             	add    $0x8,%edi
4003424c:	53                   	push   %ebx
4003424d:	89 c6                	mov    %eax,%esi
4003424f:	83 ff 0c             	cmp    $0xc,%edi
40034252:	73 05                	jae    40034259 <_malloc_r+0x18>
40034254:	bf 0c 00 00 00       	mov    $0xc,%edi
40034259:	89 f8                	mov    %edi,%eax
4003425b:	c1 e8 1f             	shr    $0x1f,%eax
4003425e:	75 0c                	jne    4003426c <_malloc_r+0x2b>
40034260:	8b 0d e4 67 00 a8    	mov    0xa80067e4,%ecx
40034266:	39 fa                	cmp    %edi,%edx
40034268:	89 c8                	mov    %ecx,%eax
4003426a:	76 18                	jbe    40034284 <_malloc_r+0x43>
4003426c:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
40034272:	31 c0                	xor    %eax,%eax
40034274:	e9 97 00 00 00       	jmp    40034310 <_malloc_r+0xcf>
40034279:	8b 10                	mov    (%eax),%edx
4003427b:	29 fa                	sub    %edi,%edx
4003427d:	79 0b                	jns    4003428a <_malloc_r+0x49>
4003427f:	89 c1                	mov    %eax,%ecx
40034281:	8b 40 04             	mov    0x4(%eax),%eax
40034284:	85 c0                	test   %eax,%eax
40034286:	75 f1                	jne    40034279 <_malloc_r+0x38>
40034288:	eb 26                	jmp    400342b0 <_malloc_r+0x6f>
4003428a:	83 fa 0b             	cmp    $0xb,%edx
4003428d:	76 09                	jbe    40034298 <_malloc_r+0x57>
4003428f:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40034292:	89 10                	mov    %edx,(%eax)
40034294:	89 39                	mov    %edi,(%ecx)
40034296:	eb 4d                	jmp    400342e5 <_malloc_r+0xa4>
40034298:	39 c1                	cmp    %eax,%ecx
4003429a:	75 0a                	jne    400342a6 <_malloc_r+0x65>
4003429c:	8b 41 04             	mov    0x4(%ecx),%eax
4003429f:	a3 e4 67 00 a8       	mov    %eax,0xa80067e4
400342a4:	eb 3f                	jmp    400342e5 <_malloc_r+0xa4>
400342a6:	8b 50 04             	mov    0x4(%eax),%edx
400342a9:	89 51 04             	mov    %edx,0x4(%ecx)
400342ac:	89 c1                	mov    %eax,%ecx
400342ae:	eb 35                	jmp    400342e5 <_malloc_r+0xa4>
400342b0:	83 3d e0 67 00 a8 00 	cmpl   $0x0,0xa80067e0
400342b7:	75 0e                	jne    400342c7 <_malloc_r+0x86>
400342b9:	31 d2                	xor    %edx,%edx
400342bb:	89 f0                	mov    %esi,%eax
400342bd:	e8 6a 00 00 00       	call   4003432c <_sbrk_r>
400342c2:	a3 e0 67 00 a8       	mov    %eax,0xa80067e0
400342c7:	89 fa                	mov    %edi,%edx
400342c9:	89 f0                	mov    %esi,%eax
400342cb:	e8 5c 00 00 00       	call   4003432c <_sbrk_r>
400342d0:	83 f8 ff             	cmp    $0xffffffff,%eax
400342d3:	74 97                	je     4003426c <_malloc_r+0x2b>
400342d5:	8d 48 03             	lea    0x3(%eax),%ecx
400342d8:	89 cb                	mov    %ecx,%ebx
400342da:	83 e3 fc             	and    $0xfffffffc,%ebx
400342dd:	39 d8                	cmp    %ebx,%eax
400342df:	75 1c                	jne    400342fd <_malloc_r+0xbc>
400342e1:	89 3b                	mov    %edi,(%ebx)
400342e3:	89 d9                	mov    %ebx,%ecx
400342e5:	8d 41 0b             	lea    0xb(%ecx),%eax
400342e8:	8d 51 04             	lea    0x4(%ecx),%edx
400342eb:	83 e0 f8             	and    $0xfffffff8,%eax
400342ee:	89 c6                	mov    %eax,%esi
400342f0:	29 d6                	sub    %edx,%esi
400342f2:	74 1c                	je     40034310 <_malloc_r+0xcf>
400342f4:	89 f3                	mov    %esi,%ebx
400342f6:	f7 db                	neg    %ebx
400342f8:	89 1c 31             	mov    %ebx,(%ecx,%esi,1)
400342fb:	eb 13                	jmp    40034310 <_malloc_r+0xcf>
400342fd:	89 da                	mov    %ebx,%edx
400342ff:	29 c2                	sub    %eax,%edx
40034301:	89 f0                	mov    %esi,%eax
40034303:	e8 24 00 00 00       	call   4003432c <_sbrk_r>
40034308:	40                   	inc    %eax
40034309:	75 d6                	jne    400342e1 <_malloc_r+0xa0>
4003430b:	e9 5c ff ff ff       	jmp    4003426c <_malloc_r+0x2b>
40034310:	5b                   	pop    %ebx
40034311:	5e                   	pop    %esi
40034312:	5f                   	pop    %edi
40034313:	c3                   	ret    

40034314 <iprintf>:
40034314:	e8 51 00 00 00       	call   4003436a <__getreent>
40034319:	8d 4c 24 08          	lea    0x8(%esp),%ecx
4003431d:	8b 50 08             	mov    0x8(%eax),%edx
40034320:	51                   	push   %ecx
40034321:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40034325:	e8 9f 00 00 00       	call   400343c9 <_vfiprintf_r>
4003432a:	5a                   	pop    %edx
4003432b:	c3                   	ret    

4003432c <_sbrk_r>:
4003432c:	53                   	push   %ebx
4003432d:	89 c3                	mov    %eax,%ebx
4003432f:	89 d0                	mov    %edx,%eax
40034331:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034338:	00 00 00 
4003433b:	e8 e0 cb ff ff       	call   40030f20 <_sbrk>
40034340:	83 f8 ff             	cmp    $0xffffffff,%eax
40034343:	75 0c                	jne    40034351 <_sbrk_r+0x25>
40034345:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
4003434b:	85 d2                	test   %edx,%edx
4003434d:	74 02                	je     40034351 <_sbrk_r+0x25>
4003434f:	89 13                	mov    %edx,(%ebx)
40034351:	5b                   	pop    %ebx
40034352:	c3                   	ret    

40034353 <strcmp>:
40034353:	8a 08                	mov    (%eax),%cl
40034355:	84 c9                	test   %cl,%cl
40034357:	74 08                	je     40034361 <strcmp+0xe>
40034359:	3a 0a                	cmp    (%edx),%cl
4003435b:	75 04                	jne    40034361 <strcmp+0xe>
4003435d:	40                   	inc    %eax
4003435e:	42                   	inc    %edx
4003435f:	eb f2                	jmp    40034353 <strcmp>
40034361:	0f b6 12             	movzbl (%edx),%edx
40034364:	0f b6 c1             	movzbl %cl,%eax
40034367:	29 d0                	sub    %edx,%eax
40034369:	c3                   	ret    

4003436a <__getreent>:
4003436a:	a1 00 64 00 a8       	mov    0xa8006400,%eax
4003436f:	c3                   	ret    

40034370 <__sfputc_r>:
40034370:	53                   	push   %ebx
40034371:	8b 59 08             	mov    0x8(%ecx),%ebx
40034374:	4b                   	dec    %ebx
40034375:	89 59 08             	mov    %ebx,0x8(%ecx)
40034378:	85 db                	test   %ebx,%ebx
4003437a:	79 10                	jns    4003438c <__sfputc_r+0x1c>
4003437c:	3b 59 18             	cmp    0x18(%ecx),%ebx
4003437f:	7c 05                	jl     40034386 <__sfputc_r+0x16>
40034381:	80 fa 0a             	cmp    $0xa,%dl
40034384:	75 06                	jne    4003438c <__sfputc_r+0x1c>
40034386:	5b                   	pop    %ebx
40034387:	e9 cf 02 00 00       	jmp    4003465b <__swbuf_r>
4003438c:	8b 01                	mov    (%ecx),%eax
4003438e:	8d 58 01             	lea    0x1(%eax),%ebx
40034391:	89 19                	mov    %ebx,(%ecx)
40034393:	88 10                	mov    %dl,(%eax)
40034395:	5b                   	pop    %ebx
40034396:	0f b6 c2             	movzbl %dl,%eax
40034399:	c3                   	ret    

4003439a <__sfputs_r>:
4003439a:	55                   	push   %ebp
4003439b:	57                   	push   %edi
4003439c:	56                   	push   %esi
4003439d:	53                   	push   %ebx
4003439e:	8b 74 24 14          	mov    0x14(%esp),%esi
400343a2:	89 c7                	mov    %eax,%edi
400343a4:	89 d5                	mov    %edx,%ebp
400343a6:	89 cb                	mov    %ecx,%ebx
400343a8:	01 ce                	add    %ecx,%esi
400343aa:	39 f3                	cmp    %esi,%ebx
400343ac:	74 14                	je     400343c2 <__sfputs_r+0x28>
400343ae:	0f be 13             	movsbl (%ebx),%edx
400343b1:	89 e9                	mov    %ebp,%ecx
400343b3:	89 f8                	mov    %edi,%eax
400343b5:	e8 b6 ff ff ff       	call   40034370 <__sfputc_r>
400343ba:	43                   	inc    %ebx
400343bb:	83 f8 ff             	cmp    $0xffffffff,%eax
400343be:	75 ea                	jne    400343aa <__sfputs_r+0x10>
400343c0:	eb 02                	jmp    400343c4 <__sfputs_r+0x2a>
400343c2:	31 c0                	xor    %eax,%eax
400343c4:	5b                   	pop    %ebx
400343c5:	5e                   	pop    %esi
400343c6:	5f                   	pop    %edi
400343c7:	5d                   	pop    %ebp
400343c8:	c3                   	ret    

400343c9 <_vfiprintf_r>:
400343c9:	55                   	push   %ebp
400343ca:	57                   	push   %edi
400343cb:	56                   	push   %esi
400343cc:	53                   	push   %ebx
400343cd:	83 ec 68             	sub    $0x68,%esp
400343d0:	89 c5                	mov    %eax,%ebp
400343d2:	89 d6                	mov    %edx,%esi
400343d4:	89 cf                	mov    %ecx,%edi
400343d6:	85 c0                	test   %eax,%eax
400343d8:	74 0b                	je     400343e5 <_vfiprintf_r+0x1c>
400343da:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400343de:	75 05                	jne    400343e5 <_vfiprintf_r+0x1c>
400343e0:	e8 93 05 00 00       	call   40034978 <__sinit>
400343e5:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
400343e9:	74 1d                	je     40034408 <_vfiprintf_r+0x3f>
400343eb:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
400343ef:	74 17                	je     40034408 <_vfiprintf_r+0x3f>
400343f1:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
400343f8:	00 
400343f9:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
400343fe:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
40034403:	e9 9b 00 00 00       	jmp    400344a3 <_vfiprintf_r+0xda>
40034408:	89 f2                	mov    %esi,%edx
4003440a:	89 e8                	mov    %ebp,%eax
4003440c:	e8 d8 02 00 00       	call   400346e9 <__swsetup_r>
40034411:	85 c0                	test   %eax,%eax
40034413:	74 dc                	je     400343f1 <_vfiprintf_r+0x28>
40034415:	83 c8 ff             	or     $0xffffffff,%eax
40034418:	e9 36 02 00 00       	jmp    40034653 <_vfiprintf_r+0x28a>
4003441d:	8b 54 24 7c          	mov    0x7c(%esp),%edx
40034421:	8d 4a 04             	lea    0x4(%edx),%ecx
40034424:	8b 12                	mov    (%edx),%edx
40034426:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
4003442a:	85 d2                	test   %edx,%edx
4003442c:	0f 88 39 01 00 00    	js     4003456b <_vfiprintf_r+0x1a2>
40034432:	89 54 24 18          	mov    %edx,0x18(%esp)
40034436:	43                   	inc    %ebx
40034437:	80 3b 2e             	cmpb   $0x2e,(%ebx)
4003443a:	0f 84 63 01 00 00    	je     400345a3 <_vfiprintf_r+0x1da>
40034440:	0f be 13             	movsbl (%ebx),%edx
40034443:	b9 03 00 00 00       	mov    $0x3,%ecx
40034448:	b8 b8 60 03 40       	mov    $0x400360b8,%eax
4003444d:	e8 26 bc ff ff       	call   40030078 <memchr>
40034452:	85 c0                	test   %eax,%eax
40034454:	74 13                	je     40034469 <_vfiprintf_r+0xa0>
40034456:	2d b8 60 03 40       	sub    $0x400360b8,%eax
4003445b:	ba 40 00 00 00       	mov    $0x40,%edx
40034460:	88 c1                	mov    %al,%cl
40034462:	43                   	inc    %ebx
40034463:	d3 e2                	shl    %cl,%edx
40034465:	09 54 24 0c          	or     %edx,0xc(%esp)
40034469:	0f be 13             	movsbl (%ebx),%edx
4003446c:	b9 06 00 00 00       	mov    $0x6,%ecx
40034471:	b8 bc 60 03 40       	mov    $0x400360bc,%eax
40034476:	88 54 24 24          	mov    %dl,0x24(%esp)
4003447a:	e8 f9 bb ff ff       	call   40030078 <memchr>
4003447f:	8d 7b 01             	lea    0x1(%ebx),%edi
40034482:	85 c0                	test   %eax,%eax
40034484:	0f 84 94 01 00 00    	je     4003461e <_vfiprintf_r+0x255>
4003448a:	b8 00 00 00 00       	mov    $0x0,%eax
4003448f:	85 c0                	test   %eax,%eax
40034491:	0f 85 6e 01 00 00    	jne    40034605 <_vfiprintf_r+0x23c>
40034497:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
4003449c:	8b 04 24             	mov    (%esp),%eax
4003449f:	01 44 24 20          	add    %eax,0x20(%esp)
400344a3:	89 fb                	mov    %edi,%ebx
400344a5:	8a 03                	mov    (%ebx),%al
400344a7:	84 c0                	test   %al,%al
400344a9:	0f 95 c2             	setne  %dl
400344ac:	3c 25                	cmp    $0x25,%al
400344ae:	0f 95 c0             	setne  %al
400344b1:	20 c2                	and    %al,%dl
400344b3:	88 54 24 07          	mov    %dl,0x7(%esp)
400344b7:	74 03                	je     400344bc <_vfiprintf_r+0xf3>
400344b9:	43                   	inc    %ebx
400344ba:	eb e9                	jmp    400344a5 <_vfiprintf_r+0xdc>
400344bc:	89 d8                	mov    %ebx,%eax
400344be:	29 f8                	sub    %edi,%eax
400344c0:	89 44 24 08          	mov    %eax,0x8(%esp)
400344c4:	74 1c                	je     400344e2 <_vfiprintf_r+0x119>
400344c6:	50                   	push   %eax
400344c7:	89 f9                	mov    %edi,%ecx
400344c9:	89 f2                	mov    %esi,%edx
400344cb:	89 e8                	mov    %ebp,%eax
400344cd:	e8 c8 fe ff ff       	call   4003439a <__sfputs_r>
400344d2:	59                   	pop    %ecx
400344d3:	40                   	inc    %eax
400344d4:	0f 84 6b 01 00 00    	je     40034645 <_vfiprintf_r+0x27c>
400344da:	8b 44 24 08          	mov    0x8(%esp),%eax
400344de:	01 44 24 20          	add    %eax,0x20(%esp)
400344e2:	80 3b 00             	cmpb   $0x0,(%ebx)
400344e5:	0f 84 5a 01 00 00    	je     40034645 <_vfiprintf_r+0x27c>
400344eb:	43                   	inc    %ebx
400344ec:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
400344f3:	00 
400344f4:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
400344fb:	00 
400344fc:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034503:	ff 
40034504:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
4003450b:	00 
4003450c:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
40034511:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
40034518:	00 
40034519:	0f be 13             	movsbl (%ebx),%edx
4003451c:	b9 05 00 00 00       	mov    $0x5,%ecx
40034521:	b8 b2 60 03 40       	mov    $0x400360b2,%eax
40034526:	e8 4d bb ff ff       	call   40030078 <memchr>
4003452b:	85 c0                	test   %eax,%eax
4003452d:	74 15                	je     40034544 <_vfiprintf_r+0x17b>
4003452f:	2d b2 60 03 40       	sub    $0x400360b2,%eax
40034534:	ba 01 00 00 00       	mov    $0x1,%edx
40034539:	88 c1                	mov    %al,%cl
4003453b:	43                   	inc    %ebx
4003453c:	d3 e2                	shl    %cl,%edx
4003453e:	09 54 24 0c          	or     %edx,0xc(%esp)
40034542:	eb d5                	jmp    40034519 <_vfiprintf_r+0x150>
40034544:	8b 44 24 0c          	mov    0xc(%esp),%eax
40034548:	a8 10                	test   $0x10,%al
4003454a:	74 05                	je     40034551 <_vfiprintf_r+0x188>
4003454c:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40034551:	a8 08                	test   $0x8,%al
40034553:	74 05                	je     4003455a <_vfiprintf_r+0x191>
40034555:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
4003455a:	80 3b 2a             	cmpb   $0x2a,(%ebx)
4003455d:	0f 84 ba fe ff ff    	je     4003441d <_vfiprintf_r+0x54>
40034563:	8b 44 24 18          	mov    0x18(%esp),%eax
40034567:	31 c9                	xor    %ecx,%ecx
40034569:	eb 12                	jmp    4003457d <_vfiprintf_r+0x1b4>
4003456b:	f7 da                	neg    %edx
4003456d:	83 c8 02             	or     $0x2,%eax
40034570:	89 54 24 18          	mov    %edx,0x18(%esp)
40034574:	89 44 24 0c          	mov    %eax,0xc(%esp)
40034578:	e9 b9 fe ff ff       	jmp    40034436 <_vfiprintf_r+0x6d>
4003457d:	0f be 13             	movsbl (%ebx),%edx
40034580:	83 ea 30             	sub    $0x30,%edx
40034583:	83 fa 09             	cmp    $0x9,%edx
40034586:	77 0a                	ja     40034592 <_vfiprintf_r+0x1c9>
40034588:	6b c0 0a             	imul   $0xa,%eax,%eax
4003458b:	43                   	inc    %ebx
4003458c:	01 d0                	add    %edx,%eax
4003458e:	b1 01                	mov    $0x1,%cl
40034590:	eb eb                	jmp    4003457d <_vfiprintf_r+0x1b4>
40034592:	84 c9                	test   %cl,%cl
40034594:	0f 84 9d fe ff ff    	je     40034437 <_vfiprintf_r+0x6e>
4003459a:	89 44 24 18          	mov    %eax,0x18(%esp)
4003459e:	e9 94 fe ff ff       	jmp    40034437 <_vfiprintf_r+0x6e>
400345a3:	8d 43 01             	lea    0x1(%ebx),%eax
400345a6:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
400345aa:	75 21                	jne    400345cd <_vfiprintf_r+0x204>
400345ac:	8b 44 24 7c          	mov    0x7c(%esp),%eax
400345b0:	83 c3 02             	add    $0x2,%ebx
400345b3:	8d 50 04             	lea    0x4(%eax),%edx
400345b6:	8b 00                	mov    (%eax),%eax
400345b8:	89 54 24 7c          	mov    %edx,0x7c(%esp)
400345bc:	85 c0                	test   %eax,%eax
400345be:	79 3c                	jns    400345fc <_vfiprintf_r+0x233>
400345c0:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
400345c7:	ff 
400345c8:	e9 73 fe ff ff       	jmp    40034440 <_vfiprintf_r+0x77>
400345cd:	89 c3                	mov    %eax,%ebx
400345cf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
400345d6:	00 
400345d7:	31 c0                	xor    %eax,%eax
400345d9:	0f be 13             	movsbl (%ebx),%edx
400345dc:	83 ea 30             	sub    $0x30,%edx
400345df:	83 fa 09             	cmp    $0x9,%edx
400345e2:	77 0d                	ja     400345f1 <_vfiprintf_r+0x228>
400345e4:	6b c0 0a             	imul   $0xa,%eax,%eax
400345e7:	43                   	inc    %ebx
400345e8:	01 d0                	add    %edx,%eax
400345ea:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
400345ef:	eb e8                	jmp    400345d9 <_vfiprintf_r+0x210>
400345f1:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
400345f6:	0f 84 44 fe ff ff    	je     40034440 <_vfiprintf_r+0x77>
400345fc:	89 44 24 10          	mov    %eax,0x10(%esp)
40034600:	e9 3b fe ff ff       	jmp    40034440 <_vfiprintf_r+0x77>
40034605:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034609:	89 f1                	mov    %esi,%ecx
4003460b:	50                   	push   %eax
4003460c:	68 9a 43 03 40       	push   $0x4003439a
40034611:	8d 54 24 14          	lea    0x14(%esp),%edx
40034615:	89 e8                	mov    %ebp,%eax
40034617:	e8 e4 b9 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
4003461c:	eb 17                	jmp    40034635 <_vfiprintf_r+0x26c>
4003461e:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034622:	89 f1                	mov    %esi,%ecx
40034624:	50                   	push   %eax
40034625:	68 9a 43 03 40       	push   $0x4003439a
4003462a:	8d 54 24 14          	lea    0x14(%esp),%edx
4003462e:	89 e8                	mov    %ebp,%eax
40034630:	e8 e7 05 00 00       	call   40034c1c <_printf_i>
40034635:	89 44 24 08          	mov    %eax,0x8(%esp)
40034639:	58                   	pop    %eax
4003463a:	5a                   	pop    %edx
4003463b:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
4003463f:	0f 85 57 fe ff ff    	jne    4003449c <_vfiprintf_r+0xd3>
40034645:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
40034649:	0f 85 c6 fd ff ff    	jne    40034415 <_vfiprintf_r+0x4c>
4003464f:	8b 44 24 20          	mov    0x20(%esp),%eax
40034653:	83 c4 68             	add    $0x68,%esp
40034656:	5b                   	pop    %ebx
40034657:	5e                   	pop    %esi
40034658:	5f                   	pop    %edi
40034659:	5d                   	pop    %ebp
4003465a:	c3                   	ret    

4003465b <__swbuf_r>:
4003465b:	55                   	push   %ebp
4003465c:	85 c0                	test   %eax,%eax
4003465e:	57                   	push   %edi
4003465f:	89 d5                	mov    %edx,%ebp
40034661:	56                   	push   %esi
40034662:	89 c6                	mov    %eax,%esi
40034664:	53                   	push   %ebx
40034665:	89 cb                	mov    %ecx,%ebx
40034667:	74 0b                	je     40034674 <__swbuf_r+0x19>
40034669:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003466d:	75 05                	jne    40034674 <__swbuf_r+0x19>
4003466f:	e8 04 03 00 00       	call   40034978 <__sinit>
40034674:	8b 43 18             	mov    0x18(%ebx),%eax
40034677:	f6 43 0c 08          	testb  $0x8,0xc(%ebx)
4003467b:	89 43 08             	mov    %eax,0x8(%ebx)
4003467e:	74 17                	je     40034697 <__swbuf_r+0x3c>
40034680:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034684:	74 11                	je     40034697 <__swbuf_r+0x3c>
40034686:	89 e8                	mov    %ebp,%eax
40034688:	0f b6 f8             	movzbl %al,%edi
4003468b:	8b 03                	mov    (%ebx),%eax
4003468d:	2b 43 10             	sub    0x10(%ebx),%eax
40034690:	3b 43 14             	cmp    0x14(%ebx),%eax
40034693:	7c 21                	jl     400346b6 <__swbuf_r+0x5b>
40034695:	eb 12                	jmp    400346a9 <__swbuf_r+0x4e>
40034697:	89 da                	mov    %ebx,%edx
40034699:	89 f0                	mov    %esi,%eax
4003469b:	e8 49 00 00 00       	call   400346e9 <__swsetup_r>
400346a0:	85 c0                	test   %eax,%eax
400346a2:	74 e2                	je     40034686 <__swbuf_r+0x2b>
400346a4:	83 cf ff             	or     $0xffffffff,%edi
400346a7:	eb 39                	jmp    400346e2 <__swbuf_r+0x87>
400346a9:	89 da                	mov    %ebx,%edx
400346ab:	89 f0                	mov    %esi,%eax
400346ad:	e8 23 02 00 00       	call   400348d5 <_fflush_r>
400346b2:	85 c0                	test   %eax,%eax
400346b4:	75 ee                	jne    400346a4 <__swbuf_r+0x49>
400346b6:	8b 13                	mov    (%ebx),%edx
400346b8:	ff 4b 08             	decl   0x8(%ebx)
400346bb:	8d 4a 01             	lea    0x1(%edx),%ecx
400346be:	40                   	inc    %eax
400346bf:	89 0b                	mov    %ecx,(%ebx)
400346c1:	89 e9                	mov    %ebp,%ecx
400346c3:	88 0a                	mov    %cl,(%edx)
400346c5:	3b 43 14             	cmp    0x14(%ebx),%eax
400346c8:	74 0b                	je     400346d5 <__swbuf_r+0x7a>
400346ca:	83 ff 0a             	cmp    $0xa,%edi
400346cd:	75 13                	jne    400346e2 <__swbuf_r+0x87>
400346cf:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
400346d3:	74 0d                	je     400346e2 <__swbuf_r+0x87>
400346d5:	89 da                	mov    %ebx,%edx
400346d7:	89 f0                	mov    %esi,%eax
400346d9:	e8 f7 01 00 00       	call   400348d5 <_fflush_r>
400346de:	85 c0                	test   %eax,%eax
400346e0:	75 c2                	jne    400346a4 <__swbuf_r+0x49>
400346e2:	5b                   	pop    %ebx
400346e3:	89 f8                	mov    %edi,%eax
400346e5:	5e                   	pop    %esi
400346e6:	5f                   	pop    %edi
400346e7:	5d                   	pop    %ebp
400346e8:	c3                   	ret    

400346e9 <__swsetup_r>:
400346e9:	56                   	push   %esi
400346ea:	89 c6                	mov    %eax,%esi
400346ec:	53                   	push   %ebx
400346ed:	89 d3                	mov    %edx,%ebx
400346ef:	e8 76 fc ff ff       	call   4003436a <__getreent>
400346f4:	85 c0                	test   %eax,%eax
400346f6:	74 0b                	je     40034703 <__swsetup_r+0x1a>
400346f8:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400346fc:	75 05                	jne    40034703 <__swsetup_r+0x1a>
400346fe:	e8 75 02 00 00       	call   40034978 <__sinit>
40034703:	8b 43 0c             	mov    0xc(%ebx),%eax
40034706:	a8 08                	test   $0x8,%al
40034708:	75 4c                	jne    40034756 <__swsetup_r+0x6d>
4003470a:	a8 10                	test   $0x10,%al
4003470c:	75 12                	jne    40034720 <__swsetup_r+0x37>
4003470e:	83 c8 40             	or     $0x40,%eax
40034711:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
40034717:	66 89 43 0c          	mov    %ax,0xc(%ebx)
4003471b:	e9 8c 00 00 00       	jmp    400347ac <__swsetup_r+0xc3>
40034720:	a8 04                	test   $0x4,%al
40034722:	74 2d                	je     40034751 <__swsetup_r+0x68>
40034724:	8b 53 30             	mov    0x30(%ebx),%edx
40034727:	85 d2                	test   %edx,%edx
40034729:	74 15                	je     40034740 <__swsetup_r+0x57>
4003472b:	8d 43 40             	lea    0x40(%ebx),%eax
4003472e:	39 c2                	cmp    %eax,%edx
40034730:	74 07                	je     40034739 <__swsetup_r+0x50>
40034732:	89 f0                	mov    %esi,%eax
40034734:	e8 4f fa ff ff       	call   40034188 <_free_r>
40034739:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40034740:	66 83 63 0c db       	andw   $0xffdb,0xc(%ebx)
40034745:	8b 43 10             	mov    0x10(%ebx),%eax
40034748:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003474f:	89 03                	mov    %eax,(%ebx)
40034751:	66 83 4b 0c 08       	orw    $0x8,0xc(%ebx)
40034756:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003475a:	75 16                	jne    40034772 <__swsetup_r+0x89>
4003475c:	8b 43 0c             	mov    0xc(%ebx),%eax
4003475f:	66 25 80 02          	and    $0x280,%ax
40034763:	66 3d 00 02          	cmp    $0x200,%ax
40034767:	74 09                	je     40034772 <__swsetup_r+0x89>
40034769:	89 da                	mov    %ebx,%edx
4003476b:	89 f0                	mov    %esi,%eax
4003476d:	e8 2e 03 00 00       	call   40034aa0 <__smakebuf_r>
40034772:	8b 53 0c             	mov    0xc(%ebx),%edx
40034775:	f6 c2 01             	test   $0x1,%dl
40034778:	74 11                	je     4003478b <__swsetup_r+0xa2>
4003477a:	8b 43 14             	mov    0x14(%ebx),%eax
4003477d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
40034784:	f7 d8                	neg    %eax
40034786:	89 43 18             	mov    %eax,0x18(%ebx)
40034789:	eb 0d                	jmp    40034798 <__swsetup_r+0xaf>
4003478b:	31 c0                	xor    %eax,%eax
4003478d:	f6 c2 02             	test   $0x2,%dl
40034790:	75 03                	jne    40034795 <__swsetup_r+0xac>
40034792:	8b 43 14             	mov    0x14(%ebx),%eax
40034795:	89 43 08             	mov    %eax,0x8(%ebx)
40034798:	31 c0                	xor    %eax,%eax
4003479a:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003479e:	75 0f                	jne    400347af <__swsetup_r+0xc6>
400347a0:	f6 c2 80             	test   $0x80,%dl
400347a3:	74 0a                	je     400347af <__swsetup_r+0xc6>
400347a5:	83 ca 40             	or     $0x40,%edx
400347a8:	66 89 53 0c          	mov    %dx,0xc(%ebx)
400347ac:	83 c8 ff             	or     $0xffffffff,%eax
400347af:	5b                   	pop    %ebx
400347b0:	5e                   	pop    %esi
400347b1:	c3                   	ret    

400347b2 <__sflush_r>:
400347b2:	55                   	push   %ebp
400347b3:	57                   	push   %edi
400347b4:	56                   	push   %esi
400347b5:	53                   	push   %ebx
400347b6:	89 c6                	mov    %eax,%esi
400347b8:	8b 42 0c             	mov    0xc(%edx),%eax
400347bb:	89 d3                	mov    %edx,%ebx
400347bd:	a8 08                	test   $0x8,%al
400347bf:	0f 85 cc 00 00 00    	jne    40034891 <__sflush_r+0xdf>
400347c5:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
400347c9:	7f 0a                	jg     400347d5 <__sflush_r+0x23>
400347cb:	83 7a 3c 00          	cmpl   $0x0,0x3c(%edx)
400347cf:	0f 8e b8 00 00 00    	jle    4003488d <__sflush_r+0xdb>
400347d5:	8b 6b 28             	mov    0x28(%ebx),%ebp
400347d8:	85 ed                	test   %ebp,%ebp
400347da:	0f 84 ad 00 00 00    	je     4003488d <__sflush_r+0xdb>
400347e0:	8b 3e                	mov    (%esi),%edi
400347e2:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
400347e8:	f6 c4 10             	test   $0x10,%ah
400347eb:	74 05                	je     400347f2 <__sflush_r+0x40>
400347ed:	8b 43 50             	mov    0x50(%ebx),%eax
400347f0:	eb 29                	jmp    4003481b <__sflush_r+0x69>
400347f2:	31 c9                	xor    %ecx,%ecx
400347f4:	8b 53 1c             	mov    0x1c(%ebx),%edx
400347f7:	89 f0                	mov    %esi,%eax
400347f9:	6a 01                	push   $0x1
400347fb:	ff d5                	call   *%ebp
400347fd:	5d                   	pop    %ebp
400347fe:	83 f8 ff             	cmp    $0xffffffff,%eax
40034801:	75 18                	jne    4003481b <__sflush_r+0x69>
40034803:	8b 16                	mov    (%esi),%edx
40034805:	85 d2                	test   %edx,%edx
40034807:	74 12                	je     4003481b <__sflush_r+0x69>
40034809:	83 fa 1d             	cmp    $0x1d,%edx
4003480c:	74 09                	je     40034817 <__sflush_r+0x65>
4003480e:	83 fa 16             	cmp    $0x16,%edx
40034811:	0f 85 95 00 00 00    	jne    400348ac <__sflush_r+0xfa>
40034817:	89 3e                	mov    %edi,(%esi)
40034819:	eb 72                	jmp    4003488d <__sflush_r+0xdb>
4003481b:	f6 43 0c 04          	testb  $0x4,0xc(%ebx)
4003481f:	74 0c                	je     4003482d <__sflush_r+0x7b>
40034821:	2b 43 04             	sub    0x4(%ebx),%eax
40034824:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
40034828:	74 03                	je     4003482d <__sflush_r+0x7b>
4003482a:	2b 43 3c             	sub    0x3c(%ebx),%eax
4003482d:	89 c1                	mov    %eax,%ecx
4003482f:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034832:	89 f0                	mov    %esi,%eax
40034834:	6a 00                	push   $0x0
40034836:	ff 53 28             	call   *0x28(%ebx)
40034839:	59                   	pop    %ecx
4003483a:	83 f8 ff             	cmp    $0xffffffff,%eax
4003483d:	75 11                	jne    40034850 <__sflush_r+0x9e>
4003483f:	8b 16                	mov    (%esi),%edx
40034841:	83 fa 1d             	cmp    $0x1d,%edx
40034844:	77 66                	ja     400348ac <__sflush_r+0xfa>
40034846:	b9 01 00 40 20       	mov    $0x20400001,%ecx
4003484b:	0f a3 d1             	bt     %edx,%ecx
4003484e:	73 5c                	jae    400348ac <__sflush_r+0xfa>
40034850:	8b 53 10             	mov    0x10(%ebx),%edx
40034853:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003485a:	89 13                	mov    %edx,(%ebx)
4003485c:	f6 43 0d 10          	testb  $0x10,0xd(%ebx)
40034860:	74 0d                	je     4003486f <__sflush_r+0xbd>
40034862:	83 f8 ff             	cmp    $0xffffffff,%eax
40034865:	75 05                	jne    4003486c <__sflush_r+0xba>
40034867:	83 3e 00             	cmpl   $0x0,(%esi)
4003486a:	75 03                	jne    4003486f <__sflush_r+0xbd>
4003486c:	89 43 50             	mov    %eax,0x50(%ebx)
4003486f:	8b 53 30             	mov    0x30(%ebx),%edx
40034872:	89 3e                	mov    %edi,(%esi)
40034874:	85 d2                	test   %edx,%edx
40034876:	74 15                	je     4003488d <__sflush_r+0xdb>
40034878:	8d 43 40             	lea    0x40(%ebx),%eax
4003487b:	39 c2                	cmp    %eax,%edx
4003487d:	74 07                	je     40034886 <__sflush_r+0xd4>
4003487f:	89 f0                	mov    %esi,%eax
40034881:	e8 02 f9 ff ff       	call   40034188 <_free_r>
40034886:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
4003488d:	31 c0                	xor    %eax,%eax
4003488f:	eb 3f                	jmp    400348d0 <__sflush_r+0x11e>
40034891:	8b 6a 10             	mov    0x10(%edx),%ebp
40034894:	85 ed                	test   %ebp,%ebp
40034896:	74 f5                	je     4003488d <__sflush_r+0xdb>
40034898:	8b 3a                	mov    (%edx),%edi
4003489a:	89 2a                	mov    %ebp,(%edx)
4003489c:	29 ef                	sub    %ebp,%edi
4003489e:	31 d2                	xor    %edx,%edx
400348a0:	a8 03                	test   $0x3,%al
400348a2:	75 03                	jne    400348a7 <__sflush_r+0xf5>
400348a4:	8b 53 14             	mov    0x14(%ebx),%edx
400348a7:	89 53 08             	mov    %edx,0x8(%ebx)
400348aa:	eb 1e                	jmp    400348ca <__sflush_r+0x118>
400348ac:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
400348b1:	83 c8 ff             	or     $0xffffffff,%eax
400348b4:	eb 1a                	jmp    400348d0 <__sflush_r+0x11e>
400348b6:	8b 53 1c             	mov    0x1c(%ebx),%edx
400348b9:	89 e9                	mov    %ebp,%ecx
400348bb:	89 f0                	mov    %esi,%eax
400348bd:	57                   	push   %edi
400348be:	ff 53 24             	call   *0x24(%ebx)
400348c1:	5a                   	pop    %edx
400348c2:	85 c0                	test   %eax,%eax
400348c4:	7e e6                	jle    400348ac <__sflush_r+0xfa>
400348c6:	01 c5                	add    %eax,%ebp
400348c8:	29 c7                	sub    %eax,%edi
400348ca:	85 ff                	test   %edi,%edi
400348cc:	7f e8                	jg     400348b6 <__sflush_r+0x104>
400348ce:	eb bd                	jmp    4003488d <__sflush_r+0xdb>
400348d0:	5b                   	pop    %ebx
400348d1:	5e                   	pop    %esi
400348d2:	5f                   	pop    %edi
400348d3:	5d                   	pop    %ebp
400348d4:	c3                   	ret    

400348d5 <_fflush_r>:
400348d5:	53                   	push   %ebx
400348d6:	85 c0                	test   %eax,%eax
400348d8:	53                   	push   %ebx
400348d9:	89 c3                	mov    %eax,%ebx
400348db:	74 11                	je     400348ee <_fflush_r+0x19>
400348dd:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400348e1:	75 0b                	jne    400348ee <_fflush_r+0x19>
400348e3:	89 14 24             	mov    %edx,(%esp)
400348e6:	e8 8d 00 00 00       	call   40034978 <__sinit>
400348eb:	8b 14 24             	mov    (%esp),%edx
400348ee:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
400348f3:	74 09                	je     400348fe <_fflush_r+0x29>
400348f5:	89 d8                	mov    %ebx,%eax
400348f7:	59                   	pop    %ecx
400348f8:	5b                   	pop    %ebx
400348f9:	e9 b4 fe ff ff       	jmp    400347b2 <__sflush_r>
400348fe:	31 c0                	xor    %eax,%eax
40034900:	5a                   	pop    %edx
40034901:	5b                   	pop    %ebx
40034902:	c3                   	ret    

40034903 <_cleanup_r>:
40034903:	ba d5 48 03 40       	mov    $0x400348d5,%edx
40034908:	e9 d7 00 00 00       	jmp    400349e4 <_fwalk_reent>

4003490d <std.isra.0>:
4003490d:	53                   	push   %ebx
4003490e:	89 c3                	mov    %eax,%ebx
40034910:	66 89 50 0c          	mov    %dx,0xc(%eax)
40034914:	66 89 48 0e          	mov    %cx,0xe(%eax)
40034918:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
4003491e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40034925:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
4003492c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
40034933:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
4003493a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40034941:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40034948:	b9 08 00 00 00       	mov    $0x8,%ecx
4003494d:	8d 40 5c             	lea    0x5c(%eax),%eax
40034950:	31 d2                	xor    %edx,%edx
40034952:	e8 13 b7 ff ff       	call   4003006a <memset>
40034957:	89 5b 1c             	mov    %ebx,0x1c(%ebx)
4003495a:	c7 43 20 b5 4e 03 40 	movl   $0x40034eb5,0x20(%ebx)
40034961:	c7 43 24 d7 4e 03 40 	movl   $0x40034ed7,0x24(%ebx)
40034968:	c7 43 28 14 4f 03 40 	movl   $0x40034f14,0x28(%ebx)
4003496f:	c7 43 2c 3d 4f 03 40 	movl   $0x40034f3d,0x2c(%ebx)
40034976:	5b                   	pop    %ebx
40034977:	c3                   	ret    

40034978 <__sinit>:
40034978:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003497c:	75 65                	jne    400349e3 <__sinit+0x6b>
4003497e:	53                   	push   %ebx
4003497f:	89 c3                	mov    %eax,%ebx
40034981:	c7 40 3c 03 49 03 40 	movl   $0x40034903,0x3c(%eax)
40034988:	c7 80 4c 01 00 00 00 	movl   $0x0,0x14c(%eax)
4003498f:	00 00 00 
40034992:	c7 80 50 01 00 00 03 	movl   $0x3,0x150(%eax)
40034999:	00 00 00 
4003499c:	8d 80 58 01 00 00    	lea    0x158(%eax),%eax
400349a2:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
400349a8:	31 c9                	xor    %ecx,%ecx
400349aa:	8b 43 04             	mov    0x4(%ebx),%eax
400349ad:	ba 04 00 00 00       	mov    $0x4,%edx
400349b2:	e8 56 ff ff ff       	call   4003490d <std.isra.0>
400349b7:	8b 43 08             	mov    0x8(%ebx),%eax
400349ba:	b9 01 00 00 00       	mov    $0x1,%ecx
400349bf:	ba 09 00 00 00       	mov    $0x9,%edx
400349c4:	e8 44 ff ff ff       	call   4003490d <std.isra.0>
400349c9:	8b 43 0c             	mov    0xc(%ebx),%eax
400349cc:	b9 02 00 00 00       	mov    $0x2,%ecx
400349d1:	ba 12 00 00 00       	mov    $0x12,%edx
400349d6:	e8 32 ff ff ff       	call   4003490d <std.isra.0>
400349db:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
400349e2:	5b                   	pop    %ebx
400349e3:	c3                   	ret    

400349e4 <_fwalk_reent>:
400349e4:	55                   	push   %ebp
400349e5:	57                   	push   %edi
400349e6:	56                   	push   %esi
400349e7:	53                   	push   %ebx
400349e8:	83 ec 08             	sub    $0x8,%esp
400349eb:	89 c5                	mov    %eax,%ebp
400349ed:	89 d1                	mov    %edx,%ecx
400349ef:	8d 98 4c 01 00 00    	lea    0x14c(%eax),%ebx
400349f5:	31 ff                	xor    %edi,%edi
400349f7:	85 db                	test   %ebx,%ebx
400349f9:	74 35                	je     40034a30 <_fwalk_reent+0x4c>
400349fb:	8b 43 04             	mov    0x4(%ebx),%eax
400349fe:	8b 73 08             	mov    0x8(%ebx),%esi
40034a01:	89 04 24             	mov    %eax,(%esp)
40034a04:	ff 0c 24             	decl   (%esp)
40034a07:	78 23                	js     40034a2c <_fwalk_reent+0x48>
40034a09:	66 83 7e 0c 01       	cmpw   $0x1,0xc(%esi)
40034a0e:	76 17                	jbe    40034a27 <_fwalk_reent+0x43>
40034a10:	66 83 7e 0e ff       	cmpw   $0xffff,0xe(%esi)
40034a15:	74 10                	je     40034a27 <_fwalk_reent+0x43>
40034a17:	89 f2                	mov    %esi,%edx
40034a19:	89 e8                	mov    %ebp,%eax
40034a1b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40034a1f:	ff d1                	call   *%ecx
40034a21:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40034a25:	09 c7                	or     %eax,%edi
40034a27:	83 c6 68             	add    $0x68,%esi
40034a2a:	eb d8                	jmp    40034a04 <_fwalk_reent+0x20>
40034a2c:	8b 1b                	mov    (%ebx),%ebx
40034a2e:	eb c7                	jmp    400349f7 <_fwalk_reent+0x13>
40034a30:	83 c4 08             	add    $0x8,%esp
40034a33:	89 f8                	mov    %edi,%eax
40034a35:	5b                   	pop    %ebx
40034a36:	5e                   	pop    %esi
40034a37:	5f                   	pop    %edi
40034a38:	5d                   	pop    %ebp
40034a39:	c3                   	ret    

40034a3a <__swhatbuf_r>:
40034a3a:	57                   	push   %edi
40034a3b:	56                   	push   %esi
40034a3c:	53                   	push   %ebx
40034a3d:	89 d7                	mov    %edx,%edi
40034a3f:	83 ec 3c             	sub    $0x3c,%esp
40034a42:	89 cb                	mov    %ecx,%ebx
40034a44:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40034a48:	66 85 d2             	test   %dx,%dx
40034a4b:	8b 74 24 4c          	mov    0x4c(%esp),%esi
40034a4f:	79 1f                	jns    40034a70 <__swhatbuf_r+0x36>
40034a51:	8b 47 0c             	mov    0xc(%edi),%eax
40034a54:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40034a5a:	66 25 80 00          	and    $0x80,%ax
40034a5e:	66 83 f8 01          	cmp    $0x1,%ax
40034a62:	19 c0                	sbb    %eax,%eax
40034a64:	25 c0 03 00 00       	and    $0x3c0,%eax
40034a69:	83 c0 40             	add    $0x40,%eax
40034a6c:	89 03                	mov    %eax,(%ebx)
40034a6e:	eb 27                	jmp    40034a97 <__swhatbuf_r+0x5d>
40034a70:	89 e1                	mov    %esp,%ecx
40034a72:	e8 23 05 00 00       	call   40034f9a <_fstat_r>
40034a77:	85 c0                	test   %eax,%eax
40034a79:	78 d6                	js     40034a51 <__swhatbuf_r+0x17>
40034a7b:	8b 44 24 04          	mov    0x4(%esp),%eax
40034a7f:	25 00 f0 00 00       	and    $0xf000,%eax
40034a84:	3d 00 20 00 00       	cmp    $0x2000,%eax
40034a89:	0f 94 c0             	sete   %al
40034a8c:	0f b6 c0             	movzbl %al,%eax
40034a8f:	89 06                	mov    %eax,(%esi)
40034a91:	c7 03 00 04 00 00    	movl   $0x400,(%ebx)
40034a97:	83 c4 3c             	add    $0x3c,%esp
40034a9a:	31 c0                	xor    %eax,%eax
40034a9c:	5b                   	pop    %ebx
40034a9d:	5e                   	pop    %esi
40034a9e:	5f                   	pop    %edi
40034a9f:	c3                   	ret    

40034aa0 <__smakebuf_r>:
40034aa0:	f6 42 0c 02          	testb  $0x2,0xc(%edx)
40034aa4:	74 10                	je     40034ab6 <__smakebuf_r+0x16>
40034aa6:	8d 42 43             	lea    0x43(%edx),%eax
40034aa9:	c7 42 14 01 00 00 00 	movl   $0x1,0x14(%edx)
40034ab0:	89 02                	mov    %eax,(%edx)
40034ab2:	89 42 10             	mov    %eax,0x10(%edx)
40034ab5:	c3                   	ret    
40034ab6:	57                   	push   %edi
40034ab7:	56                   	push   %esi
40034ab8:	53                   	push   %ebx
40034ab9:	89 c6                	mov    %eax,%esi
40034abb:	83 ec 08             	sub    $0x8,%esp
40034abe:	89 d3                	mov    %edx,%ebx
40034ac0:	8d 44 24 04          	lea    0x4(%esp),%eax
40034ac4:	50                   	push   %eax
40034ac5:	89 f0                	mov    %esi,%eax
40034ac7:	8d 4c 24 04          	lea    0x4(%esp),%ecx
40034acb:	e8 6a ff ff ff       	call   40034a3a <__swhatbuf_r>
40034ad0:	8b 54 24 04          	mov    0x4(%esp),%edx
40034ad4:	89 c7                	mov    %eax,%edi
40034ad6:	89 f0                	mov    %esi,%eax
40034ad8:	e8 64 f7 ff ff       	call   40034241 <_malloc_r>
40034add:	5a                   	pop    %edx
40034ade:	85 c0                	test   %eax,%eax
40034ae0:	75 20                	jne    40034b02 <__smakebuf_r+0x62>
40034ae2:	8b 43 0c             	mov    0xc(%ebx),%eax
40034ae5:	f6 c4 02             	test   $0x2,%ah
40034ae8:	75 4f                	jne    40034b39 <__smakebuf_r+0x99>
40034aea:	83 c8 02             	or     $0x2,%eax
40034aed:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
40034af4:	66 89 43 0c          	mov    %ax,0xc(%ebx)
40034af8:	8d 43 43             	lea    0x43(%ebx),%eax
40034afb:	89 03                	mov    %eax,(%ebx)
40034afd:	89 43 10             	mov    %eax,0x10(%ebx)
40034b00:	eb 37                	jmp    40034b39 <__smakebuf_r+0x99>
40034b02:	c7 46 3c 03 49 03 40 	movl   $0x40034903,0x3c(%esi)
40034b09:	89 03                	mov    %eax,(%ebx)
40034b0b:	89 43 10             	mov    %eax,0x10(%ebx)
40034b0e:	8b 04 24             	mov    (%esp),%eax
40034b11:	66 81 4b 0c 80 00    	orw    $0x80,0xc(%ebx)
40034b17:	89 43 14             	mov    %eax,0x14(%ebx)
40034b1a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
40034b1f:	74 14                	je     40034b35 <__smakebuf_r+0x95>
40034b21:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
40034b25:	89 f0                	mov    %esi,%eax
40034b27:	e8 97 04 00 00       	call   40034fc3 <_isatty_r>
40034b2c:	85 c0                	test   %eax,%eax
40034b2e:	74 05                	je     40034b35 <__smakebuf_r+0x95>
40034b30:	66 83 4b 0c 01       	orw    $0x1,0xc(%ebx)
40034b35:	66 09 7b 0c          	or     %di,0xc(%ebx)
40034b39:	83 c4 08             	add    $0x8,%esp
40034b3c:	5b                   	pop    %ebx
40034b3d:	5e                   	pop    %esi
40034b3e:	5f                   	pop    %edi
40034b3f:	c3                   	ret    

40034b40 <_printf_common>:
40034b40:	55                   	push   %ebp
40034b41:	57                   	push   %edi
40034b42:	56                   	push   %esi
40034b43:	53                   	push   %ebx
40034b44:	53                   	push   %ebx
40034b45:	89 d3                	mov    %edx,%ebx
40034b47:	89 c5                	mov    %eax,%ebp
40034b49:	8b 52 08             	mov    0x8(%edx),%edx
40034b4c:	8b 43 10             	mov    0x10(%ebx),%eax
40034b4f:	89 ce                	mov    %ecx,%esi
40034b51:	39 d0                	cmp    %edx,%eax
40034b53:	7d 02                	jge    40034b57 <_printf_common+0x17>
40034b55:	89 d0                	mov    %edx,%eax
40034b57:	89 06                	mov    %eax,(%esi)
40034b59:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034b5d:	74 03                	je     40034b62 <_printf_common+0x22>
40034b5f:	40                   	inc    %eax
40034b60:	89 06                	mov    %eax,(%esi)
40034b62:	f6 03 20             	testb  $0x20,(%ebx)
40034b65:	74 03                	je     40034b6a <_printf_common+0x2a>
40034b67:	83 06 02             	addl   $0x2,(%esi)
40034b6a:	8b 3b                	mov    (%ebx),%edi
40034b6c:	83 e7 06             	and    $0x6,%edi
40034b6f:	75 26                	jne    40034b97 <_printf_common+0x57>
40034b71:	8d 43 19             	lea    0x19(%ebx),%eax
40034b74:	89 04 24             	mov    %eax,(%esp)
40034b77:	eb 15                	jmp    40034b8e <_printf_common+0x4e>
40034b79:	6a 01                	push   $0x1
40034b7b:	89 e8                	mov    %ebp,%eax
40034b7d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40034b81:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034b85:	ff 54 24 20          	call   *0x20(%esp)
40034b89:	5a                   	pop    %edx
40034b8a:	40                   	inc    %eax
40034b8b:	74 3c                	je     40034bc9 <_printf_common+0x89>
40034b8d:	47                   	inc    %edi
40034b8e:	8b 43 0c             	mov    0xc(%ebx),%eax
40034b91:	2b 06                	sub    (%esi),%eax
40034b93:	39 c7                	cmp    %eax,%edi
40034b95:	7c e2                	jl     40034b79 <_printf_common+0x39>
40034b97:	31 c0                	xor    %eax,%eax
40034b99:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034b9d:	0f 95 c0             	setne  %al
40034ba0:	f6 03 20             	testb  $0x20,(%ebx)
40034ba3:	74 12                	je     40034bb7 <_printf_common+0x77>
40034ba5:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
40034baa:	8d 50 01             	lea    0x1(%eax),%edx
40034bad:	8a 4b 45             	mov    0x45(%ebx),%cl
40034bb0:	83 c0 02             	add    $0x2,%eax
40034bb3:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
40034bb7:	50                   	push   %eax
40034bb8:	8d 4b 43             	lea    0x43(%ebx),%ecx
40034bbb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034bbf:	89 e8                	mov    %ebp,%eax
40034bc1:	ff 54 24 20          	call   *0x20(%esp)
40034bc5:	5f                   	pop    %edi
40034bc6:	40                   	inc    %eax
40034bc7:	75 05                	jne    40034bce <_printf_common+0x8e>
40034bc9:	83 c8 ff             	or     $0xffffffff,%eax
40034bcc:	eb 48                	jmp    40034c16 <_printf_common+0xd6>
40034bce:	8b 43 0c             	mov    0xc(%ebx),%eax
40034bd1:	2b 06                	sub    (%esi),%eax
40034bd3:	89 c6                	mov    %eax,%esi
40034bd5:	8b 03                	mov    (%ebx),%eax
40034bd7:	83 e0 06             	and    $0x6,%eax
40034bda:	83 f8 04             	cmp    $0x4,%eax
40034bdd:	75 07                	jne    40034be6 <_printf_common+0xa6>
40034bdf:	89 f0                	mov    %esi,%eax
40034be1:	c1 e8 1f             	shr    $0x1f,%eax
40034be4:	74 02                	je     40034be8 <_printf_common+0xa8>
40034be6:	31 f6                	xor    %esi,%esi
40034be8:	8b 43 08             	mov    0x8(%ebx),%eax
40034beb:	8b 53 10             	mov    0x10(%ebx),%edx
40034bee:	39 d0                	cmp    %edx,%eax
40034bf0:	7e 04                	jle    40034bf6 <_printf_common+0xb6>
40034bf2:	29 d0                	sub    %edx,%eax
40034bf4:	01 c6                	add    %eax,%esi
40034bf6:	31 ff                	xor    %edi,%edi
40034bf8:	83 c3 1a             	add    $0x1a,%ebx
40034bfb:	39 fe                	cmp    %edi,%esi
40034bfd:	74 15                	je     40034c14 <_printf_common+0xd4>
40034bff:	6a 01                	push   $0x1
40034c01:	89 d9                	mov    %ebx,%ecx
40034c03:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034c07:	89 e8                	mov    %ebp,%eax
40034c09:	ff 54 24 20          	call   *0x20(%esp)
40034c0d:	59                   	pop    %ecx
40034c0e:	40                   	inc    %eax
40034c0f:	74 b8                	je     40034bc9 <_printf_common+0x89>
40034c11:	47                   	inc    %edi
40034c12:	eb e7                	jmp    40034bfb <_printf_common+0xbb>
40034c14:	31 c0                	xor    %eax,%eax
40034c16:	5a                   	pop    %edx
40034c17:	5b                   	pop    %ebx
40034c18:	5e                   	pop    %esi
40034c19:	5f                   	pop    %edi
40034c1a:	5d                   	pop    %ebp
40034c1b:	c3                   	ret    

40034c1c <_printf_i>:
40034c1c:	55                   	push   %ebp
40034c1d:	57                   	push   %edi
40034c1e:	56                   	push   %esi
40034c1f:	53                   	push   %ebx
40034c20:	83 ec 0c             	sub    $0xc,%esp
40034c23:	89 d3                	mov    %edx,%ebx
40034c25:	8d 6a 43             	lea    0x43(%edx),%ebp
40034c28:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40034c2c:	8a 4a 18             	mov    0x18(%edx),%cl
40034c2f:	89 04 24             	mov    %eax,(%esp)
40034c32:	80 f9 6e             	cmp    $0x6e,%cl
40034c35:	8b 44 24 24          	mov    0x24(%esp),%eax
40034c39:	0f 84 83 01 00 00    	je     40034dc2 <_printf_i+0x1a6>
40034c3f:	7f 35                	jg     40034c76 <_printf_i+0x5a>
40034c41:	80 f9 63             	cmp    $0x63,%cl
40034c44:	74 60                	je     40034ca6 <_printf_i+0x8a>
40034c46:	7f 1f                	jg     40034c67 <_printf_i+0x4b>
40034c48:	84 c9                	test   %cl,%cl
40034c4a:	0f 84 9d 01 00 00    	je     40034ded <_printf_i+0x1d1>
40034c50:	80 f9 58             	cmp    $0x58,%cl
40034c53:	0f 85 c5 01 00 00    	jne    40034e1e <_printf_i+0x202>
40034c59:	c6 42 45 58          	movb   $0x58,0x45(%edx)
40034c5d:	bf c3 60 03 40       	mov    $0x400360c3,%edi
40034c62:	e9 c2 00 00 00       	jmp    40034d29 <_printf_i+0x10d>
40034c67:	80 f9 64             	cmp    $0x64,%cl
40034c6a:	74 4e                	je     40034cba <_printf_i+0x9e>
40034c6c:	80 f9 69             	cmp    $0x69,%cl
40034c6f:	74 49                	je     40034cba <_printf_i+0x9e>
40034c71:	e9 a8 01 00 00       	jmp    40034e1e <_printf_i+0x202>
40034c76:	80 f9 73             	cmp    $0x73,%cl
40034c79:	0f 84 79 01 00 00    	je     40034df8 <_printf_i+0x1dc>
40034c7f:	7f 16                	jg     40034c97 <_printf_i+0x7b>
40034c81:	80 f9 6f             	cmp    $0x6f,%cl
40034c84:	74 65                	je     40034ceb <_printf_i+0xcf>
40034c86:	80 f9 70             	cmp    $0x70,%cl
40034c89:	0f 85 8f 01 00 00    	jne    40034e1e <_printf_i+0x202>
40034c8f:	83 0a 20             	orl    $0x20,(%edx)
40034c92:	e9 89 00 00 00       	jmp    40034d20 <_printf_i+0x104>
40034c97:	80 f9 75             	cmp    $0x75,%cl
40034c9a:	74 4f                	je     40034ceb <_printf_i+0xcf>
40034c9c:	80 f9 78             	cmp    $0x78,%cl
40034c9f:	74 7f                	je     40034d20 <_printf_i+0x104>
40034ca1:	e9 78 01 00 00       	jmp    40034e1e <_printf_i+0x202>
40034ca6:	8d 72 42             	lea    0x42(%edx),%esi
40034ca9:	8b 10                	mov    (%eax),%edx
40034cab:	8d 4a 04             	lea    0x4(%edx),%ecx
40034cae:	89 08                	mov    %ecx,(%eax)
40034cb0:	8b 02                	mov    (%edx),%eax
40034cb2:	88 43 42             	mov    %al,0x42(%ebx)
40034cb5:	e9 6a 01 00 00       	jmp    40034e24 <_printf_i+0x208>
40034cba:	8b 0b                	mov    (%ebx),%ecx
40034cbc:	8b 10                	mov    (%eax),%edx
40034cbe:	f6 c1 80             	test   $0x80,%cl
40034cc1:	74 07                	je     40034cca <_printf_i+0xae>
40034cc3:	8d 4a 04             	lea    0x4(%edx),%ecx
40034cc6:	89 08                	mov    %ecx,(%eax)
40034cc8:	eb 0f                	jmp    40034cd9 <_printf_i+0xbd>
40034cca:	80 e1 40             	and    $0x40,%cl
40034ccd:	8d 4a 04             	lea    0x4(%edx),%ecx
40034cd0:	89 08                	mov    %ecx,(%eax)
40034cd2:	74 05                	je     40034cd9 <_printf_i+0xbd>
40034cd4:	0f bf 02             	movswl (%edx),%eax
40034cd7:	eb 02                	jmp    40034cdb <_printf_i+0xbf>
40034cd9:	8b 02                	mov    (%edx),%eax
40034cdb:	85 c0                	test   %eax,%eax
40034cdd:	0f 89 83 00 00 00    	jns    40034d66 <_printf_i+0x14a>
40034ce3:	f7 d8                	neg    %eax
40034ce5:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
40034ce9:	eb 7b                	jmp    40034d66 <_printf_i+0x14a>
40034ceb:	8b 33                	mov    (%ebx),%esi
40034ced:	8b 10                	mov    (%eax),%edx
40034cef:	f7 c6 80 00 00 00    	test   $0x80,%esi
40034cf5:	74 07                	je     40034cfe <_printf_i+0xe2>
40034cf7:	8d 72 04             	lea    0x4(%edx),%esi
40034cfa:	89 30                	mov    %esi,(%eax)
40034cfc:	eb 0f                	jmp    40034d0d <_printf_i+0xf1>
40034cfe:	83 e6 40             	and    $0x40,%esi
40034d01:	8d 72 04             	lea    0x4(%edx),%esi
40034d04:	89 30                	mov    %esi,(%eax)
40034d06:	74 05                	je     40034d0d <_printf_i+0xf1>
40034d08:	0f b7 02             	movzwl (%edx),%eax
40034d0b:	eb 02                	jmp    40034d0f <_printf_i+0xf3>
40034d0d:	8b 02                	mov    (%edx),%eax
40034d0f:	bf c3 60 03 40       	mov    $0x400360c3,%edi
40034d14:	80 f9 6f             	cmp    $0x6f,%cl
40034d17:	74 42                	je     40034d5b <_printf_i+0x13f>
40034d19:	b9 0a 00 00 00       	mov    $0xa,%ecx
40034d1e:	eb 40                	jmp    40034d60 <_printf_i+0x144>
40034d20:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
40034d24:	bf d4 60 03 40       	mov    $0x400360d4,%edi
40034d29:	8b 08                	mov    (%eax),%ecx
40034d2b:	8b 13                	mov    (%ebx),%edx
40034d2d:	f6 c2 80             	test   $0x80,%dl
40034d30:	8d 71 04             	lea    0x4(%ecx),%esi
40034d33:	89 30                	mov    %esi,(%eax)
40034d35:	75 0a                	jne    40034d41 <_printf_i+0x125>
40034d37:	f6 c2 40             	test   $0x40,%dl
40034d3a:	74 05                	je     40034d41 <_printf_i+0x125>
40034d3c:	0f b7 01             	movzwl (%ecx),%eax
40034d3f:	eb 02                	jmp    40034d43 <_printf_i+0x127>
40034d41:	8b 01                	mov    (%ecx),%eax
40034d43:	f6 c2 01             	test   $0x1,%dl
40034d46:	74 05                	je     40034d4d <_printf_i+0x131>
40034d48:	83 ca 20             	or     $0x20,%edx
40034d4b:	89 13                	mov    %edx,(%ebx)
40034d4d:	b9 10 00 00 00       	mov    $0x10,%ecx
40034d52:	85 c0                	test   %eax,%eax
40034d54:	75 0a                	jne    40034d60 <_printf_i+0x144>
40034d56:	83 23 df             	andl   $0xffffffdf,(%ebx)
40034d59:	eb 05                	jmp    40034d60 <_printf_i+0x144>
40034d5b:	b9 08 00 00 00       	mov    $0x8,%ecx
40034d60:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
40034d64:	eb 0a                	jmp    40034d70 <_printf_i+0x154>
40034d66:	bf c3 60 03 40       	mov    $0x400360c3,%edi
40034d6b:	b9 0a 00 00 00       	mov    $0xa,%ecx
40034d70:	8b 53 04             	mov    0x4(%ebx),%edx
40034d73:	89 53 08             	mov    %edx,0x8(%ebx)
40034d76:	85 d2                	test   %edx,%edx
40034d78:	78 12                	js     40034d8c <_printf_i+0x170>
40034d7a:	83 23 fb             	andl   $0xfffffffb,(%ebx)
40034d7d:	85 c0                	test   %eax,%eax
40034d7f:	75 13                	jne    40034d94 <_printf_i+0x178>
40034d81:	89 ee                	mov    %ebp,%esi
40034d83:	85 d2                	test   %edx,%edx
40034d85:	74 1d                	je     40034da4 <_printf_i+0x188>
40034d87:	e9 14 01 00 00       	jmp    40034ea0 <_printf_i+0x284>
40034d8c:	85 c0                	test   %eax,%eax
40034d8e:	0f 84 0c 01 00 00    	je     40034ea0 <_printf_i+0x284>
40034d94:	89 ee                	mov    %ebp,%esi
40034d96:	31 d2                	xor    %edx,%edx
40034d98:	4e                   	dec    %esi
40034d99:	f7 f1                	div    %ecx
40034d9b:	85 c0                	test   %eax,%eax
40034d9d:	8a 14 17             	mov    (%edi,%edx,1),%dl
40034da0:	88 16                	mov    %dl,(%esi)
40034da2:	75 f2                	jne    40034d96 <_printf_i+0x17a>
40034da4:	83 f9 08             	cmp    $0x8,%ecx
40034da7:	75 12                	jne    40034dbb <_printf_i+0x19f>
40034da9:	f6 03 01             	testb  $0x1,(%ebx)
40034dac:	74 0d                	je     40034dbb <_printf_i+0x19f>
40034dae:	8b 43 10             	mov    0x10(%ebx),%eax
40034db1:	39 43 04             	cmp    %eax,0x4(%ebx)
40034db4:	7f 05                	jg     40034dbb <_printf_i+0x19f>
40034db6:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
40034dba:	4e                   	dec    %esi
40034dbb:	29 f5                	sub    %esi,%ebp
40034dbd:	89 6b 10             	mov    %ebp,0x10(%ebx)
40034dc0:	eb 6d                	jmp    40034e2f <_printf_i+0x213>
40034dc2:	8b 32                	mov    (%edx),%esi
40034dc4:	8b 4b 14             	mov    0x14(%ebx),%ecx
40034dc7:	f7 c6 80 00 00 00    	test   $0x80,%esi
40034dcd:	8b 10                	mov    (%eax),%edx
40034dcf:	74 09                	je     40034dda <_printf_i+0x1be>
40034dd1:	8d 72 04             	lea    0x4(%edx),%esi
40034dd4:	89 30                	mov    %esi,(%eax)
40034dd6:	8b 02                	mov    (%edx),%eax
40034dd8:	eb 11                	jmp    40034deb <_printf_i+0x1cf>
40034dda:	83 e6 40             	and    $0x40,%esi
40034ddd:	8d 72 04             	lea    0x4(%edx),%esi
40034de0:	89 30                	mov    %esi,(%eax)
40034de2:	8b 02                	mov    (%edx),%eax
40034de4:	74 05                	je     40034deb <_printf_i+0x1cf>
40034de6:	66 89 08             	mov    %cx,(%eax)
40034de9:	eb 02                	jmp    40034ded <_printf_i+0x1d1>
40034deb:	89 08                	mov    %ecx,(%eax)
40034ded:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
40034df4:	89 ee                	mov    %ebp,%esi
40034df6:	eb 37                	jmp    40034e2f <_printf_i+0x213>
40034df8:	8b 10                	mov    (%eax),%edx
40034dfa:	8d 4a 04             	lea    0x4(%edx),%ecx
40034dfd:	89 08                	mov    %ecx,(%eax)
40034dff:	8b 4b 04             	mov    0x4(%ebx),%ecx
40034e02:	8b 32                	mov    (%edx),%esi
40034e04:	31 d2                	xor    %edx,%edx
40034e06:	89 f0                	mov    %esi,%eax
40034e08:	e8 6b b2 ff ff       	call   40030078 <memchr>
40034e0d:	85 c0                	test   %eax,%eax
40034e0f:	74 05                	je     40034e16 <_printf_i+0x1fa>
40034e11:	29 f0                	sub    %esi,%eax
40034e13:	89 43 04             	mov    %eax,0x4(%ebx)
40034e16:	8b 43 04             	mov    0x4(%ebx),%eax
40034e19:	89 43 10             	mov    %eax,0x10(%ebx)
40034e1c:	eb 0d                	jmp    40034e2b <_printf_i+0x20f>
40034e1e:	8d 73 42             	lea    0x42(%ebx),%esi
40034e21:	88 4b 42             	mov    %cl,0x42(%ebx)
40034e24:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
40034e2b:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
40034e2f:	ff 74 24 20          	pushl  0x20(%esp)
40034e33:	ff 74 24 08          	pushl  0x8(%esp)
40034e37:	89 da                	mov    %ebx,%edx
40034e39:	8d 4c 24 10          	lea    0x10(%esp),%ecx
40034e3d:	8b 44 24 08          	mov    0x8(%esp),%eax
40034e41:	e8 fa fc ff ff       	call   40034b40 <_printf_common>
40034e46:	5f                   	pop    %edi
40034e47:	40                   	inc    %eax
40034e48:	5d                   	pop    %ebp
40034e49:	75 05                	jne    40034e50 <_printf_i+0x234>
40034e4b:	83 c8 ff             	or     $0xffffffff,%eax
40034e4e:	eb 5d                	jmp    40034ead <_printf_i+0x291>
40034e50:	ff 73 10             	pushl  0x10(%ebx)
40034e53:	89 f1                	mov    %esi,%ecx
40034e55:	8b 54 24 08          	mov    0x8(%esp),%edx
40034e59:	8b 44 24 04          	mov    0x4(%esp),%eax
40034e5d:	ff 54 24 24          	call   *0x24(%esp)
40034e61:	59                   	pop    %ecx
40034e62:	40                   	inc    %eax
40034e63:	74 e6                	je     40034e4b <_printf_i+0x22f>
40034e65:	f6 03 02             	testb  $0x2,(%ebx)
40034e68:	74 27                	je     40034e91 <_printf_i+0x275>
40034e6a:	31 f6                	xor    %esi,%esi
40034e6c:	8d 7b 19             	lea    0x19(%ebx),%edi
40034e6f:	eb 15                	jmp    40034e86 <_printf_i+0x26a>
40034e71:	6a 01                	push   $0x1
40034e73:	89 f9                	mov    %edi,%ecx
40034e75:	8b 54 24 08          	mov    0x8(%esp),%edx
40034e79:	8b 44 24 04          	mov    0x4(%esp),%eax
40034e7d:	ff 54 24 24          	call   *0x24(%esp)
40034e81:	5a                   	pop    %edx
40034e82:	40                   	inc    %eax
40034e83:	74 c6                	je     40034e4b <_printf_i+0x22f>
40034e85:	46                   	inc    %esi
40034e86:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e89:	2b 44 24 08          	sub    0x8(%esp),%eax
40034e8d:	39 c6                	cmp    %eax,%esi
40034e8f:	7c e0                	jl     40034e71 <_printf_i+0x255>
40034e91:	8b 54 24 08          	mov    0x8(%esp),%edx
40034e95:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e98:	39 d0                	cmp    %edx,%eax
40034e9a:	7d 11                	jge    40034ead <_printf_i+0x291>
40034e9c:	89 d0                	mov    %edx,%eax
40034e9e:	eb 0d                	jmp    40034ead <_printf_i+0x291>
40034ea0:	8a 07                	mov    (%edi),%al
40034ea2:	8d 73 42             	lea    0x42(%ebx),%esi
40034ea5:	88 43 42             	mov    %al,0x42(%ebx)
40034ea8:	e9 f7 fe ff ff       	jmp    40034da4 <_printf_i+0x188>
40034ead:	83 c4 0c             	add    $0xc,%esp
40034eb0:	5b                   	pop    %ebx
40034eb1:	5e                   	pop    %esi
40034eb2:	5f                   	pop    %edi
40034eb3:	5d                   	pop    %ebp
40034eb4:	c3                   	ret    

40034eb5 <__sread>:
40034eb5:	53                   	push   %ebx
40034eb6:	89 d3                	mov    %edx,%ebx
40034eb8:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40034ebc:	ff 74 24 08          	pushl  0x8(%esp)
40034ec0:	e8 52 01 00 00       	call   40035017 <_read_r>
40034ec5:	5a                   	pop    %edx
40034ec6:	85 c0                	test   %eax,%eax
40034ec8:	78 05                	js     40034ecf <__sread+0x1a>
40034eca:	01 43 50             	add    %eax,0x50(%ebx)
40034ecd:	eb 06                	jmp    40034ed5 <__sread+0x20>
40034ecf:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
40034ed5:	5b                   	pop    %ebx
40034ed6:	c3                   	ret    

40034ed7 <__swrite>:
40034ed7:	55                   	push   %ebp
40034ed8:	57                   	push   %edi
40034ed9:	56                   	push   %esi
40034eda:	53                   	push   %ebx
40034edb:	89 c6                	mov    %eax,%esi
40034edd:	89 d3                	mov    %edx,%ebx
40034edf:	89 cf                	mov    %ecx,%edi
40034ee1:	8b 6c 24 14          	mov    0x14(%esp),%ebp
40034ee5:	f6 42 0d 01          	testb  $0x1,0xd(%edx)
40034ee9:	74 0e                	je     40034ef9 <__swrite+0x22>
40034eeb:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40034eef:	31 c9                	xor    %ecx,%ecx
40034ef1:	6a 02                	push   $0x2
40034ef3:	e8 f2 00 00 00       	call   40034fea <_lseek_r>
40034ef8:	58                   	pop    %eax
40034ef9:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
40034eff:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
40034f03:	89 f9                	mov    %edi,%ecx
40034f05:	89 f0                	mov    %esi,%eax
40034f07:	89 6c 24 14          	mov    %ebp,0x14(%esp)
40034f0b:	5b                   	pop    %ebx
40034f0c:	5e                   	pop    %esi
40034f0d:	5f                   	pop    %edi
40034f0e:	5d                   	pop    %ebp
40034f0f:	e9 32 00 00 00       	jmp    40034f46 <_write_r>

40034f14 <__sseek>:
40034f14:	53                   	push   %ebx
40034f15:	89 d3                	mov    %edx,%ebx
40034f17:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40034f1b:	ff 74 24 08          	pushl  0x8(%esp)
40034f1f:	e8 c6 00 00 00       	call   40034fea <_lseek_r>
40034f24:	5a                   	pop    %edx
40034f25:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f28:	75 08                	jne    40034f32 <__sseek+0x1e>
40034f2a:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
40034f30:	eb 09                	jmp    40034f3b <__sseek+0x27>
40034f32:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
40034f38:	89 43 50             	mov    %eax,0x50(%ebx)
40034f3b:	5b                   	pop    %ebx
40034f3c:	c3                   	ret    

40034f3d <__sclose>:
40034f3d:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40034f41:	e9 2d 00 00 00       	jmp    40034f73 <_close_r>

40034f46 <_write_r>:
40034f46:	53                   	push   %ebx
40034f47:	89 c3                	mov    %eax,%ebx
40034f49:	89 d0                	mov    %edx,%eax
40034f4b:	89 ca                	mov    %ecx,%edx
40034f4d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40034f51:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034f58:	00 00 00 
40034f5b:	e8 64 bf ff ff       	call   40030ec4 <_write>
40034f60:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f63:	75 0c                	jne    40034f71 <_write_r+0x2b>
40034f65:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40034f6b:	85 d2                	test   %edx,%edx
40034f6d:	74 02                	je     40034f71 <_write_r+0x2b>
40034f6f:	89 13                	mov    %edx,(%ebx)
40034f71:	5b                   	pop    %ebx
40034f72:	c3                   	ret    

40034f73 <_close_r>:
40034f73:	53                   	push   %ebx
40034f74:	89 c3                	mov    %eax,%ebx
40034f76:	89 d0                	mov    %edx,%eax
40034f78:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034f7f:	00 00 00 
40034f82:	e8 8a bf ff ff       	call   40030f11 <_close>
40034f87:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f8a:	75 0c                	jne    40034f98 <_close_r+0x25>
40034f8c:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40034f92:	85 d2                	test   %edx,%edx
40034f94:	74 02                	je     40034f98 <_close_r+0x25>
40034f96:	89 13                	mov    %edx,(%ebx)
40034f98:	5b                   	pop    %ebx
40034f99:	c3                   	ret    

40034f9a <_fstat_r>:
40034f9a:	53                   	push   %ebx
40034f9b:	89 c3                	mov    %eax,%ebx
40034f9d:	89 d0                	mov    %edx,%eax
40034f9f:	89 ca                	mov    %ecx,%edx
40034fa1:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034fa8:	00 00 00 
40034fab:	e8 53 bf ff ff       	call   40030f03 <_fstat>
40034fb0:	83 f8 ff             	cmp    $0xffffffff,%eax
40034fb3:	75 0c                	jne    40034fc1 <_fstat_r+0x27>
40034fb5:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40034fbb:	85 d2                	test   %edx,%edx
40034fbd:	74 02                	je     40034fc1 <_fstat_r+0x27>
40034fbf:	89 13                	mov    %edx,(%ebx)
40034fc1:	5b                   	pop    %ebx
40034fc2:	c3                   	ret    

40034fc3 <_isatty_r>:
40034fc3:	53                   	push   %ebx
40034fc4:	89 c3                	mov    %eax,%ebx
40034fc6:	89 d0                	mov    %edx,%eax
40034fc8:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034fcf:	00 00 00 
40034fd2:	e8 22 bf ff ff       	call   40030ef9 <_isatty>
40034fd7:	83 f8 ff             	cmp    $0xffffffff,%eax
40034fda:	75 0c                	jne    40034fe8 <_isatty_r+0x25>
40034fdc:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40034fe2:	85 d2                	test   %edx,%edx
40034fe4:	74 02                	je     40034fe8 <_isatty_r+0x25>
40034fe6:	89 13                	mov    %edx,(%ebx)
40034fe8:	5b                   	pop    %ebx
40034fe9:	c3                   	ret    

40034fea <_lseek_r>:
40034fea:	53                   	push   %ebx
40034feb:	89 c3                	mov    %eax,%ebx
40034fed:	89 d0                	mov    %edx,%eax
40034fef:	89 ca                	mov    %ecx,%edx
40034ff1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40034ff5:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034ffc:	00 00 00 
40034fff:	e8 15 bf ff ff       	call   40030f19 <_lseek>
40035004:	83 f8 ff             	cmp    $0xffffffff,%eax
40035007:	75 0c                	jne    40035015 <_lseek_r+0x2b>
40035009:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
4003500f:	85 d2                	test   %edx,%edx
40035011:	74 02                	je     40035015 <_lseek_r+0x2b>
40035013:	89 13                	mov    %edx,(%ebx)
40035015:	5b                   	pop    %ebx
40035016:	c3                   	ret    

40035017 <_read_r>:
40035017:	53                   	push   %ebx
40035018:	89 c3                	mov    %eax,%ebx
4003501a:	89 d0                	mov    %edx,%eax
4003501c:	89 ca                	mov    %ecx,%edx
4003501e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035022:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40035029:	00 00 00 
4003502c:	e8 68 be ff ff       	call   40030e99 <_read>
40035031:	83 f8 ff             	cmp    $0xffffffff,%eax
40035034:	75 0c                	jne    40035042 <_read_r+0x2b>
40035036:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
4003503c:	85 d2                	test   %edx,%edx
4003503e:	74 02                	je     40035042 <_read_r+0x2b>
40035040:	89 13                	mov    %edx,(%ebx)
40035042:	5b                   	pop    %ebx
40035043:	c3                   	ret    

40035044 <_handle_exc_0_vector_0_stub>:
40035044:	6a 00                	push   $0x0
40035046:	68 5e 35 03 40       	push   $0x4003355e
4003504b:	e9 ad e2 ff ff       	jmp    400332fd <_exception_enter>

40035050 <_handle_exc_2_vector_2_stub>:
40035050:	6a 00                	push   $0x0
40035052:	68 6a 35 03 40       	push   $0x4003356a
40035057:	e9 a1 e2 ff ff       	jmp    400332fd <_exception_enter>

4003505c <_handle_exc_4_vector_4_stub>:
4003505c:	6a 00                	push   $0x0
4003505e:	68 79 35 03 40       	push   $0x40033579
40035063:	e9 95 e2 ff ff       	jmp    400332fd <_exception_enter>

40035068 <_handle_exc_5_vector_5_stub>:
40035068:	6a 00                	push   $0x0
4003506a:	68 88 35 03 40       	push   $0x40033588
4003506f:	e9 89 e2 ff ff       	jmp    400332fd <_exception_enter>

40035074 <_handle_exc_6_vector_6_stub>:
40035074:	6a 00                	push   $0x0
40035076:	68 97 35 03 40       	push   $0x40033597
4003507b:	e9 7d e2 ff ff       	jmp    400332fd <_exception_enter>

40035080 <_handle_exc_7_vector_7_stub>:
40035080:	6a 00                	push   $0x0
40035082:	68 a6 35 03 40       	push   $0x400335a6
40035087:	e9 71 e2 ff ff       	jmp    400332fd <_exception_enter>

4003508c <_handle_exc_8_vector_8_stub>:
4003508c:	68 b5 35 03 40       	push   $0x400335b5
40035091:	e9 67 e2 ff ff       	jmp    400332fd <_exception_enter>

40035096 <_handle_exc_10_vector_10_stub>:
40035096:	68 c4 35 03 40       	push   $0x400335c4
4003509b:	e9 5d e2 ff ff       	jmp    400332fd <_exception_enter>

400350a0 <_handle_exc_11_vector_11_stub>:
400350a0:	68 d3 35 03 40       	push   $0x400335d3
400350a5:	e9 53 e2 ff ff       	jmp    400332fd <_exception_enter>

400350aa <_handle_exc_12_vector_12_stub>:
400350aa:	68 e2 35 03 40       	push   $0x400335e2
400350af:	e9 49 e2 ff ff       	jmp    400332fd <_exception_enter>

400350b4 <_handle_exc_13_vector_13_stub>:
400350b4:	68 f1 35 03 40       	push   $0x400335f1
400350b9:	e9 3f e2 ff ff       	jmp    400332fd <_exception_enter>

400350be <_handle_exc_14_vector_14_stub>:
400350be:	68 00 36 03 40       	push   $0x40033600
400350c3:	e9 35 e2 ff ff       	jmp    400332fd <_exception_enter>

400350c8 <_handle_exc_16_vector_16_stub>:
400350c8:	6a 00                	push   $0x0
400350ca:	68 0f 36 03 40       	push   $0x4003360f
400350cf:	e9 29 e2 ff ff       	jmp    400332fd <_exception_enter>

400350d4 <_handle_exc_17_vector_17_stub>:
400350d4:	68 1e 36 03 40       	push   $0x4003361e
400350d9:	e9 1f e2 ff ff       	jmp    400332fd <_exception_enter>

400350de <_handle_exc_18_vector_18_stub>:
400350de:	6a 00                	push   $0x0
400350e0:	68 2d 36 03 40       	push   $0x4003362d
400350e5:	e9 13 e2 ff ff       	jmp    400332fd <_exception_enter>
