
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
4003000c:	0f 01 1d 4c 00 03 40 	lidtl  0x4003004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
40030013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
4003001c:	bc dc 78 00 a8       	mov    $0xa80078dc,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
40030021:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030027:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003002c:	be 08 75 03 40       	mov    $0x40037508,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030031:	b9 f5 00 00 00       	mov    $0xf5,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
40030038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003003a:	bf e0 67 00 a8       	mov    $0xa80067e0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
4003003f:	b9 3e 04 00 00       	mov    $0x43e,%ecx
	cld
40030044:	fc                   	cld    
	rep
40030045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030047:	e9 39 3d 00 00       	jmp    40033d85 <_Cstart>

4003004c <_Idt>:
4003004c:	ff 07 88 6c 03 40 66 90 66 90 66 90 66 90 66 90     ...l.@f.f.f.f.f.
4003005c:	66 90 66 90                                         f.f.

40030060 <_thread_entry_wrapper>:
40030060:	58                   	pop    %eax
40030061:	5a                   	pop    %edx
40030062:	59                   	pop    %ecx
40030063:	6a 00                	push   $0x0
40030065:	e9 3a 45 00 00       	jmp    400345a4 <_thread_entry>

4003006a <memcpy>:
4003006a:	56                   	push   %esi
4003006b:	57                   	push   %edi
4003006c:	89 c7                	mov    %eax,%edi
4003006e:	89 d6                	mov    %edx,%esi
40030070:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
40030072:	5f                   	pop    %edi
40030073:	5e                   	pop    %esi
40030074:	c3                   	ret    

40030075 <memset>:
40030075:	57                   	push   %edi
40030076:	89 c7                	mov    %eax,%edi
40030078:	0f b6 c2             	movzbl %dl,%eax
4003007b:	89 fa                	mov    %edi,%edx
4003007d:	f3 aa                	rep stos %al,%es:(%edi)
4003007f:	89 d0                	mov    %edx,%eax
40030081:	5f                   	pop    %edi
40030082:	c3                   	ret    

40030083 <memchr>:
40030083:	57                   	push   %edi
40030084:	89 c7                	mov    %eax,%edi
40030086:	89 d0                	mov    %edx,%eax
40030088:	31 d2                	xor    %edx,%edx
4003008a:	85 c9                	test   %ecx,%ecx
4003008c:	74 09                	je     40030097 <L20>
4003008e:	f2 ae                	repnz scas %es:(%edi),%al
40030090:	0f 95 c2             	setne  %dl
40030093:	4f                   	dec    %edi
40030094:	4a                   	dec    %edx
40030095:	21 fa                	and    %edi,%edx

40030097 <L20>:
40030097:	89 d0                	mov    %edx,%eax
40030099:	5f                   	pop    %edi
4003009a:	c3                   	ret    

4003009b <memmove>:
4003009b:	56                   	push   %esi
4003009c:	57                   	push   %edi
4003009d:	89 c7                	mov    %eax,%edi
4003009f:	89 d6                	mov    %edx,%esi
400300a1:	39 f7                	cmp    %esi,%edi
400300a3:	77 07                	ja     400300ac <memmove+0x11>
400300a5:	74 11                	je     400300b8 <memmove+0x1d>
400300a7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
400300a9:	5f                   	pop    %edi
400300aa:	5e                   	pop    %esi
400300ab:	c3                   	ret    
400300ac:	8d 7c 0f ff          	lea    -0x1(%edi,%ecx,1),%edi
400300b0:	8d 74 0e ff          	lea    -0x1(%esi,%ecx,1),%esi
400300b4:	fd                   	std    
400300b5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
400300b7:	fc                   	cld    
400300b8:	5f                   	pop    %edi
400300b9:	5e                   	pop    %esi
400300ba:	c3                   	ret    

400300bb <__udivdi3>:
400300bb:	55                   	push   %ebp
400300bc:	89 e5                	mov    %esp,%ebp
400300be:	57                   	push   %edi
400300bf:	56                   	push   %esi
400300c0:	53                   	push   %ebx
400300c1:	83 ec 10             	sub    $0x10,%esp
400300c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
400300c7:	8b 45 08             	mov    0x8(%ebp),%eax
400300ca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400300cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
400300d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300d3:	89 d6                	mov    %edx,%esi
400300d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
400300d8:	89 d9                	mov    %ebx,%ecx
400300da:	89 d0                	mov    %edx,%eax
400300dc:	85 db                	test   %ebx,%ebx
400300de:	8b 55 e8             	mov    -0x18(%ebp),%edx
400300e1:	75 30                	jne    40030113 <__udivdi3+0x58>
400300e3:	89 d7                	mov    %edx,%edi
400300e5:	39 f2                	cmp    %esi,%edx
400300e7:	76 07                	jbe    400300f0 <__udivdi3+0x35>
400300e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300ec:	89 f2                	mov    %esi,%edx
400300ee:	eb 1a                	jmp    4003010a <__udivdi3+0x4f>
400300f0:	85 d2                	test   %edx,%edx
400300f2:	75 0b                	jne    400300ff <__udivdi3+0x44>
400300f4:	b8 01 00 00 00       	mov    $0x1,%eax
400300f9:	31 d2                	xor    %edx,%edx
400300fb:	f7 f7                	div    %edi
400300fd:	89 c7                	mov    %eax,%edi
400300ff:	31 d2                	xor    %edx,%edx
40030101:	89 f0                	mov    %esi,%eax
40030103:	f7 f7                	div    %edi
40030105:	89 c1                	mov    %eax,%ecx
40030107:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003010a:	f7 f7                	div    %edi
4003010c:	89 c3                	mov    %eax,%ebx
4003010e:	e9 92 00 00 00       	jmp    400301a5 <__udivdi3+0xea>
40030113:	39 f3                	cmp    %esi,%ebx
40030115:	0f 87 82 00 00 00    	ja     4003019d <__udivdi3+0xe2>
4003011b:	0f bd f3             	bsr    %ebx,%esi
4003011e:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030121:	83 75 f0 1f          	xorl   $0x1f,-0x10(%ebp)
40030125:	75 15                	jne    4003013c <__udivdi3+0x81>
40030127:	39 c3                	cmp    %eax,%ebx
40030129:	b9 00 00 00 00       	mov    $0x0,%ecx
4003012e:	72 05                	jb     40030135 <__udivdi3+0x7a>
40030130:	3b 55 ec             	cmp    -0x14(%ebp),%edx
40030133:	77 6a                	ja     4003019f <__udivdi3+0xe4>
40030135:	bb 01 00 00 00       	mov    $0x1,%ebx
4003013a:	eb 69                	jmp    400301a5 <__udivdi3+0xea>
4003013c:	be 20 00 00 00       	mov    $0x20,%esi
40030141:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030144:	2b 75 f0             	sub    -0x10(%ebp),%esi
40030147:	89 d7                	mov    %edx,%edi
40030149:	d3 e3                	shl    %cl,%ebx
4003014b:	89 f1                	mov    %esi,%ecx
4003014d:	d3 ef                	shr    %cl,%edi
4003014f:	89 f9                	mov    %edi,%ecx
40030151:	09 d9                	or     %ebx,%ecx
40030153:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030156:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40030159:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003015c:	d3 e2                	shl    %cl,%edx
4003015e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030161:	89 f1                	mov    %esi,%ecx
40030163:	89 c2                	mov    %eax,%edx
40030165:	d3 ea                	shr    %cl,%edx
40030167:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003016a:	d3 e0                	shl    %cl,%eax
4003016c:	89 f1                	mov    %esi,%ecx
4003016e:	d3 eb                	shr    %cl,%ebx
40030170:	09 c3                	or     %eax,%ebx
40030172:	89 d8                	mov    %ebx,%eax
40030174:	f7 75 e8             	divl   -0x18(%ebp)
40030177:	89 d6                	mov    %edx,%esi
40030179:	89 c7                	mov    %eax,%edi
4003017b:	89 c3                	mov    %eax,%ebx
4003017d:	f7 65 e4             	mull   -0x1c(%ebp)
40030180:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030183:	39 d6                	cmp    %edx,%esi
40030185:	72 11                	jb     40030198 <__udivdi3+0xdd>
40030187:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003018a:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003018d:	d3 e0                	shl    %cl,%eax
4003018f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
40030192:	73 0f                	jae    400301a3 <__udivdi3+0xe8>
40030194:	39 d6                	cmp    %edx,%esi
40030196:	75 0b                	jne    400301a3 <__udivdi3+0xe8>
40030198:	8d 5f ff             	lea    -0x1(%edi),%ebx
4003019b:	eb 06                	jmp    400301a3 <__udivdi3+0xe8>
4003019d:	31 c9                	xor    %ecx,%ecx
4003019f:	31 db                	xor    %ebx,%ebx
400301a1:	eb 02                	jmp    400301a5 <__udivdi3+0xea>
400301a3:	31 c9                	xor    %ecx,%ecx
400301a5:	89 d8                	mov    %ebx,%eax
400301a7:	89 ca                	mov    %ecx,%edx
400301a9:	83 c4 10             	add    $0x10,%esp
400301ac:	5b                   	pop    %ebx
400301ad:	5e                   	pop    %esi
400301ae:	5f                   	pop    %edi
400301af:	5d                   	pop    %ebp
400301b0:	c3                   	ret    

400301b1 <__divdf3>:
400301b1:	55                   	push   %ebp
400301b2:	89 d1                	mov    %edx,%ecx
400301b4:	c1 e9 14             	shr    $0x14,%ecx
400301b7:	89 e5                	mov    %esp,%ebp
400301b9:	57                   	push   %edi
400301ba:	56                   	push   %esi
400301bb:	53                   	push   %ebx
400301bc:	89 d3                	mov    %edx,%ebx
400301be:	c1 ea 1f             	shr    $0x1f,%edx
400301c1:	83 ec 24             	sub    $0x24,%esp
400301c4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
400301c7:	8b 75 0c             	mov    0xc(%ebp),%esi
400301ca:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
400301ce:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
400301d4:	89 75 e0             	mov    %esi,-0x20(%ebp)
400301d7:	66 81 e1 ff 07       	and    $0x7ff,%cx
400301dc:	8b 7d 08             	mov    0x8(%ebp),%edi
400301df:	89 55 e4             	mov    %edx,-0x1c(%ebp)
400301e2:	89 c6                	mov    %eax,%esi
400301e4:	74 29                	je     4003020f <__divdf3+0x5e>
400301e6:	66 81 f9 ff 07       	cmp    $0x7ff,%cx
400301eb:	0f 84 85 00 00 00    	je     40030276 <__divdf3+0xc5>
400301f1:	c1 e8 1d             	shr    $0x1d,%eax
400301f4:	c1 e3 03             	shl    $0x3,%ebx
400301f7:	0d 00 00 80 00       	or     $0x800000,%eax
400301fc:	0f b7 c9             	movzwl %cx,%ecx
400301ff:	c1 e6 03             	shl    $0x3,%esi
40030202:	09 d8                	or     %ebx,%eax
40030204:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030207:	8d 81 01 fc ff ff    	lea    -0x3ff(%ecx),%eax
4003020d:	eb 5b                	jmp    4003026a <__divdf3+0xb9>
4003020f:	09 de                	or     %ebx,%esi
40030211:	89 75 f0             	mov    %esi,-0x10(%ebp)
40030214:	74 7a                	je     40030290 <__divdf3+0xdf>
40030216:	85 db                	test   %ebx,%ebx
40030218:	74 08                	je     40030222 <__divdf3+0x71>
4003021a:	0f bd d3             	bsr    %ebx,%edx
4003021d:	83 f2 1f             	xor    $0x1f,%edx
40030220:	eb 09                	jmp    4003022b <__divdf3+0x7a>
40030222:	0f bd d0             	bsr    %eax,%edx
40030225:	83 f2 1f             	xor    $0x1f,%edx
40030228:	83 c2 20             	add    $0x20,%edx
4003022b:	8d 72 f5             	lea    -0xb(%edx),%esi
4003022e:	83 fe 1c             	cmp    $0x1c,%esi
40030231:	7f 26                	jg     40030259 <__divdf3+0xa8>
40030233:	8d 4a f8             	lea    -0x8(%edx),%ecx
40030236:	89 4d ec             	mov    %ecx,-0x14(%ebp)
40030239:	8a 4d ec             	mov    -0x14(%ebp),%cl
4003023c:	d3 e3                	shl    %cl,%ebx
4003023e:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40030243:	29 f1                	sub    %esi,%ecx
40030245:	89 c6                	mov    %eax,%esi
40030247:	d3 ee                	shr    %cl,%esi
40030249:	89 f1                	mov    %esi,%ecx
4003024b:	09 d9                	or     %ebx,%ecx
4003024d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030250:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030253:	d3 e0                	shl    %cl,%eax
40030255:	89 c6                	mov    %eax,%esi
40030257:	eb 0a                	jmp    40030263 <__divdf3+0xb2>
40030259:	8d 4a d8             	lea    -0x28(%edx),%ecx
4003025c:	31 f6                	xor    %esi,%esi
4003025e:	d3 e0                	shl    %cl,%eax
40030260:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030263:	b8 0d fc ff ff       	mov    $0xfffffc0d,%eax
40030268:	29 d0                	sub    %edx,%eax
4003026a:	89 45 e8             	mov    %eax,-0x18(%ebp)
4003026d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40030274:	eb 3c                	jmp    400302b2 <__divdf3+0x101>
40030276:	09 d8                	or     %ebx,%eax
40030278:	89 45 f0             	mov    %eax,-0x10(%ebp)
4003027b:	74 25                	je     400302a2 <__divdf3+0xf1>
4003027d:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40030280:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40030287:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
4003028e:	eb 22                	jmp    400302b2 <__divdf3+0x101>
40030290:	31 f6                	xor    %esi,%esi
40030292:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
40030299:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
400302a0:	eb 10                	jmp    400302b2 <__divdf3+0x101>
400302a2:	31 f6                	xor    %esi,%esi
400302a4:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
400302ab:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
400302b2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
400302b5:	89 cb                	mov    %ecx,%ebx
400302b7:	89 c8                	mov    %ecx,%eax
400302b9:	c1 e9 1f             	shr    $0x1f,%ecx
400302bc:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
400302c2:	c1 e8 14             	shr    $0x14,%eax
400302c5:	89 4d d0             	mov    %ecx,-0x30(%ebp)
400302c8:	0f b6 55 d0          	movzbl -0x30(%ebp),%edx
400302cc:	66 25 ff 07          	and    $0x7ff,%ax
400302d0:	89 55 d8             	mov    %edx,-0x28(%ebp)
400302d3:	74 2f                	je     40030304 <__divdf3+0x153>
400302d5:	66 3d ff 07          	cmp    $0x7ff,%ax
400302d9:	0f 84 83 00 00 00    	je     40030362 <__divdf3+0x1b1>
400302df:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
400302e6:	89 fb                	mov    %edi,%ebx
400302e8:	c1 eb 1d             	shr    $0x1d,%ebx
400302eb:	81 cb 00 00 80 00    	or     $0x800000,%ebx
400302f1:	0f b7 c0             	movzwl %ax,%eax
400302f4:	09 cb                	or     %ecx,%ebx
400302f6:	2d ff 03 00 00       	sub    $0x3ff,%eax
400302fb:	8d 0c fd 00 00 00 00 	lea    0x0(,%edi,8),%ecx
40030302:	eb 5a                	jmp    4003035e <__divdf3+0x1ad>
40030304:	89 f9                	mov    %edi,%ecx
40030306:	09 d9                	or     %ebx,%ecx
40030308:	74 6c                	je     40030376 <__divdf3+0x1c5>
4003030a:	85 db                	test   %ebx,%ebx
4003030c:	74 08                	je     40030316 <__divdf3+0x165>
4003030e:	0f bd c3             	bsr    %ebx,%eax
40030311:	83 f0 1f             	xor    $0x1f,%eax
40030314:	eb 09                	jmp    4003031f <__divdf3+0x16e>
40030316:	0f bd c7             	bsr    %edi,%eax
40030319:	83 f0 1f             	xor    $0x1f,%eax
4003031c:	83 c0 20             	add    $0x20,%eax
4003031f:	8d 50 f5             	lea    -0xb(%eax),%edx
40030322:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030325:	83 fa 1c             	cmp    $0x1c,%edx
40030328:	7f 22                	jg     4003034c <__divdf3+0x19b>
4003032a:	8d 50 f8             	lea    -0x8(%eax),%edx
4003032d:	89 55 dc             	mov    %edx,-0x24(%ebp)
40030330:	89 fa                	mov    %edi,%edx
40030332:	8a 4d dc             	mov    -0x24(%ebp),%cl
40030335:	d3 e3                	shl    %cl,%ebx
40030337:	b9 1d 00 00 00       	mov    $0x1d,%ecx
4003033c:	2b 4d e0             	sub    -0x20(%ebp),%ecx
4003033f:	d3 ea                	shr    %cl,%edx
40030341:	8a 4d dc             	mov    -0x24(%ebp),%cl
40030344:	09 d3                	or     %edx,%ebx
40030346:	d3 e7                	shl    %cl,%edi
40030348:	89 f9                	mov    %edi,%ecx
4003034a:	eb 09                	jmp    40030355 <__divdf3+0x1a4>
4003034c:	8d 48 d8             	lea    -0x28(%eax),%ecx
4003034f:	d3 e7                	shl    %cl,%edi
40030351:	89 fb                	mov    %edi,%ebx
40030353:	31 c9                	xor    %ecx,%ecx
40030355:	bf 0d fc ff ff       	mov    $0xfffffc0d,%edi
4003035a:	29 c7                	sub    %eax,%edi
4003035c:	89 f8                	mov    %edi,%eax
4003035e:	31 ff                	xor    %edi,%edi
40030360:	eb 2b                	jmp    4003038d <__divdf3+0x1dc>
40030362:	89 f9                	mov    %edi,%ecx
40030364:	09 d9                	or     %ebx,%ecx
40030366:	74 19                	je     40030381 <__divdf3+0x1d0>
40030368:	89 f9                	mov    %edi,%ecx
4003036a:	b8 ff 07 00 00       	mov    $0x7ff,%eax
4003036f:	bf 03 00 00 00       	mov    $0x3,%edi
40030374:	eb 17                	jmp    4003038d <__divdf3+0x1dc>
40030376:	31 db                	xor    %ebx,%ebx
40030378:	31 c0                	xor    %eax,%eax
4003037a:	bf 01 00 00 00       	mov    $0x1,%edi
4003037f:	eb 0c                	jmp    4003038d <__divdf3+0x1dc>
40030381:	31 db                	xor    %ebx,%ebx
40030383:	b8 ff 07 00 00       	mov    $0x7ff,%eax
40030388:	bf 02 00 00 00       	mov    $0x2,%edi
4003038d:	8a 55 d0             	mov    -0x30(%ebp),%dl
40030390:	33 55 d4             	xor    -0x2c(%ebp),%edx
40030393:	0f b6 d2             	movzbl %dl,%edx
40030396:	89 55 e0             	mov    %edx,-0x20(%ebp)
40030399:	8b 55 e8             	mov    -0x18(%ebp),%edx
4003039c:	29 c2                	sub    %eax,%edx
4003039e:	8b 45 ec             	mov    -0x14(%ebp),%eax
400303a1:	c1 e0 02             	shl    $0x2,%eax
400303a4:	89 55 dc             	mov    %edx,-0x24(%ebp)
400303a7:	09 f8                	or     %edi,%eax
400303a9:	48                   	dec    %eax
400303aa:	83 f8 0e             	cmp    $0xe,%eax
400303ad:	77 07                	ja     400303b6 <__divdf3+0x205>
400303af:	ff 24 85 98 5c 03 40 	jmp    *0x40035c98(,%eax,4)
400303b6:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
400303b9:	77 06                	ja     400303c1 <__divdf3+0x210>
400303bb:	75 1c                	jne    400303d9 <__divdf3+0x228>
400303bd:	39 ce                	cmp    %ecx,%esi
400303bf:	72 18                	jb     400303d9 <__divdf3+0x228>
400303c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
400303c4:	89 f0                	mov    %esi,%eax
400303c6:	c1 e2 1f             	shl    $0x1f,%edx
400303c9:	c1 e6 1f             	shl    $0x1f,%esi
400303cc:	d1 e8                	shr    %eax
400303ce:	89 f7                	mov    %esi,%edi
400303d0:	89 d6                	mov    %edx,%esi
400303d2:	09 c6                	or     %eax,%esi
400303d4:	d1 6d f0             	shrl   -0x10(%ebp)
400303d7:	eb 05                	jmp    400303de <__divdf3+0x22d>
400303d9:	ff 4d dc             	decl   -0x24(%ebp)
400303dc:	31 ff                	xor    %edi,%edi
400303de:	c1 e3 08             	shl    $0x8,%ebx
400303e1:	89 c8                	mov    %ecx,%eax
400303e3:	c1 e8 18             	shr    $0x18,%eax
400303e6:	c1 e1 08             	shl    $0x8,%ecx
400303e9:	09 d8                	or     %ebx,%eax
400303eb:	89 4d e8             	mov    %ecx,-0x18(%ebp)
400303ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400303f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
400303f4:	89 ca                	mov    %ecx,%edx
400303f6:	89 f0                	mov    %esi,%eax
400303f8:	f7 75 ec             	divl   -0x14(%ebp)
400303fb:	89 d1                	mov    %edx,%ecx
400303fd:	89 c6                	mov    %eax,%esi
400303ff:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030402:	f7 65 e8             	mull   -0x18(%ebp)
40030405:	89 45 d8             	mov    %eax,-0x28(%ebp)
40030408:	89 55 d4             	mov    %edx,-0x2c(%ebp)
4003040b:	39 d1                	cmp    %edx,%ecx
4003040d:	72 06                	jb     40030415 <__divdf3+0x264>
4003040f:	75 47                	jne    40030458 <__divdf3+0x2a7>
40030411:	39 c7                	cmp    %eax,%edi
40030413:	73 43                	jae    40030458 <__divdf3+0x2a7>
40030415:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030418:	8b 45 e8             	mov    -0x18(%ebp),%eax
4003041b:	8d 5e ff             	lea    -0x1(%esi),%ebx
4003041e:	01 f8                	add    %edi,%eax
40030420:	11 ca                	adc    %ecx,%edx
40030422:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030425:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030428:	89 c7                	mov    %eax,%edi
4003042a:	39 55 ec             	cmp    %edx,-0x14(%ebp)
4003042d:	72 07                	jb     40030436 <__divdf3+0x285>
4003042f:	75 29                	jne    4003045a <__divdf3+0x2a9>
40030431:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40030434:	77 24                	ja     4003045a <__divdf3+0x2a9>
40030436:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
40030439:	77 0a                	ja     40030445 <__divdf3+0x294>
4003043b:	75 1d                	jne    4003045a <__divdf3+0x2a9>
4003043d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030440:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
40030443:	76 15                	jbe    4003045a <__divdf3+0x2a9>
40030445:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40030448:	8b 7d e8             	mov    -0x18(%ebp),%edi
4003044b:	8d 5e fe             	lea    -0x2(%esi),%ebx
4003044e:	03 7d e4             	add    -0x1c(%ebp),%edi
40030451:	11 d1                	adc    %edx,%ecx
40030453:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030456:	eb 02                	jmp    4003045a <__divdf3+0x2a9>
40030458:	89 f3                	mov    %esi,%ebx
4003045a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4003045d:	83 ce ff             	or     $0xffffffff,%esi
40030460:	2b 7d d8             	sub    -0x28(%ebp),%edi
40030463:	1b 4d d4             	sbb    -0x2c(%ebp),%ecx
40030466:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40030469:	0f 84 dc 00 00 00    	je     4003054b <__divdf3+0x39a>
4003046f:	89 f8                	mov    %edi,%eax
40030471:	89 ca                	mov    %ecx,%edx
40030473:	f7 75 ec             	divl   -0x14(%ebp)
40030476:	89 d1                	mov    %edx,%ecx
40030478:	89 c7                	mov    %eax,%edi
4003047a:	89 55 f0             	mov    %edx,-0x10(%ebp)
4003047d:	f7 65 e8             	mull   -0x18(%ebp)
40030480:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40030483:	89 55 d0             	mov    %edx,-0x30(%ebp)
40030486:	39 d1                	cmp    %edx,%ecx
40030488:	72 06                	jb     40030490 <__divdf3+0x2df>
4003048a:	75 50                	jne    400304dc <__divdf3+0x32b>
4003048c:	85 c0                	test   %eax,%eax
4003048e:	74 4c                	je     400304dc <__divdf3+0x32b>
40030490:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030493:	8d 77 ff             	lea    -0x1(%edi),%esi
40030496:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030499:	8b 55 e8             	mov    -0x18(%ebp),%edx
4003049c:	83 c2 00             	add    $0x0,%edx
4003049f:	13 4d e4             	adc    -0x1c(%ebp),%ecx
400304a2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
400304a5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
400304a8:	89 55 d8             	mov    %edx,-0x28(%ebp)
400304ab:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
400304ae:	72 07                	jb     400304b7 <__divdf3+0x306>
400304b0:	75 33                	jne    400304e5 <__divdf3+0x334>
400304b2:	39 55 e8             	cmp    %edx,-0x18(%ebp)
400304b5:	77 2e                	ja     400304e5 <__divdf3+0x334>
400304b7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400304ba:	39 4d d0             	cmp    %ecx,-0x30(%ebp)
400304bd:	77 07                	ja     400304c6 <__divdf3+0x315>
400304bf:	75 24                	jne    400304e5 <__divdf3+0x334>
400304c1:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
400304c4:	76 1f                	jbe    400304e5 <__divdf3+0x334>
400304c6:	8d 77 fe             	lea    -0x2(%edi),%esi
400304c9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400304cc:	8b 7d ec             	mov    -0x14(%ebp),%edi
400304cf:	01 d1                	add    %edx,%ecx
400304d1:	13 7d e4             	adc    -0x1c(%ebp),%edi
400304d4:	89 7d f0             	mov    %edi,-0x10(%ebp)
400304d7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
400304da:	eb 09                	jmp    400304e5 <__divdf3+0x334>
400304dc:	89 fe                	mov    %edi,%esi
400304de:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400304e5:	8b 7d d0             	mov    -0x30(%ebp),%edi
400304e8:	39 7d f0             	cmp    %edi,-0x10(%ebp)
400304eb:	75 08                	jne    400304f5 <__divdf3+0x344>
400304ed:	8b 7d d4             	mov    -0x2c(%ebp),%edi
400304f0:	39 7d d8             	cmp    %edi,-0x28(%ebp)
400304f3:	74 56                	je     4003054b <__divdf3+0x39a>
400304f5:	83 ce 01             	or     $0x1,%esi
400304f8:	eb 51                	jmp    4003054b <__divdf3+0x39a>
400304fa:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
400304fd:	0f 87 65 01 00 00    	ja     40030668 <__divdf3+0x4b7>
40030503:	75 08                	jne    4003050d <__divdf3+0x35c>
40030505:	39 ce                	cmp    %ecx,%esi
40030507:	0f 87 66 01 00 00    	ja     40030673 <__divdf3+0x4c2>
4003050d:	89 ce                	mov    %ecx,%esi
4003050f:	8b 45 d8             	mov    -0x28(%ebp),%eax
40030512:	e9 59 01 00 00       	jmp    40030670 <__divdf3+0x4bf>
40030517:	8b 45 d8             	mov    -0x28(%ebp),%eax
4003051a:	89 ce                	mov    %ecx,%esi
4003051c:	89 45 e0             	mov    %eax,-0x20(%ebp)
4003051f:	89 7d ec             	mov    %edi,-0x14(%ebp)
40030522:	eb 09                	jmp    4003052d <__divdf3+0x37c>
40030524:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40030527:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003052a:	89 45 e0             	mov    %eax,-0x20(%ebp)
4003052d:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
40030531:	0f 84 51 01 00 00    	je     40030688 <__divdf3+0x4d7>
40030537:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
4003053b:	0f 84 2c 01 00 00    	je     4003066d <__divdf3+0x4bc>
40030541:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
40030545:	0f 84 37 01 00 00    	je     40030682 <__divdf3+0x4d1>
4003054b:	8b 45 dc             	mov    -0x24(%ebp),%eax
4003054e:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
40030554:	85 d2                	test   %edx,%edx
40030556:	7e 4d                	jle    400305a5 <__divdf3+0x3f4>
40030558:	f7 c6 07 00 00 00    	test   $0x7,%esi
4003055e:	74 10                	je     40030570 <__divdf3+0x3bf>
40030560:	89 f0                	mov    %esi,%eax
40030562:	83 e0 0f             	and    $0xf,%eax
40030565:	83 f8 04             	cmp    $0x4,%eax
40030568:	74 06                	je     40030570 <__divdf3+0x3bf>
4003056a:	83 c6 04             	add    $0x4,%esi
4003056d:	83 d3 00             	adc    $0x0,%ebx
40030570:	0f ba e3 18          	bt     $0x18,%ebx
40030574:	73 0f                	jae    40030585 <__divdf3+0x3d4>
40030576:	8b 55 dc             	mov    -0x24(%ebp),%edx
40030579:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
4003057f:	81 c2 00 04 00 00    	add    $0x400,%edx
40030585:	81 fa fe 07 00 00    	cmp    $0x7fe,%edx
4003058b:	0f 8f f7 00 00 00    	jg     40030688 <__divdf3+0x4d7>
40030591:	c1 ee 03             	shr    $0x3,%esi
40030594:	89 d8                	mov    %ebx,%eax
40030596:	c1 e0 1d             	shl    $0x1d,%eax
40030599:	09 c6                	or     %eax,%esi
4003059b:	89 d8                	mov    %ebx,%eax
4003059d:	c1 e8 03             	shr    $0x3,%eax
400305a0:	e9 fd 00 00 00       	jmp    400306a2 <__divdf3+0x4f1>
400305a5:	b9 01 00 00 00       	mov    $0x1,%ecx
400305aa:	89 c8                	mov    %ecx,%eax
400305ac:	29 d0                	sub    %edx,%eax
400305ae:	83 f8 38             	cmp    $0x38,%eax
400305b1:	0f 8f 8c 00 00 00    	jg     40030643 <__divdf3+0x492>
400305b7:	83 f8 1f             	cmp    $0x1f,%eax
400305ba:	7f 30                	jg     400305ec <__divdf3+0x43b>
400305bc:	ba 20 00 00 00       	mov    $0x20,%edx
400305c1:	89 df                	mov    %ebx,%edi
400305c3:	29 c2                	sub    %eax,%edx
400305c5:	88 d1                	mov    %dl,%cl
400305c7:	d3 e7                	shl    %cl,%edi
400305c9:	89 7d f0             	mov    %edi,-0x10(%ebp)
400305cc:	88 c1                	mov    %al,%cl
400305ce:	89 f7                	mov    %esi,%edi
400305d0:	d3 ef                	shr    %cl,%edi
400305d2:	89 f9                	mov    %edi,%ecx
400305d4:	8b 7d f0             	mov    -0x10(%ebp),%edi
400305d7:	09 cf                	or     %ecx,%edi
400305d9:	88 d1                	mov    %dl,%cl
400305db:	d3 e6                	shl    %cl,%esi
400305dd:	31 d2                	xor    %edx,%edx
400305df:	88 c1                	mov    %al,%cl
400305e1:	85 f6                	test   %esi,%esi
400305e3:	0f 95 c2             	setne  %dl
400305e6:	09 d7                	or     %edx,%edi
400305e8:	d3 eb                	shr    %cl,%ebx
400305ea:	eb 28                	jmp    40030614 <__divdf3+0x463>
400305ec:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
400305f1:	89 df                	mov    %ebx,%edi
400305f3:	29 d1                	sub    %edx,%ecx
400305f5:	31 d2                	xor    %edx,%edx
400305f7:	d3 ef                	shr    %cl,%edi
400305f9:	83 f8 20             	cmp    $0x20,%eax
400305fc:	74 0b                	je     40030609 <__divdf3+0x458>
400305fe:	b9 40 00 00 00       	mov    $0x40,%ecx
40030603:	29 c1                	sub    %eax,%ecx
40030605:	d3 e3                	shl    %cl,%ebx
40030607:	89 da                	mov    %ebx,%edx
40030609:	31 c0                	xor    %eax,%eax
4003060b:	09 f2                	or     %esi,%edx
4003060d:	0f 95 c0             	setne  %al
40030610:	09 c7                	or     %eax,%edi
40030612:	31 db                	xor    %ebx,%ebx
40030614:	f7 c7 07 00 00 00    	test   $0x7,%edi
4003061a:	74 10                	je     4003062c <__divdf3+0x47b>
4003061c:	89 f8                	mov    %edi,%eax
4003061e:	83 e0 0f             	and    $0xf,%eax
40030621:	83 f8 04             	cmp    $0x4,%eax
40030624:	74 06                	je     4003062c <__divdf3+0x47b>
40030626:	83 c7 04             	add    $0x4,%edi
40030629:	83 d3 00             	adc    $0x0,%ebx
4003062c:	0f ba e3 17          	bt     $0x17,%ebx
40030630:	72 61                	jb     40030693 <__divdf3+0x4e2>
40030632:	89 de                	mov    %ebx,%esi
40030634:	89 d8                	mov    %ebx,%eax
40030636:	c1 ef 03             	shr    $0x3,%edi
40030639:	c1 e6 1d             	shl    $0x1d,%esi
4003063c:	c1 e8 03             	shr    $0x3,%eax
4003063f:	09 fe                	or     %edi,%esi
40030641:	eb 5d                	jmp    400306a0 <__divdf3+0x4ef>
40030643:	09 de                	or     %ebx,%esi
40030645:	74 57                	je     4003069e <__divdf3+0x4ed>
40030647:	31 db                	xor    %ebx,%ebx
40030649:	89 ce                	mov    %ecx,%esi
4003064b:	83 c6 04             	add    $0x4,%esi
4003064e:	83 d3 00             	adc    $0x0,%ebx
40030651:	c1 ee 03             	shr    $0x3,%esi
40030654:	89 d8                	mov    %ebx,%eax
40030656:	eb 48                	jmp    400306a0 <__divdf3+0x4ef>
40030658:	bb 00 00 08 00       	mov    $0x80000,%ebx
4003065d:	31 f6                	xor    %esi,%esi
4003065f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
40030666:	eb 0b                	jmp    40030673 <__divdf3+0x4c2>
40030668:	8b 5d f0             	mov    -0x10(%ebp),%ebx
4003066b:	eb 06                	jmp    40030673 <__divdf3+0x4c2>
4003066d:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030670:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030673:	89 d8                	mov    %ebx,%eax
40030675:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40030678:	0d 00 00 08 00       	or     $0x80000,%eax
4003067d:	89 7d e0             	mov    %edi,-0x20(%ebp)
40030680:	eb 0a                	jmp    4003068c <__divdf3+0x4db>
40030682:	31 c0                	xor    %eax,%eax
40030684:	31 f6                	xor    %esi,%esi
40030686:	eb 18                	jmp    400306a0 <__divdf3+0x4ef>
40030688:	31 c0                	xor    %eax,%eax
4003068a:	31 f6                	xor    %esi,%esi
4003068c:	ba ff 07 00 00       	mov    $0x7ff,%edx
40030691:	eb 0f                	jmp    400306a2 <__divdf3+0x4f1>
40030693:	31 c0                	xor    %eax,%eax
40030695:	31 f6                	xor    %esi,%esi
40030697:	ba 01 00 00 00       	mov    $0x1,%edx
4003069c:	eb 04                	jmp    400306a2 <__divdf3+0x4f1>
4003069e:	31 c0                	xor    %eax,%eax
400306a0:	31 d2                	xor    %edx,%edx
400306a2:	31 db                	xor    %ebx,%ebx
400306a4:	25 ff ff 0f 00       	and    $0xfffff,%eax
400306a9:	89 f1                	mov    %esi,%ecx
400306ab:	89 c6                	mov    %eax,%esi
400306ad:	89 d8                	mov    %ebx,%eax
400306af:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
400306b5:	c1 e2 14             	shl    $0x14,%edx
400306b8:	25 00 00 f0 ff       	and    $0xfff00000,%eax
400306bd:	09 f0                	or     %esi,%eax
400306bf:	25 ff ff 0f 80       	and    $0x800fffff,%eax
400306c4:	09 d0                	or     %edx,%eax
400306c6:	8b 55 e0             	mov    -0x20(%ebp),%edx
400306c9:	c1 e2 1f             	shl    $0x1f,%edx
400306cc:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
400306d1:	83 c4 24             	add    $0x24,%esp
400306d4:	09 d0                	or     %edx,%eax
400306d6:	89 c3                	mov    %eax,%ebx
400306d8:	89 c8                	mov    %ecx,%eax
400306da:	89 da                	mov    %ebx,%edx
400306dc:	5b                   	pop    %ebx
400306dd:	5e                   	pop    %esi
400306de:	5f                   	pop    %edi
400306df:	5d                   	pop    %ebp
400306e0:	c3                   	ret    

400306e1 <__fixdfsi>:
400306e1:	55                   	push   %ebp
400306e2:	89 e5                	mov    %esp,%ebp
400306e4:	56                   	push   %esi
400306e5:	53                   	push   %ebx
400306e6:	89 d3                	mov    %edx,%ebx
400306e8:	c1 eb 14             	shr    $0x14,%ebx
400306eb:	89 c6                	mov    %eax,%esi
400306ed:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
400306f3:	89 d0                	mov    %edx,%eax
400306f5:	c1 ea 1f             	shr    $0x1f,%edx
400306f8:	25 ff ff 0f 00       	and    $0xfffff,%eax
400306fd:	81 fb fe 03 00 00    	cmp    $0x3fe,%ebx
40030703:	7e 40                	jle    40030745 <__fixdfsi+0x64>
40030705:	81 fb 1d 04 00 00    	cmp    $0x41d,%ebx
4003070b:	7e 08                	jle    40030715 <__fixdfsi+0x34>
4003070d:	8d 82 ff ff ff 7f    	lea    0x7fffffff(%edx),%eax
40030713:	eb 32                	jmp    40030747 <__fixdfsi+0x66>
40030715:	b9 33 04 00 00       	mov    $0x433,%ecx
4003071a:	0d 00 00 10 00       	or     $0x100000,%eax
4003071f:	29 d9                	sub    %ebx,%ecx
40030721:	83 f9 1f             	cmp    $0x1f,%ecx
40030724:	7f 0e                	jg     40030734 <__fixdfsi+0x53>
40030726:	d3 ee                	shr    %cl,%esi
40030728:	8d 8b ed fb ff ff    	lea    -0x413(%ebx),%ecx
4003072e:	d3 e0                	shl    %cl,%eax
40030730:	09 f0                	or     %esi,%eax
40030732:	eb 09                	jmp    4003073d <__fixdfsi+0x5c>
40030734:	b9 13 04 00 00       	mov    $0x413,%ecx
40030739:	29 d9                	sub    %ebx,%ecx
4003073b:	d3 e8                	shr    %cl,%eax
4003073d:	84 d2                	test   %dl,%dl
4003073f:	74 06                	je     40030747 <__fixdfsi+0x66>
40030741:	f7 d8                	neg    %eax
40030743:	eb 02                	jmp    40030747 <__fixdfsi+0x66>
40030745:	31 c0                	xor    %eax,%eax
40030747:	5b                   	pop    %ebx
40030748:	5e                   	pop    %esi
40030749:	5d                   	pop    %ebp
4003074a:	c3                   	ret    

4003074b <__floatsidf>:
4003074b:	55                   	push   %ebp
4003074c:	85 c0                	test   %eax,%eax
4003074e:	89 e5                	mov    %esp,%ebp
40030750:	57                   	push   %edi
40030751:	56                   	push   %esi
40030752:	53                   	push   %ebx
40030753:	74 43                	je     40030798 <__floatsidf+0x4d>
40030755:	99                   	cltd   
40030756:	89 c7                	mov    %eax,%edi
40030758:	31 d0                	xor    %edx,%eax
4003075a:	29 d0                	sub    %edx,%eax
4003075c:	ba 1e 04 00 00       	mov    $0x41e,%edx
40030761:	0f bd f0             	bsr    %eax,%esi
40030764:	bb 33 04 00 00       	mov    $0x433,%ebx
40030769:	c1 ef 1f             	shr    $0x1f,%edi
4003076c:	83 f6 1f             	xor    $0x1f,%esi
4003076f:	29 f2                	sub    %esi,%edx
40030771:	29 d3                	sub    %edx,%ebx
40030773:	83 fb 1f             	cmp    $0x1f,%ebx
40030776:	7f 11                	jg     40030789 <__floatsidf+0x3e>
40030778:	b9 0b 00 00 00       	mov    $0xb,%ecx
4003077d:	29 f1                	sub    %esi,%ecx
4003077f:	89 c6                	mov    %eax,%esi
40030781:	d3 ee                	shr    %cl,%esi
40030783:	88 d9                	mov    %bl,%cl
40030785:	d3 e0                	shl    %cl,%eax
40030787:	eb 17                	jmp    400307a0 <__floatsidf+0x55>
40030789:	b9 13 04 00 00       	mov    $0x413,%ecx
4003078e:	29 d1                	sub    %edx,%ecx
40030790:	d3 e0                	shl    %cl,%eax
40030792:	89 c6                	mov    %eax,%esi
40030794:	31 c0                	xor    %eax,%eax
40030796:	eb 08                	jmp    400307a0 <__floatsidf+0x55>
40030798:	31 f6                	xor    %esi,%esi
4003079a:	31 c0                	xor    %eax,%eax
4003079c:	31 d2                	xor    %edx,%edx
4003079e:	31 ff                	xor    %edi,%edi
400307a0:	31 db                	xor    %ebx,%ebx
400307a2:	89 c1                	mov    %eax,%ecx
400307a4:	89 f0                	mov    %esi,%eax
400307a6:	89 de                	mov    %ebx,%esi
400307a8:	25 ff ff 0f 00       	and    $0xfffff,%eax
400307ad:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
400307b3:	09 c6                	or     %eax,%esi
400307b5:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
400307bb:	81 e6 ff ff 0f 80    	and    $0x800fffff,%esi
400307c1:	5b                   	pop    %ebx
400307c2:	c1 e2 14             	shl    $0x14,%edx
400307c5:	89 c8                	mov    %ecx,%eax
400307c7:	c1 e7 1f             	shl    $0x1f,%edi
400307ca:	09 f2                	or     %esi,%edx
400307cc:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
400307d2:	5e                   	pop    %esi
400307d3:	09 fa                	or     %edi,%edx
400307d5:	5f                   	pop    %edi
400307d6:	5d                   	pop    %ebp
400307d7:	c3                   	ret    

400307d8 <main>:

int counter = 0;

uint8_t buffer[10] = {0};

void main() {
400307d8:	55                   	push   %ebp
400307d9:	89 e5                	mov    %esp,%ebp
    printf("LoRa Sender\n");
400307db:	68 d4 5c 03 40       	push   $0x40035cd4
400307e0:	e8 c6 41 00 00       	call   400349ab <iprintf>
400307e5:	58                   	pop    %eax

    // start initialization
    LoRaClass();
400307e6:	e8 e9 27 00 00       	call   40032fd4 <LoRaClass>
    // call pinset
    // ss, reset, dio0
    // 101
    //setPins(10, 3, 2);
    // c1000
    setPins(60, 82, 72);
400307eb:	b9 48 00 00 00       	mov    $0x48,%ecx
400307f0:	ba 52 00 00 00       	mov    $0x52,%edx
400307f5:	b8 3c 00 00 00       	mov    $0x3c,%eax
400307fa:	e8 62 28 00 00       	call   40033061 <setPins>

    // complete initialization by finishing pin setup and
    // setting frequency
    init(915e6);
400307ff:	b8 c0 ca 89 36       	mov    $0x3689cac0,%eax
40030804:	e8 70 2e 00 00       	call   40033679 <init>
    //begin(914984144);

    dumpRegisters();
40030809:	e8 d8 28 00 00       	call   400330e6 <dumpRegisters>

#if 1
    while(1) {
        printf("sending packet: %d\n", counter);
4003080e:	ff 35 f4 67 00 a8    	pushl  0xa80067f4
40030814:	68 e1 5c 03 40       	push   $0x40035ce1
40030819:	e8 8d 41 00 00       	call   400349ab <iprintf>
4003081e:	58                   	pop    %eax

        // send packet actually
        beginPacket(false);
4003081f:	31 c0                	xor    %eax,%eax
        printf("sending packet: %d\n", counter);
40030821:	5a                   	pop    %edx
        beginPacket(false);
40030822:	e8 22 2c 00 00       	call   40033449 <beginPacket>
        //printf("packet sent: ")
        snprintf(buffer, 10, "Ping %d", counter++);
40030827:	a1 f4 67 00 a8       	mov    0xa80067f4,%eax
4003082c:	50                   	push   %eax
4003082d:	68 f5 5c 03 40       	push   $0x40035cf5
40030832:	8d 50 01             	lea    0x1(%eax),%edx
40030835:	6a 0a                	push   $0xa
40030837:	68 e8 67 00 a8       	push   $0xa80067e8
4003083c:	89 15 f4 67 00 a8    	mov    %edx,0xa80067f4
40030842:	e8 a3 41 00 00       	call   400349ea <sniprintf>
40030847:	83 c4 10             	add    $0x10,%esp
        printf("buffer: %s\n", buffer);
4003084a:	68 e8 67 00 a8       	push   $0xa80067e8
4003084f:	68 fd 5c 03 40       	push   $0x40035cfd
40030854:	e8 52 41 00 00       	call   400349ab <iprintf>
40030859:	59                   	pop    %ecx
        write_buf(buffer, 10);
4003085a:	ba 0a 00 00 00       	mov    $0xa,%edx
        printf("buffer: %s\n", buffer);
4003085f:	58                   	pop    %eax
        write_buf(buffer, 10);
40030860:	b8 e8 67 00 a8       	mov    $0xa80067e8,%eax
40030865:	e8 0f 29 00 00       	call   40033179 <write_buf>
        endPacket();
4003086a:	e8 12 2b 00 00       	call   40033381 <endPacket>

        counter++;

        upm_delay_us(10000000);
4003086f:	b8 80 96 98 00       	mov    $0x989680,%eax
        counter++;
40030874:	ff 05 f4 67 00 a8    	incl   0xa80067f4
        upm_delay_us(10000000);
4003087a:	e8 2d 27 00 00       	call   40032fac <upm_delay_us>
4003087f:	eb 8d                	jmp    4003080e <main+0x36>

40030881 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
40030881:	55                   	push   %ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
40030882:	83 f8 0a             	cmp    $0xa,%eax
{
40030885:	89 e5                	mov    %esp,%ebp
40030887:	53                   	push   %ebx
40030888:	89 c3                	mov    %eax,%ebx
	if ('\n' == c) {
4003088a:	75 10                	jne    4003089c <console_out+0x1b>
		uart_poll_out(uart_console_dev, '\r');
4003088c:	a1 f8 67 00 a8       	mov    0xa80067f8,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
40030891:	ba 0d 00 00 00       	mov    $0xd,%edx
40030896:	8b 48 04             	mov    0x4(%eax),%ecx
40030899:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
4003089c:	a1 f8 67 00 a8       	mov    0xa80067f8,%eax
400308a1:	0f b6 d3             	movzbl %bl,%edx
400308a4:	8b 48 04             	mov    0x4(%eax),%ecx
400308a7:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
400308aa:	89 d8                	mov    %ebx,%eax
400308ac:	5b                   	pop    %ebx
400308ad:	5d                   	pop    %ebp
400308ae:	c3                   	ret    

400308af <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
400308af:	55                   	push   %ebp
	__stdout_hook_install(console_out);
400308b0:	b8 81 08 03 40       	mov    $0x40030881,%eax
{
400308b5:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
400308b7:	e8 ad 0a 00 00       	call   40031369 <__stdout_hook_install>
	__printk_hook_install(console_out);
400308bc:	b8 81 08 03 40       	mov    $0x40030881,%eax
}
400308c1:	5d                   	pop    %ebp
	__printk_hook_install(console_out);
400308c2:	e9 23 0c 00 00       	jmp    400314ea <__printk_hook_install>

400308c7 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
400308c7:	55                   	push   %ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400308c8:	b8 09 5d 03 40       	mov    $0x40035d09,%eax
{
400308cd:	89 e5                	mov    %esp,%ebp
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400308cf:	e8 27 34 00 00       	call   40033cfb <device_get_binding>
400308d4:	a3 f8 67 00 a8       	mov    %eax,0xa80067f8
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
400308d9:	e8 d1 ff ff ff       	call   400308af <uart_console_hook_install>

	return 0;
}
400308de:	31 c0                	xor    %eax,%eax
400308e0:	5d                   	pop    %ebp
400308e1:	c3                   	ret    

400308e2 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
400308e2:	55                   	push   %ebp
400308e3:	89 e5                	mov    %esp,%ebp
400308e5:	56                   	push   %esi
400308e6:	53                   	push   %ebx
400308e7:	89 c6                	mov    %eax,%esi
400308e9:	83 ec 0c             	sub    $0xc,%esp
	const struct uart_qmsi_config_info *config = dev->config->config_info;
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
400308ec:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
	const struct uart_qmsi_config_info *config = dev->config->config_info;
400308f3:	8b 00                	mov    (%eax),%eax
400308f5:	8b 58 08             	mov    0x8(%eax),%ebx
	cfg.baud_divisor = config->baud_divisor;
400308f8:	8b 43 08             	mov    0x8(%ebx),%eax
400308fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cfg.hw_fc = config->hw_fc;
400308fe:	8a 43 0c             	mov    0xc(%ebx),%al
40030901:	88 45 f4             	mov    %al,-0xc(%ebp)

	clk_periph_enable(config->clock_gate);
40030904:	8b 43 04             	mov    0x4(%ebx),%eax
40030907:	e8 9e 0e 00 00       	call   400317aa <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
4003090c:	8d 55 ec             	lea    -0x14(%ebp),%edx
4003090f:	8b 03                	mov    (%ebx),%eax
40030911:	e8 db 0f 00 00       	call   400318f1 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
40030916:	c7 46 04 44 5d 03 40 	movl   $0x40035d44,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
4003091d:	83 c4 0c             	add    $0xc,%esp
40030920:	31 c0                	xor    %eax,%eax
40030922:	5b                   	pop    %ebx
40030923:	5e                   	pop    %esi
40030924:	5d                   	pop    %ebp
40030925:	c3                   	ret    

40030926 <uart_qmsi_err_check>:
{
40030926:	55                   	push   %ebp
40030927:	89 e5                	mov    %esp,%ebp
40030929:	52                   	push   %edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003092a:	8b 00                	mov    (%eax),%eax
	qm_uart_get_status(instance, &status);
4003092c:	8d 55 fc             	lea    -0x4(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003092f:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_get_status(instance, &status);
40030932:	8b 00                	mov    (%eax),%eax
40030934:	e8 25 10 00 00       	call   4003195e <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
40030939:	8b 45 fc             	mov    -0x4(%ebp),%eax
4003093c:	83 e0 1e             	and    $0x1e,%eax
}
4003093f:	c9                   	leave  
40030940:	c3                   	ret    

40030941 <uart_qmsi_poll_out>:
{
40030941:	55                   	push   %ebp
40030942:	89 e5                	mov    %esp,%ebp
40030944:	53                   	push   %ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030945:	8b 00                	mov    (%eax),%eax
{
40030947:	89 d3                	mov    %edx,%ebx
	qm_uart_write(instance, data);
40030949:	0f b6 d2             	movzbl %dl,%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
4003094c:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_write(instance, data);
4003094f:	8b 00                	mov    (%eax),%eax
40030951:	e8 49 10 00 00       	call   4003199f <qm_uart_write>
}
40030956:	88 d8                	mov    %bl,%al
40030958:	5b                   	pop    %ebx
40030959:	5d                   	pop    %ebp
4003095a:	c3                   	ret    

4003095b <uart_qmsi_poll_in>:
{
4003095b:	55                   	push   %ebp
4003095c:	89 e5                	mov    %esp,%ebp
4003095e:	56                   	push   %esi
4003095f:	53                   	push   %ebx
40030960:	51                   	push   %ecx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030961:	8b 00                	mov    (%eax),%eax
{
40030963:	89 d6                	mov    %edx,%esi
	qm_uart_get_status(instance, &status);
40030965:	8d 55 f4             	lea    -0xc(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030968:	8b 40 08             	mov    0x8(%eax),%eax
4003096b:	8b 18                	mov    (%eax),%ebx
	qm_uart_get_status(instance, &status);
4003096d:	89 d8                	mov    %ebx,%eax
4003096f:	e8 ea 0f 00 00       	call   4003195e <qm_uart_get_status>
		return -1;
40030974:	83 c8 ff             	or     $0xffffffff,%eax
	if (!(status & QM_UART_RX_BUSY))
40030977:	f6 45 f4 40          	testb  $0x40,-0xc(%ebp)
4003097b:	74 0d                	je     4003098a <uart_qmsi_poll_in+0x2f>
	qm_uart_read(instance, data, NULL);
4003097d:	31 c9                	xor    %ecx,%ecx
4003097f:	89 f2                	mov    %esi,%edx
40030981:	89 d8                	mov    %ebx,%eax
40030983:	e8 3a 10 00 00       	call   400319c2 <qm_uart_read>
	return 0;
40030988:	31 c0                	xor    %eax,%eax
}
4003098a:	5a                   	pop    %edx
4003098b:	5b                   	pop    %ebx
4003098c:	5e                   	pop    %esi
4003098d:	5d                   	pop    %ebp
4003098e:	c3                   	ret    

4003098f <_timer_int_handler>:

	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick * _sys_idle_elapsed_ticks;
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
4003098f:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
{
40030994:	55                   	push   %ebp
	accumulated_cycle_count += cycles_per_tick;
40030995:	01 05 0c 68 00 a8    	add    %eax,0xa800680c

	_sys_clock_tick_announce();
4003099b:	a1 e8 66 00 a8       	mov    0xa80066e8,%eax
{
400309a0:	89 e5                	mov    %esp,%ebp
#endif /*CONFIG_TICKLESS_IDLE*/

}
400309a2:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
400309a3:	e9 f8 38 00 00       	jmp    400342a0 <_nano_sys_clock_tick_announce>

400309a8 <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
400309a8:	a1 ec 66 00 a8       	mov    0xa80066ec,%eax
{
400309ad:	55                   	push   %ebp
	cycles_per_tick = sys_clock_hw_cycles_per_tick;
400309ae:	a3 d8 78 00 a8       	mov    %eax,0xa80078d8
{
400309b3:	89 e5                	mov    %esp,%ebp
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
400309b5:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
400309ba:	83 e0 f0             	and    $0xfffffff0,%eax
400309bd:	83 c8 0b             	or     $0xb,%eax
400309c0:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
400309c5:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
400309ca:	48                   	dec    %eax
	*_REG_TIMER_ICR = count;
400309cb:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
400309d0:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
400309d5:	0d 00 00 02 00       	or     $0x20000,%eax
400309da:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
400309df:	0f b6 05 c8 74 03 40 	movzbl 0x400374c8,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
400309e6:	31 c9                	xor    %ecx,%ecx
400309e8:	ba 40 00 00 00       	mov    $0x40,%edx
400309ed:	e8 7b 01 00 00       	call   40030b6d <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
400309f2:	b8 40 00 00 00       	mov    $0x40,%eax
400309f7:	e8 93 01 00 00       	call   40030b8f <_arch_irq_enable>

	return 0;
}
400309fc:	31 c0                	xor    %eax,%eax
400309fe:	5d                   	pop    %ebp
400309ff:	c3                   	ret    

40030a00 <_timer_int_handler_irq64_stub>:
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
40030a00:	6a 00                	push   $0x0
40030a02:	68 8f 09 03 40       	push   $0x4003098f
40030a07:	e9 b2 2f 00 00       	jmp    400339be <_interrupt_enter>

40030a0c <qm_spi_master_1_isr_irq3_stub>:
40030a0c:	6a 00                	push   $0x0
40030a0e:	68 95 1e 03 40       	push   $0x40031e95
40030a13:	e9 a6 2f 00 00       	jmp    400339be <_interrupt_enter>

40030a18 <qm_spi_master_0_isr_irq2_stub>:
40030a18:	6a 00                	push   $0x0
40030a1a:	68 8a 1e 03 40       	push   $0x40031e8a
40030a1f:	e9 9a 2f 00 00       	jmp    400339be <_interrupt_enter>

40030a24 <qm_aon_gpio_0_isr_irq31_stub>:
40030a24:	6a 00                	push   $0x0
40030a26:	68 01 18 03 40       	push   $0x40031801
40030a2b:	e9 8e 2f 00 00       	jmp    400339be <_interrupt_enter>

40030a30 <qm_gpio_0_isr_irq8_stub>:
40030a30:	6a 00                	push   $0x0
40030a32:	68 f6 17 03 40       	push   $0x400317f6
40030a37:	e9 82 2f 00 00       	jmp    400339be <_interrupt_enter>

40030a3c <_timer_cycle_get_32>:
	 * in the Initial Count Register (ICR).
	 */

#if !defined(CONFIG_TICKLESS_IDLE)
	/* The value in the ICR always matches cycles_per_tick. */
	val = accumulated_cycle_count - current_count_register_get() +
40030a3c:	a1 d8 78 00 a8       	mov    0xa80078d8,%eax
{
40030a41:	55                   	push   %ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030a42:	03 05 0c 68 00 a8    	add    0xa800680c,%eax
	return *_REG_TIMER_CCR;
40030a48:	8b 15 90 03 e0 fe    	mov    0xfee00390,%edx
{
40030a4e:	89 e5                	mov    %esp,%ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030a50:	29 d0                	sub    %edx,%eax
	val = accumulated_cycle_count - current_count_register_get() +
	      initial_count_register_get();
#endif

	return val;
}
40030a52:	5d                   	pop    %ebp
40030a53:	c3                   	ret    

40030a54 <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
40030a54:	55                   	push   %ebp
40030a55:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
40030a57:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
40030a5c:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
40030a5f:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40030a64:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
40030a69:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
40030a70:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
40030a73:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
40030a76:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
40030a7d:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
40030a80:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
40030a87:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
40030a8a:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
40030a91:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
40030a94:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
40030a9a:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030aa0:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
40030aa3:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
40030aa9:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
40030aaf:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030ab5:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40030ab8:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
40030abb:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030ac1:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
40030ac4:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
40030acb:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
40030ace:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
40030ad5:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030ad8:	7e 19                	jle    40030af3 <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
40030ada:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
40030ae1:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
40030ae4:	83 f8 04             	cmp    $0x4,%eax
40030ae7:	74 0a                	je     40030af3 <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
40030ae9:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
40030af0:	00 01 00 
		| (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF);
#endif

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
40030af3:	e8 0c 2e 00 00       	call   40033904 <_lakemont_eoi>
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
#endif

	return 0;
}
40030af8:	31 c0                	xor    %eax,%eax
40030afa:	5d                   	pop    %ebp
40030afb:	c3                   	ret    

40030afc <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
40030afc:	55                   	push   %ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030afd:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030b02:	c1 e0 04             	shl    $0x4,%eax
{
40030b05:	89 e5                	mov    %esp,%ebp
40030b07:	53                   	push   %ebx
	__asm__ volatile (
40030b08:	9c                   	pushf  
40030b09:	fa                   	cli    
40030b0a:	5b                   	pop    %ebx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
40030b0b:	8b 08                	mov    (%eax),%ecx
40030b0d:	30 c9                	xor    %cl,%cl
40030b0f:	09 ca                	or     %ecx,%edx
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
40030b11:	0f ba e3 09          	bt     $0x9,%ebx
40030b15:	89 10                	mov    %edx,(%eax)
40030b17:	73 01                	jae    40030b1a <_loapic_int_vec_set+0x1e>
	__asm__ volatile (
40030b19:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030b1a:	5b                   	pop    %ebx
40030b1b:	5d                   	pop    %ebp
40030b1c:	c3                   	ret    

40030b1d <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
40030b1d:	55                   	push   %ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030b1e:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030b23:	c1 e0 04             	shl    $0x4,%eax
{
40030b26:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030b28:	9c                   	pushf  
40030b29:	fa                   	cli    
40030b2a:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
40030b2b:	8b 10                	mov    (%eax),%edx
40030b2d:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40030b33:	0f ba e1 09          	bt     $0x9,%ecx
40030b37:	89 10                	mov    %edx,(%eax)
40030b39:	73 01                	jae    40030b3c <_loapic_irq_enable+0x1f>
	__asm__ volatile (
40030b3b:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030b3c:	5d                   	pop    %ebp
40030b3d:	c3                   	ret    

40030b3e <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
40030b3e:	55                   	push   %ebp
40030b3f:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
40030b44:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
40030b46:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
40030b4b:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
40030b4d:	85 d2                	test   %edx,%edx
40030b4f:	74 11                	je     40030b62 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
40030b51:	0f bd d2             	bsr    %edx,%edx
40030b54:	75 05                	jne    40030b5b <__irq_controller_isr_vector_get+0x1d>
40030b56:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
40030b5b:	c1 e0 05             	shl    $0x5,%eax
40030b5e:	01 d0                	add    %edx,%eax
40030b60:	eb 09                	jmp    40030b6b <__irq_controller_isr_vector_get+0x2d>
40030b62:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
40030b65:	48                   	dec    %eax
40030b66:	75 e3                	jne    40030b4b <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
40030b68:	83 c8 ff             	or     $0xffffffff,%eax
}
40030b6b:	5d                   	pop    %ebp
40030b6c:	c3                   	ret    

40030b6d <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
40030b6d:	55                   	push   %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
40030b6e:	83 fa 3f             	cmp    $0x3f,%edx
{
40030b71:	89 e5                	mov    %esp,%ebp
40030b73:	53                   	push   %ebx
40030b74:	89 c3                	mov    %eax,%ebx
40030b76:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
40030b78:	77 09                	ja     40030b83 <__irq_controller_irq_config+0x16>
		_ioapic_irq_set(irq, vector, flags);
40030b7a:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
40030b7c:	5b                   	pop    %ebx
40030b7d:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
40030b7e:	e9 a9 00 00 00       	jmp    40030c2c <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030b83:	89 da                	mov    %ebx,%edx
40030b85:	83 e8 40             	sub    $0x40,%eax
}
40030b88:	5b                   	pop    %ebx
40030b89:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030b8a:	e9 6d ff ff ff       	jmp    40030afc <_loapic_int_vec_set>

40030b8f <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
40030b8f:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030b90:	83 f8 3f             	cmp    $0x3f,%eax
{
40030b93:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030b95:	77 06                	ja     40030b9d <_arch_irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
40030b97:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
40030b98:	e9 7f 00 00 00       	jmp    40030c1c <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
40030b9d:	83 e8 40             	sub    $0x40,%eax
}
40030ba0:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
40030ba1:	e9 77 ff ff ff       	jmp    40030b1d <_loapic_irq_enable>

40030ba6 <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
40030ba6:	55                   	push   %ebp
40030ba7:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030ba9:	9c                   	pushf  
40030baa:	fa                   	cli    
40030bab:	59                   	pop    %ecx
40030bac:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
40030bb0:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
40030bb5:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
40030bbb:	73 01                	jae    40030bbe <__IoApicSet+0x18>
	__asm__ volatile (
40030bbd:	fb                   	sti    

	irq_unlock(key);
}
40030bbe:	5d                   	pop    %ebp
40030bbf:	c3                   	ret    

40030bc0 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
40030bc0:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030bc1:	01 c0                	add    %eax,%eax
{
40030bc3:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030bc5:	83 c0 10             	add    $0x10,%eax
{
40030bc8:	56                   	push   %esi
40030bc9:	53                   	push   %ebx
	__asm__ volatile (
40030bca:	9c                   	pushf  
40030bcb:	fa                   	cli    
40030bcc:	5e                   	pop    %esi
40030bcd:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
40030bd1:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
40030bd6:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
40030bdc:	73 01                	jae    40030bdf <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
40030bde:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
40030bdf:	31 da                	xor    %ebx,%edx
40030be1:	21 ca                	and    %ecx,%edx
40030be3:	31 da                	xor    %ebx,%edx
}
40030be5:	5b                   	pop    %ebx
40030be6:	5e                   	pop    %esi
40030be7:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
40030be8:	e9 b9 ff ff ff       	jmp    40030ba6 <__IoApicSet>

40030bed <_ioapic_init>:
{
40030bed:	55                   	push   %ebp
40030bee:	89 e5                	mov    %esp,%ebp
40030bf0:	53                   	push   %ebx
40030bf1:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
40030bf6:	31 d2                	xor    %edx,%edx
40030bf8:	89 d8                	mov    %ebx,%eax
40030bfa:	e8 a7 ff ff ff       	call   40030ba6 <__IoApicSet>
	__IoApicSet(offset, lower32);
40030bff:	8d 43 ff             	lea    -0x1(%ebx),%eax
40030c02:	ba 00 00 01 00       	mov    $0x10000,%edx
40030c07:	83 c3 02             	add    $0x2,%ebx
40030c0a:	e8 97 ff ff ff       	call   40030ba6 <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
40030c0f:	81 fb 91 00 00 00    	cmp    $0x91,%ebx
40030c15:	75 df                	jne    40030bf6 <_ioapic_init+0x9>
}
40030c17:	31 c0                	xor    %eax,%eax
40030c19:	5b                   	pop    %ebx
40030c1a:	5d                   	pop    %ebp
40030c1b:	c3                   	ret    

40030c1c <_ioapic_irq_enable>:
{
40030c1c:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030c1d:	b9 00 00 01 00       	mov    $0x10000,%ecx
40030c22:	31 d2                	xor    %edx,%edx
{
40030c24:	89 e5                	mov    %esp,%ebp
}
40030c26:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030c27:	e9 94 ff ff ff       	jmp    40030bc0 <_IoApicRedUpdateLo>

40030c2c <_ioapic_irq_set>:
{
40030c2c:	55                   	push   %ebp
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030c2d:	81 c9 00 00 01 00    	or     $0x10000,%ecx
{
40030c33:	89 e5                	mov    %esp,%ebp
40030c35:	56                   	push   %esi
40030c36:	53                   	push   %ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030c37:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
40030c3a:	0f b6 f2             	movzbl %dl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030c3d:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
40030c40:	31 d2                	xor    %edx,%edx
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030c42:	09 ce                	or     %ecx,%esi
	__IoApicSet(offset, upper32);
40030c44:	e8 5d ff ff ff       	call   40030ba6 <__IoApicSet>
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030c49:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
40030c4c:	89 f2                	mov    %esi,%edx
}
40030c4e:	5b                   	pop    %ebx
40030c4f:	5e                   	pop    %esi
40030c50:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
40030c51:	e9 50 ff ff ff       	jmp    40030ba6 <__IoApicSet>

40030c56 <spi_qmsi_configure>:
	gpio_pin_write(gpio, config->cs_pin, !active);
}

static int spi_qmsi_configure(struct device *dev,
				struct spi_config *config)
{
40030c56:	55                   	push   %ebp
40030c57:	89 e5                	mov    %esp,%ebp
40030c59:	56                   	push   %esi
40030c5a:	53                   	push   %ebx
40030c5b:	51                   	push   %ecx
	struct spi_qmsi_runtime *context = dev->driver_data;
40030c5c:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_spi_config_t *cfg = &context->cfg;

	cfg->frame_size = SPI_WORD_SIZE_GET(config->config) - 1;
40030c5f:	8b 02                	mov    (%edx),%eax
40030c61:	89 c1                	mov    %eax,%ecx
40030c63:	c1 e9 04             	shr    $0x4,%ecx
40030c66:	0f b6 c9             	movzbl %cl,%ecx
40030c69:	49                   	dec    %ecx
40030c6a:	89 4b 14             	mov    %ecx,0x14(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030c6d:	89 c1                	mov    %eax,%ecx
40030c6f:	83 e1 07             	and    $0x7,%ecx
40030c72:	49                   	dec    %ecx
40030c73:	88 4d f7             	mov    %cl,-0x9(%ebp)
40030c76:	31 c9                	xor    %ecx,%ecx
40030c78:	80 7d f7 02          	cmpb   $0x2,-0x9(%ebp)
40030c7c:	77 0a                	ja     40030c88 <spi_qmsi_configure+0x32>
40030c7e:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
40030c82:	8a 89 70 5d 03 40    	mov    0x40035d70(%ecx),%cl
	/* As loopback is implemented inside the controller,
	 * the bus mode doesn't matter.
	 */
	context->loopback = SPI_MODE(config->config) & SPI_MODE_LOOP;
40030c88:	c1 e8 02             	shr    $0x2,%eax
40030c8b:	83 e0 01             	and    $0x1,%eax
40030c8e:	88 43 2c             	mov    %al,0x2c(%ebx)
	cfg->clk_divider = config->max_sys_freq;
40030c91:	8b 42 04             	mov    0x4(%edx),%eax
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030c94:	0f b6 f1             	movzbl %cl,%esi
	cfg->clk_divider = config->max_sys_freq;
40030c97:	66 89 43 24          	mov    %ax,0x24(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030c9b:	89 73 1c             	mov    %esi,0x1c(%ebx)

	/* Will set the configuration before the transfer starts */
	return 0;
}
40030c9e:	5a                   	pop    %edx
40030c9f:	31 c0                	xor    %eax,%eax
40030ca1:	5b                   	pop    %ebx
40030ca2:	5e                   	pop    %esi
40030ca3:	5d                   	pop    %ebp
40030ca4:	c3                   	ret    

40030ca5 <spi_qmsi_slave_select>:
	context->rc = error;
	k_sem_give(&context->device_sync_sem);
}

static int spi_qmsi_slave_select(struct device *dev, uint32_t slave)
{
40030ca5:	55                   	push   %ebp
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
	qm_spi_t spi = spi_config->spi;

	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030ca6:	8d 4a ff             	lea    -0x1(%edx),%ecx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030ca9:	8b 00                	mov    (%eax),%eax
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030cab:	ba 01 00 00 00       	mov    $0x1,%edx
40030cb0:	d3 e2                	shl    %cl,%edx
	qm_spi_t spi = spi_config->spi;
40030cb2:	8b 40 08             	mov    0x8(%eax),%eax
{
40030cb5:	89 e5                	mov    %esp,%ebp
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030cb7:	8b 00                	mov    (%eax),%eax
40030cb9:	e8 4e 10 00 00       	call   40031d0c <qm_spi_slave_select>
40030cbe:	85 c0                	test   %eax,%eax
40030cc0:	74 05                	je     40030cc7 <spi_qmsi_slave_select+0x22>
40030cc2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030cc7:	5d                   	pop    %ebp
40030cc8:	c3                   	ret    

40030cc9 <spi_qmsi_init>:
#else
#define spi_master_set_power_state(...)
#endif

static int spi_qmsi_init(struct device *dev)
{
40030cc9:	55                   	push   %ebp
40030cca:	89 e5                	mov    %esp,%ebp
40030ccc:	57                   	push   %edi
40030ccd:	56                   	push   %esi
40030cce:	53                   	push   %ebx
40030ccf:	83 ec 08             	sub    $0x8,%esp
40030cd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030cd5:	8b 00                	mov    (%eax),%eax
40030cd7:	8b 70 08             	mov    0x8(%eax),%esi
	struct spi_qmsi_runtime *context = dev->driver_data;
40030cda:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030cdd:	8b 40 08             	mov    0x8(%eax),%eax
40030ce0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	switch (spi_config->spi) {
40030ce3:	8b 06                	mov    (%esi),%eax
40030ce5:	85 c0                	test   %eax,%eax
40030ce7:	74 40                	je     40030d29 <spi_qmsi_init+0x60>
40030ce9:	48                   	dec    %eax
40030cea:	0f 85 ea 00 00 00    	jne    40030dda <spi_qmsi_init+0x111>
40030cf0:	0f b6 05 8b 74 03 40 	movzbl 0x4003748b,%eax
40030cf7:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030cfc:	ba 03 00 00 00       	mov    $0x3,%edx
40030d01:	e8 67 fe ff ff       	call   40030b6d <__irq_controller_irq_config>
#ifdef CONFIG_SPI_1
	case QM_SPI_MST_1:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT),
			    CONFIG_SPI_1_IRQ_PRI, qm_spi_master_1_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT));
40030d06:	b8 03 00 00 00       	mov    $0x3,%eax
40030d0b:	e8 7f fe ff ff       	call   40030b8f <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M1_REGISTER);
40030d10:	b8 02 80 00 00       	mov    $0x8002,%eax
40030d15:	e8 90 0a 00 00       	call   400317aa <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030d1a:	a1 58 04 80 b0       	mov    0xb0800458,%eax
40030d1f:	83 e0 fe             	and    $0xfffffffe,%eax
40030d22:	a3 58 04 80 b0       	mov    %eax,0xb0800458
				QM_INTERRUPT_ROUTER->spi_master_1_int_mask);
		break;
40030d27:	eb 37                	jmp    40030d60 <spi_qmsi_init+0x97>
40030d29:	0f b6 05 8a 74 03 40 	movzbl 0x4003748a,%eax
40030d30:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030d35:	ba 02 00 00 00       	mov    $0x2,%edx
40030d3a:	e8 2e fe ff ff       	call   40030b6d <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_0_INT));
40030d3f:	b8 02 00 00 00       	mov    $0x2,%eax
40030d44:	e8 46 fe ff ff       	call   40030b8f <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M0_REGISTER);
40030d49:	b8 02 40 00 00       	mov    $0x4002,%eax
40030d4e:	e8 57 0a 00 00       	call   400317aa <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030d53:	a1 54 04 80 b0       	mov    0xb0800454,%eax
40030d58:	83 e0 fe             	and    $0xfffffffe,%eax
40030d5b:	a3 54 04 80 b0       	mov    %eax,0xb0800454
	if (!config->cs_port)
40030d60:	8b 46 04             	mov    0x4(%esi),%eax
40030d63:	85 c0                	test   %eax,%eax
40030d65:	75 04                	jne    40030d6b <spi_qmsi_init+0xa2>
		return NULL;
40030d67:	31 db                	xor    %ebx,%ebx
40030d69:	eb 35                	jmp    40030da0 <spi_qmsi_init+0xd7>
	gpio = device_get_binding(config->cs_port);
40030d6b:	e8 8b 2f 00 00       	call   40033cfb <device_get_binding>
40030d70:	89 c3                	mov    %eax,%ebx
	if (!gpio)
40030d72:	85 c0                	test   %eax,%eax
40030d74:	74 f1                	je     40030d67 <spi_qmsi_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40030d76:	8b 40 04             	mov    0x4(%eax),%eax
40030d79:	31 d2                	xor    %edx,%edx
40030d7b:	0f b6 4e 08          	movzbl 0x8(%esi),%ecx
40030d7f:	89 c7                	mov    %eax,%edi
40030d81:	89 d8                	mov    %ebx,%eax
40030d83:	6a 01                	push   $0x1
40030d85:	ff 17                	call   *(%edi)
40030d87:	59                   	pop    %ecx
	if (gpio_pin_configure(gpio, config->cs_pin, GPIO_DIR_OUT) != 0) {
40030d88:	85 c0                	test   %eax,%eax
40030d8a:	75 db                	jne    40030d67 <spi_qmsi_init+0x9e>
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40030d8c:	8b 4e 08             	mov    0x8(%esi),%ecx
40030d8f:	8b 73 04             	mov    0x4(%ebx),%esi
40030d92:	31 d2                	xor    %edx,%edx
40030d94:	89 d8                	mov    %ebx,%eax
40030d96:	6a 01                	push   $0x1
40030d98:	ff 56 04             	call   *0x4(%esi)
40030d9b:	5a                   	pop    %edx
	if (gpio_pin_write(gpio, config->cs_pin, 1) != 0) {
40030d9c:	85 c0                	test   %eax,%eax
40030d9e:	75 c7                	jne    40030d67 <spi_qmsi_init+0x9e>

	default:
		return -EIO;
	}

	context->gpio_cs = gpio_cs_init(spi_config);
40030da0:	8b 45 f0             	mov    -0x10(%ebp),%eax

	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40030da3:	83 c9 ff             	or     $0xffffffff,%ecx
40030da6:	83 c0 04             	add    $0x4,%eax
40030da9:	31 d2                	xor    %edx,%edx
	context->gpio_cs = gpio_cs_init(spi_config);
40030dab:	89 58 fc             	mov    %ebx,-0x4(%eax)
	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40030dae:	e8 2f 34 00 00       	call   400341e2 <k_sem_init>
	k_sem_init(&context->sem, 0, UINT_MAX);
40030db3:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030db6:	8d 58 30             	lea    0x30(%eax),%ebx
40030db9:	83 c9 ff             	or     $0xffffffff,%ecx
40030dbc:	31 d2                	xor    %edx,%edx
40030dbe:	89 d8                	mov    %ebx,%eax
40030dc0:	e8 1d 34 00 00       	call   400341e2 <k_sem_init>
	k_sem_give(&context->sem);
40030dc5:	89 d8                	mov    %ebx,%eax
40030dc7:	e8 26 34 00 00       	call   400341f2 <k_sem_give>

	spi_master_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	dev->driver_api = &spi_qmsi_api;
40030dcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030dcf:	c7 40 04 8c 5d 03 40 	movl   $0x40035d8c,0x4(%eax)
	return 0;
40030dd6:	31 c0                	xor    %eax,%eax
40030dd8:	eb 05                	jmp    40030ddf <spi_qmsi_init+0x116>
		return -EIO;
40030dda:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030ddf:	8d 65 f4             	lea    -0xc(%ebp),%esp
40030de2:	5b                   	pop    %ebx
40030de3:	5e                   	pop    %esi
40030de4:	5f                   	pop    %edi
40030de5:	5d                   	pop    %ebp
40030de6:	c3                   	ret    

40030de7 <spi_control_cs>:
{
40030de7:	55                   	push   %ebp
40030de8:	89 e5                	mov    %esp,%ebp
40030dea:	56                   	push   %esi
40030deb:	53                   	push   %ebx
	struct device *gpio = context->gpio_cs;
40030dec:	8b 48 08             	mov    0x8(%eax),%ecx
40030def:	8b 31                	mov    (%ecx),%esi
	if (!gpio)
40030df1:	85 f6                	test   %esi,%esi
40030df3:	74 1a                	je     40030e0f <spi_control_cs+0x28>
	const struct spi_qmsi_config *config = dev->config->config_info;
40030df5:	8b 00                	mov    (%eax),%eax
	gpio_pin_write(gpio, config->cs_pin, !active);
40030df7:	83 f2 01             	xor    $0x1,%edx
40030dfa:	8b 5e 04             	mov    0x4(%esi),%ebx
40030dfd:	8b 40 08             	mov    0x8(%eax),%eax
40030e00:	0f b6 d2             	movzbl %dl,%edx
40030e03:	8b 48 08             	mov    0x8(%eax),%ecx
40030e06:	52                   	push   %edx
40030e07:	89 f0                	mov    %esi,%eax
40030e09:	31 d2                	xor    %edx,%edx
40030e0b:	ff 53 04             	call   *0x4(%ebx)
40030e0e:	58                   	pop    %eax
}
40030e0f:	8d 65 f8             	lea    -0x8(%ebp),%esp
40030e12:	5b                   	pop    %ebx
40030e13:	5e                   	pop    %esi
40030e14:	5d                   	pop    %ebp
40030e15:	c3                   	ret    

40030e16 <transfer_complete>:
{
40030e16:	55                   	push   %ebp
40030e17:	89 e5                	mov    %esp,%ebp
40030e19:	57                   	push   %edi
40030e1a:	56                   	push   %esi
40030e1b:	53                   	push   %ebx
	const struct spi_qmsi_config *spi_config =
40030e1c:	8b 00                	mov    (%eax),%eax
	qm_spi_t spi = spi_config->spi;
40030e1e:	8b 40 08             	mov    0x8(%eax),%eax
	struct device *dev = pending->dev;
40030e21:	6b 38 1c             	imul   $0x1c,(%eax),%edi
40030e24:	8b 87 a0 68 00 a8    	mov    -0x57ff9760(%edi),%eax
	if (!dev)
40030e2a:	85 c0                	test   %eax,%eax
40030e2c:	74 25                	je     40030e53 <transfer_complete+0x3d>
40030e2e:	89 d6                	mov    %edx,%esi
	spi_control_cs(dev, false);
40030e30:	31 d2                	xor    %edx,%edx
	context = dev->driver_data;
40030e32:	8b 58 08             	mov    0x8(%eax),%ebx
	spi_control_cs(dev, false);
40030e35:	e8 ad ff ff ff       	call   40030de7 <spi_control_cs>
	pending->dev = NULL;
40030e3a:	c7 87 a0 68 00 a8 00 	movl   $0x0,-0x57ff9760(%edi)
40030e41:	00 00 00 
	k_sem_give(&context->device_sync_sem);
40030e44:	8d 43 04             	lea    0x4(%ebx),%eax
	context->rc = error;
40030e47:	89 73 28             	mov    %esi,0x28(%ebx)
}
40030e4a:	5b                   	pop    %ebx
40030e4b:	5e                   	pop    %esi
40030e4c:	5f                   	pop    %edi
40030e4d:	5d                   	pop    %ebp
	k_sem_give(&context->device_sync_sem);
40030e4e:	e9 9f 33 00 00       	jmp    400341f2 <k_sem_give>
}
40030e53:	5b                   	pop    %ebx
40030e54:	5e                   	pop    %esi
40030e55:	5f                   	pop    %edi
40030e56:	5d                   	pop    %ebp
40030e57:	c3                   	ret    

40030e58 <spi_qmsi_transceive>:
{
40030e58:	55                   	push   %ebp
40030e59:	89 e5                	mov    %esp,%ebp
40030e5b:	57                   	push   %edi
40030e5c:	56                   	push   %esi
40030e5d:	53                   	push   %ebx
40030e5e:	83 ec 14             	sub    $0x14,%esp
40030e61:	89 c3                	mov    %eax,%ebx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030e63:	8b 00                	mov    (%eax),%eax
{
40030e65:	89 55 e0             	mov    %edx,-0x20(%ebp)
	struct spi_qmsi_runtime *context = dev->driver_data;
40030e68:	8b 73 08             	mov    0x8(%ebx),%esi
{
40030e6b:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	qm_spi_t spi = spi_config->spi;
40030e6e:	8b 40 08             	mov    0x8(%eax),%eax
40030e71:	8b 00                	mov    (%eax),%eax
40030e73:	89 45 f0             	mov    %eax,-0x10(%ebp)
	qm_spi_config_t *cfg = &context->cfg;
40030e76:	8d 46 14             	lea    0x14(%esi),%eax
40030e79:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8_t dfs = frame_size_to_dfs(cfg->frame_size);
40030e7c:	8b 46 14             	mov    0x14(%esi),%eax
		return 1;
40030e7f:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_8_BIT)
40030e83:	83 f8 07             	cmp    $0x7,%eax
40030e86:	76 15                	jbe    40030e9d <spi_qmsi_transceive+0x45>
		return 2;
40030e88:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_16_BIT)
40030e8c:	83 f8 0f             	cmp    $0xf,%eax
40030e8f:	76 0c                	jbe    40030e9d <spi_qmsi_transceive+0x45>
	return 0;
40030e91:	83 f8 20             	cmp    $0x20,%eax
40030e94:	0f 92 c0             	setb   %al
40030e97:	c1 e0 02             	shl    $0x2,%eax
40030e9a:	88 45 ec             	mov    %al,-0x14(%ebp)
	k_sem_take(&context->sem, K_FOREVER);
40030e9d:	8d 4e 30             	lea    0x30(%esi),%ecx
40030ea0:	83 ca ff             	or     $0xffffffff,%edx
40030ea3:	89 c8                	mov    %ecx,%eax
40030ea5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40030ea8:	e8 ba 33 00 00       	call   40034267 <k_sem_take>
	if (pending_transfers[spi].dev) {
40030ead:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030eb0:	6b 55 f0 1c          	imul   $0x1c,-0x10(%ebp),%edx
40030eb4:	8d ba a0 68 00 a8    	lea    -0x57ff9760(%edx),%edi
40030eba:	83 ba a0 68 00 a8 00 	cmpl   $0x0,-0x57ff9760(%edx)
40030ec1:	74 11                	je     40030ed4 <spi_qmsi_transceive+0x7c>
		k_sem_give(&context->sem);
40030ec3:	89 c8                	mov    %ecx,%eax
40030ec5:	e8 28 33 00 00       	call   400341f2 <k_sem_give>
		return -EBUSY;
40030eca:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
40030ecf:	e9 ed 00 00 00       	jmp    40030fc1 <spi_qmsi_transceive+0x169>
	k_sem_give(&context->sem);
40030ed4:	89 c8                	mov    %ecx,%eax
	pending_transfers[spi].dev = dev;
40030ed6:	89 9a a0 68 00 a8    	mov    %ebx,-0x57ff9760(%edx)
40030edc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_sem_give(&context->sem);
40030edf:	e8 0e 33 00 00       	call   400341f2 <k_sem_give>
	device_busy_set(dev);
40030ee4:	89 d8                	mov    %ebx,%eax
40030ee6:	e8 48 2e 00 00       	call   40033d33 <device_busy_set>
	xfer = &pending_transfers[spi].xfer;
40030eeb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40030eee:	8d 82 a4 68 00 a8    	lea    -0x57ff975c(%edx),%eax
	xfer->rx_len = rx_buf_len / dfs;
40030ef4:	31 d2                	xor    %edx,%edx
40030ef6:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
	xfer = &pending_transfers[spi].xfer;
40030efa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	xfer->rx = rx_buf;
40030efd:	8b 45 08             	mov    0x8(%ebp),%eax
40030f00:	89 47 08             	mov    %eax,0x8(%edi)
	xfer->rx_len = rx_buf_len / dfs;
40030f03:	8b 45 0c             	mov    0xc(%ebp),%eax
40030f06:	f7 f1                	div    %ecx
40030f08:	66 89 47 0e          	mov    %ax,0xe(%edi)
	xfer->tx = (uint8_t *)tx_buf;
40030f0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
	xfer->tx_len = tx_buf_len / dfs;
40030f0f:	31 d2                	xor    %edx,%edx
	xfer->tx = (uint8_t *)tx_buf;
40030f11:	89 47 04             	mov    %eax,0x4(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030f14:	8b 45 e8             	mov    -0x18(%ebp),%eax
	xfer->callback_data = dev;
40030f17:	89 5f 18             	mov    %ebx,0x18(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030f1a:	f7 f1                	div    %ecx
40030f1c:	66 89 47 0c          	mov    %ax,0xc(%edi)
	xfer->callback = transfer_complete;
40030f20:	c7 47 14 16 0e 03 40 	movl   $0x40030e16,0x14(%edi)
	if (tx_buf_len == 0)
40030f27:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030f2b:	75 09                	jne    40030f36 <spi_qmsi_transceive+0xde>
		cfg->transfer_mode = QM_SPI_TMOD_RX;
40030f2d:	c7 46 18 02 00 00 00 	movl   $0x2,0x18(%esi)
40030f34:	eb 0c                	jmp    40030f42 <spi_qmsi_transceive+0xea>
		cfg->transfer_mode = QM_SPI_TMOD_TX;
40030f36:	31 c0                	xor    %eax,%eax
40030f38:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40030f3c:	0f 94 c0             	sete   %al
40030f3f:	89 46 18             	mov    %eax,0x18(%esi)
	if (context->loopback)
40030f42:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
40030f46:	74 11                	je     40030f59 <spi_qmsi_transceive+0x101>
		QM_SPI[spi]->ctrlr0 |= BIT(11);
40030f48:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030f4b:	8b 14 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edx
40030f52:	8b 02                	mov    (%edx),%eax
40030f54:	80 cc 08             	or     $0x8,%ah
40030f57:	89 02                	mov    %eax,(%edx)
	rc = qm_spi_set_config(spi, cfg);
40030f59:	8d 56 14             	lea    0x14(%esi),%edx
40030f5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030f5f:	e8 3b 0d 00 00       	call   40031c9f <qm_spi_set_config>
	if (rc != 0) {
40030f64:	85 c0                	test   %eax,%eax
40030f66:	74 0e                	je     40030f76 <spi_qmsi_transceive+0x11e>
		device_busy_clear(dev);
40030f68:	89 d8                	mov    %ebx,%eax
40030f6a:	e8 c9 2d 00 00       	call   40033d38 <device_busy_clear>
		return -EINVAL;
40030f6f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
40030f74:	eb 4b                	jmp    40030fc1 <spi_qmsi_transceive+0x169>
	spi_control_cs(dev, true);
40030f76:	ba 01 00 00 00       	mov    $0x1,%edx
40030f7b:	89 d8                	mov    %ebx,%eax
40030f7d:	e8 65 fe ff ff       	call   40030de7 <spi_control_cs>
	rc = qm_spi_irq_transfer(spi, xfer);
40030f82:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40030f85:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030f88:	e8 01 0e 00 00       	call   40031d8e <qm_spi_irq_transfer>
	if (rc != 0) {
40030f8d:	85 c0                	test   %eax,%eax
40030f8f:	74 12                	je     40030fa3 <spi_qmsi_transceive+0x14b>
		spi_control_cs(dev, false);
40030f91:	89 d8                	mov    %ebx,%eax
40030f93:	31 d2                	xor    %edx,%edx
40030f95:	e8 4d fe ff ff       	call   40030de7 <spi_control_cs>
		device_busy_clear(dev);
40030f9a:	89 d8                	mov    %ebx,%eax
40030f9c:	e8 97 2d 00 00       	call   40033d38 <device_busy_clear>
40030fa1:	eb 19                	jmp    40030fbc <spi_qmsi_transceive+0x164>
	k_sem_take(&context->device_sync_sem, K_FOREVER);
40030fa3:	83 ca ff             	or     $0xffffffff,%edx
40030fa6:	8d 46 04             	lea    0x4(%esi),%eax
40030fa9:	e8 b9 32 00 00       	call   40034267 <k_sem_take>
	device_busy_clear(dev);
40030fae:	89 d8                	mov    %ebx,%eax
40030fb0:	e8 83 2d 00 00       	call   40033d38 <device_busy_clear>
	return context->rc ? -EIO : 0;
40030fb5:	8b 46 28             	mov    0x28(%esi),%eax
40030fb8:	85 c0                	test   %eax,%eax
40030fba:	74 05                	je     40030fc1 <spi_qmsi_transceive+0x169>
40030fbc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030fc1:	83 c4 14             	add    $0x14,%esp
40030fc4:	5b                   	pop    %ebx
40030fc5:	5e                   	pop    %esi
40030fc6:	5f                   	pop    %edi
40030fc7:	5d                   	pop    %ebp
40030fc8:	c3                   	ret    

40030fc9 <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
40030fc9:	55                   	push   %ebp
40030fca:	89 e5                	mov    %esp,%ebp
40030fcc:	57                   	push   %edi
40030fcd:	56                   	push   %esi
40030fce:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
40030fcf:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
40030fd2:	89 d6                	mov    %edx,%esi
40030fd4:	23 71 08             	and    0x8(%ecx),%esi
40030fd7:	74 1c                	je     40030ff5 <gpio_qmsi_callback+0x2c>
40030fd9:	8b 19                	mov    (%ecx),%ebx
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
40030fdb:	85 db                	test   %ebx,%ebx
40030fdd:	74 16                	je     40030ff5 <gpio_qmsi_callback+0x2c>
40030fdf:	89 c7                	mov    %eax,%edi
		if (cb->pin_mask & pins) {
40030fe1:	85 73 08             	test   %esi,0x8(%ebx)
40030fe4:	74 09                	je     40030fef <gpio_qmsi_callback+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
40030fe6:	89 f1                	mov    %esi,%ecx
40030fe8:	89 da                	mov    %ebx,%edx
40030fea:	89 f8                	mov    %edi,%eax
40030fec:	ff 53 04             	call   *0x4(%ebx)
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
40030fef:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
40030ff1:	85 db                	test   %ebx,%ebx
40030ff3:	75 ec                	jne    40030fe1 <gpio_qmsi_callback+0x18>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
40030ff5:	5b                   	pop    %ebx
40030ff6:	5e                   	pop    %esi
40030ff7:	5f                   	pop    %edi
40030ff8:	5d                   	pop    %ebp
40030ff9:	c3                   	ret    

40030ffa <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
40030ffa:	55                   	push   %ebp
	if (value) {
40030ffb:	84 c9                	test   %cl,%cl
{
40030ffd:	89 e5                	mov    %esp,%ebp
40030fff:	0f b6 d2             	movzbl %dl,%edx
	if (value) {
40031002:	74 05                	je     40031009 <qmsi_write_bit+0xf>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
40031004:	0f ab 10             	bts    %edx,(%eax)
40031007:	eb 03                	jmp    4003100c <qmsi_write_bit+0x12>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
40031009:	0f b3 10             	btr    %edx,(%eax)
		sys_set_bit((uintptr_t) target, bit);
	} else {
		sys_clear_bit((uintptr_t) target, bit);
	}
}
4003100c:	5d                   	pop    %ebp
4003100d:	c3                   	ret    

4003100e <gpio_qmsi_manage_callback>:

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
4003100e:	8b 40 08             	mov    0x8(%eax),%eax
	if (set) {
40031011:	84 c9                	test   %cl,%cl
40031013:	74 11                	je     40031026 <gpio_qmsi_manage_callback+0x18>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
40031015:	8b 08                	mov    (%eax),%ecx
40031017:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
40031019:	89 10                	mov    %edx,(%eax)

	if (!list->tail) {
4003101b:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
4003101f:	75 44                	jne    40031065 <gpio_qmsi_manage_callback+0x57>
		list->tail = list->head;
40031021:	89 50 04             	mov    %edx,0x4(%eax)
40031024:	eb 3f                	jmp    40031065 <gpio_qmsi_manage_callback+0x57>
{
40031026:	55                   	push   %ebp
40031027:	89 e5                	mov    %esp,%ebp
40031029:	53                   	push   %ebx
4003102a:	8b 08                	mov    (%eax),%ecx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
4003102c:	31 db                	xor    %ebx,%ebx
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
4003102e:	85 c9                	test   %ecx,%ecx
40031030:	74 2e                	je     40031060 <gpio_qmsi_manage_callback+0x52>
		if (test == node) {
40031032:	39 ca                	cmp    %ecx,%edx
40031034:	75 24                	jne    4003105a <gpio_qmsi_manage_callback+0x4c>
	if (!prev_node) {
40031036:	85 db                	test   %ebx,%ebx
40031038:	8b 0a                	mov    (%edx),%ecx
4003103a:	75 0c                	jne    40031048 <gpio_qmsi_manage_callback+0x3a>
		list->head = node->next;
4003103c:	89 08                	mov    %ecx,(%eax)
		if (list->tail == node) {
4003103e:	3b 50 04             	cmp    0x4(%eax),%edx
40031041:	75 0f                	jne    40031052 <gpio_qmsi_manage_callback+0x44>
			list->tail = list->head;
40031043:	89 48 04             	mov    %ecx,0x4(%eax)
40031046:	eb 0a                	jmp    40031052 <gpio_qmsi_manage_callback+0x44>
		prev_node->next = node->next;
40031048:	89 0b                	mov    %ecx,(%ebx)
		if (list->tail == node) {
4003104a:	3b 50 04             	cmp    0x4(%eax),%edx
4003104d:	75 03                	jne    40031052 <gpio_qmsi_manage_callback+0x44>
			list->tail = prev_node;
4003104f:	89 58 04             	mov    %ebx,0x4(%eax)
	node->next = NULL;
40031052:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
40031058:	eb 06                	jmp    40031060 <gpio_qmsi_manage_callback+0x52>
	SYS_SLIST_FOR_EACH_NODE(list, test) {
4003105a:	89 cb                	mov    %ecx,%ebx
4003105c:	8b 09                	mov    (%ecx),%ecx
4003105e:	eb ce                	jmp    4003102e <gpio_qmsi_manage_callback+0x20>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
40031060:	31 c0                	xor    %eax,%eax
40031062:	5b                   	pop    %ebx
40031063:	5d                   	pop    %ebp
40031064:	c3                   	ret    
40031065:	31 c0                	xor    %eax,%eax
40031067:	c3                   	ret    

40031068 <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
40031068:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
40031069:	85 d2                	test   %edx,%edx
{
4003106b:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
4003106d:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031070:	75 0c                	jne    4003107e <gpio_qmsi_enable_callback+0x16>
		context->pin_callbacks |= BIT(pin);
40031072:	ba 01 00 00 00       	mov    $0x1,%edx
40031077:	d3 e2                	shl    %cl,%edx
40031079:	09 50 08             	or     %edx,0x8(%eax)
4003107c:	eb 07                	jmp    40031085 <gpio_qmsi_enable_callback+0x1d>
	} else {
		context->pin_callbacks = 0xffffffff;
4003107e:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
40031085:	31 c0                	xor    %eax,%eax
40031087:	5d                   	pop    %ebp
40031088:	c3                   	ret    

40031089 <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
40031089:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
4003108a:	85 d2                	test   %edx,%edx
{
4003108c:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
4003108e:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031091:	75 0c                	jne    4003109f <gpio_qmsi_disable_callback+0x16>
		context->pin_callbacks &= ~BIT(pin);
40031093:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
40031098:	d3 c2                	rol    %cl,%edx
4003109a:	21 50 08             	and    %edx,0x8(%eax)
4003109d:	eb 07                	jmp    400310a6 <gpio_qmsi_disable_callback+0x1d>
	} else {
		context->pin_callbacks = 0;
4003109f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
400310a6:	31 c0                	xor    %eax,%eax
400310a8:	5d                   	pop    %ebp
400310a9:	c3                   	ret    

400310aa <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
400310aa:	55                   	push   %ebp
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
400310ab:	8b 00                	mov    (%eax),%eax
{
400310ad:	89 e5                	mov    %esp,%ebp
	qm_gpio_t gpio = gpio_config->gpio;

	return QM_GPIO[gpio]->gpio_intstatus;
}
400310af:	5d                   	pop    %ebp
	qm_gpio_t gpio = gpio_config->gpio;
400310b0:	8b 40 08             	mov    0x8(%eax),%eax
	return QM_GPIO[gpio]->gpio_intstatus;
400310b3:	8b 00                	mov    (%eax),%eax
400310b5:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
400310bc:	8b 40 40             	mov    0x40(%eax),%eax
}
400310bf:	c3                   	ret    

400310c0 <gpio_qmsi_read>:
{
400310c0:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
400310c1:	85 d2                	test   %edx,%edx
{
400310c3:	89 e5                	mov    %esp,%ebp
400310c5:	53                   	push   %ebx
400310c6:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400310c7:	8b 00                	mov    (%eax),%eax
{
400310c9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
400310cc:	8b 40 08             	mov    0x8(%eax),%eax
400310cf:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
400310d1:	75 12                	jne    400310e5 <gpio_qmsi_read+0x25>
		qm_gpio_read_pin(gpio, pin, &state);
400310d3:	0f b6 d1             	movzbl %cl,%edx
400310d6:	8d 4d f8             	lea    -0x8(%ebp),%ecx
400310d9:	e8 90 07 00 00       	call   4003186e <qm_gpio_read_pin>
		*value = state;
400310de:	8b 45 f8             	mov    -0x8(%ebp),%eax
400310e1:	89 03                	mov    %eax,(%ebx)
400310e3:	eb 07                	jmp    400310ec <gpio_qmsi_read+0x2c>
		qm_gpio_read_port(gpio, (uint32_t *const) value);
400310e5:	89 da                	mov    %ebx,%edx
400310e7:	e8 e2 07 00 00       	call   400318ce <qm_gpio_read_port>
}
400310ec:	5a                   	pop    %edx
400310ed:	31 c0                	xor    %eax,%eax
400310ef:	5b                   	pop    %ebx
400310f0:	5d                   	pop    %ebp
400310f1:	c3                   	ret    

400310f2 <gpio_qmsi_write>:
{
400310f2:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
400310f3:	85 d2                	test   %edx,%edx
{
400310f5:	89 e5                	mov    %esp,%ebp
400310f7:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400310f8:	8b 00                	mov    (%eax),%eax
{
400310fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
400310fd:	8b 40 08             	mov    0x8(%eax),%eax
40031100:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031102:	75 15                	jne    40031119 <gpio_qmsi_write+0x27>
		if (value) {
40031104:	85 db                	test   %ebx,%ebx
40031106:	0f b6 d1             	movzbl %cl,%edx
40031109:	74 07                	je     40031112 <gpio_qmsi_write+0x20>
			qm_gpio_set_pin(gpio, pin);
4003110b:	e8 7c 07 00 00       	call   4003188c <qm_gpio_set_pin>
40031110:	eb 0e                	jmp    40031120 <gpio_qmsi_write+0x2e>
			qm_gpio_clear_pin(gpio, pin);
40031112:	e8 96 07 00 00       	call   400318ad <qm_gpio_clear_pin>
40031117:	eb 07                	jmp    40031120 <gpio_qmsi_write+0x2e>
		qm_gpio_write_port(gpio, value);
40031119:	89 da                	mov    %ebx,%edx
4003111b:	e8 c1 07 00 00       	call   400318e1 <qm_gpio_write_port>
}
40031120:	31 c0                	xor    %eax,%eax
40031122:	5b                   	pop    %ebx
40031123:	5d                   	pop    %ebp
40031124:	c3                   	ret    

40031125 <qmsi_pin_config>:
{
40031125:	55                   	push   %ebp
40031126:	89 e5                	mov    %esp,%ebp
40031128:	57                   	push   %edi
40031129:	56                   	push   %esi
4003112a:	53                   	push   %ebx
4003112b:	83 ec 24             	sub    $0x24,%esp
4003112e:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40031130:	8b 00                	mov    (%eax),%eax
{
40031132:	89 ce                	mov    %ecx,%esi
	qm_gpio_port_config_t cfg = { 0 };
40031134:	8d 7d d4             	lea    -0x2c(%ebp),%edi
40031137:	b9 08 00 00 00       	mov    $0x8,%ecx
	qm_gpio_t gpio = gpio_config->gpio;
4003113c:	8b 40 08             	mov    0x8(%eax),%eax
4003113f:	8b 00                	mov    (%eax),%eax
40031141:	89 45 d0             	mov    %eax,-0x30(%ebp)
	qm_gpio_port_config_t cfg = { 0 };
40031144:	31 c0                	xor    %eax,%eax
40031146:	f3 ab                	rep stos %eax,%es:(%edi)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40031148:	8b 45 d0             	mov    -0x30(%ebp),%eax
4003114b:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40031152:	8b 48 04             	mov    0x4(%eax),%ecx
	cfg.callback_data = port;
40031155:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
40031158:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
4003115b:	8b 48 30             	mov    0x30(%eax),%ecx
4003115e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
40031161:	8b 48 38             	mov    0x38(%eax),%ecx
40031164:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
40031167:	8b 48 3c             	mov    0x3c(%eax),%ecx
4003116a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
4003116d:	8b 48 48             	mov    0x48(%eax),%ecx
40031170:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40031173:	8b 40 68             	mov    0x68(%eax),%eax
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40031176:	0f b6 da             	movzbl %dl,%ebx
40031179:	89 f1                	mov    %esi,%ecx
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
4003117b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
4003117e:	83 e1 01             	and    $0x1,%ecx
40031181:	89 da                	mov    %ebx,%edx
40031183:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	cfg.callback = gpio_qmsi_callback;
40031186:	c7 45 ec c9 0f 03 40 	movl   $0x40030fc9,-0x14(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
4003118d:	e8 68 fe ff ff       	call   40030ffa <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 0);
40031192:	31 c9                	xor    %ecx,%ecx
	if (flags & GPIO_INT) {
40031194:	f7 c6 02 00 00 00    	test   $0x2,%esi
4003119a:	74 41                	je     400311dd <qmsi_pin_config+0xb8>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
4003119c:	89 f1                	mov    %esi,%ecx
4003119e:	89 da                	mov    %ebx,%edx
400311a0:	83 e1 20             	and    $0x20,%ecx
400311a3:	8d 45 dc             	lea    -0x24(%ebp),%eax
400311a6:	e8 4f fe ff ff       	call   40030ffa <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
400311ab:	89 f1                	mov    %esi,%ecx
400311ad:	83 e1 04             	and    $0x4,%ecx
400311b0:	89 da                	mov    %ebx,%edx
400311b2:	8d 45 e0             	lea    -0x20(%ebp),%eax
400311b5:	e8 40 fe ff ff       	call   40030ffa <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_debounce, pin,
400311ba:	89 f1                	mov    %esi,%ecx
400311bc:	83 e1 10             	and    $0x10,%ecx
400311bf:	89 da                	mov    %ebx,%edx
400311c1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		qmsi_write_bit(&cfg.int_bothedge, pin,
400311c4:	83 e6 40             	and    $0x40,%esi
		qmsi_write_bit(&cfg.int_debounce, pin,
400311c7:	e8 2e fe ff ff       	call   40030ffa <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_bothedge, pin,
400311cc:	89 f1                	mov    %esi,%ecx
400311ce:	89 da                	mov    %ebx,%edx
400311d0:	8d 45 e8             	lea    -0x18(%ebp),%eax
400311d3:	e8 22 fe ff ff       	call   40030ffa <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 1);
400311d8:	b9 01 00 00 00       	mov    $0x1,%ecx
		qmsi_write_bit(&cfg.int_en, pin, 0);
400311dd:	89 da                	mov    %ebx,%edx
400311df:	8d 45 d8             	lea    -0x28(%ebp),%eax
400311e2:	e8 13 fe ff ff       	call   40030ffa <qmsi_write_bit>
	qm_gpio_set_config(gpio, &cfg);
400311e7:	8d 55 d4             	lea    -0x2c(%ebp),%edx
400311ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
400311ed:	e8 1d 06 00 00       	call   4003180f <qm_gpio_set_config>
}
400311f2:	83 c4 24             	add    $0x24,%esp
400311f5:	5b                   	pop    %ebx
400311f6:	5e                   	pop    %esi
400311f7:	5f                   	pop    %edi
400311f8:	5d                   	pop    %ebp
400311f9:	c3                   	ret    

400311fa <gpio_qmsi_config>:
{
400311fa:	55                   	push   %ebp
400311fb:	89 e5                	mov    %esp,%ebp
400311fd:	57                   	push   %edi
400311fe:	56                   	push   %esi
400311ff:	89 c6                	mov    %eax,%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40031201:	8b 45 08             	mov    0x8(%ebp),%eax
{
40031204:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
40031205:	83 e0 03             	and    $0x3,%eax
		return -EINVAL;
40031208:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
4003120d:	83 f8 03             	cmp    $0x3,%eax
40031210:	74 34                	je     40031246 <gpio_qmsi_config+0x4c>
40031212:	89 d3                	mov    %edx,%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031214:	85 d2                	test   %edx,%edx
40031216:	75 0e                	jne    40031226 <gpio_qmsi_config+0x2c>
40031218:	89 ca                	mov    %ecx,%edx
		qmsi_pin_config(port, pin, flags);
4003121a:	89 f0                	mov    %esi,%eax
4003121c:	8b 4d 08             	mov    0x8(%ebp),%ecx
4003121f:	e8 01 ff ff ff       	call   40031125 <qmsi_pin_config>
40031224:	eb 20                	jmp    40031246 <gpio_qmsi_config+0x4c>
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40031226:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < num_pins; i++) {
40031228:	31 db                	xor    %ebx,%ebx
	uint8_t num_pins = gpio_config->num_pins;
4003122a:	8b 40 08             	mov    0x8(%eax),%eax
	for (i = 0; i < num_pins; i++) {
4003122d:	0f b6 78 04          	movzbl 0x4(%eax),%edi
40031231:	39 fb                	cmp    %edi,%ebx
40031233:	7d 0f                	jge    40031244 <gpio_qmsi_config+0x4a>
		qmsi_pin_config(port, i, flags);
40031235:	89 da                	mov    %ebx,%edx
40031237:	8b 4d 08             	mov    0x8(%ebp),%ecx
4003123a:	89 f0                	mov    %esi,%eax
	for (i = 0; i < num_pins; i++) {
4003123c:	43                   	inc    %ebx
		qmsi_pin_config(port, i, flags);
4003123d:	e8 e3 fe ff ff       	call   40031125 <qmsi_pin_config>
40031242:	eb ed                	jmp    40031231 <gpio_qmsi_config+0x37>
	return 0;
40031244:	31 db                	xor    %ebx,%ebx
}
40031246:	89 d8                	mov    %ebx,%eax
40031248:	5b                   	pop    %ebx
40031249:	5e                   	pop    %esi
4003124a:	5f                   	pop    %edi
4003124b:	5d                   	pop    %ebp
4003124c:	c3                   	ret    

4003124d <gpio_qmsi_init>:
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
4003124d:	55                   	push   %ebp
4003124e:	89 e5                	mov    %esp,%ebp
40031250:	53                   	push   %ebx
40031251:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40031253:	8b 00                	mov    (%eax),%eax
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
40031255:	8b 40 08             	mov    0x8(%eax),%eax
40031258:	8b 00                	mov    (%eax),%eax
4003125a:	85 c0                	test   %eax,%eax
4003125c:	74 32                	je     40031290 <gpio_qmsi_init+0x43>
4003125e:	48                   	dec    %eax
4003125f:	75 71                	jne    400312d2 <gpio_qmsi_init+0x85>
40031261:	0f b6 05 a7 74 03 40 	movzbl 0x400374a7,%eax
40031268:	b9 00 80 00 00       	mov    $0x8000,%ecx
4003126d:	ba 1f 00 00 00       	mov    $0x1f,%edx
40031272:	e8 f6 f8 ff ff       	call   40030b6d <__irq_controller_irq_config>
#ifdef CONFIG_GPIO_QMSI_1
	case QM_AON_GPIO_0:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_1_IRQ_PRI, qm_aon_gpio_0_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT));
40031277:	b8 1f 00 00 00       	mov    $0x1f,%eax
4003127c:	e8 0e f9 ff ff       	call   40030b8f <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
40031281:	a1 d4 04 80 b0       	mov    0xb08004d4,%eax
40031286:	83 e0 fe             	and    $0xfffffffe,%eax
40031289:	a3 d4 04 80 b0       	mov    %eax,0xb08004d4
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
4003128e:	eb 37                	jmp    400312c7 <gpio_qmsi_init+0x7a>
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
40031290:	b8 82 21 00 00       	mov    $0x2182,%eax
40031295:	e8 10 05 00 00       	call   400317aa <clk_periph_enable>
4003129a:	0f b6 05 90 74 03 40 	movzbl 0x40037490,%eax
400312a1:	b9 00 80 00 00       	mov    $0x8000,%ecx
400312a6:	ba 08 00 00 00       	mov    $0x8,%edx
400312ab:	e8 bd f8 ff ff       	call   40030b6d <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
400312b0:	b8 08 00 00 00       	mov    $0x8,%eax
400312b5:	e8 d5 f8 ff ff       	call   40030b8f <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
400312ba:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
400312bf:	83 e0 fe             	and    $0xfffffffe,%eax
400312c2:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
400312c7:	c7 43 04 98 5d 03 40 	movl   $0x40035d98,0x4(%ebx)
	return 0;
400312ce:	31 c0                	xor    %eax,%eax
400312d0:	eb 05                	jmp    400312d7 <gpio_qmsi_init+0x8a>
		return -EIO;
400312d2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400312d7:	5b                   	pop    %ebx
400312d8:	5d                   	pop    %ebp
400312d9:	c3                   	ret    

400312da <pinmux_get>:
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
400312da:	89 d0                	mov    %edx,%eax
{
400312dc:	55                   	push   %ebp
	uint32_t reg_offset = pin >> 4;
400312dd:	c1 e8 04             	shr    $0x4,%eax
{
400312e0:	89 e5                	mov    %esp,%ebp
400312e2:	53                   	push   %ebx
400312e3:	89 cb                	mov    %ecx,%ebx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400312e5:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
	uint32_t mode_mask = *mux_register & pin_mask;
400312e8:	8b 14 85 30 09 80 b0 	mov    -0x4f7ff6d0(,%eax,4),%edx
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400312ef:	83 e1 1e             	and    $0x1e,%ecx
400312f2:	b8 03 00 00 00       	mov    $0x3,%eax
400312f7:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
400312f9:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
400312fb:	d3 e8                	shr    %cl,%eax
400312fd:	89 03                	mov    %eax,(%ebx)

	*func = mode;

	return 0;
}
400312ff:	31 c0                	xor    %eax,%eax
40031301:	5b                   	pop    %ebx
40031302:	5d                   	pop    %ebp
40031303:	c3                   	ret    

40031304 <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(struct device *port)
{
40031304:	55                   	push   %ebp
	return 0;
}
40031305:	31 c0                	xor    %eax,%eax
{
40031307:	89 e5                	mov    %esp,%ebp
}
40031309:	5d                   	pop    %ebp
4003130a:	c3                   	ret    

4003130b <pinmux_input>:
{
4003130b:	55                   	push   %ebp
4003130c:	89 d0                	mov    %edx,%eax
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
4003130e:	31 d2                	xor    %edx,%edx
{
40031310:	89 e5                	mov    %esp,%ebp
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
40031312:	84 c9                	test   %cl,%cl
40031314:	0f 95 c2             	setne  %dl
40031317:	e8 be 0b 00 00       	call   40031eda <qm_pmux_input_en>
4003131c:	85 c0                	test   %eax,%eax
4003131e:	74 05                	je     40031325 <pinmux_input+0x1a>
40031320:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40031325:	5d                   	pop    %ebp
40031326:	c3                   	ret    

40031327 <pinmux_pullup>:
{
40031327:	55                   	push   %ebp
40031328:	89 d0                	mov    %edx,%eax
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
4003132a:	31 d2                	xor    %edx,%edx
{
4003132c:	89 e5                	mov    %esp,%ebp
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
4003132e:	84 c9                	test   %cl,%cl
40031330:	0f 95 c2             	setne  %dl
40031333:	e8 d2 0b 00 00       	call   40031f0a <qm_pmux_pullup_en>
40031338:	85 c0                	test   %eax,%eax
4003133a:	74 05                	je     40031341 <pinmux_pullup+0x1a>
4003133c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40031341:	5d                   	pop    %ebp
40031342:	c3                   	ret    

40031343 <pinmux_set>:
{
40031343:	55                   	push   %ebp
40031344:	89 d0                	mov    %edx,%eax
40031346:	89 e5                	mov    %esp,%ebp
40031348:	89 ca                	mov    %ecx,%edx
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
4003134a:	e8 54 0b 00 00       	call   40031ea3 <qm_pmux_select>
4003134f:	85 c0                	test   %eax,%eax
40031351:	74 05                	je     40031358 <pinmux_set+0x15>
40031353:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40031358:	5d                   	pop    %ebp
40031359:	c3                   	ret    

4003135a <_stdin_hook_default>:
{
	_stdout_hook = hook;
}

static unsigned char _stdin_hook_default(void)
{
4003135a:	55                   	push   %ebp
	return 0;
}
4003135b:	31 c0                	xor    %eax,%eax
{
4003135d:	89 e5                	mov    %esp,%ebp
}
4003135f:	5d                   	pop    %ebp
40031360:	c3                   	ret    

40031361 <_stdout_hook_default>:
40031361:	55                   	push   %ebp
40031362:	83 c8 ff             	or     $0xffffffff,%eax
40031365:	89 e5                	mov    %esp,%ebp
40031367:	5d                   	pop    %ebp
40031368:	c3                   	ret    

40031369 <__stdout_hook_install>:
{
40031369:	55                   	push   %ebp
	_stdout_hook = hook;
4003136a:	a3 c4 66 00 a8       	mov    %eax,0xa80066c4
{
4003136f:	89 e5                	mov    %esp,%ebp
}
40031371:	5d                   	pop    %ebp
40031372:	c3                   	ret    

40031373 <_read>:
{
	_stdin_hook = hook;
}

int _read(int fd, char *buf, int nbytes)
{
40031373:	55                   	push   %ebp
40031374:	89 e5                	mov    %esp,%ebp
40031376:	57                   	push   %edi
40031377:	89 d7                	mov    %edx,%edi
40031379:	56                   	push   %esi
4003137a:	89 ce                	mov    %ecx,%esi
4003137c:	53                   	push   %ebx
	int i = 0;

	for (i = 0; i < nbytes; i++) {
4003137d:	31 db                	xor    %ebx,%ebx
4003137f:	39 f3                	cmp    %esi,%ebx
40031381:	7d 14                	jge    40031397 <_read+0x24>
		*(buf + i) = _stdin_hook();
40031383:	ff 15 c0 66 00 a8    	call   *0xa80066c0
40031389:	88 04 1f             	mov    %al,(%edi,%ebx,1)
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
4003138c:	3c 0a                	cmp    $0xa,%al
4003138e:	8d 5b 01             	lea    0x1(%ebx),%ebx
40031391:	74 04                	je     40031397 <_read+0x24>
40031393:	3c 0d                	cmp    $0xd,%al
40031395:	75 e8                	jne    4003137f <_read+0xc>
			i++;
			break;
		}
	}
	return i;
}
40031397:	89 d8                	mov    %ebx,%eax
40031399:	5b                   	pop    %ebx
4003139a:	5e                   	pop    %esi
4003139b:	5f                   	pop    %edi
4003139c:	5d                   	pop    %ebp
4003139d:	c3                   	ret    

4003139e <_write>:
FUNC_ALIAS(_read, read, int);

int _write(int fd, char *buf, int nbytes)
{
4003139e:	55                   	push   %ebp
4003139f:	89 e5                	mov    %esp,%ebp
400313a1:	57                   	push   %edi
400313a2:	89 d7                	mov    %edx,%edi
400313a4:	56                   	push   %esi
400313a5:	89 ce                	mov    %ecx,%esi
400313a7:	53                   	push   %ebx
	int i;

	for (i = 0; i < nbytes; i++) {
400313a8:	31 db                	xor    %ebx,%ebx
400313aa:	39 f3                	cmp    %esi,%ebx
400313ac:	7d 1e                	jge    400313cc <_write+0x2e>
		if (*(buf + i) == '\n') {
400313ae:	80 3c 1f 0a          	cmpb   $0xa,(%edi,%ebx,1)
400313b2:	75 0b                	jne    400313bf <_write+0x21>
			_stdout_hook('\r');
400313b4:	b8 0d 00 00 00       	mov    $0xd,%eax
400313b9:	ff 15 c4 66 00 a8    	call   *0xa80066c4
		}
		_stdout_hook(*(buf + i));
400313bf:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
	for (i = 0; i < nbytes; i++) {
400313c3:	43                   	inc    %ebx
		_stdout_hook(*(buf + i));
400313c4:	ff 15 c4 66 00 a8    	call   *0xa80066c4
400313ca:	eb de                	jmp    400313aa <_write+0xc>
	}
	return nbytes;
}
400313cc:	5b                   	pop    %ebx
400313cd:	89 f0                	mov    %esi,%eax
400313cf:	5e                   	pop    %esi
400313d0:	5f                   	pop    %edi
400313d1:	5d                   	pop    %ebp
400313d2:	c3                   	ret    

400313d3 <_isatty>:
FUNC_ALIAS(_write, write, int);

int _isatty(int file)
{
400313d3:	55                   	push   %ebp
	return 1;
}
400313d4:	b8 01 00 00 00       	mov    $0x1,%eax
{
400313d9:	89 e5                	mov    %esp,%ebp
}
400313db:	5d                   	pop    %ebp
400313dc:	c3                   	ret    

400313dd <_fstat>:
	return 0;
}
FUNC_ALIAS(_getpid, getpid, int);

int _fstat(int file, struct stat *st)
{
400313dd:	55                   	push   %ebp
	st->st_mode = S_IFCHR;
	return 0;
}
400313de:	31 c0                	xor    %eax,%eax
{
400313e0:	89 e5                	mov    %esp,%ebp
	st->st_mode = S_IFCHR;
400313e2:	c7 42 04 00 20 00 00 	movl   $0x2000,0x4(%edx)
}
400313e9:	5d                   	pop    %ebp
400313ea:	c3                   	ret    

400313eb <_close>:
	return -1;
}
FUNC_ALIAS(_open, open, int);

int _close(int file)
{
400313eb:	55                   	push   %ebp
	return -1;
}
400313ec:	83 c8 ff             	or     $0xffffffff,%eax
{
400313ef:	89 e5                	mov    %esp,%ebp
}
400313f1:	5d                   	pop    %ebp
400313f2:	c3                   	ret    

400313f3 <_lseek>:
FUNC_ALIAS(_close, close, int);

int _lseek(int file, int ptr, int dir)
{
400313f3:	55                   	push   %ebp
	return 0;
}
400313f4:	31 c0                	xor    %eax,%eax
{
400313f6:	89 e5                	mov    %esp,%ebp
}
400313f8:	5d                   	pop    %ebp
400313f9:	c3                   	ret    

400313fa <_sbrk>:
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
	void *ptr = heap_base + heap_sz;
400313fa:	8b 15 0c 69 00 a8    	mov    0xa800690c,%edx
{
40031400:	55                   	push   %ebp
40031401:	89 e5                	mov    %esp,%ebp

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
40031403:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40031406:	b8 00 40 01 a8       	mov    $0xa8014000,%eax
4003140b:	2d dc 85 00 a8       	sub    $0xa80085dc,%eax
40031410:	39 c1                	cmp    %eax,%ecx
40031412:	73 0e                	jae    40031422 <_sbrk+0x28>
	void *ptr = heap_base + heap_sz;
40031414:	8d 82 dc 85 00 a8    	lea    -0x57ff7a24(%edx),%eax
		heap_sz += count;
4003141a:	89 0d 0c 69 00 a8    	mov    %ecx,0xa800690c
		return ptr;
40031420:	eb 03                	jmp    40031425 <_sbrk+0x2b>
	} else {
		return (void *)-1;
40031422:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
40031425:	5d                   	pop    %ebp
40031426:	c3                   	ret    

40031427 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
40031427:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40031428:	31 c0                	xor    %eax,%eax
{
4003142a:	89 e5                	mov    %esp,%ebp
}
4003142c:	5d                   	pop    %ebp
4003142d:	c3                   	ret    

4003142e <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
4003142e:	ff 02                	incl   (%edx)
{
40031430:	55                   	push   %ebp
40031431:	89 e5                	mov    %esp,%ebp
	return _char_out(c);
}
40031433:	5d                   	pop    %ebp
	return _char_out(c);
40031434:	ff 25 c8 66 00 a8    	jmp    *0xa80066c8

4003143a <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
4003143a:	55                   	push   %ebp
4003143b:	89 e5                	mov    %esp,%ebp
4003143d:	57                   	push   %edi
4003143e:	56                   	push   %esi
4003143f:	53                   	push   %ebx
40031440:	83 ec 14             	sub    $0x14,%esp
40031443:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40031446:	8b 75 0c             	mov    0xc(%ebp),%esi
40031449:	89 55 e0             	mov    %edx,-0x20(%ebp)
4003144c:	8b 45 08             	mov    0x8(%ebp),%eax
4003144f:	89 75 ec             	mov    %esi,-0x14(%ebp)
40031452:	85 f6                	test   %esi,%esi
40031454:	7f 07                	jg     4003145d <_printk_dec_ulong+0x23>
40031456:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
4003145d:	83 f8 01             	cmp    $0x1,%eax
40031460:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40031463:	19 f6                	sbb    %esi,%esi
40031465:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
4003146c:	83 e6 f0             	and    $0xfffffff0,%esi
4003146f:	31 ff                	xor    %edi,%edi
40031471:	83 c6 30             	add    $0x30,%esi
40031474:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
40031479:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
4003147c:	72 04                	jb     40031482 <_printk_dec_ulong+0x48>
4003147e:	85 ff                	test   %edi,%edi
40031480:	74 1c                	je     4003149e <_printk_dec_ulong+0x64>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
40031482:	8d 4b 01             	lea    0x1(%ebx),%ecx
40031485:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031488:	31 d2                	xor    %edx,%edx
4003148a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
4003148d:	f7 f1                	div    %ecx
4003148f:	83 c0 30             	add    $0x30,%eax
40031492:	8b 55 e0             	mov    -0x20(%ebp),%edx
40031495:	ff d7                	call   *%edi
			found_largest_digit = 1;
40031497:	bf 01 00 00 00       	mov    $0x1,%edi
4003149c:	eb 14                	jmp    400314b2 <_printk_dec_ulong+0x78>
		} else if (remaining <= min_width) {
4003149e:	8b 55 e8             	mov    -0x18(%ebp),%edx
400314a1:	31 ff                	xor    %edi,%edi
400314a3:	39 55 ec             	cmp    %edx,-0x14(%ebp)
400314a6:	7c 0a                	jl     400314b2 <_printk_dec_ulong+0x78>
			out((int)(pad_zero ? '0' : ' '), ctx);
400314a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
400314ab:	89 f0                	mov    %esi,%eax
400314ad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
400314b0:	ff d1                	call   *%ecx
		}
		remaining--;
		remainder %= (pos + 1);
400314b2:	8d 4b 01             	lea    0x1(%ebx),%ecx
400314b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400314b8:	31 d2                	xor    %edx,%edx
		remaining--;
400314ba:	ff 4d e8             	decl   -0x18(%ebp)
		remainder %= (pos + 1);
400314bd:	f7 f1                	div    %ecx
400314bf:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
400314c2:	89 d8                	mov    %ebx,%eax
400314c4:	31 d2                	xor    %edx,%edx
400314c6:	b9 0a 00 00 00       	mov    $0xa,%ecx
400314cb:	f7 f1                	div    %ecx
400314cd:	89 c3                	mov    %eax,%ebx
	while (pos >= 9) {
400314cf:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
400314d3:	75 a4                	jne    40031479 <_printk_dec_ulong+0x3f>
	}
	out((int)(remainder + 48), ctx);
400314d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400314d8:	8b 55 e0             	mov    -0x20(%ebp),%edx
400314db:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}
400314de:	83 c4 14             	add    $0x14,%esp
	out((int)(remainder + 48), ctx);
400314e1:	83 c0 30             	add    $0x30,%eax
}
400314e4:	5b                   	pop    %ebx
400314e5:	5e                   	pop    %esi
400314e6:	5f                   	pop    %edi
400314e7:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
400314e8:	ff e1                	jmp    *%ecx

400314ea <__printk_hook_install>:
{
400314ea:	55                   	push   %ebp
	_char_out = fn;
400314eb:	a3 c8 66 00 a8       	mov    %eax,0xa80066c8
{
400314f0:	89 e5                	mov    %esp,%ebp
}
400314f2:	5d                   	pop    %ebp
400314f3:	c3                   	ret    

400314f4 <_vprintk>:
{
400314f4:	55                   	push   %ebp
400314f5:	89 e5                	mov    %esp,%ebp
400314f7:	57                   	push   %edi
400314f8:	56                   	push   %esi
400314f9:	53                   	push   %ebx
400314fa:	83 ec 20             	sub    $0x20,%esp
400314fd:	89 c7                	mov    %eax,%edi
400314ff:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031502:	89 4d e0             	mov    %ecx,-0x20(%ebp)
40031505:	8b 75 08             	mov    0x8(%ebp),%esi
	int min_width = -1;
40031508:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	int pad_zero = 0;
4003150f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
40031516:	31 db                	xor    %ebx,%ebx
	while (*fmt) {
40031518:	8b 45 e0             	mov    -0x20(%ebp),%eax
4003151b:	0f be 00             	movsbl (%eax),%eax
4003151e:	84 c0                	test   %al,%al
40031520:	0f 84 0d 02 00 00    	je     40031733 <_vprintk+0x23f>
		if (!might_format) {
40031526:	85 db                	test   %ebx,%ebx
40031528:	75 12                	jne    4003153c <_vprintk+0x48>
			if (*fmt != '%') {
4003152a:	3c 25                	cmp    $0x25,%al
4003152c:	0f 84 e1 01 00 00    	je     40031713 <_vprintk+0x21f>
				out((int)*fmt, ctx);
40031532:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031535:	ff d7                	call   *%edi
40031537:	e9 ef 01 00 00       	jmp    4003172b <_vprintk+0x237>
			switch (*fmt) {
4003153c:	3c 68                	cmp    $0x68,%al
4003153e:	0f 84 e7 01 00 00    	je     4003172b <_vprintk+0x237>
40031544:	7f 3a                	jg     40031580 <_vprintk+0x8c>
40031546:	3c 39                	cmp    $0x39,%al
40031548:	7f 19                	jg     40031563 <_vprintk+0x6f>
4003154a:	3c 31                	cmp    $0x31,%al
4003154c:	0f 8d 89 00 00 00    	jge    400315db <_vprintk+0xe7>
40031552:	3c 25                	cmp    $0x25,%al
40031554:	0f 84 96 01 00 00    	je     400316f0 <_vprintk+0x1fc>
4003155a:	3c 30                	cmp    $0x30,%al
4003155c:	74 6b                	je     400315c9 <_vprintk+0xd5>
4003155e:	e9 97 01 00 00       	jmp    400316fa <_vprintk+0x206>
40031563:	3c 63                	cmp    $0x63,%al
40031565:	0f 84 76 01 00 00    	je     400316e1 <_vprintk+0x1ed>
4003156b:	3c 64                	cmp    $0x64,%al
4003156d:	0f 84 83 00 00 00    	je     400315f6 <_vprintk+0x102>
40031573:	3c 58                	cmp    $0x58,%al
40031575:	0f 85 7f 01 00 00    	jne    400316fa <_vprintk+0x206>
4003157b:	e9 c7 00 00 00       	jmp    40031647 <_vprintk+0x153>
40031580:	3c 73                	cmp    $0x73,%al
40031582:	0f 84 41 01 00 00    	je     400316c9 <_vprintk+0x1d5>
40031588:	7f 1a                	jg     400315a4 <_vprintk+0xb0>
4003158a:	3c 6c                	cmp    $0x6c,%al
4003158c:	0f 84 99 01 00 00    	je     4003172b <_vprintk+0x237>
40031592:	3c 70                	cmp    $0x70,%al
40031594:	0f 84 8f 00 00 00    	je     40031629 <_vprintk+0x135>
4003159a:	3c 69                	cmp    $0x69,%al
4003159c:	0f 85 58 01 00 00    	jne    400316fa <_vprintk+0x206>
400315a2:	eb 52                	jmp    400315f6 <_vprintk+0x102>
400315a4:	3c 78                	cmp    $0x78,%al
400315a6:	0f 84 9b 00 00 00    	je     40031647 <_vprintk+0x153>
400315ac:	3c 7a                	cmp    $0x7a,%al
400315ae:	0f 84 77 01 00 00    	je     4003172b <_vprintk+0x237>
400315b4:	3c 75                	cmp    $0x75,%al
400315b6:	0f 85 3e 01 00 00    	jne    400316fa <_vprintk+0x206>
				_printk_dec_ulong(out, ctx, u, pad_zero,
400315bc:	ff 75 ec             	pushl  -0x14(%ebp)
				unsigned long u = va_arg(
400315bf:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
400315c2:	8b 0e                	mov    (%esi),%ecx
400315c4:	ff 75 e8             	pushl  -0x18(%ebp)
400315c7:	eb 4d                	jmp    40031616 <_vprintk+0x122>
				if (min_width < 0 && pad_zero == 0) {
400315c9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
400315cc:	c1 e9 1f             	shr    $0x1f,%ecx
400315cf:	74 0a                	je     400315db <_vprintk+0xe7>
400315d1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
400315d5:	0f 84 4d 01 00 00    	je     40031728 <_vprintk+0x234>
				if (min_width < 0) {
400315db:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400315df:	79 05                	jns    400315e6 <_vprintk+0xf2>
					min_width = *fmt - '0';
400315e1:	83 e8 30             	sub    $0x30,%eax
400315e4:	eb 08                	jmp    400315ee <_vprintk+0xfa>
					min_width = 10 * min_width + *fmt - '0';
400315e6:	6b 55 ec 0a          	imul   $0xa,-0x14(%ebp),%edx
400315ea:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
400315ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
400315f1:	e9 35 01 00 00       	jmp    4003172b <_vprintk+0x237>
				long d = va_arg(ap, long);
400315f6:	8d 5e 04             	lea    0x4(%esi),%ebx
400315f9:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
400315fb:	85 f6                	test   %esi,%esi
400315fd:	79 0f                	jns    4003160e <_vprintk+0x11a>
					out((int)'-', ctx);
400315ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031602:	b8 2d 00 00 00       	mov    $0x2d,%eax
40031607:	ff d7                	call   *%edi
					min_width--;
40031609:	ff 4d ec             	decl   -0x14(%ebp)
					d = -d;
4003160c:	f7 de                	neg    %esi
				_printk_dec_ulong(out, ctx, d, pad_zero,
4003160e:	ff 75 ec             	pushl  -0x14(%ebp)
40031611:	ff 75 e8             	pushl  -0x18(%ebp)
40031614:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40031616:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031619:	89 f8                	mov    %edi,%eax
4003161b:	e8 1a fe ff ff       	call   4003143a <_printk_dec_ulong>
40031620:	58                   	pop    %eax
40031621:	5a                   	pop    %edx
				unsigned long u = va_arg(
40031622:	89 de                	mov    %ebx,%esi
40031624:	e9 e6 00 00 00       	jmp    4003170f <_vprintk+0x21b>
				  out('0', ctx);
40031629:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003162c:	b8 30 00 00 00       	mov    $0x30,%eax
40031631:	ff d7                	call   *%edi
				  out('x', ctx);
40031633:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031636:	b8 78 00 00 00       	mov    $0x78,%eax
4003163b:	ff d7                	call   *%edi
				  pad_zero = 1;
4003163d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
				  min_width = 8;
40031640:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
40031647:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
				unsigned long x = va_arg(
4003164b:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
4003164e:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
				unsigned long x = va_arg(
40031655:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40031658:	8b 06                	mov    (%esi),%eax
4003165a:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int size = sizeof(num) * 2;
4003165d:	be 08 00 00 00       	mov    $0x8,%esi
40031662:	19 c0                	sbb    %eax,%eax
	int found_largest_digit = 0;
40031664:	31 d2                	xor    %edx,%edx
40031666:	89 45 dc             	mov    %eax,-0x24(%ebp)
40031669:	83 65 dc f0          	andl   $0xfffffff0,-0x24(%ebp)
4003166d:	83 45 dc 30          	addl   $0x30,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
40031671:	4e                   	dec    %esi
40031672:	8b 45 d8             	mov    -0x28(%ebp),%eax
40031675:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
4003167c:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
4003167e:	24 0f                	and    $0xf,%al
40031680:	75 0c                	jne    4003168e <_vprintk+0x19a>
40031682:	85 d2                	test   %edx,%edx
40031684:	75 08                	jne    4003168e <_vprintk+0x19a>
40031686:	85 f6                	test   %esi,%esi
40031688:	75 1e                	jne    400316a8 <_vprintk+0x1b4>
			nibble += nibble > 9 ? 87 : 48;
4003168a:	b2 30                	mov    $0x30,%dl
4003168c:	eb 0c                	jmp    4003169a <_vprintk+0x1a6>
4003168e:	3c 09                	cmp    $0x9,%al
40031690:	0f 9f c2             	setg   %dl
40031693:	4a                   	dec    %edx
40031694:	83 e2 d9             	and    $0xffffffd9,%edx
40031697:	83 c2 57             	add    $0x57,%edx
4003169a:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
4003169c:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003169f:	0f b6 c0             	movzbl %al,%eax
400316a2:	ff d7                	call   *%edi
			found_largest_digit = 1;
400316a4:	89 da                	mov    %ebx,%edx
400316a6:	eb 18                	jmp    400316c0 <_vprintk+0x1cc>
		if (remaining-- <= min_width) {
400316a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400316ab:	39 45 ec             	cmp    %eax,-0x14(%ebp)
400316ae:	8d 48 ff             	lea    -0x1(%eax),%ecx
400316b1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
400316b4:	7c 08                	jl     400316be <_vprintk+0x1ca>
			out((int)(pad_zero ? '0' : ' '), ctx);
400316b6:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
400316bc:	ff d7                	call   *%edi
		if (remaining-- <= min_width) {
400316be:	31 d2                	xor    %edx,%edx
	for (; size; size--) {
400316c0:	85 f6                	test   %esi,%esi
400316c2:	75 ad                	jne    40031671 <_vprintk+0x17d>
				unsigned long x = va_arg(
400316c4:	8b 75 d4             	mov    -0x2c(%ebp),%esi
400316c7:	eb 46                	jmp    4003170f <_vprintk+0x21b>
				char *s = va_arg(ap, char *);
400316c9:	8d 5e 04             	lea    0x4(%esi),%ebx
400316cc:	8b 36                	mov    (%esi),%esi
				while (*s)
400316ce:	0f be 06             	movsbl (%esi),%eax
400316d1:	84 c0                	test   %al,%al
400316d3:	0f 84 49 ff ff ff    	je     40031622 <_vprintk+0x12e>
					out((int)(*s++), ctx);
400316d9:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316dc:	46                   	inc    %esi
400316dd:	ff d7                	call   *%edi
400316df:	eb ed                	jmp    400316ce <_vprintk+0x1da>
				out(c, ctx);
400316e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316e4:	8b 06                	mov    (%esi),%eax
				int c = va_arg(ap, int);
400316e6:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
400316e9:	ff d7                	call   *%edi
400316eb:	e9 32 ff ff ff       	jmp    40031622 <_vprintk+0x12e>
				out((int)'%', ctx);
400316f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316f3:	b8 25 00 00 00       	mov    $0x25,%eax
400316f8:	eb 13                	jmp    4003170d <_vprintk+0x219>
				out((int)'%', ctx);
400316fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316fd:	b8 25 00 00 00       	mov    $0x25,%eax
40031702:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
40031704:	8b 45 e0             	mov    -0x20(%ebp),%eax
40031707:	0f be 00             	movsbl (%eax),%eax
4003170a:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003170d:	ff d7                	call   *%edi
			might_format = 0;
4003170f:	31 db                	xor    %ebx,%ebx
				break;
40031711:	eb 18                	jmp    4003172b <_vprintk+0x237>
				pad_zero = 0;
40031713:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
4003171a:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				might_format = 1;
40031721:	bb 01 00 00 00       	mov    $0x1,%ebx
40031726:	eb 03                	jmp    4003172b <_vprintk+0x237>
					pad_zero = 1;
40031728:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		++fmt;
4003172b:	ff 45 e0             	incl   -0x20(%ebp)
4003172e:	e9 e5 fd ff ff       	jmp    40031518 <_vprintk+0x24>
}
40031733:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031736:	5b                   	pop    %ebx
40031737:	5e                   	pop    %esi
40031738:	5f                   	pop    %edi
40031739:	5d                   	pop    %ebp
4003173a:	c3                   	ret    

4003173b <printk>:
{
4003173b:	55                   	push   %ebp
4003173c:	89 e5                	mov    %esp,%ebp
4003173e:	50                   	push   %eax
	va_start(ap, fmt);
4003173f:	8d 45 0c             	lea    0xc(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031742:	8d 55 fc             	lea    -0x4(%ebp),%edx
40031745:	50                   	push   %eax
40031746:	8b 4d 08             	mov    0x8(%ebp),%ecx
40031749:	b8 2e 14 03 40       	mov    $0x4003142e,%eax
	struct out_context ctx = { 0 };
4003174e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031755:	e8 9a fd ff ff       	call   400314f4 <_vprintk>
}
4003175a:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
4003175d:	5a                   	pop    %edx
}
4003175e:	c9                   	leave  
4003175f:	c3                   	ret    

40031760 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40031760:	55                   	push   %ebp
40031761:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
40031763:	5d                   	pop    %ebp
40031764:	c3                   	ret    

40031765 <pinmux_initialize>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static int pinmux_initialize(struct device *port)
{
40031765:	55                   	push   %ebp
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
40031766:	b8 30 09 80 b0       	mov    $0xb0800930,%eax
{
4003176b:	89 e5                	mov    %esp,%ebp
4003176d:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  9, PINMUX_FUNC_C);
40031770:	c7 45 ec 55 00 0a 00 	movl   $0xa0055,-0x14(%ebp)
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
40031777:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
	PIN_CONFIG(mux_config, 41, PINMUX_FUNC_B);
4003177e:	c7 45 f4 04 00 05 00 	movl   $0x50004,-0xc(%ebp)
	PIN_CONFIG(mux_config, 63, PINMUX_FUNC_B);
40031785:	c7 45 f8 00 40 15 40 	movl   $0x40154000,-0x8(%ebp)
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
4003178c:	c7 45 fc 15 00 00 00 	movl   $0x15,-0x4(%ebp)
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
40031793:	8b 94 05 bc f6 7f 4f 	mov    0x4f7ff6bc(%ebp,%eax,1),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
4003179a:	89 10                	mov    %edx,(%eax)
4003179c:	83 c0 04             	add    $0x4,%eax
	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
4003179f:	3d 44 09 80 b0       	cmp    $0xb0800944,%eax
400317a4:	75 ed                	jne    40031793 <pinmux_initialize+0x2e>
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);

	return 0;
}
400317a6:	31 c0                	xor    %eax,%eax
400317a8:	c9                   	leave  
400317a9:	c3                   	ret    

400317aa <clk_periph_enable>:

	return 0;
}

int clk_periph_enable(const clk_periph_t clocks)
{
400317aa:	55                   	push   %ebp
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
400317ab:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
{
400317b1:	89 e5                	mov    %esp,%ebp
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
400317b3:	09 d0                	or     %edx,%eax
400317b5:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
400317ba:	31 c0                	xor    %eax,%eax
400317bc:	5d                   	pop    %ebp
400317bd:	c3                   	ret    

400317be <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
400317be:	55                   	push   %ebp
400317bf:	89 e5                	mov    %esp,%ebp
400317c1:	56                   	push   %esi
400317c2:	53                   	push   %ebx
400317c3:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
400317c5:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
		qm_power_soc_restore();
	}
#endif

	if (callback[gpio]) {
400317cc:	8b 0c 9d 18 69 00 a8 	mov    -0x57ff96e8(,%ebx,4),%ecx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
400317d3:	8b 70 40             	mov    0x40(%eax),%esi
	if (callback[gpio]) {
400317d6:	85 c9                	test   %ecx,%ecx
400317d8:	74 0b                	je     400317e5 <gpio_isr+0x27>
		(*callback[gpio])(callback_data[gpio], int_status);
400317da:	8b 04 9d 10 69 00 a8 	mov    -0x57ff96f0(,%ebx,4),%eax
400317e1:	89 f2                	mov    %esi,%edx
400317e3:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
400317e5:	8b 04 9d cc 66 00 a8 	mov    -0x57ff9934(,%ebx,4),%eax
400317ec:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
}
400317ef:	5b                   	pop    %ebx
	QM_GPIO[gpio]->gpio_porta_eoi;
400317f0:	8b 40 4c             	mov    0x4c(%eax),%eax
}
400317f3:	5e                   	pop    %esi
400317f4:	5d                   	pop    %ebp
400317f5:	c3                   	ret    

400317f6 <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
400317f6:	55                   	push   %ebp
	gpio_isr(QM_GPIO_0);
400317f7:	31 c0                	xor    %eax,%eax
{
400317f9:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_GPIO_0_INT_VECTOR);
}
400317fb:	5d                   	pop    %ebp
	gpio_isr(QM_GPIO_0);
400317fc:	e9 bd ff ff ff       	jmp    400317be <gpio_isr>

40031801 <qm_aon_gpio_0_isr>:

#if (HAS_AON_GPIO)
QM_ISR_DECLARE(qm_aon_gpio_0_isr)
{
40031801:	55                   	push   %ebp
	gpio_isr(QM_AON_GPIO_0);
40031802:	b8 01 00 00 00       	mov    $0x1,%eax
{
40031807:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_AON_GPIO_0_INT_VECTOR);
}
40031809:	5d                   	pop    %ebp
	gpio_isr(QM_AON_GPIO_0);
4003180a:	e9 af ff ff ff       	jmp    400317be <gpio_isr>

4003180f <qm_gpio_set_config>:
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
4003180f:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
40031810:	8b 0c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ecx
{
40031817:	89 e5                	mov    %esp,%ebp
40031819:	56                   	push   %esi
4003181a:	53                   	push   %ebx

	uint32_t mask = controller->gpio_intmask;
	controller->gpio_intmask = 0xffffffff;

	controller->gpio_swporta_ddr = cfg->direction;
4003181b:	8b 1a                	mov    (%edx),%ebx
	uint32_t mask = controller->gpio_intmask;
4003181d:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
40031820:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)
	controller->gpio_swporta_ddr = cfg->direction;
40031827:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
4003182a:	8b 5a 04             	mov    0x4(%edx),%ebx
4003182d:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
40031830:	8b 5a 08             	mov    0x8(%edx),%ebx
40031833:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
40031836:	8b 5a 0c             	mov    0xc(%edx),%ebx
40031839:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
4003183c:	8b 5a 10             	mov    0x10(%edx),%ebx
4003183f:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
40031842:	8b 5a 14             	mov    0x14(%edx),%ebx
40031845:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
40031848:	8b 59 60             	mov    0x60(%ecx),%ebx
4003184b:	83 cb 01             	or     $0x1,%ebx
4003184e:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
40031851:	8b 5a 18             	mov    0x18(%edx),%ebx
	callback_data[gpio] = cfg->callback_data;
40031854:	8b 52 1c             	mov    0x1c(%edx),%edx

	controller->gpio_intmask = mask;
40031857:	89 71 34             	mov    %esi,0x34(%ecx)
	callback[gpio] = cfg->callback;
4003185a:	89 1c 85 18 69 00 a8 	mov    %ebx,-0x57ff96e8(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
40031861:	89 14 85 10 69 00 a8 	mov    %edx,-0x57ff96f0(,%eax,4)

	return 0;
}
40031868:	5b                   	pop    %ebx
40031869:	31 c0                	xor    %eax,%eax
4003186b:	5e                   	pop    %esi
4003186c:	5d                   	pop    %ebp
4003186d:	c3                   	ret    

4003186e <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
4003186e:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
4003186f:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
40031876:	89 e5                	mov    %esp,%ebp
40031878:	53                   	push   %ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031879:	8b 40 50             	mov    0x50(%eax),%eax
{
4003187c:	89 cb                	mov    %ecx,%ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
4003187e:	88 d1                	mov    %dl,%cl
40031880:	d3 e8                	shr    %cl,%eax
40031882:	83 e0 01             	and    $0x1,%eax
40031885:	89 03                	mov    %eax,(%ebx)

	return 0;
}
40031887:	31 c0                	xor    %eax,%eax
40031889:	5b                   	pop    %ebx
4003188a:	5d                   	pop    %ebp
4003188b:	c3                   	ret    

4003188c <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
4003188c:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
4003188d:	88 d1                	mov    %dl,%cl
{
4003188f:	89 e5                	mov    %esp,%ebp
40031891:	56                   	push   %esi
40031892:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40031893:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
4003189a:	b8 01 00 00 00       	mov    $0x1,%eax
4003189f:	8b 33                	mov    (%ebx),%esi
400318a1:	d3 e0                	shl    %cl,%eax
400318a3:	09 f0                	or     %esi,%eax
400318a5:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400318a7:	31 c0                	xor    %eax,%eax
400318a9:	5b                   	pop    %ebx
400318aa:	5e                   	pop    %esi
400318ab:	5d                   	pop    %ebp
400318ac:	c3                   	ret    

400318ad <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
400318ad:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
400318ae:	88 d1                	mov    %dl,%cl
{
400318b0:	89 e5                	mov    %esp,%ebp
400318b2:	56                   	push   %esi
400318b3:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
400318b4:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
400318bb:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
400318c0:	8b 33                	mov    (%ebx),%esi
400318c2:	d3 c0                	rol    %cl,%eax
400318c4:	21 f0                	and    %esi,%eax
400318c6:	89 03                	mov    %eax,(%ebx)

	return 0;
}
400318c8:	31 c0                	xor    %eax,%eax
400318ca:	5b                   	pop    %ebx
400318cb:	5e                   	pop    %esi
400318cc:	5d                   	pop    %ebp
400318cd:	c3                   	ret    

400318ce <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
400318ce:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400318d5:	55                   	push   %ebp
400318d6:	89 e5                	mov    %esp,%ebp

	return 0;
}
400318d8:	5d                   	pop    %ebp
	*port = QM_GPIO[gpio]->gpio_ext_porta;
400318d9:	8b 40 50             	mov    0x50(%eax),%eax
400318dc:	89 02                	mov    %eax,(%edx)
}
400318de:	31 c0                	xor    %eax,%eax
400318e0:	c3                   	ret    

400318e1 <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
400318e1:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400318e8:	55                   	push   %ebp
400318e9:	89 e5                	mov    %esp,%ebp
	QM_GPIO[gpio]->gpio_swporta_dr = val;
400318eb:	89 10                	mov    %edx,(%eax)

	return 0;
}
400318ed:	31 c0                	xor    %eax,%eax
400318ef:	5d                   	pop    %ebp
400318f0:	c3                   	ret    

400318f1 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
400318f1:	55                   	push   %ebp
400318f2:	89 e5                	mov    %esp,%ebp
400318f4:	53                   	push   %ebx
400318f5:	51                   	push   %ecx
	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400318f6:	8b 4a 04             	mov    0x4(%edx),%ecx
	qm_uart_reg_t *const regs = QM_UART[uart];
400318f9:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40031900:	89 cb                	mov    %ecx,%ebx
40031902:	c1 eb 10             	shr    $0x10,%ebx
	regs->lcr = 0;
40031905:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
4003190c:	0f b6 db             	movzbl %bl,%ebx
	regs->lcr = QM_UART_LCR_DLAB;
4003190f:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
40031916:	89 58 04             	mov    %ebx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
40031919:	0f b6 dd             	movzbl %ch,%ebx
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
4003191c:	0f b6 c9             	movzbl %cl,%ecx
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
4003191f:	89 18                	mov    %ebx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
40031921:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
40031927:	8b 0a                	mov    (%edx),%ecx
40031929:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
4003192c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
40031933:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
40031937:	74 09                	je     40031942 <qm_uart_set_config+0x51>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
40031939:	8b 50 10             	mov    0x10(%eax),%edx
4003193c:	83 ca 22             	or     $0x22,%edx
4003193f:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
40031942:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
40031949:	8b 50 04             	mov    0x4(%eax),%edx
4003194c:	80 ca 80             	or     $0x80,%dl
4003194f:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
40031952:	8b 40 14             	mov    0x14(%eax),%eax
40031955:	89 45 f8             	mov    %eax,-0x8(%ebp)

	return 0;
}
40031958:	5a                   	pop    %edx
40031959:	31 c0                	xor    %eax,%eax
4003195b:	5b                   	pop    %ebx
4003195c:	5d                   	pop    %ebp
4003195d:	c3                   	ret    

4003195e <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
4003195e:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
4003195f:	8b 0c 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%ecx
{
40031966:	89 e5                	mov    %esp,%ebp
40031968:	56                   	push   %esi
40031969:	53                   	push   %ebx
	uint32_t lsr = regs->lsr;
4003196a:	8b 59 14             	mov    0x14(%ecx),%ebx

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
4003196d:	8b 71 1c             	mov    0x1c(%ecx),%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031970:	89 d8                	mov    %ebx,%eax
40031972:	83 e0 1e             	and    $0x1e,%eax
	if (regs->scr & BIT(0)) {
40031975:	83 e6 01             	and    $0x1,%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031978:	89 02                	mov    %eax,(%edx)
	if (regs->scr & BIT(0)) {
4003197a:	74 0b                	je     40031987 <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
4003197c:	8b 41 1c             	mov    0x1c(%ecx),%eax
4003197f:	83 e0 fe             	and    $0xfffffffe,%eax
40031982:	89 41 1c             	mov    %eax,0x1c(%ecx)
40031985:	eb 0a                	jmp    40031991 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
40031987:	f6 c3 40             	test   $0x40,%bl
4003198a:	75 05                	jne    40031991 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
4003198c:	83 c8 20             	or     $0x20,%eax
4003198f:	89 02                	mov    %eax,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
40031991:	80 e3 01             	and    $0x1,%bl
40031994:	74 03                	je     40031999 <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
40031996:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
40031999:	5b                   	pop    %ebx
4003199a:	31 c0                	xor    %eax,%eax
4003199c:	5e                   	pop    %esi
4003199d:	5d                   	pop    %ebp
4003199e:	c3                   	ret    

4003199f <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
4003199f:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
400319a0:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
{
400319a7:	89 e5                	mov    %esp,%ebp

	while (regs->lsr & QM_UART_LSR_THRE) {
400319a9:	8b 48 14             	mov    0x14(%eax),%ecx
400319ac:	80 e1 20             	and    $0x20,%cl
400319af:	75 f8                	jne    400319a9 <qm_uart_write+0xa>
	}
	regs->rbr_thr_dll = data;
400319b1:	0f b6 d2             	movzbl %dl,%edx
400319b4:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
400319b6:	8b 50 14             	mov    0x14(%eax),%edx
400319b9:	80 e2 40             	and    $0x40,%dl
400319bc:	74 f8                	je     400319b6 <qm_uart_write+0x17>
	}

	return 0;
}
400319be:	31 c0                	xor    %eax,%eax
400319c0:	5d                   	pop    %ebp
400319c1:	c3                   	ret    

400319c2 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
400319c2:	55                   	push   %ebp
400319c3:	89 e5                	mov    %esp,%ebp
400319c5:	56                   	push   %esi
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
400319c6:	8b 34 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%esi
{
400319cd:	53                   	push   %ebx

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
		lsr = regs->lsr;
400319ce:	8b 46 14             	mov    0x14(%esi),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
400319d1:	a8 01                	test   $0x1,%al
400319d3:	74 f9                	je     400319ce <qm_uart_read+0xc>
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
400319d5:	83 e0 1e             	and    $0x1e,%eax
400319d8:	89 c3                	mov    %eax,%ebx
400319da:	74 0d                	je     400319e9 <qm_uart_read+0x27>
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
400319dc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		if (status) {
400319e1:	85 c9                	test   %ecx,%ecx
400319e3:	74 0a                	je     400319ef <qm_uart_read+0x2d>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
400319e5:	89 19                	mov    %ebx,(%ecx)
400319e7:	eb 06                	jmp    400319ef <qm_uart_read+0x2d>
	}
	*data = regs->rbr_thr_dll;
400319e9:	8b 06                	mov    (%esi),%eax
400319eb:	88 02                	mov    %al,(%edx)

	return 0;
400319ed:	31 c0                	xor    %eax,%eax
}
400319ef:	5b                   	pop    %ebx
400319f0:	5e                   	pop    %esi
400319f1:	5d                   	pop    %ebp
400319f2:	c3                   	ret    

400319f3 <read_frame>:
static dma_context_t dma_context_rx[QM_SPI_NUM];
/* DMA core being used by each SPI controller. */
static qm_dma_t dma_core[QM_SPI_NUM];

static void read_frame(const qm_spi_t spi, uint8_t *const rx_buffer)
{
400319f3:	55                   	push   %ebp
	const qm_spi_reg_t *const controller = QM_SPI[spi];
400319f4:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
400319fb:	8a 80 38 69 00 a8    	mov    -0x57ff96c8(%eax),%al
{
40031a01:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031a03:	3c 01                	cmp    $0x1,%al
40031a05:	75 07                	jne    40031a0e <read_frame+0x1b>
		*(uint8_t *)rx_buffer = controller->dr[0];
40031a07:	8b 41 60             	mov    0x60(%ecx),%eax
40031a0a:	88 02                	mov    %al,(%edx)
40031a0c:	eb 0e                	jmp    40031a1c <read_frame+0x29>
	} else if (frame_size == 2) {
40031a0e:	3c 02                	cmp    $0x2,%al
		*(uint16_t *)rx_buffer = controller->dr[0];
40031a10:	8b 41 60             	mov    0x60(%ecx),%eax
	} else if (frame_size == 2) {
40031a13:	75 05                	jne    40031a1a <read_frame+0x27>
		*(uint16_t *)rx_buffer = controller->dr[0];
40031a15:	66 89 02             	mov    %ax,(%edx)
40031a18:	eb 02                	jmp    40031a1c <read_frame+0x29>
	} else {
		*(uint32_t *)rx_buffer = controller->dr[0];
40031a1a:	89 02                	mov    %eax,(%edx)
	}
}
40031a1c:	5d                   	pop    %ebp
40031a1d:	c3                   	ret    

40031a1e <write_frame>:

static void write_frame(const qm_spi_t spi, const uint8_t *const tx_buffer)
{
40031a1e:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031a1f:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40031a26:	8a 80 38 69 00 a8    	mov    -0x57ff96c8(%eax),%al
{
40031a2c:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031a2e:	3c 01                	cmp    $0x1,%al
40031a30:	75 05                	jne    40031a37 <write_frame+0x19>
		controller->dr[0] = *(uint8_t *)tx_buffer;
40031a32:	0f b6 02             	movzbl (%edx),%eax
40031a35:	eb 0b                	jmp    40031a42 <write_frame+0x24>
	} else if (frame_size == 2) {
40031a37:	3c 02                	cmp    $0x2,%al
40031a39:	75 05                	jne    40031a40 <write_frame+0x22>
		controller->dr[0] = *(uint16_t *)tx_buffer;
40031a3b:	0f b7 02             	movzwl (%edx),%eax
40031a3e:	eb 02                	jmp    40031a42 <write_frame+0x24>
	} else {
		controller->dr[0] = *(uint32_t *)tx_buffer;
40031a40:	8b 02                	mov    (%edx),%eax
40031a42:	89 41 60             	mov    %eax,0x60(%ecx)
	}
}
40031a45:	5d                   	pop    %ebp
40031a46:	c3                   	ret    

40031a47 <handle_spi_overflow_interrupt>:
		controller->txftlr = 0;
	}
}

static void handle_spi_overflow_interrupt(const qm_spi_t spi)
{
40031a47:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
	const volatile qm_spi_async_transfer_t *transfer =
40031a48:	8b 0c 85 4c 69 00 a8 	mov    -0x57ff96b4(,%eax,4),%ecx
{
40031a4f:	89 e5                	mov    %esp,%ebp
40031a51:	56                   	push   %esi
40031a52:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031a53:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	    spi_async_transfer[spi];

	if (transfer->callback) {
40031a5a:	8b 51 10             	mov    0x10(%ecx),%edx
40031a5d:	85 d2                	test   %edx,%edx
40031a5f:	74 1c                	je     40031a7d <handle_spi_overflow_interrupt+0x36>
		transfer->callback(transfer->callback_data, -EIO,
40031a61:	8b 71 10             	mov    0x10(%ecx),%esi
				   QM_SPI_RX_OVERFLOW, rx_counter[spi]);
40031a64:	0f b7 94 00 3c 69 00 	movzwl -0x57ff96c4(%eax,%eax,1),%edx
40031a6b:	a8 
		transfer->callback(transfer->callback_data, -EIO,
40031a6c:	8b 41 14             	mov    0x14(%ecx),%eax
40031a6f:	52                   	push   %edx
40031a70:	b9 02 00 00 00       	mov    $0x2,%ecx
40031a75:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
40031a7a:	ff d6                	call   *%esi
40031a7c:	58                   	pop    %eax
	}

	/* Clear RX FIFO Overflow interrupt. */
	controller->rxoicr;
40031a7d:	8b 43 3c             	mov    0x3c(%ebx),%eax
	controller->imr = QM_SPI_IMR_MASK_ALL;
40031a80:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	controller->ssienr = 0;
40031a87:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
40031a8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031a91:	5b                   	pop    %ebx
40031a92:	5e                   	pop    %esi
40031a93:	5d                   	pop    %ebp
40031a94:	c3                   	ret    

40031a95 <handle_spi_mst_interrupt>:

static void handle_spi_mst_interrupt(const qm_spi_t spi)
{
40031a95:	55                   	push   %ebp
40031a96:	89 e5                	mov    %esp,%ebp
40031a98:	57                   	push   %edi
40031a99:	56                   	push   %esi
40031a9a:	53                   	push   %ebx
40031a9b:	83 ec 0c             	sub    $0xc,%esp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031a9e:	8b 3c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edi
40031aa5:	89 7d f0             	mov    %edi,-0x10(%ebp)
	const volatile qm_spi_async_transfer_t *transfer =
	    spi_async_transfer[spi];
	const uint32_t int_status = controller->isr;
40031aa8:	8b 4f 30             	mov    0x30(%edi),%ecx
40031aab:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	QM_ASSERT((int_status & (QM_SPI_ISR_TXOIS | QM_SPI_ISR_RXUIS)) == 0);

	/* RX FIFO Overflow interrupt. */
	if (int_status & QM_SPI_ISR_RXOIS) {
40031aae:	80 e1 08             	and    $0x8,%cl
40031ab1:	74 0c                	je     40031abf <handle_spi_mst_interrupt+0x2a>

	if (int_status & QM_SPI_ISR_TXEIS &&
	    transfer->tx_len > tx_counter[spi]) {
		handle_mst_tx_interrupt(spi);
	}
}
40031ab3:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031ab6:	5b                   	pop    %ebx
40031ab7:	5e                   	pop    %esi
40031ab8:	5f                   	pop    %edi
40031ab9:	5d                   	pop    %ebp
		handle_spi_overflow_interrupt(spi);
40031aba:	e9 88 ff ff ff       	jmp    40031a47 <handle_spi_overflow_interrupt>
40031abf:	89 c3                	mov    %eax,%ebx
	const volatile qm_spi_async_transfer_t *transfer =
40031ac1:	8b 34 85 4c 69 00 a8 	mov    -0x57ff96b4(,%eax,4),%esi
	if (int_status & QM_SPI_ISR_RXFIS) {
40031ac8:	f6 45 ec 10          	testb  $0x10,-0x14(%ebp)
40031acc:	0f 84 b6 00 00 00    	je     40031b88 <handle_spi_mst_interrupt+0xf3>
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40031ad2:	8b 56 04             	mov    0x4(%esi),%edx
40031ad5:	0f b7 8c 00 3c 69 00 	movzwl -0x57ff96c4(%eax,%eax,1),%ecx
40031adc:	a8 
40031add:	0f b6 80 38 69 00 a8 	movzbl -0x57ff96c8(%eax),%eax
40031ae4:	0f af c8             	imul   %eax,%ecx
		rx_buffer += dfs[spi];
40031ae7:	89 c7                	mov    %eax,%edi
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40031ae9:	01 d1                	add    %edx,%ecx
	while (controller->rxflr) {
40031aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031aee:	8b 40 24             	mov    0x24(%eax),%eax
40031af1:	85 c0                	test   %eax,%eax
40031af3:	74 77                	je     40031b6c <handle_spi_mst_interrupt+0xd7>
		read_frame(spi, rx_buffer);
40031af5:	89 ca                	mov    %ecx,%edx
40031af7:	89 d8                	mov    %ebx,%eax
40031af9:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031afc:	e8 f2 fe ff ff       	call   400319f3 <read_frame>
		rx_counter[spi]++;
40031b01:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
40031b08:	a8 
40031b09:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40031b0c:	40                   	inc    %eax
40031b0d:	01 f9                	add    %edi,%ecx
40031b0f:	66 89 84 1b 3c 69 00 	mov    %ax,-0x57ff96c4(%ebx,%ebx,1)
40031b16:	a8 
		if (transfer->rx_len == rx_counter[spi]) {
40031b17:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031b1b:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
40031b22:	a8 
40031b23:	66 39 c2             	cmp    %ax,%dx
40031b26:	75 c3                	jne    40031aeb <handle_spi_mst_interrupt+0x56>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40031b28:	8b 45 f0             	mov    -0x10(%ebp),%eax
			if (tmode[spi] == QM_SPI_TMOD_RX) {
40031b2b:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
40031b32:	02 
40031b33:	75 2b                	jne    40031b60 <handle_spi_mst_interrupt+0xcb>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40031b35:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				controller->ssienr = 0;
40031b3c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				if (transfer->callback) {
40031b43:	8b 46 10             	mov    0x10(%esi),%eax
40031b46:	85 c0                	test   %eax,%eax
40031b48:	74 22                	je     40031b6c <handle_spi_mst_interrupt+0xd7>
					transfer->callback(
40031b4a:	8b 46 10             	mov    0x10(%esi),%eax
40031b4d:	31 c9                	xor    %ecx,%ecx
					    QM_SPI_IDLE, transfer->rx_len);
40031b4f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
					transfer->callback(
40031b53:	89 c7                	mov    %eax,%edi
40031b55:	8b 46 14             	mov    0x14(%esi),%eax
40031b58:	52                   	push   %edx
40031b59:	31 d2                	xor    %edx,%edx
40031b5b:	ff d7                	call   *%edi
40031b5d:	5a                   	pop    %edx
40031b5e:	eb 0c                	jmp    40031b6c <handle_spi_mst_interrupt+0xd7>
				controller->imr &=
40031b60:	8b 40 2c             	mov    0x2c(%eax),%eax
40031b63:	8b 7d f0             	mov    -0x10(%ebp),%edi
40031b66:	83 e0 e3             	and    $0xffffffe3,%eax
40031b69:	89 47 2c             	mov    %eax,0x2c(%edi)
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031b6c:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (frames_left <= controller->rxftlr) {
40031b70:	8b 7d f0             	mov    -0x10(%ebp),%edi
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031b73:	0f b7 94 1b 3c 69 00 	movzwl -0x57ff96c4(%ebx,%ebx,1),%edx
40031b7a:	a8 
40031b7b:	29 d0                	sub    %edx,%eax
	if (frames_left <= controller->rxftlr) {
40031b7d:	8b 57 1c             	mov    0x1c(%edi),%edx
40031b80:	39 d0                	cmp    %edx,%eax
40031b82:	77 04                	ja     40031b88 <handle_spi_mst_interrupt+0xf3>
		controller->rxftlr = frames_left - 1;
40031b84:	48                   	dec    %eax
40031b85:	89 47 1c             	mov    %eax,0x1c(%edi)
	if (transfer->rx_len == rx_counter[spi] &&
40031b88:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031b8c:	66 8b 84 1b 3c 69 00 	mov    -0x57ff96c4(%ebx,%ebx,1),%ax
40031b93:	a8 
40031b94:	66 39 c2             	cmp    %ax,%dx
40031b97:	75 66                	jne    40031bff <handle_spi_mst_interrupt+0x16a>
	    transfer->tx_len == tx_counter[spi] &&
40031b99:	66 8b 56 08          	mov    0x8(%esi),%dx
40031b9d:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031ba4:	a8 
	if (transfer->rx_len == rx_counter[spi] &&
40031ba5:	66 39 c2             	cmp    %ax,%dx
40031ba8:	75 55                	jne    40031bff <handle_spi_mst_interrupt+0x16a>
	    (controller->sr & QM_SPI_SR_TFE) &&
40031baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031bad:	8b 40 28             	mov    0x28(%eax),%eax
	    transfer->tx_len == tx_counter[spi] &&
40031bb0:	a8 04                	test   $0x4,%al
40031bb2:	74 4b                	je     40031bff <handle_spi_mst_interrupt+0x16a>
	    !(controller->sr & QM_SPI_SR_BUSY)) {
40031bb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031bb7:	8b 40 28             	mov    0x28(%eax),%eax
	    (controller->sr & QM_SPI_SR_TFE) &&
40031bba:	a8 01                	test   $0x1,%al
40031bbc:	75 41                	jne    40031bff <handle_spi_mst_interrupt+0x16a>
		controller->imr = QM_SPI_IMR_MASK_ALL;
40031bbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031bc1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
		controller->ssienr = 0;
40031bc8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (transfer->callback && tmode[spi] != QM_SPI_TMOD_RX) {
40031bcf:	8b 46 10             	mov    0x10(%esi),%eax
40031bd2:	85 c0                	test   %eax,%eax
40031bd4:	0f 84 bd 00 00 00    	je     40031c97 <handle_spi_mst_interrupt+0x202>
40031bda:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
40031be1:	02 
40031be2:	0f 84 af 00 00 00    	je     40031c97 <handle_spi_mst_interrupt+0x202>
			transfer->callback(transfer->callback_data, 0,
40031be8:	8b 5e 10             	mov    0x10(%esi),%ebx
40031beb:	31 c9                	xor    %ecx,%ecx
					   QM_SPI_IDLE, transfer->tx_len);
40031bed:	0f b7 56 08          	movzwl 0x8(%esi),%edx
			transfer->callback(transfer->callback_data, 0,
40031bf1:	8b 46 14             	mov    0x14(%esi),%eax
40031bf4:	52                   	push   %edx
40031bf5:	31 d2                	xor    %edx,%edx
40031bf7:	ff d3                	call   *%ebx
40031bf9:	58                   	pop    %eax
40031bfa:	e9 98 00 00 00       	jmp    40031c97 <handle_spi_mst_interrupt+0x202>
	if (int_status & QM_SPI_ISR_TXEIS &&
40031bff:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
40031c03:	0f 84 8e 00 00 00    	je     40031c97 <handle_spi_mst_interrupt+0x202>
	    transfer->tx_len > tx_counter[spi]) {
40031c09:	66 8b 56 08          	mov    0x8(%esi),%dx
40031c0d:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031c14:	a8 
	if (int_status & QM_SPI_ISR_TXEIS &&
40031c15:	66 39 c2             	cmp    %ax,%dx
40031c18:	76 7d                	jbe    40031c97 <handle_spi_mst_interrupt+0x202>
	const volatile qm_spi_async_transfer_t *const transfer =
40031c1a:	8b 0c 9d 4c 69 00 a8 	mov    -0x57ff96b4(,%ebx,4),%ecx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031c21:	8b 3c 9d dc 66 00 a8 	mov    -0x57ff9924(,%ebx,4),%edi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031c28:	0f b6 93 38 69 00 a8 	movzbl -0x57ff96c8(%ebx),%edx
40031c2f:	8b 31                	mov    (%ecx),%esi
		tx_buffer += dfs[spi];
40031c31:	89 55 ec             	mov    %edx,-0x14(%ebp)
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031c34:	0f b7 84 1b 44 69 00 	movzwl -0x57ff96bc(%ebx,%ebx,1),%eax
40031c3b:	a8 
40031c3c:	0f af c2             	imul   %edx,%eax
40031c3f:	01 f0                	add    %esi,%eax
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031c41:	8b 77 20             	mov    0x20(%edi),%esi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031c44:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031c47:	8b 47 24             	mov    0x24(%edi),%eax
40031c4a:	01 f0                	add    %esi,%eax
40031c4c:	be 07 00 00 00       	mov    $0x7,%esi
40031c51:	29 c6                	sub    %eax,%esi
	while (frames > 0) {
40031c53:	85 f6                	test   %esi,%esi
40031c55:	7e 40                	jle    40031c97 <handle_spi_mst_interrupt+0x202>
		write_frame(spi, tx_buffer);
40031c57:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031c5a:	89 d8                	mov    %ebx,%eax
40031c5c:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031c5f:	e8 ba fd ff ff       	call   40031a1e <write_frame>
		tx_counter[spi]++;
40031c64:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031c6b:	a8 
40031c6c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40031c6f:	40                   	inc    %eax
40031c70:	01 4d f0             	add    %ecx,-0x10(%ebp)
		if (transfer->tx_len == tx_counter[spi]) {
40031c73:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		tx_counter[spi]++;
40031c76:	66 89 84 1b 44 69 00 	mov    %ax,-0x57ff96bc(%ebx,%ebx,1)
40031c7d:	a8 
		frames--;
40031c7e:	4e                   	dec    %esi
		if (transfer->tx_len == tx_counter[spi]) {
40031c7f:	66 8b 51 08          	mov    0x8(%ecx),%dx
40031c83:	66 8b 84 1b 44 69 00 	mov    -0x57ff96bc(%ebx,%ebx,1),%ax
40031c8a:	a8 
40031c8b:	66 39 c2             	cmp    %ax,%dx
40031c8e:	75 c3                	jne    40031c53 <handle_spi_mst_interrupt+0x1be>
			controller->txftlr = 0;
40031c90:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
}
40031c97:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031c9a:	5b                   	pop    %ebx
40031c9b:	5e                   	pop    %esi
40031c9c:	5f                   	pop    %edi
40031c9d:	5d                   	pop    %ebp
40031c9e:	c3                   	ret    

40031c9f <qm_spi_set_config>:
		handle_slv_tx_interrupt(spi);
	}
}

int qm_spi_set_config(const qm_spi_t spi, const qm_spi_config_t *cfg)
{
40031c9f:	55                   	push   %ebp
40031ca0:	89 e5                	mov    %esp,%ebp
40031ca2:	57                   	push   %edi
40031ca3:	56                   	push   %esi
40031ca4:	53                   	push   %ebx
40031ca5:	51                   	push   %ecx
	QM_CHECK(QM_SPI_SLV_0 == spi
		     ? cfg->transfer_mode != QM_SPI_TMOD_EEPROM_READ
		     : 1,
		 -EINVAL);

	if (0 != QM_SPI[spi]->ssienr) {
40031ca6:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi
40031cad:	8b 4e 08             	mov    0x8(%esi),%ecx
40031cb0:	85 c9                	test   %ecx,%ecx
40031cb2:	75 4d                	jne    40031d01 <qm_spi_set_config+0x62>
	}

	qm_spi_reg_t *const controller = QM_SPI[spi];

	/* Apply the selected cfg options. */
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031cb4:	8b 3a                	mov    (%edx),%edi
40031cb6:	89 7d f0             	mov    %edi,-0x10(%ebp)
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031cb9:	8b 7a 04             	mov    0x4(%edx),%edi
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031cbc:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031cbf:	89 f9                	mov    %edi,%ecx
40031cc1:	c1 e1 08             	shl    $0x8,%ecx
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031cc4:	c1 e3 10             	shl    $0x10,%ebx
40031cc7:	09 cb                	or     %ecx,%ebx
			     (cfg->bus_mode << QM_SPI_CTRLR0_SCPOL_SCPH_OFFSET);
40031cc9:	8b 4a 08             	mov    0x8(%edx),%ecx
40031ccc:	c1 e1 06             	shl    $0x6,%ecx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031ccf:	09 cb                	or     %ecx,%ebx

	/*
	 * If the device is configured as a slave, an external master will
	 * set the baud rate.
	 */
	if (QM_SPI_SLV_0 != spi) {
40031cd1:	83 f8 02             	cmp    $0x2,%eax
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031cd4:	89 1e                	mov    %ebx,(%esi)
	if (QM_SPI_SLV_0 != spi) {
40031cd6:	74 07                	je     40031cdf <qm_spi_set_config+0x40>
		controller->baudr = cfg->clk_divider;
40031cd8:	0f b7 5a 10          	movzwl 0x10(%edx),%ebx
40031cdc:	89 5e 14             	mov    %ebx,0x14(%esi)
	 * - 1 byte for DFS set from 4 to 8 bits;
	 * - 2 bytes for DFS set from 9 to 16 bits;
	 * - 3 bytes for DFS set from 17 to 24 bits;
	 * - 4 bytes for DFS set from 25 to 32 bits.
	 */
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031cdf:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	tmode[spi] = cfg->transfer_mode;
	frf[spi] = cfg->frame_format;
40031ce2:	8b 52 0c             	mov    0xc(%edx),%edx
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031ce5:	c1 e9 03             	shr    $0x3,%ecx
	tmode[spi] = cfg->transfer_mode;
40031ce8:	89 3c 85 2c 69 00 a8 	mov    %edi,-0x57ff96d4(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031cef:	41                   	inc    %ecx
	frf[spi] = cfg->frame_format;
40031cf0:	89 14 85 20 69 00 a8 	mov    %edx,-0x57ff96e0(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031cf7:	88 88 38 69 00 a8    	mov    %cl,-0x57ff96c8(%eax)

	return 0;
40031cfd:	31 c0                	xor    %eax,%eax
40031cff:	eb 05                	jmp    40031d06 <qm_spi_set_config+0x67>
		return -EBUSY;
40031d01:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031d06:	5a                   	pop    %edx
40031d07:	5b                   	pop    %ebx
40031d08:	5e                   	pop    %esi
40031d09:	5f                   	pop    %edi
40031d0a:	5d                   	pop    %ebp
40031d0b:	c3                   	ret    

40031d0c <qm_spi_slave_select>:
int qm_spi_slave_select(const qm_spi_t spi, const qm_spi_slave_select_t ss)
{
	QM_CHECK((spi < QM_SPI_NUM) && (spi != QM_SPI_SLV_0), -EINVAL);

	/* Check if the device reports as busy. */
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
40031d0c:	8b 04 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%eax
{
40031d13:	55                   	push   %ebp
40031d14:	89 e5                	mov    %esp,%ebp
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
40031d16:	8b 48 28             	mov    0x28(%eax),%ecx
40031d19:	80 e1 01             	and    $0x1,%cl
40031d1c:	75 07                	jne    40031d25 <qm_spi_slave_select+0x19>
		return -EBUSY;
	}

	QM_SPI[spi]->ser = ss;
40031d1e:	89 50 10             	mov    %edx,0x10(%eax)

	return 0;
40031d21:	31 c0                	xor    %eax,%eax
40031d23:	eb 05                	jmp    40031d2a <qm_spi_slave_select+0x1e>
		return -EBUSY;
40031d25:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031d2a:	5d                   	pop    %ebp
40031d2b:	c3                   	ret    

40031d2c <qm_spi_irq_update>:
}

int qm_spi_irq_update(const qm_spi_t spi,
		      const volatile qm_spi_async_transfer_t *const xfer,
		      const qm_spi_update_t update)
{
40031d2c:	55                   	push   %ebp
	QM_CHECK((update & QM_SPI_UPDATE_RX) ? (tmode[spi] != QM_SPI_TMOD_TX)
					     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
	spi_async_transfer[spi] = xfer;
40031d2d:	89 14 85 4c 69 00 a8 	mov    %edx,-0x57ff96b4(,%eax,4)
{
40031d34:	89 e5                	mov    %esp,%ebp

	if (update == QM_SPI_UPDATE_RX) {
40031d36:	83 f9 01             	cmp    $0x1,%ecx
{
40031d39:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031d3a:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	if (update == QM_SPI_UPDATE_RX) {
40031d41:	75 13                	jne    40031d56 <qm_spi_irq_update+0x2a>
		rx_counter[spi] = 0;
40031d43:	66 c7 84 00 3c 69 00 	movw   $0x0,-0x57ff96c4(%eax,%eax,1)
40031d4a:	a8 00 00 
		/* Unmask RX interrupt sources. */
		controller->imr =
40031d4d:	c7 43 2c 1c 00 00 00 	movl   $0x1c,0x2c(%ebx)
40031d54:	eb 33                	jmp    40031d89 <qm_spi_irq_update+0x5d>
		    QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM | QM_SPI_IMR_RXFIM;
	} else if (update == QM_SPI_UPDATE_TX) {
40031d56:	83 f9 02             	cmp    $0x2,%ecx
40031d59:	75 13                	jne    40031d6e <qm_spi_irq_update+0x42>
		tx_counter[spi] = 0;
40031d5b:	66 c7 84 00 44 69 00 	movw   $0x0,-0x57ff96bc(%eax,%eax,1)
40031d62:	a8 00 00 
		/* Unmask TX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM;
40031d65:	c7 43 2c 03 00 00 00 	movl   $0x3,0x2c(%ebx)
40031d6c:	eb 1b                	jmp    40031d89 <qm_spi_irq_update+0x5d>
	} else {
		rx_counter[spi] = 0;
40031d6e:	66 c7 84 00 3c 69 00 	movw   $0x0,-0x57ff96c4(%eax,%eax,1)
40031d75:	a8 00 00 
		tx_counter[spi] = 0;
40031d78:	66 c7 84 00 44 69 00 	movw   $0x0,-0x57ff96bc(%eax,%eax,1)
40031d7f:	a8 00 00 
		/* Unmask both TX and RX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM |
40031d82:	c7 43 2c 1f 00 00 00 	movl   $0x1f,0x2c(%ebx)
				  QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM |
				  QM_SPI_IMR_RXFIM;
	}

	return 0;
}
40031d89:	31 c0                	xor    %eax,%eax
40031d8b:	5b                   	pop    %ebx
40031d8c:	5d                   	pop    %ebp
40031d8d:	c3                   	ret    

40031d8e <qm_spi_irq_transfer>:

int qm_spi_irq_transfer(const qm_spi_t spi,
			const volatile qm_spi_async_transfer_t *const xfer)
{
40031d8e:	55                   	push   %ebp
40031d8f:	89 e5                	mov    %esp,%ebp
40031d91:	57                   	push   %edi
40031d92:	56                   	push   %esi
40031d93:	53                   	push   %ebx
40031d94:	51                   	push   %ecx
40031d95:	89 c3                	mov    %eax,%ebx
	QM_CHECK(tmode[spi] == QM_SPI_TMOD_TX_RX
		     ? (xfer->tx_len == xfer->rx_len)
		     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
40031d97:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi

	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031d9e:	8b 04 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%eax
40031da5:	89 45 f0             	mov    %eax,-0x10(%ebp)
40031da8:	83 e8 02             	sub    $0x2,%eax
40031dab:	83 f8 01             	cmp    $0x1,%eax
{
40031dae:	89 d7                	mov    %edx,%edi
	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031db0:	0f 96 c1             	setbe  %cl
40031db3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40031db7:	0f 94 c0             	sete   %al
	qm_spi_update_t update = 0;
40031dba:	09 c1                	or     %eax,%ecx
40031dbc:	0f b6 c9             	movzbl %cl,%ecx
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_RX;
	}
	if ((tmode[spi] == QM_SPI_TMOD_TX) ||
40031dbf:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
40031dc3:	76 06                	jbe    40031dcb <qm_spi_irq_transfer+0x3d>
40031dc5:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
40031dc9:	75 03                	jne    40031dce <qm_spi_irq_transfer+0x40>
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_TX;
40031dcb:	83 c9 02             	or     $0x2,%ecx
	}

	rx_counter[spi] = 0;
	tx_counter[spi] = 0;
	qm_spi_irq_update(spi, xfer, update);
40031dce:	89 fa                	mov    %edi,%edx
40031dd0:	89 d8                	mov    %ebx,%eax
	rx_counter[spi] = 0;
40031dd2:	66 c7 84 1b 3c 69 00 	movw   $0x0,-0x57ff96c4(%ebx,%ebx,1)
40031dd9:	a8 00 00 
	tx_counter[spi] = 0;
40031ddc:	66 c7 84 1b 44 69 00 	movw   $0x0,-0x57ff96bc(%ebx,%ebx,1)
40031de3:	a8 00 00 
	qm_spi_irq_update(spi, xfer, update);
40031de6:	e8 41 ff ff ff       	call   40031d2c <qm_spi_irq_update>
		 * holds how many bytes the controller solicits, minus 1.
		 * We also set the same into rxftlr, so the controller only
		 * triggers a RX_FIFO_FULL interrupt when all frames are
		 * available at the FIFO for consumption.
		 */
		if (xfer->rx_len) {
40031deb:	66 8b 47 0a          	mov    0xa(%edi),%ax
	if (QM_SPI_SLV_0 != spi) {
40031def:	83 fb 02             	cmp    $0x2,%ebx
40031df2:	74 2d                	je     40031e21 <qm_spi_irq_transfer+0x93>
		if (xfer->rx_len) {
40031df4:	66 85 c0             	test   %ax,%ax
40031df7:	74 1f                	je     40031e18 <qm_spi_irq_transfer+0x8a>
			controller->ctrlr1 = xfer->rx_len - 1;
40031df9:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031dfd:	48                   	dec    %eax
40031dfe:	89 46 04             	mov    %eax,0x4(%esi)
40031e01:	b8 05 00 00 00       	mov    $0x5,%eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
40031e06:	66 8b 57 0a          	mov    0xa(%edi),%dx
						 ? xfer->rx_len - 1
						 : SPI_MST_DEFAULT_RX_THRESHOLD;
40031e0a:	66 83 fa 07          	cmp    $0x7,%dx
40031e0e:	77 05                	ja     40031e15 <qm_spi_irq_transfer+0x87>
						 ? xfer->rx_len - 1
40031e10:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031e14:	48                   	dec    %eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
40031e15:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_MST_DEFAULT_TX_THRESHOLD;
40031e18:	c7 46 18 05 00 00 00 	movl   $0x5,0x18(%esi)
40031e1f:	eb 35                	jmp    40031e56 <qm_spi_irq_transfer+0xc8>
	} else {
		if (xfer->rx_len) {
40031e21:	66 85 c0             	test   %ax,%ax
40031e24:	74 17                	je     40031e3d <qm_spi_irq_transfer+0xaf>
			controller->rxftlr =
			    (xfer->rx_len < SPI_SLV_DEFAULT_RX_THRESHOLD)
40031e26:	66 8b 57 0a          	mov    0xa(%edi),%dx
40031e2a:	b8 03 00 00 00       	mov    $0x3,%eax
				? xfer->rx_len - 1
				: SPI_SLV_DEFAULT_RX_THRESHOLD;
40031e2f:	66 83 fa 02          	cmp    $0x2,%dx
40031e33:	77 05                	ja     40031e3a <qm_spi_irq_transfer+0xac>
				? xfer->rx_len - 1
40031e35:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031e39:	48                   	dec    %eax
			controller->rxftlr =
40031e3a:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_SLV_DEFAULT_TX_THRESHOLD;
40031e3d:	c7 46 18 04 00 00 00 	movl   $0x4,0x18(%esi)

		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031e44:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
			/* Enable MISO line. */
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031e48:	8b 06                	mov    (%esi),%eax
		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031e4a:	74 05                	je     40031e51 <qm_spi_irq_transfer+0xc3>
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031e4c:	80 e4 fb             	and    $0xfb,%ah
40031e4f:	eb 03                	jmp    40031e54 <qm_spi_irq_transfer+0xc6>
		} else {
			/* Disable MISO line. */
			controller->ctrlr0 |= QM_SPI_CTRLR0_SLV_OE;
40031e51:	80 cc 04             	or     $0x4,%ah
40031e54:	89 06                	mov    %eax,(%esi)
		}
	}

	/* Enable SPI controller. */
	controller->ssienr = QM_SPI_SSIENR_SSIENR;
40031e56:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)

	if ((QM_SPI_SLV_0 != spi && QM_SPI_TMOD_RX == tmode[spi]) &&
40031e5d:	83 fb 02             	cmp    $0x2,%ebx
40031e60:	74 20                	je     40031e82 <qm_spi_irq_transfer+0xf4>
40031e62:	83 3c 9d 2c 69 00 a8 	cmpl   $0x2,-0x57ff96d4(,%ebx,4)
40031e69:	02 
40031e6a:	75 16                	jne    40031e82 <qm_spi_irq_transfer+0xf4>
40031e6c:	83 3c 9d 20 69 00 a8 	cmpl   $0x0,-0x57ff96e0(,%ebx,4)
40031e73:	00 
40031e74:	75 0c                	jne    40031e82 <qm_spi_irq_transfer+0xf4>
		/*
		 * In RX only, master is required to send
		 * a dummy frame in order to start the
		 * communication.
		 */
		write_frame(spi, (uint8_t *)&tx_dummy_frame);
40031e76:	ba c4 5d 03 40       	mov    $0x40035dc4,%edx
40031e7b:	89 d8                	mov    %ebx,%eax
40031e7d:	e8 9c fb ff ff       	call   40031a1e <write_frame>
	}

	return 0;
}
40031e82:	5a                   	pop    %edx
40031e83:	31 c0                	xor    %eax,%eax
40031e85:	5b                   	pop    %ebx
40031e86:	5e                   	pop    %esi
40031e87:	5f                   	pop    %edi
40031e88:	5d                   	pop    %ebp
40031e89:	c3                   	ret    

40031e8a <qm_spi_master_0_isr>:

QM_ISR_DECLARE(qm_spi_master_0_isr)
{
40031e8a:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031e8b:	31 c0                	xor    %eax,%eax
{
40031e8d:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_0_INT_VECTOR);
}
40031e8f:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031e90:	e9 00 fc ff ff       	jmp    40031a95 <handle_spi_mst_interrupt>

40031e95 <qm_spi_master_1_isr>:

#if (QUARK_SE)
QM_ISR_DECLARE(qm_spi_master_1_isr)
{
40031e95:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40031e96:	b8 01 00 00 00       	mov    $0x1,%eax
{
40031e9b:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_1_INT_VECTOR);
}
40031e9d:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40031e9e:	e9 f2 fb ff ff       	jmp    40031a95 <handle_spi_mst_interrupt>

40031ea3 <qm_pmux_select>:
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
	return ((pin % (32 / width)) * width);
40031ea3:	89 c1                	mov    %eax,%ecx
}

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
40031ea5:	55                   	push   %ebp
	return (pin / (32 / width));
40031ea6:	c1 e8 04             	shr    $0x4,%eax
	return ((pin % (32 / width)) * width);
40031ea9:	83 e1 0f             	and    $0xf,%ecx
{
40031eac:	89 e5                	mov    %esp,%ebp
	return ((pin % (32 / width)) * width);
40031eae:	01 c9                	add    %ecx,%ecx
{
40031eb0:	56                   	push   %esi
40031eb1:	53                   	push   %ebx
40031eb2:	8d 1c 85 00 09 80 b0 	lea    -0x4f7ff700(,%eax,4),%ebx
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
	uint32_t offs = pin_to_offset(pin, 2);

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
40031eb9:	b8 03 00 00 00       	mov    $0x3,%eax
40031ebe:	d3 e0                	shl    %cl,%eax
40031ec0:	8b 73 30             	mov    0x30(%ebx),%esi
40031ec3:	f7 d0                	not    %eax
40031ec5:	21 f0                	and    %esi,%eax
40031ec7:	89 43 30             	mov    %eax,0x30(%ebx)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40031eca:	8b 43 30             	mov    0x30(%ebx),%eax
40031ecd:	d3 e2                	shl    %cl,%edx
40031ecf:	09 c2                	or     %eax,%edx

	return 0;
}
40031ed1:	31 c0                	xor    %eax,%eax
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40031ed3:	89 53 30             	mov    %edx,0x30(%ebx)
}
40031ed6:	5b                   	pop    %ebx
40031ed7:	5e                   	pop    %esi
40031ed8:	5d                   	pop    %ebp
40031ed9:	c3                   	ret    

40031eda <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
40031eda:	55                   	push   %ebp
40031edb:	89 c1                	mov    %eax,%ecx
40031edd:	89 e5                	mov    %esp,%ebp
40031edf:	53                   	push   %ebx
	return (pin / (32 / width));
40031ee0:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031ee2:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031ee7:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031eea:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031eec:	84 d2                	test   %dl,%dl
40031eee:	8d 14 9d 00 09 80 b0 	lea    -0x4f7ff700(,%ebx,4),%edx
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031ef5:	8b 4a 20             	mov    0x20(%edx),%ecx
	if (enable == false) {
40031ef8:	75 06                	jne    40031f00 <qm_pmux_input_en+0x26>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031efa:	f7 d0                	not    %eax
40031efc:	21 c8                	and    %ecx,%eax
40031efe:	eb 02                	jmp    40031f02 <qm_pmux_input_en+0x28>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
40031f00:	09 c8                	or     %ecx,%eax
40031f02:	89 42 20             	mov    %eax,0x20(%edx)
	}
	return 0;
}
40031f05:	31 c0                	xor    %eax,%eax
40031f07:	5b                   	pop    %ebx
40031f08:	5d                   	pop    %ebp
40031f09:	c3                   	ret    

40031f0a <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
40031f0a:	55                   	push   %ebp
40031f0b:	89 c1                	mov    %eax,%ecx
40031f0d:	89 e5                	mov    %esp,%ebp
40031f0f:	53                   	push   %ebx
	return (pin / (32 / width));
40031f10:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031f12:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031f17:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031f1a:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031f1c:	84 d2                	test   %dl,%dl
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031f1e:	8b 14 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edx
	if (enable == false) {
40031f25:	75 06                	jne    40031f2d <qm_pmux_pullup_en+0x23>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031f27:	f7 d0                	not    %eax
40031f29:	21 d0                	and    %edx,%eax
40031f2b:	eb 02                	jmp    40031f2f <qm_pmux_pullup_en+0x25>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
40031f2d:	09 d0                	or     %edx,%eax
40031f2f:	89 04 9d 00 09 80 b0 	mov    %eax,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
40031f36:	31 c0                	xor    %eax,%eax
40031f38:	5b                   	pop    %ebx
40031f39:	5d                   	pop    %ebp
40031f3a:	c3                   	ret    

40031f3b <mraa_init>:
mraa_board_t* plat = NULL;
struct _gpio _internalgpios[4];

mraa_result_t
mraa_init()
{
40031f3b:	55                   	push   %ebp
40031f3c:	89 e5                	mov    %esp,%ebp
#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
    plat = mraa_intel_arduino_101_sss();
#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
    plat = mraa_intel_d2k_crb();
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    plat = mraa_intel_quark_se_devboard();
40031f3e:	e8 3d 05 00 00       	call   40032480 <mraa_intel_quark_se_devboard>
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
    plat = mraa_intel_quark_se_ss_devboard();
#endif
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
}
40031f43:	5d                   	pop    %ebp
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40031f44:	83 f8 01             	cmp    $0x1,%eax
    plat = mraa_intel_quark_se_devboard();
40031f47:	a3 58 69 00 a8       	mov    %eax,0xa8006958
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40031f4c:	19 c0                	sbb    %eax,%eax
40031f4e:	83 e0 06             	and    $0x6,%eax
}
40031f51:	c3                   	ret    

40031f52 <mraa_setup_mux_mapped>:
    return false;
}

mraa_result_t
mraa_setup_mux_mapped(mraa_pin_t meta)
{
40031f52:	55                   	push   %ebp
    int mi;
    mraa_result_t ret;
    mraa_gpio_context mux_i = NULL;
    int last_pin = -1;
40031f53:	83 c8 ff             	or     $0xffffffff,%eax
{
40031f56:	89 e5                	mov    %esp,%ebp
40031f58:	57                   	push   %edi
40031f59:	56                   	push   %esi
40031f5a:	53                   	push   %ebx
40031f5b:	83 ec 08             	sub    $0x8,%esp
40031f5e:	8d 7d 08             	lea    0x8(%ebp),%edi
    mraa_gpio_context mux_i = NULL;
40031f61:	31 db                	xor    %ebx,%ebx

    for (mi = 0; mi < meta.mux_total; mi++) {
40031f63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40031f6a:	0f b6 55 0a          	movzbl 0xa(%ebp),%edx
40031f6e:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40031f71:	0f 8d 8a 01 00 00    	jge    40032101 <mraa_setup_mux_mapped+0x1af>

        switch (meta.mux[mi].pincmd) {
40031f77:	80 7f 03 05          	cmpb   $0x5,0x3(%edi)
40031f7b:	0f 87 6f 01 00 00    	ja     400320f0 <mraa_setup_mux_mapped+0x19e>
40031f81:	0f b6 57 03          	movzbl 0x3(%edi),%edx
40031f85:	0f b6 77 04          	movzbl 0x4(%edi),%esi
                    return MRAA_ERROR_INVALID_RESOURCE;
                }
                break;

            case PINCMD_SET_MODE:
                if (meta.mux[mi].pin != last_pin) {
40031f89:	89 75 f0             	mov    %esi,-0x10(%ebp)
40031f8c:	39 f0                	cmp    %esi,%eax
        switch (meta.mux[mi].pincmd) {
40031f8e:	ff 24 95 c8 5d 03 40 	jmp    *0x40035dc8(,%edx,4)
                if (meta.mux[mi].pin != last_pin) {
40031f95:	74 2b                	je     40031fc2 <mraa_setup_mux_mapped+0x70>
                    if (mux_i != NULL) {
40031f97:	85 db                	test   %ebx,%ebx
40031f99:	74 10                	je     40031fab <mraa_setup_mux_mapped+0x59>
                        mraa_gpio_owner(mux_i, 0);
40031f9b:	31 d2                	xor    %edx,%edx
40031f9d:	89 d8                	mov    %ebx,%eax
40031f9f:	e8 b7 03 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031fa4:	89 d8                	mov    %ebx,%eax
40031fa6:	e8 cc 03 00 00       	call   40032377 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031fab:	89 f0                	mov    %esi,%eax
40031fad:	e8 dc 01 00 00       	call   4003218e <mraa_gpio_init_raw>
40031fb2:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031fb4:	85 c0                	test   %eax,%eax
40031fb6:	75 0a                	jne    40031fc2 <mraa_setup_mux_mapped+0x70>
                        return MRAA_ERROR_INVALID_HANDLE;
40031fb8:	b8 05 00 00 00       	mov    $0x5,%eax
40031fbd:	e9 57 01 00 00       	jmp    40032119 <mraa_setup_mux_mapped+0x1c7>
                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40031fc2:	31 d2                	xor    %edx,%edx
40031fc4:	89 d8                	mov    %ebx,%eax
40031fc6:	e8 f1 02 00 00       	call   400322bc <mraa_gpio_dir>
40031fcb:	e9 c2 00 00 00       	jmp    40032092 <mraa_setup_mux_mapped+0x140>
                if (meta.mux[mi].pin != last_pin) {
40031fd0:	0f 84 bc 00 00 00    	je     40032092 <mraa_setup_mux_mapped+0x140>
                    if (mux_i != NULL) {
40031fd6:	85 db                	test   %ebx,%ebx
40031fd8:	74 10                	je     40031fea <mraa_setup_mux_mapped+0x98>
                        mraa_gpio_owner(mux_i, 0);
40031fda:	31 d2                	xor    %edx,%edx
40031fdc:	89 d8                	mov    %ebx,%eax
40031fde:	e8 78 03 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40031fe3:	89 d8                	mov    %ebx,%eax
40031fe5:	e8 8d 03 00 00       	call   40032377 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40031fea:	89 f0                	mov    %esi,%eax
40031fec:	e8 9d 01 00 00       	call   4003218e <mraa_gpio_init_raw>
40031ff1:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40031ff3:	85 c0                	test   %eax,%eax
40031ff5:	0f 85 97 00 00 00    	jne    40032092 <mraa_setup_mux_mapped+0x140>
40031ffb:	eb bb                	jmp    40031fb8 <mraa_setup_mux_mapped+0x66>
                if (meta.mux[mi].pin != last_pin) {
40031ffd:	74 21                	je     40032020 <mraa_setup_mux_mapped+0xce>
                    if (mux_i != NULL) {
40031fff:	85 db                	test   %ebx,%ebx
40032001:	74 10                	je     40032013 <mraa_setup_mux_mapped+0xc1>
                        mraa_gpio_owner(mux_i, 0);
40032003:	31 d2                	xor    %edx,%edx
40032005:	89 d8                	mov    %ebx,%eax
40032007:	e8 4f 03 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003200c:	89 d8                	mov    %ebx,%eax
4003200e:	e8 64 03 00 00       	call   40032377 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40032013:	89 f0                	mov    %esi,%eax
40032015:	e8 74 01 00 00       	call   4003218e <mraa_gpio_init_raw>
4003201a:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003201c:	85 c0                	test   %eax,%eax
4003201e:	74 98                	je     40031fb8 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
40032020:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40032024:	89 d8                	mov    %ebx,%eax
40032026:	e8 91 02 00 00       	call   400322bc <mraa_gpio_dir>
4003202b:	e9 a1 00 00 00       	jmp    400320d1 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40032030:	74 25                	je     40032057 <mraa_setup_mux_mapped+0x105>
                    if (mux_i != NULL) {
40032032:	85 db                	test   %ebx,%ebx
40032034:	74 10                	je     40032046 <mraa_setup_mux_mapped+0xf4>
                        mraa_gpio_owner(mux_i, 0);
40032036:	31 d2                	xor    %edx,%edx
40032038:	89 d8                	mov    %ebx,%eax
4003203a:	e8 1c 03 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003203f:	89 d8                	mov    %ebx,%eax
40032041:	e8 31 03 00 00       	call   40032377 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40032046:	89 f0                	mov    %esi,%eax
40032048:	e8 41 01 00 00       	call   4003218e <mraa_gpio_init_raw>
4003204d:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003204f:	85 c0                	test   %eax,%eax
40032051:	0f 84 61 ff ff ff    	je     40031fb8 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
40032057:	ba 01 00 00 00       	mov    $0x1,%edx
4003205c:	eb 29                	jmp    40032087 <mraa_setup_mux_mapped+0x135>
                if (meta.mux[mi].pin != last_pin) {
4003205e:	74 25                	je     40032085 <mraa_setup_mux_mapped+0x133>
                    if (mux_i != NULL) {
40032060:	85 db                	test   %ebx,%ebx
40032062:	74 10                	je     40032074 <mraa_setup_mux_mapped+0x122>
                        mraa_gpio_owner(mux_i, 0);
40032064:	31 d2                	xor    %edx,%edx
40032066:	89 d8                	mov    %ebx,%eax
40032068:	e8 ee 02 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
4003206d:	89 d8                	mov    %ebx,%eax
4003206f:	e8 03 03 00 00       	call   40032377 <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40032074:	89 f0                	mov    %esi,%eax
40032076:	e8 13 01 00 00       	call   4003218e <mraa_gpio_init_raw>
4003207b:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
4003207d:	85 c0                	test   %eax,%eax
4003207f:	0f 84 33 ff ff ff    	je     40031fb8 <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40032085:	31 d2                	xor    %edx,%edx
40032087:	89 d8                	mov    %ebx,%eax
40032089:	e8 2e 02 00 00       	call   400322bc <mraa_gpio_dir>
                if (ret == MRAA_SUCCESS)
4003208e:	85 c0                	test   %eax,%eax
40032090:	75 43                	jne    400320d5 <mraa_setup_mux_mapped+0x183>
                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
40032092:	0f b6 57 05          	movzbl 0x5(%edi),%edx
40032096:	89 d8                	mov    %ebx,%eax
40032098:	e8 95 02 00 00       	call   40032332 <mraa_gpio_write>
4003209d:	eb 32                	jmp    400320d1 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
4003209f:	74 25                	je     400320c6 <mraa_setup_mux_mapped+0x174>
                    if (mux_i != NULL) {
400320a1:	85 db                	test   %ebx,%ebx
400320a3:	74 10                	je     400320b5 <mraa_setup_mux_mapped+0x163>
                        mraa_gpio_owner(mux_i, 0);
400320a5:	31 d2                	xor    %edx,%edx
400320a7:	89 d8                	mov    %ebx,%eax
400320a9:	e8 ad 02 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400320ae:	89 d8                	mov    %ebx,%eax
400320b0:	e8 c2 02 00 00       	call   40032377 <mraa_gpio_close>
                    }
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400320b5:	89 f0                	mov    %esi,%eax
400320b7:	e8 d2 00 00 00       	call   4003218e <mraa_gpio_init_raw>
400320bc:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400320be:	85 c0                	test   %eax,%eax
400320c0:	0f 84 f2 fe ff ff    	je     40031fb8 <mraa_setup_mux_mapped+0x66>
                        return MRAA_ERROR_INVALID_HANDLE;
                    last_pin = meta.mux[mi].pin;
                }

                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
400320c6:	0f b6 57 05          	movzbl 0x5(%edi),%edx
400320ca:	89 d8                	mov    %ebx,%eax
400320cc:	e8 9f 02 00 00       	call   40032370 <mraa_gpio_mode>

                if (ret != MRAA_SUCCESS) {
400320d1:	85 c0                	test   %eax,%eax
400320d3:	74 1e                	je     400320f3 <mraa_setup_mux_mapped+0x1a1>
                    if (mux_i != NULL) {
400320d5:	85 db                	test   %ebx,%ebx
400320d7:	74 10                	je     400320e9 <mraa_setup_mux_mapped+0x197>
                        mraa_gpio_owner(mux_i, 0);
400320d9:	31 d2                	xor    %edx,%edx
400320db:	89 d8                	mov    %ebx,%eax
400320dd:	e8 79 02 00 00       	call   4003235b <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400320e2:	89 d8                	mov    %ebx,%eax
400320e4:	e8 8e 02 00 00       	call   40032377 <mraa_gpio_close>
                    return MRAA_ERROR_INVALID_RESOURCE;
400320e9:	b8 07 00 00 00       	mov    $0x7,%eax
400320ee:	eb 29                	jmp    40032119 <mraa_setup_mux_mapped+0x1c7>
        switch (meta.mux[mi].pincmd) {
400320f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (mi = 0; mi < meta.mux_total; mi++) {
400320f3:	ff 45 ec             	incl   -0x14(%ebp)
400320f6:	83 c7 03             	add    $0x3,%edi
400320f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
400320fc:	e9 69 fe ff ff       	jmp    40031f6a <mraa_setup_mux_mapped+0x18>

    if (mux_i != NULL) {
        mraa_gpio_owner(mux_i, 0);
        mraa_gpio_close(mux_i);
    }
    return MRAA_SUCCESS;
40032101:	31 c0                	xor    %eax,%eax
    if (mux_i != NULL) {
40032103:	85 db                	test   %ebx,%ebx
40032105:	74 12                	je     40032119 <mraa_setup_mux_mapped+0x1c7>
        mraa_gpio_owner(mux_i, 0);
40032107:	31 d2                	xor    %edx,%edx
40032109:	89 d8                	mov    %ebx,%eax
4003210b:	e8 4b 02 00 00       	call   4003235b <mraa_gpio_owner>
        mraa_gpio_close(mux_i);
40032110:	89 d8                	mov    %ebx,%eax
40032112:	e8 60 02 00 00       	call   40032377 <mraa_gpio_close>
    return MRAA_SUCCESS;
40032117:	31 c0                	xor    %eax,%eax
}
40032119:	5a                   	pop    %edx
4003211a:	59                   	pop    %ecx
4003211b:	5b                   	pop    %ebx
4003211c:	5e                   	pop    %esi
4003211d:	5f                   	pop    %edi
4003211e:	5d                   	pop    %ebp
4003211f:	c3                   	ret    

40032120 <mraa_set_pininfo>:


// Internal functions
mraa_result_t
mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
{
40032120:	55                   	push   %ebp
40032121:	89 e5                	mov    %esp,%ebp
40032123:	53                   	push   %ebx
    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
    pin_info->gpio.pinmap = zephyr_pin;
40032124:	6b da 44             	imul   $0x44,%edx,%ebx
#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB) || defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    pin_info->uart.pinmap = zephyr_pin;
#endif
    pin_info->pwm.pinmap = zephyr_pin;
    pin_info->gpio.mux_total = 0;
    pin_info->name = name;
40032127:	42                   	inc    %edx
    pin_info->gpio.pinmap = zephyr_pin;
40032128:	01 c3                	add    %eax,%ebx
    pin_info->name = name;
4003212a:	6b d2 44             	imul   $0x44,%edx,%edx
    pin_info->gpio.pinmap = zephyr_pin;
4003212d:	88 4b 4c             	mov    %cl,0x4c(%ebx)
    pin_info->uart.pinmap = zephyr_pin;
40032130:	88 4b 7c             	mov    %cl,0x7c(%ebx)
    pin_info->pwm.pinmap = zephyr_pin;
40032133:	88 4b 58             	mov    %cl,0x58(%ebx)
    pin_info->name = name;
40032136:	8b 4d 08             	mov    0x8(%ebp),%ecx
    pin_info->gpio.mux_total = 0;
40032139:	c6 43 4e 00          	movb   $0x0,0x4e(%ebx)
    pin_info->name = name;
4003213d:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
    pin_info->capabilites = caps;
40032140:	8a 45 0c             	mov    0xc(%ebp),%al
40032143:	88 43 48             	mov    %al,0x48(%ebx)
    return MRAA_SUCCESS;
}
40032146:	31 c0                	xor    %eax,%eax
40032148:	5b                   	pop    %ebx
40032149:	5d                   	pop    %ebp
4003214a:	c3                   	ret    

4003214b <mraa_set_board_config>:


void
mraa_set_board_config(mraa_board_t* board)
{
4003214b:	55                   	push   %ebp
    memset(board, 0, sizeof(mraa_board_t));
4003214c:	b9 48 0d 00 00       	mov    $0xd48,%ecx
{
40032151:	89 e5                	mov    %esp,%ebp
40032153:	53                   	push   %ebx
40032154:	89 c3                	mov    %eax,%ebx
    memset(board, 0, sizeof(mraa_board_t));
40032156:	31 d2                	xor    %edx,%edx
40032158:	e8 18 df ff ff       	call   40030075 <memset>
    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
4003215d:	c6 03 31             	movb   $0x31,(%ebx)
    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
40032160:	c6 43 01 1f          	movb   $0x1f,0x1(%ebx)
    board->aio_count = CONFIG_MRAA_AIO_COUNT;
40032164:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
40032168:	c6 43 03 02          	movb   $0x2,0x3(%ebx)
    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
4003216c:	c6 43 0b 02          	movb   $0x2,0xb(%ebx)
    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
40032170:	c6 43 1e 01          	movb   $0x1,0x1e(%ebx)
}
40032174:	5b                   	pop    %ebx
40032175:	5d                   	pop    %ebp
40032176:	c3                   	ret    

40032177 <gpio_pin_configure>:
{
40032177:	55                   	push   %ebp
40032178:	89 e5                	mov    %esp,%ebp
4003217a:	53                   	push   %ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
4003217b:	8b 58 04             	mov    0x4(%eax),%ebx
4003217e:	51                   	push   %ecx
4003217f:	0f b6 d2             	movzbl %dl,%edx
40032182:	89 d1                	mov    %edx,%ecx
40032184:	31 d2                	xor    %edx,%edx
40032186:	ff 13                	call   *(%ebx)
40032188:	5a                   	pop    %edx
}
40032189:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4003218c:	c9                   	leave  
4003218d:	c3                   	ret    

4003218e <mraa_gpio_init_raw>:
    return dev;
}

mraa_gpio_context
mraa_gpio_init_raw(int gpiopin)
{
4003218e:	55                   	push   %ebp
4003218f:	89 e5                	mov    %esp,%ebp
40032191:	56                   	push   %esi
40032192:	89 c6                	mov    %eax,%esi
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40032194:	b8 20 00 00 00       	mov    $0x20,%eax
{
40032199:	53                   	push   %ebx
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
4003219a:	e8 60 26 00 00       	call   400347ff <malloc>
4003219f:	89 c3                	mov    %eax,%ebx
    if (!dev) {
400321a1:	85 c0                	test   %eax,%eax
400321a3:	75 13                	jne    400321b8 <mraa_gpio_init_raw+0x2a>
        printf("%s: context allocation failed\n", __FUNCTION__);
400321a5:	68 ac 5e 03 40       	push   $0x40035eac
400321aa:	68 e0 5d 03 40       	push   $0x40035de0
400321af:	e8 f7 27 00 00       	call   400349ab <iprintf>
400321b4:	58                   	pop    %eax
400321b5:	5a                   	pop    %edx
400321b6:	eb 49                	jmp    40032201 <mraa_gpio_init_raw+0x73>
        return NULL;
    }

    dev->phy_pin = gpiopin;
400321b8:	89 f0                	mov    %esi,%eax
400321ba:	88 43 01             	mov    %al,0x1(%ebx)
    dev->zdev = device_get_binding(GPIO_DRV_NAME);
400321bd:	b8 34 5d 03 40       	mov    $0x40035d34,%eax
400321c2:	e8 34 1b 00 00       	call   40033cfb <device_get_binding>
400321c7:	89 43 04             	mov    %eax,0x4(%ebx)
//printf("GPIO : %s", GPIO_DRV_NAME);
    if (dev->zdev == NULL) {
400321ca:	85 c0                	test   %eax,%eax
400321cc:	74 2a                	je     400321f8 <mraa_gpio_init_raw+0x6a>
        free(dev);
        return NULL;
    }
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
400321ce:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
400321d2:	b9 01 00 00 00       	mov    $0x1,%ecx
400321d7:	e8 9b ff ff ff       	call   40032177 <gpio_pin_configure>
    if (ret) {
400321dc:	85 c0                	test   %eax,%eax
400321de:	74 21                	je     40032201 <mraa_gpio_init_raw+0x73>
        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
400321e0:	0f be 53 01          	movsbl 0x1(%ebx),%edx
400321e4:	52                   	push   %edx
400321e5:	68 34 5d 03 40       	push   $0x40035d34
400321ea:	50                   	push   %eax
400321eb:	68 ff 5d 03 40       	push   $0x40035dff
400321f0:	e8 b6 27 00 00       	call   400349ab <iprintf>
400321f5:	83 c4 10             	add    $0x10,%esp
        free(dev);
400321f8:	89 d8                	mov    %ebx,%eax
        return NULL;
400321fa:	31 db                	xor    %ebx,%ebx
        free(dev);
400321fc:	e8 0e 26 00 00       	call   4003480f <free>
    }
    return dev;
}
40032201:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032204:	89 d8                	mov    %ebx,%eax
40032206:	5b                   	pop    %ebx
40032207:	5e                   	pop    %esi
40032208:	5d                   	pop    %ebp
40032209:	c3                   	ret    

4003220a <mraa_gpio_init>:
{
4003220a:	55                   	push   %ebp
4003220b:	89 e5                	mov    %esp,%ebp
4003220d:	57                   	push   %edi
4003220e:	56                   	push   %esi
4003220f:	53                   	push   %ebx
40032210:	53                   	push   %ebx
    mraa_board_t* board = plat;
40032211:	8b 15 58 69 00 a8    	mov    0xa8006958,%edx
    if (board == NULL) {
40032217:	85 d2                	test   %edx,%edx
40032219:	75 07                	jne    40032222 <mraa_gpio_init+0x18>
        printf("gpio: platform not initialised\n");
4003221b:	68 1f 5e 03 40       	push   $0x40035e1f
40032220:	eb 37                	jmp    40032259 <mraa_gpio_init+0x4f>
40032222:	89 c3                	mov    %eax,%ebx
    if (pin < 0 || pin >= board->phy_pin_count) {
40032224:	85 c0                	test   %eax,%eax
40032226:	78 07                	js     4003222f <mraa_gpio_init+0x25>
40032228:	0f b6 02             	movzbl (%edx),%eax
4003222b:	39 c3                	cmp    %eax,%ebx
4003222d:	7c 11                	jl     40032240 <mraa_gpio_init+0x36>
        printf("gpio: pin %i beyond platform definition\n", pin);
4003222f:	53                   	push   %ebx
40032230:	68 3f 5e 03 40       	push   $0x40035e3f
40032235:	e8 71 27 00 00       	call   400349ab <iprintf>
4003223a:	5a                   	pop    %edx
4003223b:	59                   	pop    %ecx
        return NULL;
4003223c:	31 c0                	xor    %eax,%eax
4003223e:	eb 74                	jmp    400322b4 <mraa_gpio_init+0xaa>
    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
40032240:	b8 3b 5d 03 40       	mov    $0x40035d3b,%eax
40032245:	89 55 f0             	mov    %edx,-0x10(%ebp)
40032248:	e8 ae 1a 00 00       	call   40033cfb <device_get_binding>
    if (pinmux_dev == NULL) {
4003224d:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032250:	85 c0                	test   %eax,%eax
40032252:	75 0d                	jne    40032261 <mraa_gpio_init+0x57>
        printf("Failed to get binding for pinmux\n");
40032254:	68 68 5e 03 40       	push   $0x40035e68
40032259:	e8 4d 27 00 00       	call   400349ab <iprintf>
4003225e:	58                   	pop    %eax
4003225f:	eb db                	jmp    4003223c <mraa_gpio_init+0x32>
    if (board->pins[pin].capabilites.gpio != 1) {
40032261:	6b f3 44             	imul   $0x44,%ebx,%esi
40032264:	01 d6                	add    %edx,%esi
40032266:	f6 46 48 02          	testb  $0x2,0x48(%esi)
4003226a:	75 08                	jne    40032274 <mraa_gpio_init+0x6a>
        printf("gpio: pin %i not capable of gpio\n", pin);
4003226c:	53                   	push   %ebx
4003226d:	68 8a 5e 03 40       	push   $0x40035e8a
40032272:	eb c1                	jmp    40032235 <mraa_gpio_init+0x2b>
    if (board->pins[pin].gpio.mux_total > 0) {
40032274:	80 7e 4e 00          	cmpb   $0x0,0x4e(%esi)
40032278:	75 15                	jne    4003228f <mraa_gpio_init+0x85>
    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
4003227a:	6b c3 44             	imul   $0x44,%ebx,%eax
4003227d:	0f b6 44 02 4c       	movzbl 0x4c(%edx,%eax,1),%eax
40032282:	e8 07 ff ff ff       	call   4003218e <mraa_gpio_init_raw>
    if (dev) {
40032287:	85 c0                	test   %eax,%eax
40032289:	74 29                	je     400322b4 <mraa_gpio_init+0xaa>
        dev->pin = pin;
4003228b:	88 18                	mov    %bl,(%eax)
4003228d:	eb 25                	jmp    400322b4 <mraa_gpio_init+0xaa>
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
4003228f:	83 ec 0c             	sub    $0xc,%esp
40032292:	83 c6 4c             	add    $0x4c,%esi
40032295:	89 e7                	mov    %esp,%edi
40032297:	b9 03 00 00 00       	mov    $0x3,%ecx
4003229c:	89 55 f0             	mov    %edx,-0x10(%ebp)
4003229f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
400322a1:	e8 ac fc ff ff       	call   40031f52 <mraa_setup_mux_mapped>
400322a6:	83 c4 0c             	add    $0xc,%esp
400322a9:	89 c1                	mov    %eax,%ecx
400322ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
            return NULL;
400322ae:	31 c0                	xor    %eax,%eax
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
400322b0:	85 c9                	test   %ecx,%ecx
400322b2:	74 c6                	je     4003227a <mraa_gpio_init+0x70>
}
400322b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
400322b7:	5b                   	pop    %ebx
400322b8:	5e                   	pop    %esi
400322b9:	5f                   	pop    %edi
400322ba:	5d                   	pop    %ebp
400322bb:	c3                   	ret    

400322bc <mraa_gpio_dir>:

mraa_result_t
mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
{
400322bc:	55                   	push   %ebp
    int flags = 0;
    uint32_t value = 0;
    switch (dir) {
400322bd:	83 fa 01             	cmp    $0x1,%edx
{
400322c0:	89 e5                	mov    %esp,%ebp
400322c2:	57                   	push   %edi
400322c3:	56                   	push   %esi
400322c4:	53                   	push   %ebx
    switch (dir) {
400322c5:	74 0e                	je     400322d5 <mraa_gpio_dir+0x19>
400322c7:	72 19                	jb     400322e2 <mraa_gpio_dir+0x26>
400322c9:	83 fa 02             	cmp    $0x2,%edx
400322cc:	74 0d                	je     400322db <mraa_gpio_dir+0x1f>
400322ce:	83 fa 03             	cmp    $0x3,%edx
400322d1:	75 52                	jne    40032325 <mraa_gpio_dir+0x69>
400322d3:	eb 0d                	jmp    400322e2 <mraa_gpio_dir+0x26>
    uint32_t value = 0;
400322d5:	31 ff                	xor    %edi,%edi
        case MRAA_GPIO_OUT:
            flags = GPIO_DIR_OUT;
            break;
        case MRAA_GPIO_IN:
            flags = GPIO_DIR_IN;
400322d7:	31 c9                	xor    %ecx,%ecx
400322d9:	eb 0e                	jmp    400322e9 <mraa_gpio_dir+0x2d>
            break;
        case MRAA_GPIO_OUT_HIGH:
            flags = GPIO_DIR_OUT;
            value = 1;
400322db:	bf 01 00 00 00       	mov    $0x1,%edi
400322e0:	eb 02                	jmp    400322e4 <mraa_gpio_dir+0x28>
    uint32_t value = 0;
400322e2:	31 ff                	xor    %edi,%edi
            flags = GPIO_DIR_OUT;
400322e4:	b9 01 00 00 00       	mov    $0x1,%ecx
400322e9:	89 d3                	mov    %edx,%ebx
400322eb:	89 c6                	mov    %eax,%esi
            value = 0;
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }
    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
400322ed:	0f b6 50 01          	movzbl 0x1(%eax),%edx
400322f1:	8b 40 04             	mov    0x4(%eax),%eax
400322f4:	e8 7e fe ff ff       	call   40032177 <gpio_pin_configure>
400322f9:	85 c0                	test   %eax,%eax
400322fb:	74 07                	je     40032304 <mraa_gpio_dir+0x48>
        return MRAA_ERROR_UNSPECIFIED;
400322fd:	b8 63 00 00 00       	mov    $0x63,%eax
40032302:	eb 26                	jmp    4003232a <mraa_gpio_dir+0x6e>
    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
40032304:	83 eb 02             	sub    $0x2,%ebx
40032307:	83 fb 01             	cmp    $0x1,%ebx
4003230a:	77 15                	ja     40032321 <mraa_gpio_dir+0x65>
        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
4003230c:	8b 46 04             	mov    0x4(%esi),%eax
	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
4003230f:	31 d2                	xor    %edx,%edx
40032311:	0f be 4e 01          	movsbl 0x1(%esi),%ecx
40032315:	8b 58 04             	mov    0x4(%eax),%ebx
40032318:	57                   	push   %edi
40032319:	ff 53 04             	call   *0x4(%ebx)
4003231c:	5a                   	pop    %edx
4003231d:	85 c0                	test   %eax,%eax
4003231f:	75 dc                	jne    400322fd <mraa_gpio_dir+0x41>
            return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
40032321:	31 c0                	xor    %eax,%eax
40032323:	eb 05                	jmp    4003232a <mraa_gpio_dir+0x6e>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
40032325:	b8 01 00 00 00       	mov    $0x1,%eax
}
4003232a:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003232d:	5b                   	pop    %ebx
4003232e:	5e                   	pop    %esi
4003232f:	5f                   	pop    %edi
40032330:	5d                   	pop    %ebp
40032331:	c3                   	ret    

40032332 <mraa_gpio_write>:
        return (int) value;
}

mraa_result_t
mraa_gpio_write(mraa_gpio_context dev, int value)
{
40032332:	55                   	push   %ebp
40032333:	89 e5                	mov    %esp,%ebp
40032335:	56                   	push   %esi
40032336:	53                   	push   %ebx
    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
40032337:	8b 58 04             	mov    0x4(%eax),%ebx
4003233a:	0f be 48 01          	movsbl 0x1(%eax),%ecx
4003233e:	8b 73 04             	mov    0x4(%ebx),%esi
40032341:	89 d8                	mov    %ebx,%eax
40032343:	52                   	push   %edx
40032344:	31 d2                	xor    %edx,%edx
40032346:	ff 56 04             	call   *0x4(%esi)
40032349:	5a                   	pop    %edx
        return MRAA_ERROR_UNSPECIFIED;
    return MRAA_SUCCESS;
4003234a:	83 f8 01             	cmp    $0x1,%eax
4003234d:	19 c0                	sbb    %eax,%eax
}
4003234f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    return MRAA_SUCCESS;
40032352:	f7 d0                	not    %eax
}
40032354:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40032355:	83 e0 63             	and    $0x63,%eax
}
40032358:	5e                   	pop    %esi
40032359:	5d                   	pop    %ebp
4003235a:	c3                   	ret    

4003235b <mraa_gpio_owner>:
}


mraa_result_t
mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
{
4003235b:	55                   	push   %ebp
    if (dev == NULL) {
4003235c:	85 c0                	test   %eax,%eax
{
4003235e:	89 e5                	mov    %esp,%ebp
    if (dev == NULL) {
40032360:	74 07                	je     40032369 <mraa_gpio_owner+0xe>
        return MRAA_ERROR_INVALID_RESOURCE;
    }
    dev->owner = own;
40032362:	88 50 14             	mov    %dl,0x14(%eax)
    return MRAA_SUCCESS;
40032365:	31 c0                	xor    %eax,%eax
40032367:	eb 05                	jmp    4003236e <mraa_gpio_owner+0x13>
        return MRAA_ERROR_INVALID_RESOURCE;
40032369:	b8 07 00 00 00       	mov    $0x7,%eax
}
4003236e:	5d                   	pop    %ebp
4003236f:	c3                   	ret    

40032370 <mraa_gpio_mode>:

mraa_result_t
mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
{
40032370:	55                   	push   %ebp
    return MRAA_SUCCESS;
}
40032371:	31 c0                	xor    %eax,%eax
{
40032373:	89 e5                	mov    %esp,%ebp
}
40032375:	5d                   	pop    %ebp
40032376:	c3                   	ret    

40032377 <mraa_gpio_close>:
    return dev->pin;
}

mraa_result_t
mraa_gpio_close(mraa_gpio_context dev)
{
40032377:	55                   	push   %ebp
40032378:	89 e5                	mov    %esp,%ebp
    free(dev);
4003237a:	e8 90 24 00 00       	call   4003480f <free>

    return MRAA_SUCCESS;
}
4003237f:	31 c0                	xor    %eax,%eax
40032381:	5d                   	pop    %ebp
40032382:	c3                   	ret    

40032383 <spi_configure>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
40032383:	55                   	push   %ebp
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
40032384:	8b 48 04             	mov    0x4(%eax),%ecx
{
40032387:	89 e5                	mov    %esp,%ebp
}
40032389:	5d                   	pop    %ebp
	return api->configure(dev, config);
4003238a:	8b 09                	mov    (%ecx),%ecx
4003238c:	ff e1                	jmp    *%ecx

4003238e <spi_transceive>:
 * @retval Negative errno code if failure.
 */
static inline int spi_transceive(struct device *dev,
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
4003238e:	55                   	push   %ebp
4003238f:	89 e5                	mov    %esp,%ebp
40032391:	53                   	push   %ebx
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
40032392:	8b 58 04             	mov    0x4(%eax),%ebx
40032395:	ff 75 0c             	pushl  0xc(%ebp)
40032398:	ff 75 08             	pushl  0x8(%ebp)
4003239b:	ff 53 08             	call   *0x8(%ebx)
4003239e:	5a                   	pop    %edx
4003239f:	59                   	pop    %ecx
}
400323a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400323a3:	c9                   	leave  
400323a4:	c3                   	ret    

400323a5 <mraa_spi_init>:

typedef struct spi_config* spi_config_ptr;

mraa_spi_context
mraa_spi_init(int bus)
{
400323a5:	55                   	push   %ebp
400323a6:	89 e5                	mov    %esp,%ebp
400323a8:	56                   	push   %esi
400323a9:	89 c6                	mov    %eax,%esi
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
400323ab:	b8 10 00 00 00       	mov    $0x10,%eax
{
400323b0:	53                   	push   %ebx
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
400323b1:	e8 49 24 00 00       	call   400347ff <malloc>
400323b6:	89 c3                	mov    %eax,%ebx
    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);

    dev->pinmux_dev = pinmux_dev;
#endif

    dev->busnum = bus;
400323b8:	89 f0                	mov    %esi,%eax
400323ba:	88 03                	mov    %al,(%ebx)
    dev->zdev = device_get_binding(SPI_DRV_NAME);
400323bc:	b8 27 5d 03 40       	mov    $0x40035d27,%eax
400323c1:	e8 35 19 00 00       	call   40033cfb <device_get_binding>
400323c6:	89 43 08             	mov    %eax,0x8(%ebx)
    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
400323c9:	b8 08 00 00 00       	mov    $0x8,%eax
400323ce:	e8 2c 24 00 00       	call   400347ff <malloc>
400323d3:	89 c6                	mov    %eax,%esi
    // only default settings, can be changed by using the other functions provided
    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
400323d5:	c7 00 83 00 00 00    	movl   $0x83,(%eax)
    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
400323db:	c7 40 04 80 00 00 00 	movl   $0x80,0x4(%eax)
    dev->config = conf;

    if (spi_configure(dev->zdev, dev->config) != 0) {
400323e2:	89 f2                	mov    %esi,%edx
    dev->config = conf;
400323e4:	89 43 04             	mov    %eax,0x4(%ebx)
    if (spi_configure(dev->zdev, dev->config) != 0) {
400323e7:	8b 43 08             	mov    0x8(%ebx),%eax
400323ea:	e8 94 ff ff ff       	call   40032383 <spi_configure>
400323ef:	85 c0                	test   %eax,%eax
400323f1:	74 1d                	je     40032410 <mraa_spi_init+0x6b>
        printf("Unable to configure the SPI Driver\n");
400323f3:	68 bf 5e 03 40       	push   $0x40035ebf
400323f8:	e8 ae 25 00 00       	call   400349ab <iprintf>
400323fd:	58                   	pop    %eax
        free(conf);
400323fe:	89 f0                	mov    %esi,%eax
40032400:	e8 0a 24 00 00       	call   4003480f <free>
        free(dev);
40032405:	89 d8                	mov    %ebx,%eax
40032407:	e8 03 24 00 00       	call   4003480f <free>
        return NULL;
4003240c:	31 db                	xor    %ebx,%ebx
4003240e:	eb 14                	jmp    40032424 <mraa_spi_init+0x7f>
    }

    spi_slave_select(dev->zdev, SPI_SLAVE);
40032410:	8b 43 08             	mov    0x8(%ebx),%eax
	if (!api->slave_select) {
40032413:	8b 50 04             	mov    0x4(%eax),%edx
40032416:	8b 4a 04             	mov    0x4(%edx),%ecx
40032419:	85 c9                	test   %ecx,%ecx
4003241b:	74 07                	je     40032424 <mraa_spi_init+0x7f>
	return api->slave_select(dev, slave);
4003241d:	ba 01 00 00 00       	mov    $0x1,%edx
40032422:	ff d1                	call   *%ecx

    return dev;
}
40032424:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032427:	89 d8                	mov    %ebx,%eax
40032429:	5b                   	pop    %ebx
4003242a:	5e                   	pop    %esi
4003242b:	5d                   	pop    %ebp
4003242c:	c3                   	ret    

4003242d <mraa_spi_frequency>:

mraa_result_t
mraa_spi_frequency(mraa_spi_context dev, int hz)
{
    uint32_t freq = 0;
    if (hz > 0) {
4003242d:	85 d2                	test   %edx,%edx
4003242f:	7e 2f                	jle    40032460 <mraa_spi_frequency+0x33>
{
40032431:	55                   	push   %ebp
40032432:	89 d1                	mov    %edx,%ecx
40032434:	89 e5                	mov    %esp,%ebp
40032436:	56                   	push   %esi
40032437:	53                   	push   %ebx
40032438:	89 c3                	mov    %eax,%ebx
        freq = sys_clock_hw_cycles_per_sec / hz;
    } else {
        return MRAA_ERROR_INVALID_PARAMETER;
    }

    dev->config->max_sys_freq = freq;
4003243a:	8b 70 04             	mov    0x4(%eax),%esi
        freq = sys_clock_hw_cycles_per_sec / hz;
4003243d:	b8 00 48 e8 01       	mov    $0x1e84800,%eax
40032442:	99                   	cltd   
40032443:	f7 f9                	idiv   %ecx
    dev->config->max_sys_freq = freq;
40032445:	89 46 04             	mov    %eax,0x4(%esi)
    if (spi_configure(dev->zdev, dev->config) != 0) {
40032448:	89 f2                	mov    %esi,%edx
4003244a:	8b 43 08             	mov    0x8(%ebx),%eax
4003244d:	e8 31 ff ff ff       	call   40032383 <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
40032452:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40032453:	83 f8 01             	cmp    $0x1,%eax
}
40032456:	5e                   	pop    %esi
    return MRAA_SUCCESS;
40032457:	19 c0                	sbb    %eax,%eax
}
40032459:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
4003245a:	f7 d0                	not    %eax
4003245c:	83 e0 63             	and    $0x63,%eax
}
4003245f:	c3                   	ret    
        return MRAA_ERROR_INVALID_PARAMETER;
40032460:	b8 04 00 00 00       	mov    $0x4,%eax
40032465:	c3                   	ret    

40032466 <mraa_spi_transfer_buf>:
    return MRAA_SUCCESS;
}

mraa_result_t
mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
{
40032466:	55                   	push   %ebp
40032467:	89 e5                	mov    %esp,%ebp
40032469:	53                   	push   %ebx
    mraa_result_t ret;
//printf("data %x %x\n", data[0], data[1]);
//k_busy_wait(1000);
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
4003246a:	8b 40 08             	mov    0x8(%eax),%eax
{
4003246d:	8b 5d 08             	mov    0x8(%ebp),%ebx
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40032470:	53                   	push   %ebx
40032471:	51                   	push   %ecx
40032472:	89 d9                	mov    %ebx,%ecx
40032474:	e8 15 ff ff ff       	call   4003238e <spi_transceive>
40032479:	5a                   	pop    %edx
4003247a:	59                   	pop    %ecx

    return ret;
}
4003247b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4003247e:	c9                   	leave  
4003247f:	c3                   	ret    

40032480 <mraa_intel_quark_se_devboard>:
#include "mraa/gpio.h"

static mraa_board_t _board;

mraa_board_t* mraa_intel_quark_se_devboard()
{
40032480:	55                   	push   %ebp
    mraa_board_t* b = &_board;
    mraa_set_board_config(b);
40032481:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
{
40032486:	89 e5                	mov    %esp,%ebp
40032488:	57                   	push   %edi
40032489:	56                   	push   %esi
4003248a:	53                   	push   %ebx
4003248b:	83 ec 10             	sub    $0x10,%esp
    mraa_set_board_config(b);
4003248e:	e8 b8 fc ff ff       	call   4003214b <mraa_set_board_config>
b->phy_pin_count = 94;
    //b->platform_type = MRAA_INTEL_QUARK_SE_DEVBOARD;

// header - J14
#if 1
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032493:	b9 01 00 00 00       	mov    $0x1,%ecx
40032498:	ba 01 00 00 00       	mov    $0x1,%edx
4003249d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400324a2:	6a 00                	push   $0x0
    b->platform_name = "Quark SE Devboard/C1000 x86";
400324a4:	c7 05 9c 69 00 a8 e3 	movl   $0x40035ee3,0xa800699c
400324ab:	5e 03 40 
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324ae:	68 ff 5e 03 40       	push   $0x40035eff
b->phy_pin_count = 94;
400324b3:	c6 05 60 69 00 a8 5e 	movb   $0x5e,0xa8006960
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324ba:	e8 61 fc ff ff       	call   40032120 <mraa_set_pininfo>
400324bf:	5a                   	pop    %edx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
400324c0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400324c5:	59                   	pop    %ecx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
400324c6:	ba 02 00 00 00       	mov    $0x2,%edx
400324cb:	b9 02 00 00 00       	mov    $0x2,%ecx
400324d0:	6a 00                	push   $0x0
400324d2:	68 ff 5e 03 40       	push   $0x40035eff
400324d7:	e8 44 fc ff ff       	call   40032120 <mraa_set_pininfo>
400324dc:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400324dd:	b9 1f 00 00 00       	mov    $0x1f,%ecx
400324e2:	8a 1d 80 5c 03 40    	mov    0x40035c80,%bl
400324e8:	ba 03 00 00 00       	mov    $0x3,%edx
400324ed:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
400324f2:	5e                   	pop    %esi
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400324f3:	53                   	push   %ebx
400324f4:	68 07 5f 03 40       	push   $0x40035f07
400324f9:	e8 22 fc ff ff       	call   40032120 <mraa_set_pininfo>
400324fe:	5f                   	pop    %edi
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400324ff:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032501:	58                   	pop    %eax
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032502:	ba 04 00 00 00       	mov    $0x4,%edx
40032507:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003250c:	53                   	push   %ebx
4003250d:	68 1b 5f 03 40       	push   $0x40035f1b
40032512:	e8 09 fc ff ff       	call   40032120 <mraa_set_pininfo>
40032517:	58                   	pop    %eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032518:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003251d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003251e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032523:	ba 05 00 00 00       	mov    $0x5,%edx
40032528:	53                   	push   %ebx
40032529:	68 31 5f 03 40       	push   $0x40035f31
4003252e:	e8 ed fb ff ff       	call   40032120 <mraa_set_pininfo>
40032533:	59                   	pop    %ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032534:	ba 06 00 00 00       	mov    $0x6,%edx
40032539:	b9 12 00 00 00       	mov    $0x12,%ecx
4003253e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032543:	5e                   	pop    %esi
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032544:	53                   	push   %ebx
40032545:	68 44 5f 03 40       	push   $0x40035f44
4003254a:	e8 d1 fb ff ff       	call   40032120 <mraa_set_pininfo>
4003254f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032550:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032555:	58                   	pop    %eax
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032556:	ba 07 00 00 00       	mov    $0x7,%edx
4003255b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032560:	53                   	push   %ebx
40032561:	68 5a 5f 03 40       	push   $0x40035f5a
40032566:	e8 b5 fb ff ff       	call   40032120 <mraa_set_pininfo>
4003256b:	58                   	pop    %eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003256c:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032571:	5a                   	pop    %edx
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032572:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032577:	ba 08 00 00 00       	mov    $0x8,%edx
4003257c:	53                   	push   %ebx
4003257d:	68 77 5f 03 40       	push   $0x40035f77
40032582:	e8 99 fb ff ff       	call   40032120 <mraa_set_pininfo>
40032587:	59                   	pop    %ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032588:	ba 09 00 00 00       	mov    $0x9,%edx
4003258d:	b9 03 00 00 00       	mov    $0x3,%ecx
40032592:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032597:	5e                   	pop    %esi
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032598:	53                   	push   %ebx
40032599:	68 83 5f 03 40       	push   $0x40035f83
4003259e:	e8 7d fb ff ff       	call   40032120 <mraa_set_pininfo>
400325a3:	5f                   	pop    %edi
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325a4:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325a9:	58                   	pop    %eax
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325aa:	ba 0a 00 00 00       	mov    $0xa,%edx
400325af:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325b4:	53                   	push   %ebx
400325b5:	68 a0 5f 03 40       	push   $0x40035fa0
400325ba:	e8 61 fb ff ff       	call   40032120 <mraa_set_pininfo>
400325bf:	58                   	pop    %eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325c0:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325c5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325c6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400325cb:	ba 0b 00 00 00       	mov    $0xb,%edx
400325d0:	6a 00                	push   $0x0
400325d2:	68 ac 5f 03 40       	push   $0x40035fac
400325d7:	e8 44 fb ff ff       	call   40032120 <mraa_set_pininfo>
400325dc:	59                   	pop    %ecx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325dd:	ba 0c 00 00 00       	mov    $0xc,%edx
400325e2:	b9 0c 00 00 00       	mov    $0xc,%ecx
400325e7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325ec:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400325ed:	6a 00                	push   $0x0
400325ef:	68 ac 5f 03 40       	push   $0x40035fac
400325f4:	e8 27 fb ff ff       	call   40032120 <mraa_set_pininfo>
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400325f9:	8a 1d 81 5c 03 40    	mov    0x40035c81,%bl
400325ff:	b9 04 00 00 00       	mov    $0x4,%ecx
40032604:	ba 0d 00 00 00       	mov    $0xd,%edx
40032609:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003260e:	5e                   	pop    %esi
4003260f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032610:	53                   	push   %ebx
40032611:	68 b0 5f 03 40       	push   $0x40035fb0
40032616:	e8 05 fb ff ff       	call   40032120 <mraa_set_pininfo>
4003261b:	58                   	pop    %eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003261c:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032621:	5a                   	pop    %edx
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032622:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032627:	ba 0e 00 00 00       	mov    $0xe,%edx
4003262c:	6a 01                	push   $0x1
4003262e:	68 be 5f 03 40       	push   $0x40035fbe
40032633:	e8 e8 fa ff ff       	call   40032120 <mraa_set_pininfo>
40032638:	59                   	pop    %ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032639:	ba 0f 00 00 00       	mov    $0xf,%edx
4003263e:	b9 05 00 00 00       	mov    $0x5,%ecx
40032643:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032648:	5e                   	pop    %esi
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032649:	53                   	push   %ebx
4003264a:	68 d0 5f 03 40       	push   $0x40035fd0
4003264f:	e8 cc fa ff ff       	call   40032120 <mraa_set_pininfo>
40032654:	5f                   	pop    %edi
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032655:	b9 10 00 00 00       	mov    $0x10,%ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003265a:	58                   	pop    %eax
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003265b:	ba 10 00 00 00       	mov    $0x10,%edx
40032660:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032665:	6a 01                	push   $0x1
40032667:	68 de 5f 03 40       	push   $0x40035fde
4003266c:	e8 af fa ff ff       	call   40032120 <mraa_set_pininfo>
40032671:	58                   	pop    %eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032672:	b9 06 00 00 00       	mov    $0x6,%ecx
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032677:	5a                   	pop    %edx
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032678:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003267d:	ba 11 00 00 00       	mov    $0x11,%edx
40032682:	53                   	push   %ebx
40032683:	68 f0 5f 03 40       	push   $0x40035ff0
40032688:	e8 93 fa ff ff       	call   40032120 <mraa_set_pininfo>
4003268d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003268e:	ba 12 00 00 00       	mov    $0x12,%edx
40032693:	b9 12 00 00 00       	mov    $0x12,%ecx
40032698:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003269d:	5e                   	pop    %esi
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003269e:	6a 01                	push   $0x1
400326a0:	68 02 60 03 40       	push   $0x40036002
400326a5:	e8 76 fa ff ff       	call   40032120 <mraa_set_pininfo>
400326aa:	5f                   	pop    %edi
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400326ab:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326b0:	58                   	pop    %eax
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400326b1:	ba 13 00 00 00       	mov    $0x13,%edx
400326b6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400326bb:	53                   	push   %ebx
400326bc:	68 14 60 03 40       	push   $0x40036014
400326c1:	e8 5a fa ff ff       	call   40032120 <mraa_set_pininfo>
400326c6:	58                   	pop    %eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326c7:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400326cc:	5a                   	pop    %edx
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326cd:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400326d2:	ba 14 00 00 00       	mov    $0x14,%edx
400326d7:	6a 01                	push   $0x1
400326d9:	68 2b 60 03 40       	push   $0x4003602b
400326de:	e8 3d fa ff ff       	call   40032120 <mraa_set_pininfo>
400326e3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400326e4:	ba 15 00 00 00       	mov    $0x15,%edx
400326e9:	b9 0f 00 00 00       	mov    $0xf,%ecx
400326ee:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326f3:	5e                   	pop    %esi
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400326f4:	53                   	push   %ebx
400326f5:	68 3d 60 03 40       	push   $0x4003603d
400326fa:	e8 21 fa ff ff       	call   40032120 <mraa_set_pininfo>
400326ff:	5f                   	pop    %edi
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40032700:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40032705:	58                   	pop    %eax
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40032706:	ba 16 00 00 00       	mov    $0x16,%edx
4003270b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032710:	6a 01                	push   $0x1
40032712:	68 54 60 03 40       	push   $0x40036054
40032717:	e8 04 fa ff ff       	call   40032120 <mraa_set_pininfo>
4003271c:	58                   	pop    %eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003271d:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
40032722:	5a                   	pop    %edx
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032723:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032728:	ba 17 00 00 00       	mov    $0x17,%edx
4003272d:	6a 00                	push   $0x0
4003272f:	68 ff 5e 03 40       	push   $0x40035eff
40032734:	e8 e7 f9 ff ff       	call   40032120 <mraa_set_pininfo>
40032739:	59                   	pop    %ecx
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003273a:	ba 18 00 00 00       	mov    $0x18,%edx
4003273f:	b9 14 00 00 00       	mov    $0x14,%ecx
40032744:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032749:	5e                   	pop    %esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003274a:	6a 01                	push   $0x1
4003274c:	68 66 60 03 40       	push   $0x40036066
40032751:	e8 ca f9 ff ff       	call   40032120 <mraa_set_pininfo>
40032756:	5f                   	pop    %edi
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032757:	0f b6 35 82 5c 03 40 	movzbl 0x40035c82,%esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003275e:	58                   	pop    %eax
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003275f:	31 c9                	xor    %ecx,%ecx
40032761:	ba 19 00 00 00       	mov    $0x19,%edx
40032766:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003276b:	56                   	push   %esi
4003276c:	68 78 60 03 40       	push   $0x40036078
40032771:	e8 aa f9 ff ff       	call   40032120 <mraa_set_pininfo>
40032776:	58                   	pop    %eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032777:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003277c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003277d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032782:	ba 1a 00 00 00       	mov    $0x1a,%edx
40032787:	6a 00                	push   $0x0
40032789:	68 ff 5e 03 40       	push   $0x40035eff
4003278e:	e8 8d f9 ff ff       	call   40032120 <mraa_set_pininfo>
40032793:	59                   	pop    %ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032794:	ba 1b 00 00 00       	mov    $0x1b,%edx
40032799:	b9 01 00 00 00       	mov    $0x1,%ecx
4003279e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400327a3:	5f                   	pop    %edi
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400327a4:	56                   	push   %esi
400327a5:	68 8a 60 03 40       	push   $0x4003608a
400327aa:	e8 71 f9 ff ff       	call   40032120 <mraa_set_pininfo>
400327af:	58                   	pop    %eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400327b0:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400327b5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400327b6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400327bb:	ba 1c 00 00 00       	mov    $0x1c,%edx
400327c0:	53                   	push   %ebx
400327c1:	68 9c 60 03 40       	push   $0x4003609c
400327c6:	e8 55 f9 ff ff       	call   40032120 <mraa_set_pininfo>
400327cb:	59                   	pop    %ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400327cc:	ba 1d 00 00 00       	mov    $0x1d,%edx
400327d1:	b9 02 00 00 00       	mov    $0x2,%ecx
400327d6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400327db:	5f                   	pop    %edi
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400327dc:	56                   	push   %esi
400327dd:	68 ae 60 03 40       	push   $0x400360ae
400327e2:	e8 39 f9 ff ff       	call   40032120 <mraa_set_pininfo>
400327e7:	58                   	pop    %eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400327e8:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400327ed:	5a                   	pop    %edx
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400327ee:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400327f3:	ba 1e 00 00 00       	mov    $0x1e,%edx
400327f8:	53                   	push   %ebx
400327f9:	68 c0 60 03 40       	push   $0x400360c0
400327fe:	e8 1d f9 ff ff       	call   40032120 <mraa_set_pininfo>
40032803:	59                   	pop    %ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032804:	ba 1f 00 00 00       	mov    $0x1f,%edx
40032809:	b9 03 00 00 00       	mov    $0x3,%ecx
4003280e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032813:	5f                   	pop    %edi
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032814:	56                   	push   %esi
40032815:	68 d3 60 03 40       	push   $0x400360d3
4003281a:	e8 01 f9 ff ff       	call   40032120 <mraa_set_pininfo>
4003281f:	58                   	pop    %eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032820:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032825:	5a                   	pop    %edx
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032826:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003282b:	ba 20 00 00 00       	mov    $0x20,%edx
40032830:	53                   	push   %ebx
40032831:	68 e5 60 03 40       	push   $0x400360e5
40032836:	e8 e5 f8 ff ff       	call   40032120 <mraa_set_pininfo>
4003283b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003283c:	ba 21 00 00 00       	mov    $0x21,%edx
40032841:	b9 21 00 00 00       	mov    $0x21,%ecx
40032846:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003284b:	5e                   	pop    %esi
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003284c:	6a 00                	push   $0x0
4003284e:	68 ac 5f 03 40       	push   $0x40035fac
40032853:	e8 c8 f8 ff ff       	call   40032120 <mraa_set_pininfo>
40032858:	5f                   	pop    %edi
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032859:	b9 12 00 00 00       	mov    $0x12,%ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003285e:	58                   	pop    %eax
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003285f:	ba 22 00 00 00       	mov    $0x22,%edx
40032864:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032869:	53                   	push   %ebx
4003286a:	68 f7 60 03 40       	push   $0x400360f7
4003286f:	e8 ac f8 ff ff       	call   40032120 <mraa_set_pininfo>
40032874:	58                   	pop    %eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032875:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032877:	5a                   	pop    %edx
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032878:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003287d:	ba 23 00 00 00       	mov    $0x23,%edx
40032882:	53                   	push   %ebx
40032883:	68 0a 61 03 40       	push   $0x4003610a
40032888:	e8 93 f8 ff ff       	call   40032120 <mraa_set_pininfo>
4003288d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003288e:	ba 24 00 00 00       	mov    $0x24,%edx
40032893:	b9 13 00 00 00       	mov    $0x13,%ecx
40032898:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003289d:	5e                   	pop    %esi
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003289e:	53                   	push   %ebx
4003289f:	68 17 61 03 40       	push   $0x40036117
400328a4:	e8 77 f8 ff ff       	call   40032120 <mraa_set_pininfo>
400328a9:	5f                   	pop    %edi
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400328aa:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328af:	58                   	pop    %eax
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400328b0:	ba 25 00 00 00       	mov    $0x25,%edx
400328b5:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400328ba:	53                   	push   %ebx
400328bb:	68 29 61 03 40       	push   $0x40036129
400328c0:	e8 5b f8 ff ff       	call   40032120 <mraa_set_pininfo>
400328c5:	58                   	pop    %eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328c6:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400328cb:	5a                   	pop    %edx
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328cc:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400328d1:	ba 26 00 00 00       	mov    $0x26,%edx
400328d6:	53                   	push   %ebx
400328d7:	68 36 61 03 40       	push   $0x40036136
400328dc:	e8 3f f8 ff ff       	call   40032120 <mraa_set_pininfo>
400328e1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400328e2:	ba 27 00 00 00       	mov    $0x27,%edx
400328e7:	b9 02 00 00 00       	mov    $0x2,%ecx
400328ec:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328f1:	5e                   	pop    %esi
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400328f2:	53                   	push   %ebx
400328f3:	68 48 61 03 40       	push   $0x40036148
400328f8:	e8 23 f8 ff ff       	call   40032120 <mraa_set_pininfo>
400328fd:	5f                   	pop    %edi
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400328fe:	b9 28 00 00 00       	mov    $0x28,%ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032903:	58                   	pop    %eax
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032904:	ba 28 00 00 00       	mov    $0x28,%edx
40032909:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003290e:	6a 00                	push   $0x0
40032910:	68 ac 5f 03 40       	push   $0x40035fac
40032915:	e8 06 f8 ff ff       	call   40032120 <mraa_set_pininfo>
4003291a:	58                   	pop    %eax
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003291b:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032920:	5a                   	pop    %edx
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032921:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032926:	ba 29 00 00 00       	mov    $0x29,%edx
4003292b:	53                   	push   %ebx
4003292c:	68 55 61 03 40       	push   $0x40036155
40032931:	e8 ea f7 ff ff       	call   40032120 <mraa_set_pininfo>
40032936:	59                   	pop    %ecx
40032937:	5e                   	pop    %esi
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032938:	b9 01 00 00 00       	mov    $0x1,%ecx
4003293d:	0f b6 35 83 5c 03 40 	movzbl 0x40035c83,%esi
40032944:	ba 2a 00 00 00       	mov    $0x2a,%edx
40032949:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003294e:	56                   	push   %esi
4003294f:	68 62 61 03 40       	push   $0x40036162
40032954:	e8 c7 f7 ff ff       	call   40032120 <mraa_set_pininfo>
40032959:	5f                   	pop    %edi
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003295a:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003295f:	58                   	pop    %eax
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032960:	ba 2b 00 00 00       	mov    $0x2b,%edx
40032965:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
4003296a:	53                   	push   %ebx
4003296b:	68 71 61 03 40       	push   $0x40036171
40032970:	e8 ab f7 ff ff       	call   40032120 <mraa_set_pininfo>
40032975:	58                   	pop    %eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032976:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003297b:	5a                   	pop    %edx
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
4003297c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032981:	ba 2c 00 00 00       	mov    $0x2c,%edx
40032986:	56                   	push   %esi
40032987:	68 7e 61 03 40       	push   $0x4003617e
4003298c:	e8 8f f7 ff ff       	call   40032120 <mraa_set_pininfo>
40032991:	59                   	pop    %ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032992:	ba 2d 00 00 00       	mov    $0x2d,%edx
40032997:	b9 05 00 00 00       	mov    $0x5,%ecx
4003299c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
400329a1:	5f                   	pop    %edi
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329a2:	53                   	push   %ebx
400329a3:	68 8d 61 03 40       	push   $0x4003618d
400329a8:	e8 73 f7 ff ff       	call   40032120 <mraa_set_pininfo>
400329ad:	58                   	pop    %eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329ae:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329b0:	5a                   	pop    %edx
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329b1:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400329b6:	ba 2e 00 00 00       	mov    $0x2e,%edx
400329bb:	6a 00                	push   $0x0
400329bd:	68 9a 61 03 40       	push   $0x4003619a
400329c2:	e8 59 f7 ff ff       	call   40032120 <mraa_set_pininfo>
400329c7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400329c8:	ba 2f 00 00 00       	mov    $0x2f,%edx
400329cd:	b9 07 00 00 00       	mov    $0x7,%ecx
400329d2:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329d7:	5f                   	pop    %edi
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400329d8:	53                   	push   %ebx
400329d9:	68 a0 61 03 40       	push   $0x400361a0
400329de:	e8 3d f7 ff ff       	call   40032120 <mraa_set_pininfo>
400329e3:	58                   	pop    %eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329e4:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400329e6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329e7:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
400329ec:	ba 30 00 00 00       	mov    $0x30,%edx
400329f1:	6a 00                	push   $0x0
400329f3:	68 ae 61 03 40       	push   $0x400361ae
400329f8:	e8 23 f7 ff ff       	call   40032120 <mraa_set_pininfo>
400329fd:	59                   	pop    %ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329fe:	ba 31 00 00 00       	mov    $0x31,%edx
40032a03:	b9 31 00 00 00       	mov    $0x31,%ecx
40032a08:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a0d:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a0e:	6a 00                	push   $0x0
40032a10:	68 ff 5e 03 40       	push   $0x40035eff
40032a15:	e8 06 f7 ff ff       	call   40032120 <mraa_set_pininfo>
40032a1a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a1b:	b9 32 00 00 00       	mov    $0x32,%ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a20:	58                   	pop    %eax
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a21:	ba 32 00 00 00       	mov    $0x32,%edx
40032a26:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032a2b:	6a 00                	push   $0x0
40032a2d:	68 ff 5e 03 40       	push   $0x40035eff
40032a32:	e8 e9 f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032a37:	58                   	pop    %eax
#endif
// the other big header - J15
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a38:	b9 33 00 00 00       	mov    $0x33,%ecx
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a3d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a3e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032a43:	ba 33 00 00 00       	mov    $0x33,%edx
40032a48:	6a 00                	push   $0x0
40032a4a:	68 ff 5e 03 40       	push   $0x40035eff
40032a4f:	e8 cc f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032a54:	59                   	pop    %ecx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a55:	ba 34 00 00 00       	mov    $0x34,%edx
40032a5a:	b9 34 00 00 00       	mov    $0x34,%ecx
40032a5f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a64:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a65:	6a 00                	push   $0x0
40032a67:	68 ff 5e 03 40       	push   $0x40035eff
40032a6c:	e8 af f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032a71:	5f                   	pop    %edi
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032a72:	0f b6 3d 84 5c 03 40 	movzbl 0x40035c84,%edi
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a79:	58                   	pop    %eax
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032a7a:	31 c9                	xor    %ecx,%ecx
40032a7c:	ba 35 00 00 00       	mov    $0x35,%edx
40032a81:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032a86:	57                   	push   %edi
40032a87:	68 bc 61 03 40       	push   $0x400361bc
40032a8c:	e8 8f f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032a91:	58                   	pop    %eax
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032a92:	8a 1d 85 5c 03 40    	mov    0x40035c85,%bl
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032a98:	5a                   	pop    %edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032a99:	b9 15 00 00 00       	mov    $0x15,%ecx
40032a9e:	ba 36 00 00 00       	mov    $0x36,%edx
40032aa3:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032aa8:	53                   	push   %ebx
40032aa9:	68 cb 61 03 40       	push   $0x400361cb
40032aae:	e8 6d f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032ab3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032ab4:	ba 37 00 00 00       	mov    $0x37,%edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ab9:	58                   	pop    %eax
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032aba:	31 c9                	xor    %ecx,%ecx
40032abc:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032ac1:	57                   	push   %edi
40032ac2:	68 e0 61 03 40       	push   $0x400361e0
40032ac7:	e8 54 f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032acc:	58                   	pop    %eax
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032acd:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032ad2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ad3:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032ad8:	ba 38 00 00 00       	mov    $0x38,%edx
40032add:	53                   	push   %ebx
40032ade:	68 f0 61 03 40       	push   $0x400361f0
40032ae3:	e8 38 f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032ae8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032ae9:	ba 39 00 00 00       	mov    $0x39,%edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032aee:	58                   	pop    %eax
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032aef:	31 c9                	xor    %ecx,%ecx
40032af1:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032af6:	57                   	push   %edi
40032af7:	68 06 62 03 40       	push   $0x40036206
40032afc:	e8 1f f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032b01:	58                   	pop    %eax
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b02:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b07:	5a                   	pop    %edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b08:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b0d:	ba 3a 00 00 00       	mov    $0x3a,%edx
40032b12:	53                   	push   %ebx
40032b13:	68 16 62 03 40       	push   $0x40036216
40032b18:	e8 03 f6 ff ff       	call   40032120 <mraa_set_pininfo>
40032b1d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b1e:	ba 3b 00 00 00       	mov    $0x3b,%edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b23:	58                   	pop    %eax
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b24:	31 c9                	xor    %ecx,%ecx
40032b26:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b2b:	57                   	push   %edi
40032b2c:	68 2c 62 03 40       	push   $0x4003622c
40032b31:	e8 ea f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032b36:	58                   	pop    %eax
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b37:	b9 18 00 00 00       	mov    $0x18,%ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b3c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b3d:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b42:	ba 3c 00 00 00       	mov    $0x3c,%edx
40032b47:	53                   	push   %ebx
40032b48:	68 3d 62 03 40       	push   $0x4003623d
40032b4d:	e8 ce f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032b52:	59                   	pop    %ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b53:	ba 3d 00 00 00       	mov    $0x3d,%edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b58:	58                   	pop    %eax
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b59:	31 c9                	xor    %ecx,%ecx
40032b5b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b60:	57                   	push   %edi
40032b61:	68 54 62 03 40       	push   $0x40036254
40032b66:	e8 b5 f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032b6b:	58                   	pop    %eax
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b6c:	b9 19 00 00 00       	mov    $0x19,%ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b71:	5a                   	pop    %edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b72:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b77:	ba 3e 00 00 00       	mov    $0x3e,%edx
40032b7c:	53                   	push   %ebx
40032b7d:	68 65 62 03 40       	push   $0x40036265
40032b82:	e8 99 f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032b87:	59                   	pop    %ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b88:	ba 3f 00 00 00       	mov    $0x3f,%edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b8d:	58                   	pop    %eax
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b8e:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40032b93:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032b98:	53                   	push   %ebx
40032b99:	68 7c 62 03 40       	push   $0x4003627c
40032b9e:	e8 7d f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032ba3:	58                   	pop    %eax
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ba4:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ba9:	5a                   	pop    %edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032baa:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032baf:	ba 40 00 00 00       	mov    $0x40,%edx
40032bb4:	53                   	push   %ebx
40032bb5:	68 94 62 03 40       	push   $0x40036294
40032bba:	e8 61 f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032bbf:	59                   	pop    %ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bc0:	ba 41 00 00 00       	mov    $0x41,%edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bc5:	58                   	pop    %eax
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bc6:	b9 1e 00 00 00       	mov    $0x1e,%ecx
40032bcb:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032bd0:	53                   	push   %ebx
40032bd1:	68 ab 62 03 40       	push   $0x400362ab
40032bd6:	e8 45 f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032bdb:	58                   	pop    %eax
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bdc:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032be1:	5a                   	pop    %edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032be2:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032be7:	ba 42 00 00 00       	mov    $0x42,%edx
40032bec:	53                   	push   %ebx
40032bed:	68 c3 62 03 40       	push   $0x400362c3
40032bf2:	e8 29 f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032bf7:	59                   	pop    %ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032bf8:	ba 43 00 00 00       	mov    $0x43,%edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bfd:	58                   	pop    %eax
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032bfe:	b9 43 00 00 00       	mov    $0x43,%ecx
40032c03:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c08:	6a 00                	push   $0x0
40032c0a:	68 ac 5f 03 40       	push   $0x40035fac
40032c0f:	e8 0c f5 ff ff       	call   40032120 <mraa_set_pininfo>
40032c14:	58                   	pop    %eax
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032c15:	b9 44 00 00 00       	mov    $0x44,%ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032c1a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032c1b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c20:	ba 44 00 00 00       	mov    $0x44,%edx
40032c25:	6a 00                	push   $0x0
40032c27:	68 ac 5f 03 40       	push   $0x40035fac
40032c2c:	e8 ef f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032c31:	59                   	pop    %ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c32:	ba 45 00 00 00       	mov    $0x45,%edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032c37:	58                   	pop    %eax
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c38:	31 c9                	xor    %ecx,%ecx
40032c3a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c3f:	57                   	push   %edi
40032c40:	68 de 62 03 40       	push   $0x400362de
40032c45:	e8 d6 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032c4a:	58                   	pop    %eax
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c4b:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c50:	5a                   	pop    %edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c51:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c56:	ba 46 00 00 00       	mov    $0x46,%edx
40032c5b:	53                   	push   %ebx
40032c5c:	68 ed 62 03 40       	push   $0x400362ed
40032c61:	e8 ba f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032c66:	59                   	pop    %ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c67:	ba 47 00 00 00       	mov    $0x47,%edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c6c:	58                   	pop    %eax
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c6d:	31 c9                	xor    %ecx,%ecx
40032c6f:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c74:	57                   	push   %edi
40032c75:	68 01 63 03 40       	push   $0x40036301
40032c7a:	e8 a1 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032c7f:	58                   	pop    %eax
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c80:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c85:	5a                   	pop    %edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c86:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032c8b:	ba 48 00 00 00       	mov    $0x48,%edx
40032c90:	53                   	push   %ebx
40032c91:	68 11 63 03 40       	push   $0x40036311
40032c96:	e8 85 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032c9b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c9c:	ba 49 00 00 00       	mov    $0x49,%edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ca1:	58                   	pop    %eax
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032ca2:	31 c9                	xor    %ecx,%ecx
40032ca4:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032ca9:	57                   	push   %edi
40032caa:	68 26 63 03 40       	push   $0x40036326
40032caf:	e8 6c f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032cb4:	58                   	pop    %eax
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cb5:	b9 0a 00 00 00       	mov    $0xa,%ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cba:	5a                   	pop    %edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cbb:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032cc0:	ba 4a 00 00 00       	mov    $0x4a,%edx
40032cc5:	53                   	push   %ebx
40032cc6:	68 36 63 03 40       	push   $0x40036336
40032ccb:	e8 50 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032cd0:	59                   	pop    %ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cd1:	ba 4b 00 00 00       	mov    $0x4b,%edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cd6:	58                   	pop    %eax
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cd7:	31 c9                	xor    %ecx,%ecx
40032cd9:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032cde:	57                   	push   %edi
40032cdf:	68 4c 63 03 40       	push   $0x4003634c
40032ce4:	e8 37 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032ce9:	58                   	pop    %eax
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cea:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cef:	5a                   	pop    %edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cf0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032cf5:	ba 4c 00 00 00       	mov    $0x4c,%edx
40032cfa:	53                   	push   %ebx
40032cfb:	68 5d 63 03 40       	push   $0x4003635d
40032d00:	e8 1b f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032d05:	59                   	pop    %ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d06:	ba 4d 00 00 00       	mov    $0x4d,%edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d0b:	58                   	pop    %eax
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d0c:	31 c9                	xor    %ecx,%ecx
40032d0e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032d13:	57                   	push   %edi
40032d14:	68 74 63 03 40       	push   $0x40036374
40032d19:	e8 02 f4 ff ff       	call   40032120 <mraa_set_pininfo>
40032d1e:	58                   	pop    %eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d1f:	b9 0c 00 00 00       	mov    $0xc,%ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d24:	5a                   	pop    %edx
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d25:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032d2a:	ba 4e 00 00 00       	mov    $0x4e,%edx
40032d2f:	53                   	push   %ebx
40032d30:	68 85 63 03 40       	push   $0x40036385
40032d35:	e8 e6 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032d3a:	59                   	pop    %ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032d3b:	ba 4f 00 00 00       	mov    $0x4f,%edx
40032d40:	b9 4f 00 00 00       	mov    $0x4f,%ecx
40032d45:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d4a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032d4b:	6a 00                	push   $0x0
40032d4d:	68 ff 5e 03 40       	push   $0x40035eff
40032d52:	e8 c9 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032d57:	58                   	pop    %eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d58:	b9 0d 00 00 00       	mov    $0xd,%ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032d5d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d5e:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032d63:	ba 50 00 00 00       	mov    $0x50,%edx
40032d68:	53                   	push   %ebx
40032d69:	68 9c 63 03 40       	push   $0x4003639c
40032d6e:	e8 ad f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032d73:	59                   	pop    %ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032d74:	ba 51 00 00 00       	mov    $0x51,%edx
40032d79:	31 c9                	xor    %ecx,%ecx
40032d7b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d80:	5f                   	pop    %edi
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032d81:	56                   	push   %esi
40032d82:	68 b3 63 03 40       	push   $0x400363b3
40032d87:	e8 94 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032d8c:	58                   	pop    %eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d8d:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032d92:	5a                   	pop    %edx
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d93:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032d98:	ba 52 00 00 00       	mov    $0x52,%edx
40032d9d:	53                   	push   %ebx
40032d9e:	68 bf 63 03 40       	push   $0x400363bf
40032da3:	e8 78 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032da8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032da9:	ba 53 00 00 00       	mov    $0x53,%edx
40032dae:	31 c9                	xor    %ecx,%ecx
40032db0:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032db5:	5f                   	pop    %edi
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032db6:	56                   	push   %esi
40032db7:	68 d6 63 03 40       	push   $0x400363d6
40032dbc:	e8 5f f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032dc1:	58                   	pop    %eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032dc2:	b9 54 00 00 00       	mov    $0x54,%ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032dc7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032dc8:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032dcd:	ba 54 00 00 00       	mov    $0x54,%edx
40032dd2:	6a 00                	push   $0x0
40032dd4:	68 ff 5e 03 40       	push   $0x40035eff
40032dd9:	e8 42 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032dde:	59                   	pop    %ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ddf:	ba 55 00 00 00       	mov    $0x55,%edx
40032de4:	31 c9                	xor    %ecx,%ecx
40032de6:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032deb:	5f                   	pop    %edi
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032dec:	56                   	push   %esi
40032ded:	68 e2 63 03 40       	push   $0x400363e2
40032df2:	e8 29 f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032df7:	58                   	pop    %eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032df8:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032dfd:	5a                   	pop    %edx
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032dfe:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032e03:	ba 56 00 00 00       	mov    $0x56,%edx
40032e08:	53                   	push   %ebx
40032e09:	68 f1 63 03 40       	push   $0x400363f1
40032e0e:	e8 0d f3 ff ff       	call   40032120 <mraa_set_pininfo>
40032e13:	59                   	pop    %ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e14:	ba 57 00 00 00       	mov    $0x57,%edx
40032e19:	31 c9                	xor    %ecx,%ecx
40032e1b:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e20:	5f                   	pop    %edi
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e21:	56                   	push   %esi
40032e22:	68 09 64 03 40       	push   $0x40036409
40032e27:	e8 f4 f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032e2c:	58                   	pop    %eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e2d:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e32:	5a                   	pop    %edx
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e33:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032e38:	ba 58 00 00 00       	mov    $0x58,%edx
40032e3d:	53                   	push   %ebx
40032e3e:	68 18 64 03 40       	push   $0x40036418
40032e43:	e8 d8 f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032e48:	59                   	pop    %ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e49:	ba 59 00 00 00       	mov    $0x59,%edx
40032e4e:	31 c9                	xor    %ecx,%ecx
40032e50:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e55:	5f                   	pop    %edi
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e56:	56                   	push   %esi
40032e57:	68 31 64 03 40       	push   $0x40036431
40032e5c:	e8 bf f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032e61:	58                   	pop    %eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e62:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e67:	5a                   	pop    %edx
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e68:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032e6d:	ba 5a 00 00 00       	mov    $0x5a,%edx
40032e72:	53                   	push   %ebx
40032e73:	68 3d 64 03 40       	push   $0x4003643d
40032e78:	e8 a3 f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032e7d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e7e:	ba 5b 00 00 00       	mov    $0x5b,%edx
40032e83:	31 c9                	xor    %ecx,%ecx
40032e85:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e8a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e8b:	56                   	push   %esi
40032e8c:	68 56 64 03 40       	push   $0x40036456
40032e91:	e8 8a f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032e96:	58                   	pop    %eax
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e97:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e99:	5a                   	pop    %edx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e9a:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032e9f:	ba 5c 00 00 00       	mov    $0x5c,%edx
40032ea4:	53                   	push   %ebx
    b->spi_bus[0].sclk = 13;
    b->spi_bus[0].mosi = 11;
    b->spi_bus[0].miso = 12;
    b->spi_bus[0].cs = 10;

    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032ea5:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ea8:	68 62 64 03 40       	push   $0x40036462
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032ead:	be 88 5c 03 40       	mov    $0x40035c88,%esi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032eb2:	e8 69 f2 ff ff       	call   40032120 <mraa_set_pininfo>
40032eb7:	59                   	pop    %ecx
    struct device* zdev = device_get_binding("GPIO_0");
40032eb8:	b8 34 5d 03 40       	mov    $0x40035d34,%eax
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032ebd:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ec2:	5b                   	pop    %ebx
    b->def_i2c_bus = 0;
40032ec3:	c6 05 6a 69 00 a8 00 	movb   $0x0,0xa800696a
    b->i2c_bus[0].bus_id = 0;
40032eca:	c6 05 64 69 00 a8 00 	movb   $0x0,0xa8006964
    b->pins[18].i2c.mux_total = 0;
40032ed1:	c6 05 8e 6e 00 a8 00 	movb   $0x0,0xa8006e8e
    b->pins[19].i2c.mux_total = 0;
40032ed8:	c6 05 d2 6e 00 a8 00 	movb   $0x0,0xa8006ed2
    b->i2c_bus[0].sda = 18;
40032edf:	c6 05 66 69 00 a8 12 	movb   $0x12,0xa8006966
    b->i2c_bus[0].scl = 19;
40032ee6:	c6 05 65 69 00 a8 13 	movb   $0x13,0xa8006965
    b->spi_bus[0].bus_id = 0;
40032eed:	c6 05 6c 69 00 a8 00 	movb   $0x0,0xa800696c
    b->spi_bus[0].sclk = 13;
40032ef4:	c6 05 6f 69 00 a8 0d 	movb   $0xd,0xa800696f
    b->spi_bus[0].mosi = 11;
40032efb:	c6 05 70 69 00 a8 0b 	movb   $0xb,0xa8006970
    b->spi_bus[0].miso = 12;
40032f02:	c6 05 71 69 00 a8 0c 	movb   $0xc,0xa8006971
    b->spi_bus[0].cs = 10;
40032f09:	c6 05 72 69 00 a8 0a 	movb   $0xa,0xa8006972
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032f10:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    struct device* zdev = device_get_binding("GPIO_0");
40032f12:	e8 e4 0d 00 00       	call   40033cfb <device_get_binding>
    if (zdev != NULL) {
40032f17:	85 c0                	test   %eax,%eax
40032f19:	74 1e                	je     40032f39 <mraa_intel_quark_se_devboard+0xab9>
40032f1b:	89 c6                	mov    %eax,%esi
40032f1d:	31 db                	xor    %ebx,%ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40032f1f:	0f b6 4c 9d e4       	movzbl -0x1c(%ebp,%ebx,4),%ecx
40032f24:	8b 7e 04             	mov    0x4(%esi),%edi
40032f27:	31 d2                	xor    %edx,%edx
40032f29:	89 f0                	mov    %esi,%eax
        for (int i = 0; i<4; ++i) {
40032f2b:	43                   	inc    %ebx
40032f2c:	68 00 01 00 00       	push   $0x100
40032f31:	ff 17                	call   *(%edi)
40032f33:	58                   	pop    %eax
40032f34:	83 fb 04             	cmp    $0x4,%ebx
40032f37:	75 e6                	jne    40032f1f <mraa_intel_quark_se_devboard+0xa9f>
        return NULL;
    }
#endif

    return b;
}
40032f39:	8d 65 f4             	lea    -0xc(%ebp),%esp
40032f3c:	b8 60 69 00 a8       	mov    $0xa8006960,%eax
40032f41:	5b                   	pop    %ebx
40032f42:	5e                   	pop    %esi
40032f43:	5f                   	pop    %edi
40032f44:	5d                   	pop    %ebp
40032f45:	c3                   	ret    

40032f46 <upm_clock_init>:

#endif
}

void upm_clock_init(upm_clock_t *clock)
{
40032f46:	55                   	push   %ebp
40032f47:	89 e5                	mov    %esp,%ebp
40032f49:	53                   	push   %ebx
40032f4a:	89 c3                	mov    %eax,%ebx
#if defined(UPM_PLATFORM_LINUX)

    gettimeofday(clock, NULL);

#elif defined(UPM_PLATFORM_ZEPHYR)
    *clock = k_cycle_get_32();
40032f4c:	e8 eb da ff ff       	call   40030a3c <_timer_cycle_get_32>
40032f51:	89 03                	mov    %eax,(%ebx)
#endif
}
40032f53:	5b                   	pop    %ebx
40032f54:	5d                   	pop    %ebp
40032f55:	c3                   	ret    

40032f56 <upm_elapsed_us>:
    return elapsed;
#endif
}

uint32_t upm_elapsed_us(upm_clock_t *clock)
{
40032f56:	55                   	push   %ebp
40032f57:	89 e5                	mov    %esp,%ebp
40032f59:	56                   	push   %esi
40032f5a:	89 c6                	mov    %eax,%esi
40032f5c:	53                   	push   %ebx
        elapse = 1;

    return elapse;

#elif defined(UPM_PLATFORM_ZEPHYR)
    uint32_t now = k_cycle_get_32();
40032f5d:	e8 da da ff ff       	call   40030a3c <_timer_cycle_get_32>

    uint32_t elapsed =
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40032f62:	2b 06                	sub    (%esi),%eax
40032f64:	89 c3                	mov    %eax,%ebx
40032f66:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40032f6b:	f7 2d f0 66 00 a8    	imull  0xa80066f0
40032f71:	89 d1                	mov    %edx,%ecx
40032f73:	0f af cb             	imul   %ebx,%ecx
40032f76:	f7 e3                	mul    %ebx
40032f78:	01 ca                	add    %ecx,%edx
40032f7a:	8b 0d ec 66 00 a8    	mov    0xa80066ec,%ecx
40032f80:	89 cb                	mov    %ecx,%ebx
40032f82:	c1 fb 1f             	sar    $0x1f,%ebx
40032f85:	53                   	push   %ebx
40032f86:	51                   	push   %ecx
40032f87:	e8 2f d1 ff ff       	call   400300bb <__udivdi3>
40032f8c:	59                   	pop    %ecx
40032f8d:	5b                   	pop    %ebx
40032f8e:	6a 00                	push   $0x0
40032f90:	68 e8 03 00 00       	push   $0x3e8
40032f95:	e8 21 d1 ff ff       	call   400300bb <__udivdi3>
40032f9a:	5e                   	pop    %esi
//printf("hello\n");
    // never return 0
    if (elapsed == 0)
40032f9b:	85 c0                	test   %eax,%eax
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40032f9d:	5a                   	pop    %edx
    if (elapsed == 0)
40032f9e:	75 05                	jne    40032fa5 <upm_elapsed_us+0x4f>
        elapsed = 1;
40032fa0:	b8 01 00 00 00       	mov    $0x1,%eax

    return elapsed;
#endif
}
40032fa5:	8d 65 f8             	lea    -0x8(%ebp),%esp
40032fa8:	5b                   	pop    %ebx
40032fa9:	5e                   	pop    %esi
40032faa:	5d                   	pop    %ebp
40032fab:	c3                   	ret    

40032fac <upm_delay_us>:
{
40032fac:	55                   	push   %ebp
40032fad:	85 c0                	test   %eax,%eax
40032faf:	89 e5                	mov    %esp,%ebp
40032fb1:	53                   	push   %ebx
40032fb2:	bb 01 00 00 00       	mov    $0x1,%ebx
40032fb7:	52                   	push   %edx
40032fb8:	7e 02                	jle    40032fbc <upm_delay_us+0x10>
40032fba:	89 c3                	mov    %eax,%ebx
    upm_clock_init(&timer);
40032fbc:	8d 45 f8             	lea    -0x8(%ebp),%eax
40032fbf:	e8 82 ff ff ff       	call   40032f46 <upm_clock_init>
    while (upm_elapsed_us(&timer) < time)
40032fc4:	8d 45 f8             	lea    -0x8(%ebp),%eax
40032fc7:	e8 8a ff ff ff       	call   40032f56 <upm_elapsed_us>
40032fcc:	39 d8                	cmp    %ebx,%eax
40032fce:	72 f4                	jb     40032fc4 <upm_delay_us+0x18>
}
40032fd0:	58                   	pop    %eax
40032fd1:	5b                   	pop    %ebx
40032fd2:	5d                   	pop    %ebp
40032fd3:	c3                   	ret    

40032fd4 <LoRaClass>:
  //_ss(LORA_DEFAULT_SS_PIN), _reset(LORA_DEFAULT_RESET_PIN), _dio0(LORA_DEFAULT_DIO0_PIN),
  //_frequency(0),
  //_packetIndex(0),
  //_implicitHeaderMode(0),
  //_onReceive(NULL)
{
40032fd4:	55                   	push   %ebp
40032fd5:	89 e5                	mov    %esp,%ebp
    // initialize MRAA
    int mraa_rv;
    if((mraa_rv = mraa_init()) != MRAA_SUCCESS) {
40032fd7:	e8 5f ef ff ff       	call   40031f3b <mraa_init>
40032fdc:	85 c0                	test   %eax,%eax
40032fde:	74 13                	je     40032ff3 <LoRaClass+0x1f>
        printf("%s: mraa_init failed (%d).\n", __FUNCTION__, mraa_rv);
40032fe0:	50                   	push   %eax
40032fe1:	68 1c 69 03 40       	push   $0x4003691c
40032fe6:	68 7b 64 03 40       	push   $0x4003647b
40032feb:	e8 bb 19 00 00       	call   400349ab <iprintf>
40032ff0:	83 c4 0c             	add    $0xc,%esp
    }

    if(!(SX1276.spi = mraa_spi_init(0)))
40032ff3:	31 c0                	xor    %eax,%eax
40032ff5:	e8 ab f3 ff ff       	call   400323a5 <mraa_spi_init>
40032ffa:	a3 94 78 00 a8       	mov    %eax,0xa8007894
40032fff:	85 c0                	test   %eax,%eax
40033001:	75 0b                	jne    4003300e <LoRaClass+0x3a>
        printf("Unable to Initialize Spi bus\n");
40033003:	68 97 64 03 40       	push   $0x40036497
40033008:	e8 9e 19 00 00       	call   400349ab <iprintf>
4003300d:	5a                   	pop    %edx

    if(mraa_spi_frequency(SX1276.spi, 4000000) != MRAA_SUCCESS) {
4003300e:	ba 00 09 3d 00       	mov    $0x3d0900,%edx
40033013:	a1 94 78 00 a8       	mov    0xa8007894,%eax
40033018:	e8 10 f4 ff ff       	call   4003242d <mraa_spi_frequency>
4003301d:	85 c0                	test   %eax,%eax
4003301f:	74 0b                	je     4003302c <LoRaClass+0x58>
        printf("sx1276: Unable to set higher frequency\n");
40033021:	68 b5 64 03 40       	push   $0x400364b5
40033026:	e8 80 19 00 00       	call   400349ab <iprintf>
4003302b:	58                   	pop    %eax
    }

    SX1276._frequency  = 0;
4003302c:	c7 05 98 78 00 a8 00 	movl   $0x0,0xa8007898
40033033:	00 00 00 
    SX1276._packetIndex = 0;
40033036:	c7 05 9c 78 00 a8 00 	movl   $0x0,0xa800789c
4003303d:	00 00 00 
    SX1276._implicitHeaderMode = 0;
40033040:	c7 05 a0 78 00 a8 00 	movl   $0x0,0xa80078a0
40033047:	00 00 00 

    SX1276._ss = LORA_DEFAULT_SS_PIN;
4003304a:	c6 05 8c 78 00 a8 0a 	movb   $0xa,0xa800788c
    SX1276._reset = LORA_DEFAULT_RESET_PIN;
40033051:	c6 05 8d 78 00 a8 09 	movb   $0x9,0xa800788d
    SX1276._dio0 = LORA_DEFAULT_DIO0_PIN;
40033058:	c6 05 8e 78 00 a8 02 	movb   $0x2,0xa800788e
}
4003305f:	c9                   	leave  
40033060:	c3                   	ret    

40033061 <setPins>:

int8_t random() {
    return readRegister(REG_RSSI_WIDEBAND);
}

void setPins(int ss, int reset, int dio0) {
40033061:	55                   	push   %ebp
    SX1276._ss = ss;
40033062:	a2 8c 78 00 a8       	mov    %al,0xa800788c
void setPins(int ss, int reset, int dio0) {
40033067:	89 e5                	mov    %esp,%ebp
    SX1276._reset = reset;
40033069:	88 15 8d 78 00 a8    	mov    %dl,0xa800788d
    SX1276._dio0 = dio0;
4003306f:	88 0d 8e 78 00 a8    	mov    %cl,0xa800788e
}
40033075:	5d                   	pop    %ebp
40033076:	c3                   	ret    

40033077 <readRegister>:
        // reset FIFO address
        writeRegister(REG_FIFO_ADDR_PTR, 0);
    }
}

uint8_t readRegister(uint8_t address) {
40033077:	55                   	push   %ebp
    //return singleTransfer(address & 0x7f, 0x00);

    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40033078:	83 e0 7f             	and    $0x7f,%eax
uint8_t readRegister(uint8_t address) {
4003307b:	89 e5                	mov    %esp,%ebp
4003307d:	52                   	push   %edx
    uint8_t rx_buf[2];

    mraa_gpio_write(SX1276.gpio_ss, 0);
4003307e:	31 d2                	xor    %edx,%edx
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40033080:	88 45 fc             	mov    %al,-0x4(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40033083:	a1 80 78 00 a8       	mov    0xa8007880,%eax
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40033088:	c6 45 fd 00          	movb   $0x0,-0x3(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
4003308c:	e8 a1 f2 ff ff       	call   40032332 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, tx_buf, rx_buf, 2) != MRAA_SUCCESS) {
40033091:	8d 4d fe             	lea    -0x2(%ebp),%ecx
40033094:	8d 55 fc             	lea    -0x4(%ebp),%edx
40033097:	a1 94 78 00 a8       	mov    0xa8007894,%eax
4003309c:	6a 02                	push   $0x2
4003309e:	e8 c3 f3 ff ff       	call   40032466 <mraa_spi_transfer_buf>
400330a3:	59                   	pop    %ecx
400330a4:	85 c0                	test   %eax,%eax
400330a6:	74 2a                	je     400330d2 <readRegister+0x5b>
        printf("Unable to transfer data over the SPI bus\n");
400330a8:	68 dd 64 03 40       	push   $0x400364dd
400330ad:	e8 f9 18 00 00       	call   400349ab <iprintf>
        printf("SPI operation failed\n");
400330b2:	c7 04 24 07 65 03 40 	movl   $0x40036507,(%esp)
400330b9:	e8 ed 18 00 00       	call   400349ab <iprintf>
400330be:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
400330bf:	ba 01 00 00 00       	mov    $0x1,%edx
400330c4:	a1 80 78 00 a8       	mov    0xa8007880,%eax
400330c9:	e8 64 f2 ff ff       	call   40032332 <mraa_gpio_write>
400330ce:	b0 ff                	mov    $0xff,%al
400330d0:	eb 12                	jmp    400330e4 <readRegister+0x6d>
        return -1;
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
400330d2:	ba 01 00 00 00       	mov    $0x1,%edx
400330d7:	a1 80 78 00 a8       	mov    0xa8007880,%eax
400330dc:	e8 51 f2 ff ff       	call   40032332 <mraa_gpio_write>

    return rx_buf[1];
400330e1:	8a 45 ff             	mov    -0x1(%ebp),%al
}
400330e4:	c9                   	leave  
400330e5:	c3                   	ret    

400330e6 <dumpRegisters>:
{
400330e6:	55                   	push   %ebp
400330e7:	89 e5                	mov    %esp,%ebp
400330e9:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
400330ea:	31 db                	xor    %ebx,%ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
400330ec:	89 d8                	mov    %ebx,%eax
400330ee:	e8 84 ff ff ff       	call   40033077 <readRegister>
400330f3:	0f b6 c0             	movzbl %al,%eax
400330f6:	50                   	push   %eax
400330f7:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
400330f8:	43                   	inc    %ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
400330f9:	68 1d 65 03 40       	push   $0x4003651d
400330fe:	e8 a8 18 00 00       	call   400349ab <iprintf>
40033103:	83 c4 0c             	add    $0xc,%esp
  for (int i = 0; i < 128; i++) {
40033106:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
4003310c:	75 de                	jne    400330ec <dumpRegisters+0x6>
}
4003310e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033111:	c9                   	leave  
40033112:	c3                   	ret    

40033113 <writeRegister>:

void writeRegister(uint8_t address, uint8_t value) {
40033113:	55                   	push   %ebp
    //singleTransfer(address | 0x80, value);

    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40033114:	83 c8 80             	or     $0xffffff80,%eax
void writeRegister(uint8_t address, uint8_t value) {
40033117:	89 e5                	mov    %esp,%ebp
40033119:	51                   	push   %ecx
    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
4003311a:	88 45 fe             	mov    %al,-0x2(%ebp)
4003311d:	88 55 ff             	mov    %dl,-0x1(%ebp)

    mraa_gpio_write(SX1276.gpio_ss, 0);
40033120:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40033125:	31 d2                	xor    %edx,%edx
40033127:	e8 06 f2 ff ff       	call   40032332 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, pkt, NULL, 2) != MRAA_SUCCESS) {
4003312c:	31 c9                	xor    %ecx,%ecx
4003312e:	8d 55 fe             	lea    -0x2(%ebp),%edx
40033131:	a1 94 78 00 a8       	mov    0xa8007894,%eax
40033136:	6a 02                	push   $0x2
40033138:	e8 29 f3 ff ff       	call   40032466 <mraa_spi_transfer_buf>
4003313d:	5a                   	pop    %edx
4003313e:	85 c0                	test   %eax,%eax
40033140:	74 26                	je     40033168 <writeRegister+0x55>
        printf("Unable to transfer data over the SPI bus\n");
40033142:	68 dd 64 03 40       	push   $0x400364dd
40033147:	e8 5f 18 00 00       	call   400349ab <iprintf>
        printf("SPI operation failed\n");
4003314c:	c7 04 24 07 65 03 40 	movl   $0x40036507,(%esp)
40033153:	e8 53 18 00 00       	call   400349ab <iprintf>
40033158:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40033159:	ba 01 00 00 00       	mov    $0x1,%edx
4003315e:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40033163:	e8 ca f1 ff ff       	call   40032332 <mraa_gpio_write>
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40033168:	ba 01 00 00 00       	mov    $0x1,%edx
4003316d:	a1 80 78 00 a8       	mov    0xa8007880,%eax
40033172:	e8 bb f1 ff ff       	call   40032332 <mraa_gpio_write>
}
40033177:	c9                   	leave  
40033178:	c3                   	ret    

40033179 <write_buf>:
{
40033179:	55                   	push   %ebp
4003317a:	89 e5                	mov    %esp,%ebp
4003317c:	57                   	push   %edi
4003317d:	89 c7                	mov    %eax,%edi
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
4003317f:	b8 22 00 00 00       	mov    $0x22,%eax
{
40033184:	56                   	push   %esi
40033185:	53                   	push   %ebx
40033186:	89 d3                	mov    %edx,%ebx
40033188:	51                   	push   %ecx
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
40033189:	e8 e9 fe ff ff       	call   40033077 <readRegister>
4003318e:	0f b6 f0             	movzbl %al,%esi
    printf("current length: %d\n", currentLength);
40033191:	56                   	push   %esi
    int currentLength = readRegister(REG_PAYLOAD_LENGTH);
40033192:	88 45 f3             	mov    %al,-0xd(%ebp)
    printf("current length: %d\n", currentLength);
40033195:	68 29 65 03 40       	push   $0x40036529
4003319a:	e8 0c 18 00 00       	call   400349ab <iprintf>
4003319f:	58                   	pop    %eax
    if ((currentLength + size) > MAX_PKT_LENGTH) {
400331a0:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
    printf("current length: %d\n", currentLength);
400331a3:	5a                   	pop    %edx
    if ((currentLength + size) > MAX_PKT_LENGTH) {
400331a4:	3d ff 00 00 00       	cmp    $0xff,%eax
400331a9:	76 07                	jbe    400331b2 <write_buf+0x39>
        size = MAX_PKT_LENGTH - currentLength;
400331ab:	bb ff 00 00 00       	mov    $0xff,%ebx
400331b0:	29 f3                	sub    %esi,%ebx
400331b2:	8d 34 1f             	lea    (%edi,%ebx,1),%esi
    for (size_t i = 0; i < size; i++) {
400331b5:	39 f7                	cmp    %esi,%edi
400331b7:	74 0d                	je     400331c6 <write_buf+0x4d>
        writeRegister(REG_FIFO, buffer[i]);
400331b9:	0f b6 17             	movzbl (%edi),%edx
400331bc:	31 c0                	xor    %eax,%eax
400331be:	47                   	inc    %edi
400331bf:	e8 4f ff ff ff       	call   40033113 <writeRegister>
400331c4:	eb ef                	jmp    400331b5 <write_buf+0x3c>
    writeRegister(REG_PAYLOAD_LENGTH, currentLength + size);
400331c6:	8a 55 f3             	mov    -0xd(%ebp),%dl
400331c9:	b8 22 00 00 00       	mov    $0x22,%eax
400331ce:	01 da                	add    %ebx,%edx
400331d0:	0f b6 d2             	movzbl %dl,%edx
400331d3:	e8 3b ff ff ff       	call   40033113 <writeRegister>
}
400331d8:	8d 65 f4             	lea    -0xc(%ebp),%esp
400331db:	89 d8                	mov    %ebx,%eax
400331dd:	5b                   	pop    %ebx
400331de:	5e                   	pop    %esi
400331df:	5f                   	pop    %edi
400331e0:	5d                   	pop    %ebp
400331e1:	c3                   	ret    

400331e2 <setTxPower.part.2>:
void setTxPower(int level, int outputPin) {
400331e2:	55                   	push   %ebp
400331e3:	83 f8 11             	cmp    $0x11,%eax
400331e6:	89 e5                	mov    %esp,%ebp
400331e8:	53                   	push   %ebx
400331e9:	7e 05                	jle    400331f0 <setTxPower.part.2+0xe>
400331eb:	b8 11 00 00 00       	mov    $0x11,%eax
400331f0:	89 c3                	mov    %eax,%ebx
400331f2:	83 f8 02             	cmp    $0x2,%eax
400331f5:	7d 05                	jge    400331fc <setTxPower.part.2+0x1a>
400331f7:	bb 02 00 00 00       	mov    $0x2,%ebx
        printf("value to be written to REG_PA_CONFIG; %x\n", PA_BOOST | (level - 2));
400331fc:	8d 43 fe             	lea    -0x2(%ebx),%eax
400331ff:	0c 80                	or     $0x80,%al
40033201:	50                   	push   %eax
40033202:	68 3d 65 03 40       	push   $0x4003653d
40033207:	e8 9f 17 00 00       	call   400349ab <iprintf>
4003320c:	58                   	pop    %eax
4003320d:	5a                   	pop    %edx
        writeRegister(REG_PA_CONFIG, PA_BOOST | (level - 2));
4003320e:	8d 53 fe             	lea    -0x2(%ebx),%edx
40033211:	83 ca 80             	or     $0xffffff80,%edx
40033214:	b8 09 00 00 00       	mov    $0x9,%eax
40033219:	0f b6 d2             	movzbl %dl,%edx
4003321c:	e8 f2 fe ff ff       	call   40033113 <writeRegister>
        printf("REG_PA_CONFIG: %x\n", readRegister(REG_PA_CONFIG));
40033221:	b8 09 00 00 00       	mov    $0x9,%eax
40033226:	e8 4c fe ff ff       	call   40033077 <readRegister>
4003322b:	0f b6 c0             	movzbl %al,%eax
4003322e:	50                   	push   %eax
4003322f:	68 67 65 03 40       	push   $0x40036567
40033234:	e8 72 17 00 00       	call   400349ab <iprintf>
40033239:	59                   	pop    %ecx
4003323a:	5b                   	pop    %ebx
}
4003323b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
4003323e:	c9                   	leave  
4003323f:	c3                   	ret    

40033240 <setFrequency>:
void setFrequency(long frequency) {
40033240:	55                   	push   %ebp
40033241:	89 e5                	mov    %esp,%ebp
40033243:	57                   	push   %edi
40033244:	56                   	push   %esi
40033245:	89 c6                	mov    %eax,%esi
    printf("setting Frequency to: %d\n", frequency);
40033247:	50                   	push   %eax
40033248:	68 7a 65 03 40       	push   $0x4003657a
4003324d:	e8 59 17 00 00       	call   400349ab <iprintf>
40033252:	58                   	pop    %eax
    frequency = frequency/1.00001732945;
40033253:	89 f0                	mov    %esi,%eax
    printf("setting Frequency to: %d\n", frequency);
40033255:	5a                   	pop    %edx
    frequency = frequency/1.00001732945;
40033256:	e8 f0 d4 ff ff       	call   4003074b <__floatsidf>
4003325b:	68 12 00 f0 3f       	push   $0x3ff00012
40033260:	68 73 bc d6 2b       	push   $0x2bd6bc73
40033265:	e8 47 cf ff ff       	call   400301b1 <__divdf3>
4003326a:	59                   	pop    %ecx
4003326b:	5e                   	pop    %esi
4003326c:	e8 70 d4 ff ff       	call   400306e1 <__fixdfsi>
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40033271:	6a 00                	push   $0x0
40033273:	99                   	cltd   
    SX1276._frequency = frequency;
40033274:	a3 98 78 00 a8       	mov    %eax,0xa8007898
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40033279:	68 00 48 e8 01       	push   $0x1e84800
4003327e:	0f a4 c2 13          	shld   $0x13,%eax,%edx
40033282:	c1 e0 13             	shl    $0x13,%eax
40033285:	e8 31 ce ff ff       	call   400300bb <__udivdi3>
4003328a:	5f                   	pop    %edi
4003328b:	89 c6                	mov    %eax,%esi
4003328d:	89 d7                	mov    %edx,%edi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
4003328f:	0f ac d0 10          	shrd   $0x10,%edx,%eax
40033293:	0f b6 d0             	movzbl %al,%edx
40033296:	b8 06 00 00 00       	mov    $0x6,%eax
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
4003329b:	59                   	pop    %ecx
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
4003329c:	e8 72 fe ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_FRF_MID, (uint8_t)(frf >> 8));
400332a1:	89 fa                	mov    %edi,%edx
400332a3:	89 f0                	mov    %esi,%eax
400332a5:	0f ac d0 08          	shrd   $0x8,%edx,%eax
400332a9:	0f b6 d0             	movzbl %al,%edx
400332ac:	b8 07 00 00 00       	mov    $0x7,%eax
400332b1:	e8 5d fe ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400332b6:	89 f0                	mov    %esi,%eax
}
400332b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400332bb:	0f b6 d0             	movzbl %al,%edx
400332be:	b8 08 00 00 00       	mov    $0x8,%eax
}
400332c3:	5e                   	pop    %esi
400332c4:	5f                   	pop    %edi
400332c5:	5d                   	pop    %ebp
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400332c6:	e9 48 fe ff ff       	jmp    40033113 <writeRegister>

400332cb <explicitHeaderMode>:
void explicitHeaderMode() {
400332cb:	55                   	push   %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400332cc:	b8 1d 00 00 00       	mov    $0x1d,%eax
void explicitHeaderMode() {
400332d1:	89 e5                	mov    %esp,%ebp
    SX1276._implicitHeaderMode = 0;
400332d3:	c7 05 a0 78 00 a8 00 	movl   $0x0,0xa80078a0
400332da:	00 00 00 
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400332dd:	e8 95 fd ff ff       	call   40033077 <readRegister>
}
400332e2:	5d                   	pop    %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400332e3:	89 c2                	mov    %eax,%edx
400332e5:	b8 1d 00 00 00       	mov    $0x1d,%eax
400332ea:	81 e2 fe 00 00 00    	and    $0xfe,%edx
400332f0:	e9 1e fe ff ff       	jmp    40033113 <writeRegister>

400332f5 <implicitHeaderMode>:
void implicitHeaderMode() {
400332f5:	55                   	push   %ebp
400332f6:	89 e5                	mov    %esp,%ebp
    printf("inside implicit header mode\n");
400332f8:	68 94 65 03 40       	push   $0x40036594
400332fd:	e8 a9 16 00 00       	call   400349ab <iprintf>
40033302:	58                   	pop    %eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033303:	b8 1d 00 00 00       	mov    $0x1d,%eax
    SX1276._implicitHeaderMode = 1;
40033308:	c7 05 a0 78 00 a8 01 	movl   $0x1,0xa80078a0
4003330f:	00 00 00 
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033312:	e8 60 fd ff ff       	call   40033077 <readRegister>
40033317:	0f b6 c0             	movzbl %al,%eax
4003331a:	50                   	push   %eax
4003331b:	68 b1 65 03 40       	push   $0x400365b1
40033320:	e8 86 16 00 00       	call   400349ab <iprintf>
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
40033325:	b8 1d 00 00 00       	mov    $0x1d,%eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
4003332a:	5a                   	pop    %edx
4003332b:	59                   	pop    %ecx
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
4003332c:	e8 46 fd ff ff       	call   40033077 <readRegister>
40033331:	83 c8 01             	or     $0x1,%eax
40033334:	0f b6 d0             	movzbl %al,%edx
40033337:	b8 1d 00 00 00       	mov    $0x1d,%eax
4003333c:	e8 d2 fd ff ff       	call   40033113 <writeRegister>
    printf("next value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033341:	b8 1d 00 00 00       	mov    $0x1d,%eax
40033346:	e8 2c fd ff ff       	call   40033077 <readRegister>
4003334b:	0f b6 c0             	movzbl %al,%eax
4003334e:	50                   	push   %eax
4003334f:	68 da 65 03 40       	push   $0x400365da
40033354:	e8 52 16 00 00       	call   400349ab <iprintf>
40033359:	58                   	pop    %eax
4003335a:	5a                   	pop    %edx
}
4003335b:	c9                   	leave  
4003335c:	c3                   	ret    

4003335d <SX1276SetOpMode>:
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
            break;
    }
}

void SX1276SetOpMode(uint8_t mode) {
4003335d:	55                   	push   %ebp
4003335e:	89 e5                	mov    %esp,%ebp
40033360:	53                   	push   %ebx
40033361:	89 c3                	mov    %eax,%ebx
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
40033363:	b8 01 00 00 00       	mov    $0x1,%eax
40033368:	e8 0a fd ff ff       	call   40033077 <readRegister>
4003336d:	83 e0 80             	and    $0xffffff80,%eax
40033370:	09 d8                	or     %ebx,%eax
}
40033372:	5b                   	pop    %ebx
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
40033373:	0f b6 d0             	movzbl %al,%edx
40033376:	b8 01 00 00 00       	mov    $0x1,%eax
}
4003337b:	5d                   	pop    %ebp
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
4003337c:	e9 92 fd ff ff       	jmp    40033113 <writeRegister>

40033381 <endPacket>:
int endPacket() {
40033381:	55                   	push   %ebp
    printf("value of REG_IRQ_FLAGS very prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40033382:	b8 12 00 00 00       	mov    $0x12,%eax
int endPacket() {
40033387:	89 e5                	mov    %esp,%ebp
    printf("value of REG_IRQ_FLAGS very prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40033389:	e8 e9 fc ff ff       	call   40033077 <readRegister>
4003338e:	0f b6 c0             	movzbl %al,%eax
40033391:	50                   	push   %eax
40033392:	68 00 66 03 40       	push   $0x40036600
40033397:	e8 0f 16 00 00       	call   400349ab <iprintf>
4003339c:	59                   	pop    %ecx
4003339d:	58                   	pop    %eax
    printf("inside end packet\n");
4003339e:	68 41 66 03 40       	push   $0x40036641
400333a3:	e8 03 16 00 00       	call   400349ab <iprintf>
400333a8:	58                   	pop    %eax
    printf("final value of REG_PAYLOAD_LENGTH: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400333a9:	b8 22 00 00 00       	mov    $0x22,%eax
400333ae:	e8 c4 fc ff ff       	call   40033077 <readRegister>
400333b3:	0f b6 c0             	movzbl %al,%eax
400333b6:	50                   	push   %eax
400333b7:	68 54 66 03 40       	push   $0x40036654
400333bc:	e8 ea 15 00 00       	call   400349ab <iprintf>
400333c1:	58                   	pop    %eax
    SX1276SetOpMode(MODE_TX);
400333c2:	b8 03 00 00 00       	mov    $0x3,%eax
    printf("final value of REG_PAYLOAD_LENGTH: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400333c7:	5a                   	pop    %edx
    SX1276SetOpMode(MODE_TX);
400333c8:	e8 90 ff ff ff       	call   4003335d <SX1276SetOpMode>
    while((readRegister(REG_IRQ_FLAGS) & RFLR_IRQFLAGS_TXDONE) == 0);
400333cd:	b8 12 00 00 00       	mov    $0x12,%eax
400333d2:	e8 a0 fc ff ff       	call   40033077 <readRegister>
400333d7:	a8 08                	test   $0x8,%al
400333d9:	74 f2                	je     400333cd <endPacket+0x4c>
    printf("interrupt 0 detected\n");
400333db:	68 7b 66 03 40       	push   $0x4003667b
400333e0:	e8 c6 15 00 00       	call   400349ab <iprintf>
400333e5:	58                   	pop    %eax
    printf("value of REG_IRQ_FLAGS prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
400333e6:	b8 12 00 00 00       	mov    $0x12,%eax
400333eb:	e8 87 fc ff ff       	call   40033077 <readRegister>
400333f0:	0f b6 c0             	movzbl %al,%eax
400333f3:	50                   	push   %eax
400333f4:	68 91 66 03 40       	push   $0x40036691
400333f9:	e8 ad 15 00 00       	call   400349ab <iprintf>
400333fe:	5a                   	pop    %edx
    writeRegister(REG_IRQ_FLAGS, 0x80);
400333ff:	b8 12 00 00 00       	mov    $0x12,%eax
40033404:	ba 80 00 00 00       	mov    $0x80,%edx
    printf("value of REG_IRQ_FLAGS prior to clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
40033409:	59                   	pop    %ecx
    writeRegister(REG_IRQ_FLAGS, 0x80);
4003340a:	e8 04 fd ff ff       	call   40033113 <writeRegister>
    printf("value of REG_IRQ_FLAGS after clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
4003340f:	b8 12 00 00 00       	mov    $0x12,%eax
40033414:	e8 5e fc ff ff       	call   40033077 <readRegister>
40033419:	0f b6 c0             	movzbl %al,%eax
4003341c:	50                   	push   %eax
4003341d:	68 cd 66 03 40       	push   $0x400366cd
40033422:	e8 84 15 00 00       	call   400349ab <iprintf>
40033427:	58                   	pop    %eax
}
40033428:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("value of REG_IRQ_FLAGS after clearing the interrupt: %x\n", readRegister(REG_IRQ_FLAGS));
4003342d:	5a                   	pop    %edx
}
4003342e:	c9                   	leave  
4003342f:	c3                   	ret    

40033430 <idle>:
void idle() {
40033430:	55                   	push   %ebp
40033431:	89 e5                	mov    %esp,%ebp
    printf("Setting to idle state\n");
40033433:	68 06 67 03 40       	push   $0x40036706
40033438:	e8 6e 15 00 00       	call   400349ab <iprintf>
4003343d:	58                   	pop    %eax
    SX1276SetOpMode(MODE_STDBY);
4003343e:	b8 01 00 00 00       	mov    $0x1,%eax
}
40033443:	c9                   	leave  
    SX1276SetOpMode(MODE_STDBY);
40033444:	e9 14 ff ff ff       	jmp    4003335d <SX1276SetOpMode>

40033449 <beginPacket>:
int beginPacket(int implicitHeader) {
40033449:	55                   	push   %ebp
4003344a:	89 e5                	mov    %esp,%ebp
4003344c:	53                   	push   %ebx
4003344d:	89 c3                	mov    %eax,%ebx
    idle();
4003344f:	e8 dc ff ff ff       	call   40033430 <idle>
    printf("inside begin packet\n");
40033454:	68 1d 67 03 40       	push   $0x4003671d
40033459:	e8 4d 15 00 00       	call   400349ab <iprintf>
4003345e:	58                   	pop    %eax
    if (implicitHeader) {
4003345f:	85 db                	test   %ebx,%ebx
40033461:	74 07                	je     4003346a <beginPacket+0x21>
        implicitHeaderMode();
40033463:	e8 8d fe ff ff       	call   400332f5 <implicitHeaderMode>
40033468:	eb 05                	jmp    4003346f <beginPacket+0x26>
        explicitHeaderMode();
4003346a:	e8 5c fe ff ff       	call   400332cb <explicitHeaderMode>
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
4003346f:	b8 0d 00 00 00       	mov    $0xd,%eax
40033474:	e8 fe fb ff ff       	call   40033077 <readRegister>
40033479:	0f b6 c0             	movzbl %al,%eax
4003347c:	50                   	push   %eax
4003347d:	68 32 67 03 40       	push   $0x40036732
40033482:	e8 24 15 00 00       	call   400349ab <iprintf>
40033487:	58                   	pop    %eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
40033488:	b8 22 00 00 00       	mov    $0x22,%eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
4003348d:	5a                   	pop    %edx
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
4003348e:	e8 e4 fb ff ff       	call   40033077 <readRegister>
40033493:	0f b6 c0             	movzbl %al,%eax
40033496:	50                   	push   %eax
40033497:	68 32 67 03 40       	push   $0x40036732
4003349c:	e8 0a 15 00 00       	call   400349ab <iprintf>
    writeRegister(REG_FIFO_ADDR_PTR, 0);
400334a1:	31 d2                	xor    %edx,%edx
400334a3:	b8 0d 00 00 00       	mov    $0xd,%eax
    printf("initial value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400334a8:	59                   	pop    %ecx
400334a9:	5b                   	pop    %ebx
    writeRegister(REG_FIFO_ADDR_PTR, 0);
400334aa:	e8 64 fc ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_PAYLOAD_LENGTH, 0);
400334af:	31 d2                	xor    %edx,%edx
400334b1:	b8 22 00 00 00       	mov    $0x22,%eax
400334b6:	e8 58 fc ff ff       	call   40033113 <writeRegister>
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
400334bb:	b8 0d 00 00 00       	mov    $0xd,%eax
400334c0:	e8 b2 fb ff ff       	call   40033077 <readRegister>
400334c5:	0f b6 c0             	movzbl %al,%eax
400334c8:	50                   	push   %eax
400334c9:	68 5a 67 03 40       	push   $0x4003675a
400334ce:	e8 d8 14 00 00       	call   400349ab <iprintf>
400334d3:	58                   	pop    %eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400334d4:	b8 22 00 00 00       	mov    $0x22,%eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_FIFO_ADDR_PTR));
400334d9:	5a                   	pop    %edx
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400334da:	e8 98 fb ff ff       	call   40033077 <readRegister>
400334df:	0f b6 c0             	movzbl %al,%eax
400334e2:	50                   	push   %eax
400334e3:	68 5a 67 03 40       	push   $0x4003675a
400334e8:	e8 be 14 00 00       	call   400349ab <iprintf>
400334ed:	59                   	pop    %ecx
}
400334ee:	b8 01 00 00 00       	mov    $0x1,%eax
    printf("later value of REG_FIFO_ADDR_PTR: %x\n", readRegister(REG_PAYLOAD_LENGTH));
400334f3:	5b                   	pop    %ebx
}
400334f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400334f7:	c9                   	leave  
400334f8:	c3                   	ret    

400334f9 <SX1276sleep>:
void SX1276sleep() {
400334f9:	55                   	push   %ebp
400334fa:	89 e5                	mov    %esp,%ebp
    printf("Setting to sleep/ FIFO not accessible\n");
400334fc:	68 80 67 03 40       	push   $0x40036780
40033501:	e8 a5 14 00 00       	call   400349ab <iprintf>
40033506:	58                   	pop    %eax
    SX1276SetOpMode(MODE_SLEEP);
40033507:	31 c0                	xor    %eax,%eax
}
40033509:	c9                   	leave  
    SX1276SetOpMode(MODE_SLEEP);
4003350a:	e9 4e fe ff ff       	jmp    4003335d <SX1276SetOpMode>

4003350f <SX1276SetModem.part.3>:
void SX1276SetModem(RadioModems_t modem) {
4003350f:	55                   	push   %ebp
40033510:	89 e5                	mov    %esp,%ebp
            SX1276sleep();
40033512:	e8 e2 ff ff ff       	call   400334f9 <SX1276sleep>
            writeRegister(REG_OP_MODE, readRegister(REG_OP_MODE) | MODE_LONG_RANGE_MODE);
40033517:	b8 01 00 00 00       	mov    $0x1,%eax
4003351c:	e8 56 fb ff ff       	call   40033077 <readRegister>
40033521:	83 c8 80             	or     $0xffffff80,%eax
40033524:	0f b6 d0             	movzbl %al,%edx
40033527:	b8 01 00 00 00       	mov    $0x1,%eax
4003352c:	e8 e2 fb ff ff       	call   40033113 <writeRegister>
            writeRegister(REG_DIO_MAPPING_1, 0x00);
40033531:	31 d2                	xor    %edx,%edx
40033533:	b8 40 00 00 00       	mov    $0x40,%eax
40033538:	e8 d6 fb ff ff       	call   40033113 <writeRegister>
            writeRegister(REG_DIO_MAPPING_2, 0x00);
4003353d:	31 d2                	xor    %edx,%edx
4003353f:	b8 41 00 00 00       	mov    $0x41,%eax
}
40033544:	5d                   	pop    %ebp
            writeRegister(REG_DIO_MAPPING_2, 0x00);
40033545:	e9 c9 fb ff ff       	jmp    40033113 <writeRegister>

4003354a <SX1276SetModem>:
    switch(modem) {
4003354a:	85 c0                	test   %eax,%eax
4003354c:	74 05                	je     40033553 <SX1276SetModem+0x9>
4003354e:	e9 bc ff ff ff       	jmp    4003350f <SX1276SetModem.part.3>
void SX1276SetModem(RadioModems_t modem) {
40033553:	55                   	push   %ebp
40033554:	89 e5                	mov    %esp,%ebp
            SX1276sleep();
40033556:	e8 9e ff ff ff       	call   400334f9 <SX1276sleep>
            writeRegister(REG_OP_MODE, readRegister(REG_OP_MODE) & MODE_LONG_RANGE_MODE_OFF);
4003355b:	b8 01 00 00 00       	mov    $0x1,%eax
40033560:	e8 12 fb ff ff       	call   40033077 <readRegister>
40033565:	89 c2                	mov    %eax,%edx
40033567:	b8 01 00 00 00       	mov    $0x1,%eax
4003356c:	83 e2 7f             	and    $0x7f,%edx
4003356f:	e8 9f fb ff ff       	call   40033113 <writeRegister>
            writeRegister(REG_DIO_MAPPING_1, 0x00);
40033574:	31 d2                	xor    %edx,%edx
40033576:	b8 40 00 00 00       	mov    $0x40,%eax
4003357b:	e8 93 fb ff ff       	call   40033113 <writeRegister>
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
40033580:	ba 30 00 00 00       	mov    $0x30,%edx
40033585:	b8 41 00 00 00       	mov    $0x41,%eax
}
4003358a:	5d                   	pop    %ebp
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
4003358b:	e9 83 fb ff ff       	jmp    40033113 <writeRegister>

40033590 <SX1276RxChainCalibration>:

void SX1276RxChainCalibration() {
40033590:	55                   	push   %ebp
40033591:	89 e5                	mov    %esp,%ebp
40033593:	57                   	push   %edi
40033594:	56                   	push   %esi
40033595:	53                   	push   %ebx
40033596:	50                   	push   %eax
    printf("Entering rx chain calibration\n");
40033597:	68 a7 67 03 40       	push   $0x400367a7
4003359c:	e8 0a 14 00 00       	call   400349ab <iprintf>
    uint8_t initialFreq_lsb;

    // Save context
    // this part has been changed somewhat from the original semtech/upm driver
    // avoiding a call to the set frequency function would be easier here
    regPaConfigInitVal = readRegister( REG_PA_CONFIG );
400335a1:	b8 09 00 00 00       	mov    $0x9,%eax
    printf("Entering rx chain calibration\n");
400335a6:	5a                   	pop    %edx
    regPaConfigInitVal = readRegister( REG_PA_CONFIG );
400335a7:	e8 cb fa ff ff       	call   40033077 <readRegister>
400335ac:	89 c7                	mov    %eax,%edi
    initialFreq_msb = readRegister(REG_FRF_MSB);
400335ae:	b8 06 00 00 00       	mov    $0x6,%eax
400335b3:	e8 bf fa ff ff       	call   40033077 <readRegister>
400335b8:	89 c6                	mov    %eax,%esi
    initialFreq_mid = readRegister(REG_FRF_MID);
400335ba:	b8 07 00 00 00       	mov    $0x7,%eax
400335bf:	e8 b3 fa ff ff       	call   40033077 <readRegister>
400335c4:	88 c3                	mov    %al,%bl
    initialFreq_lsb = readRegister(REG_FRF_LSB);
400335c6:	b8 08 00 00 00       	mov    $0x8,%eax
400335cb:	e8 a7 fa ff ff       	call   40033077 <readRegister>

    // Cut the PA just in case, RFO output, power = -1 dBm
    writeRegister( REG_PA_CONFIG, 0x00 );
400335d0:	31 d2                	xor    %edx,%edx
    initialFreq_lsb = readRegister(REG_FRF_LSB);
400335d2:	88 45 f3             	mov    %al,-0xd(%ebp)
    writeRegister( REG_PA_CONFIG, 0x00 );
400335d5:	b8 09 00 00 00       	mov    $0x9,%eax
400335da:	e8 34 fb ff ff       	call   40033113 <writeRegister>

    // Launch Rx chain calibration for LF band
    writeRegister( REG_IMAGE_CAL, ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
400335df:	b8 3b 00 00 00       	mov    $0x3b,%eax
400335e4:	e8 8e fa ff ff       	call   40033077 <readRegister>
400335e9:	83 c8 40             	or     $0x40,%eax
400335ec:	0f b6 d0             	movzbl %al,%edx
400335ef:	b8 3b 00 00 00       	mov    $0x3b,%eax
400335f4:	e8 1a fb ff ff       	call   40033113 <writeRegister>
    while( ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
400335f9:	b8 3b 00 00 00       	mov    $0x3b,%eax
400335fe:	e8 74 fa ff ff       	call   40033077 <readRegister>
40033603:	a8 20                	test   $0x20,%al
40033605:	75 f2                	jne    400335f9 <SX1276RxChainCalibration+0x69>
    {}

    // Sets a Frequency in HF band
    setFrequency( 868000000 );
40033607:	b8 00 a1 bc 33       	mov    $0x33bca100,%eax
4003360c:	e8 2f fc ff ff       	call   40033240 <setFrequency>

    // Launch Rx chain calibration for HF band
    writeRegister( REG_IMAGE_CAL, ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
40033611:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033616:	e8 5c fa ff ff       	call   40033077 <readRegister>
4003361b:	83 c8 40             	or     $0x40,%eax
4003361e:	0f b6 d0             	movzbl %al,%edx
40033621:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033626:	e8 e8 fa ff ff       	call   40033113 <writeRegister>
    while( ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
4003362b:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033630:	e8 42 fa ff ff       	call   40033077 <readRegister>
40033635:	a8 20                	test   $0x20,%al
40033637:	75 f2                	jne    4003362b <SX1276RxChainCalibration+0x9b>
    {}

    // Restore context
    writeRegister( REG_PA_CONFIG, regPaConfigInitVal );
40033639:	89 f8                	mov    %edi,%eax
4003363b:	0f b6 d0             	movzbl %al,%edx
4003363e:	b8 09 00 00 00       	mov    $0x9,%eax
40033643:	e8 cb fa ff ff       	call   40033113 <writeRegister>

    writeRegister(REG_FRF_MSB, initialFreq_msb);
40033648:	89 f0                	mov    %esi,%eax
4003364a:	0f b6 d0             	movzbl %al,%edx
4003364d:	b8 06 00 00 00       	mov    $0x6,%eax
40033652:	e8 bc fa ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_FRF_MID, initialFreq_mid);
40033657:	b8 07 00 00 00       	mov    $0x7,%eax
4003365c:	0f b6 d3             	movzbl %bl,%edx
4003365f:	e8 af fa ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_FRF_LSB, initialFreq_lsb);
40033664:	b8 08 00 00 00       	mov    $0x8,%eax
40033669:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
}
4003366d:	8d 65 f4             	lea    -0xc(%ebp),%esp
40033670:	5b                   	pop    %ebx
40033671:	5e                   	pop    %esi
40033672:	5f                   	pop    %edi
40033673:	5d                   	pop    %ebp
    writeRegister(REG_FRF_LSB, initialFreq_lsb);
40033674:	e9 9a fa ff ff       	jmp    40033113 <writeRegister>

40033679 <init>:
{
40033679:	55                   	push   %ebp
4003367a:	89 e5                	mov    %esp,%ebp
4003367c:	56                   	push   %esi
4003367d:	89 c6                	mov    %eax,%esi
4003367f:	53                   	push   %ebx
    if(!(SX1276.gpio_ss = mraa_gpio_init(SX1276._ss))) {
40033680:	0f b6 05 8c 78 00 a8 	movzbl 0xa800788c,%eax
40033687:	e8 7e eb ff ff       	call   4003220a <mraa_gpio_init>
4003368c:	a3 80 78 00 a8       	mov    %eax,0xa8007880
40033691:	85 c0                	test   %eax,%eax
40033693:	75 0b                	jne    400336a0 <init+0x27>
        printf("sx1276: unable to init SPI CS\n");
40033695:	68 c6 67 03 40       	push   $0x400367c6
4003369a:	e8 0c 13 00 00       	call   400349ab <iprintf>
4003369f:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_ss, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
400336a0:	31 d2                	xor    %edx,%edx
400336a2:	a1 80 78 00 a8       	mov    0xa8007880,%eax
400336a7:	e8 10 ec ff ff       	call   400322bc <mraa_gpio_dir>
400336ac:	85 c0                	test   %eax,%eax
400336ae:	74 0b                	je     400336bb <init+0x42>
        printf("sx1276: unable to set direction on SPI CS\n");
400336b0:	68 e5 67 03 40       	push   $0x400367e5
400336b5:	e8 f1 12 00 00       	call   400349ab <iprintf>
400336ba:	58                   	pop    %eax
    if(!(SX1276.gpio_reset = mraa_gpio_init(SX1276._reset))) {
400336bb:	0f b6 05 8d 78 00 a8 	movzbl 0xa800788d,%eax
400336c2:	e8 43 eb ff ff       	call   4003220a <mraa_gpio_init>
400336c7:	a3 84 78 00 a8       	mov    %eax,0xa8007884
400336cc:	85 c0                	test   %eax,%eax
400336ce:	75 0b                	jne    400336db <init+0x62>
        printf("sx1276: unable to init chip reset\n");
400336d0:	68 10 68 03 40       	push   $0x40036810
400336d5:	e8 d1 12 00 00       	call   400349ab <iprintf>
400336da:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_reset, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
400336db:	31 d2                	xor    %edx,%edx
400336dd:	a1 84 78 00 a8       	mov    0xa8007884,%eax
400336e2:	e8 d5 eb ff ff       	call   400322bc <mraa_gpio_dir>
400336e7:	85 c0                	test   %eax,%eax
400336e9:	74 0b                	je     400336f6 <init+0x7d>
        printf("sx1276: unable to set direction on reset pin\n");
400336eb:	68 33 68 03 40       	push   $0x40036833
400336f0:	e8 b6 12 00 00       	call   400349ab <iprintf>
400336f5:	5b                   	pop    %ebx
    mraa_gpio_write(SX1276.gpio_reset, 1);
400336f6:	ba 01 00 00 00       	mov    $0x1,%edx
400336fb:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40033700:	e8 2d ec ff ff       	call   40032332 <mraa_gpio_write>
    upm_delay_us(1000);
40033705:	b8 e8 03 00 00       	mov    $0x3e8,%eax
4003370a:	e8 9d f8 ff ff       	call   40032fac <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 0);
4003370f:	31 d2                	xor    %edx,%edx
40033711:	a1 84 78 00 a8       	mov    0xa8007884,%eax
40033716:	e8 17 ec ff ff       	call   40032332 <mraa_gpio_write>
    upm_delay_us(1000);
4003371b:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40033720:	e8 87 f8 ff ff       	call   40032fac <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 1);
40033725:	ba 01 00 00 00       	mov    $0x1,%edx
4003372a:	a1 84 78 00 a8       	mov    0xa8007884,%eax
4003372f:	e8 fe eb ff ff       	call   40032332 <mraa_gpio_write>
    upm_delay_us(15000);
40033734:	b8 98 3a 00 00       	mov    $0x3a98,%eax
40033739:	e8 6e f8 ff ff       	call   40032fac <upm_delay_us>
    SX1276RxChainCalibration();
4003373e:	e8 4d fe ff ff       	call   40033590 <SX1276RxChainCalibration>
    mraa_gpio_write(SX1276.gpio_ss, 1);
40033743:	ba 01 00 00 00       	mov    $0x1,%edx
40033748:	a1 80 78 00 a8       	mov    0xa8007880,%eax
4003374d:	e8 e0 eb ff ff       	call   40032332 <mraa_gpio_write>
    uint8_t version = readRegister(REG_VERSION);
40033752:	b8 42 00 00 00       	mov    $0x42,%eax
40033757:	e8 1b f9 ff ff       	call   40033077 <readRegister>
4003375c:	0f b6 d8             	movzbl %al,%ebx
    if (version != 0x12) {
4003375f:	80 fb 12             	cmp    $0x12,%bl
40033762:	74 0b                	je     4003376f <init+0xf6>
        printf("wrong version\n");
40033764:	68 61 68 03 40       	push   $0x40036861
40033769:	e8 3d 12 00 00       	call   400349ab <iprintf>
4003376e:	59                   	pop    %ecx
    printf("chip version: %x\n", version);
4003376f:	53                   	push   %ebx
40033770:	68 70 68 03 40       	push   $0x40036870
40033775:	e8 31 12 00 00       	call   400349ab <iprintf>
4003377a:	58                   	pop    %eax
4003377b:	5a                   	pop    %edx
    SX1276sleep();
4003377c:	e8 78 fd ff ff       	call   400334f9 <SX1276sleep>
40033781:	31 db                	xor    %ebx,%ebx
        SX1276SetModem( RadioRegsInit[i].Modem );
40033783:	8b 83 40 69 03 40    	mov    0x40036940(%ebx),%eax
40033789:	83 c3 08             	add    $0x8,%ebx
4003378c:	e8 b9 fd ff ff       	call   4003354a <SX1276SetModem>
        writeRegister( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );
40033791:	0f b6 93 3d 69 03 40 	movzbl 0x4003693d(%ebx),%edx
40033798:	0f b6 83 3c 69 03 40 	movzbl 0x4003693c(%ebx),%eax
4003379f:	e8 6f f9 ff ff       	call   40033113 <writeRegister>
    for( i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
400337a4:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
400337aa:	75 d7                	jne    40033783 <init+0x10a>
400337ac:	e8 5e fd ff ff       	call   4003350f <SX1276SetModem.part.3>
    setFrequency(frequency);
400337b1:	89 f0                	mov    %esi,%eax
400337b3:	e8 88 fa ff ff       	call   40033240 <setFrequency>
    printf("setting rx and tx base addresses\n");
400337b8:	68 82 68 03 40       	push   $0x40036882
400337bd:	e8 e9 11 00 00       	call   400349ab <iprintf>
400337c2:	58                   	pop    %eax
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
400337c3:	31 d2                	xor    %edx,%edx
400337c5:	b8 0e 00 00 00       	mov    $0xe,%eax
400337ca:	e8 44 f9 ff ff       	call   40033113 <writeRegister>
    writeRegister(REG_FIFO_RX_BASE_ADDR, 0);
400337cf:	31 d2                	xor    %edx,%edx
400337d1:	b8 0f 00 00 00       	mov    $0xf,%eax
400337d6:	e8 38 f9 ff ff       	call   40033113 <writeRegister>
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
400337db:	b8 0e 00 00 00       	mov    $0xe,%eax
400337e0:	e8 92 f8 ff ff       	call   40033077 <readRegister>
400337e5:	0f b6 c0             	movzbl %al,%eax
400337e8:	50                   	push   %eax
400337e9:	68 a4 68 03 40       	push   $0x400368a4
400337ee:	e8 b8 11 00 00       	call   400349ab <iprintf>
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
400337f3:	b8 0f 00 00 00       	mov    $0xf,%eax
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
400337f8:	5a                   	pop    %edx
400337f9:	59                   	pop    %ecx
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
400337fa:	e8 78 f8 ff ff       	call   40033077 <readRegister>
400337ff:	0f b6 c0             	movzbl %al,%eax
40033802:	50                   	push   %eax
40033803:	68 bf 68 03 40       	push   $0x400368bf
40033808:	e8 9e 11 00 00       	call   400349ab <iprintf>
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
4003380d:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40033812:	5b                   	pop    %ebx
40033813:	5e                   	pop    %esi
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40033814:	e8 5e f8 ff ff       	call   40033077 <readRegister>
40033819:	0f b6 c0             	movzbl %al,%eax
4003381c:	50                   	push   %eax
4003381d:	68 da 68 03 40       	push   $0x400368da
40033822:	e8 84 11 00 00       	call   400349ab <iprintf>
40033827:	58                   	pop    %eax
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
40033828:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
4003382d:	5a                   	pop    %edx
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
4003382e:	e8 44 f8 ff ff       	call   40033077 <readRegister>
40033833:	83 c8 23             	or     $0x23,%eax
40033836:	0f b6 d0             	movzbl %al,%edx
40033839:	b8 0c 00 00 00       	mov    $0xc,%eax
4003383e:	e8 d0 f8 ff ff       	call   40033113 <writeRegister>
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
40033843:	b8 0c 00 00 00       	mov    $0xc,%eax
40033848:	e8 2a f8 ff ff       	call   40033077 <readRegister>
4003384d:	0f b6 c0             	movzbl %al,%eax
40033850:	50                   	push   %eax
40033851:	68 ee 68 03 40       	push   $0x400368ee
40033856:	e8 50 11 00 00       	call   400349ab <iprintf>
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
4003385b:	ba 04 00 00 00       	mov    $0x4,%edx
40033860:	b8 26 00 00 00       	mov    $0x26,%eax
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
40033865:	59                   	pop    %ecx
40033866:	5b                   	pop    %ebx
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
40033867:	e8 a7 f8 ff ff       	call   40033113 <writeRegister>
    printf("REG_MODEM_CONFIG_3; %x\n", readRegister(REG_MODEM_CONFIG_3));
4003386c:	b8 26 00 00 00       	mov    $0x26,%eax
40033871:	e8 01 f8 ff ff       	call   40033077 <readRegister>
40033876:	0f b6 c0             	movzbl %al,%eax
40033879:	50                   	push   %eax
4003387a:	68 01 69 03 40       	push   $0x40036901
4003387f:	e8 27 11 00 00       	call   400349ab <iprintf>
40033884:	5e                   	pop    %esi
40033885:	58                   	pop    %eax
40033886:	b8 11 00 00 00       	mov    $0x11,%eax
4003388b:	e8 52 f9 ff ff       	call   400331e2 <setTxPower.part.2>
    idle();
40033890:	e8 9b fb ff ff       	call   40033430 <idle>
}
40033895:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033898:	b8 01 00 00 00       	mov    $0x1,%eax
4003389d:	5b                   	pop    %ebx
4003389e:	5e                   	pop    %esi
4003389f:	5d                   	pop    %ebp
400338a0:	c3                   	ret    

400338a1 <_arc_init>:
{
	uint32_t *reset_vector;

	ARG_UNUSED(arg);

	if (!SCSS_REG_VAL(SCSS_SS_STS)) {
400338a1:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400338a6:	85 c0                	test   %eax,%eax
400338a8:	75 15                	jne    400338bf <_arc_init+0x1e>
{
400338aa:	55                   	push   %ebp
400338ab:	89 e5                	mov    %esp,%ebp
		/* ARC shouldn't already be running! */
		printk("ARC core already running!");
400338ad:	68 c0 69 03 40       	push   $0x400369c0
400338b2:	e8 84 de ff ff       	call   4003173b <printk>
400338b7:	58                   	pop    %eax
		return -EIO;
400338b8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}

skip_arc_init:

	return 0;
}
400338bd:	c9                   	leave  
400338be:	c3                   	ret    
	shared_data->arc_start = *reset_vector;
400338bf:	a1 00 00 00 40       	mov    0x40000000,%eax
400338c4:	a3 00 00 00 a8       	mov    %eax,0xa8000000
	shared_data->flags = 0;
400338c9:	c7 05 04 00 00 a8 00 	movl   $0x0,0xa8000004
400338d0:	00 00 00 
	if (!shared_data->arc_start) {
400338d3:	a1 00 00 00 a8       	mov    0xa8000000,%eax
400338d8:	85 c0                	test   %eax,%eax
400338da:	75 03                	jne    400338df <_arc_init+0x3e>
	return 0;
400338dc:	31 c0                	xor    %eax,%eax
400338de:	c3                   	ret    
	SCSS_REG_VAL(SCSS_SS_CFG) |= ARC_RUN_REQ_A;
400338df:	a1 00 06 80 b0       	mov    0xb0800600,%eax
400338e4:	0d 00 00 00 01       	or     $0x1000000,%eax
400338e9:	a3 00 06 80 b0       	mov    %eax,0xb0800600
	while (SCSS_REG_VAL(SCSS_SS_STS) & 0x4000) {
400338ee:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400338f3:	0f ba e0 0e          	bt     $0xe,%eax
400338f7:	72 f5                	jb     400338ee <_arc_init+0x4d>
	while (!(shared_data->flags & ARC_READY)) {
400338f9:	a1 04 00 00 a8       	mov    0xa8000004,%eax
400338fe:	a8 01                	test   $0x1,%al
40033900:	74 f7                	je     400338f9 <_arc_init+0x58>
40033902:	eb d8                	jmp    400338dc <_arc_init+0x3b>

40033904 <_lakemont_eoi>:
#include <arch/x86/irq_controller.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
40033904:	55                   	push   %ebp
40033905:	89 e5                	mov    %esp,%ebp
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
40033907:	e8 32 d2 ff ff       	call   40030b3e <__irq_controller_isr_vector_get>
4003390c:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
40033911:	31 c0                	xor    %eax,%eax
40033913:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	sys_write32(_irq_controller_isr_vector_get(),
		    CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);

	/* Send EOI to the LOAPIC as well */
	sys_write32(0, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI);
}
40033918:	5d                   	pop    %ebp
40033919:	c3                   	ret    

4003391a <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
4003391a:	55                   	push   %ebp
4003391b:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
4003391d:	e8 61 0c 00 00       	call   40034583 <k_is_in_isr>
40033922:	85 c0                	test   %eax,%eax
40033924:	74 15                	je     4003393b <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
40033926:	e8 58 0c 00 00       	call   40034583 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
4003392b:	ba da 69 03 40       	mov    $0x400369da,%edx
40033930:	85 c0                	test   %eax,%eax
40033932:	75 2c                	jne    40033960 <_SysFatalErrorHandler+0x46>
40033934:	ba de 69 03 40       	mov    $0x400369de,%edx
40033939:	eb 25                	jmp    40033960 <_SysFatalErrorHandler+0x46>
	if (k_is_in_isr() || _is_thread_essential()) {
4003393b:	e8 54 0c 00 00       	call   40034594 <_is_thread_essential>
40033940:	85 c0                	test   %eax,%eax
40033942:	75 e2                	jne    40033926 <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
40033944:	ff 35 c8 76 00 a8    	pushl  0xa80076c8
4003394a:	68 0f 6a 03 40       	push   $0x40036a0f
4003394f:	e8 e7 dd ff ff       	call   4003173b <printk>
40033954:	58                   	pop    %eax
	k_thread_abort(_current);
40033955:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
	printk("Fatal fault in thread %p! Aborting.\n", _current);
4003395a:	5a                   	pop    %edx
	k_thread_abort(_current);
4003395b:	e8 6f 0d 00 00       	call   400346cf <k_thread_abort>
		printk("Fatal fault in %s! Spinning...\n",
40033960:	52                   	push   %edx
40033961:	68 ef 69 03 40       	push   $0x400369ef
40033966:	e8 d0 dd ff ff       	call   4003173b <printk>
4003396b:	59                   	pop    %ecx
4003396c:	58                   	pop    %eax
4003396d:	eb fe                	jmp    4003396d <_SysFatalErrorHandler+0x53>

4003396f <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
4003396f:	53                   	push   %ebx
	movl $1, %eax
40033970:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
40033975:	0f a2                	cpuid  
	movl %ebx, %eax
40033977:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
40033979:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
4003397e:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
40033981:	5b                   	pop    %ebx
	ret
40033982:	c3                   	ret    

40033983 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
40033983:	55                   	push   %ebp
40033984:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
40033986:	e8 e4 ff ff ff       	call   4003396f <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
4003398b:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
4003398c:	a3 bc 78 00 a8       	mov    %eax,0xa80078bc
}
40033991:	31 c0                	xor    %eax,%eax
40033993:	c3                   	ret    

40033994 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
40033994:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
40033995:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
40033998:	50                   	push   %eax
	pushl	%edx
40033999:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
4003399a:	57                   	push   %edi
	pushl	%esi
4003399b:	56                   	push   %esi
	pushl	%ebx
4003399c:	53                   	push   %ebx
	pushl	%ebp
4003399d:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
4003399e:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
400339a2:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
400339a3:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
400339aa:	00 
	je	allDone
400339ab:	74 01                	je     400339ae <allDone>
	sti
400339ad:	fb                   	sti    

400339ae <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
400339ae:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
400339b0:	ff d1                	call   *%ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
400339b2:	5d                   	pop    %ebp
	popl	%ebp
400339b3:	5d                   	pop    %ebp
	popl	%ebx
400339b4:	5b                   	pop    %ebx
	popl	%esi
400339b5:	5e                   	pop    %esi
	popl	%edi
400339b6:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
400339b7:	5a                   	pop    %edx
	popl	%eax
400339b8:	58                   	pop    %eax
	popl	%ecx
400339b9:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
400339ba:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
400339bd:	cf                   	iret   

400339be <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
400339be:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
400339bf:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
400339c3:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
400339c6:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
400339c7:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
400339c8:	b9 c0 76 00 a8       	mov    $0xa80076c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
400339cd:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
400339cf:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
400339d2:	75 06                	jne    400339da <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
400339d4:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
400339d6:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
400339d9:	57                   	push   %edi

400339da <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
400339da:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
400339db:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
400339dd:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
400339de:	e8 21 ff ff ff       	call   40033904 <_lakemont_eoi>
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
400339e3:	b9 c0 76 00 a8       	mov    $0xa80076c0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
400339e8:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
400339ea:	75 1e                	jne    40033a0a <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
400339ec:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
400339ef:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
400339f5:	73 12                	jae    40033a09 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
400339f7:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
400339fa:	74 0d                	je     40033a09 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
400339fc:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
400339fd:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
400339fe:	58                   	pop    %eax
#endif
	call	_Swap
400339ff:	e8 27 00 00 00       	call   40033a2b <_Swap>

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
40033a04:	5f                   	pop    %edi
	popl	%ecx
40033a05:	59                   	pop    %ecx
	popl	%edx
40033a06:	5a                   	pop    %edx
	popl	%eax
40033a07:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033a08:	cf                   	iret   

40033a09 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
40033a09:	5c                   	pop    %esp

40033a0a <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
40033a0a:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
40033a0b:	59                   	pop    %ecx
	popl	%edx
40033a0c:	5a                   	pop    %edx
	popl	%eax
40033a0d:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033a0e:	cf                   	iret   

40033a0f <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
40033a0f:	6a 00                	push   $0x0

40033a11 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
40033a11:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
40033a12:	50                   	push   %eax
	pushl %ecx
40033a13:	51                   	push   %ecx
	pushl %edx
40033a14:	52                   	push   %edx
	pushl %edi
40033a15:	57                   	push   %edi
	pushl %esi
40033a16:	56                   	push   %esi
	pushl %ebx
40033a17:	53                   	push   %ebx
	pushl %ebp
40033a18:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
40033a19:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
40033a1d:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
40033a1e:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
40033a20:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
40033a21:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
40033a26:	e8 9b 00 00 00       	call   40033ac6 <_NanoFatalErrorHandler>

40033a2b <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
40033a2b:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
40033a2e:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
40033a32:	57                   	push   %edi

	movl	$_kernel, %edi
40033a33:	bf c0 76 00 a8       	mov    $0xa80076c0,%edi

	pushl	%esi
40033a38:	56                   	push   %esi
	pushl	%ebx
40033a39:	53                   	push   %ebx
	pushl	%ebp
40033a3a:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
40033a3b:	ff 35 04 6c 03 40    	pushl  0x40036c04


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
40033a41:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
40033a44:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
40033a47:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
40033a4a:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
40033a4d:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
40033a50:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
40033a51:	5d                   	pop    %ebp
	popl	%ebx
40033a52:	5b                   	pop    %ebx
	popl	%esi
40033a53:	5e                   	pop    %esi
	popl	%edi
40033a54:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
40033a55:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
40033a59:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
40033a5a:	5a                   	pop    %edx
	movl	%edx, (%esp)
40033a5b:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
40033a5e:	c3                   	ret    

40033a5f <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
40033a5f:	55                   	push   %ebp
40033a60:	89 e5                	mov    %esp,%ebp
40033a62:	56                   	push   %esi
40033a63:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
40033a64:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
40033a67:	83 e3 fc             	and    $0xfffffffc,%ebx
{
40033a6a:	89 c6                	mov    %eax,%esi
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
40033a6c:	8b 45 10             	mov    0x10(%ebp),%eax
40033a6f:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
40033a72:	8b 45 0c             	mov    0xc(%ebp),%eax
40033a75:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
40033a78:	8b 45 08             	mov    0x8(%ebp),%eax
40033a7b:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
40033a7e:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
40033a81:	9c                   	pushf  
40033a82:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033a83:	80 e4 cd             	and    $0xcd,%ah
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
40033a86:	c7 43 e8 60 00 03 40 	movl   $0x40030060,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033a8d:	80 cc 02             	or     $0x2,%ah
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033a90:	8b 55 14             	mov    0x14(%ebp),%edx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033a93:	89 43 ec             	mov    %eax,-0x14(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033a96:	b9 04 00 00 00       	mov    $0x4,%ecx
40033a9b:	ff 75 18             	pushl  0x18(%ebp)
40033a9e:	89 f0                	mov    %esi,%eax
	pInitialCtx -= 11;
40033aa0:	83 eb 2c             	sub    $0x2c,%ebx
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033aa3:	e8 f4 0b 00 00       	call   4003469c <_init_thread_base>
	pInitialCtx -= 11;
40033aa8:	89 5e 28             	mov    %ebx,0x28(%esi)
	thread->init_data = NULL;
40033aab:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
40033ab2:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033ab9:	58                   	pop    %eax
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
40033aba:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033abd:	5b                   	pop    %ebx
40033abe:	5e                   	pop    %esi
40033abf:	5d                   	pop    %ebp
40033ac0:	c3                   	ret    

40033ac1 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
40033ac1:	55                   	push   %ebp
40033ac2:	89 e5                	mov    %esp,%ebp
40033ac4:	5d                   	pop    %ebp
40033ac5:	c3                   	ret    

40033ac6 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
40033ac6:	55                   	push   %ebp
40033ac7:	89 e5                	mov    %esp,%ebp
40033ac9:	57                   	push   %edi
40033aca:	56                   	push   %esi
40033acb:	53                   	push   %ebx
40033acc:	83 ec 28             	sub    $0x28,%esp
40033acf:	89 c6                	mov    %eax,%esi
	_debug_fatal_hook(pEsf);
40033ad1:	89 d0                	mov    %edx,%eax
{
40033ad3:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
40033ad5:	e8 e7 ff ff ff       	call   40033ac1 <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
40033ada:	83 fe 03             	cmp    $0x3,%esi
40033add:	74 3e                	je     40033b1d <_NanoFatalErrorHandler+0x57>
40033adf:	77 06                	ja     40033ae7 <_NanoFatalErrorHandler+0x21>
40033ae1:	85 f6                	test   %esi,%esi
40033ae3:	74 0e                	je     40033af3 <_NanoFatalErrorHandler+0x2d>
40033ae5:	eb 4a                	jmp    40033b31 <_NanoFatalErrorHandler+0x6b>
40033ae7:	83 fe 05             	cmp    $0x5,%esi
40033aea:	74 3e                	je     40033b2a <_NanoFatalErrorHandler+0x64>
40033aec:	83 fe 06             	cmp    $0x6,%esi
40033aef:	74 4d                	je     40033b3e <_NanoFatalErrorHandler+0x78>
40033af1:	eb 3e                	jmp    40033b31 <_NanoFatalErrorHandler+0x6b>
40033af3:	e8 46 d0 ff ff       	call   40030b3e <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
40033af8:	68 34 6a 03 40       	push   $0x40036a34
40033afd:	89 c3                	mov    %eax,%ebx
40033aff:	e8 37 dc ff ff       	call   4003173b <printk>
40033b04:	58                   	pop    %eax
		if (vector >= 0) {
40033b05:	85 db                	test   %ebx,%ebx
40033b07:	78 0d                	js     40033b16 <_NanoFatalErrorHandler+0x50>
			printk("%d ", vector);
40033b09:	53                   	push   %ebx
40033b0a:	68 56 6a 03 40       	push   $0x40036a56
40033b0f:	e8 27 dc ff ff       	call   4003173b <printk>
40033b14:	5b                   	pop    %ebx
40033b15:	58                   	pop    %eax
		}
		printk("*****\n");
40033b16:	68 7d 6a 03 40       	push   $0x40036a7d
40033b1b:	eb 05                	jmp    40033b22 <_NanoFatalErrorHandler+0x5c>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
40033b1d:	68 5a 6a 03 40       	push   $0x40036a5a
40033b22:	e8 14 dc ff ff       	call   4003173b <printk>
40033b27:	59                   	pop    %ecx
		break;
40033b28:	eb 14                	jmp    40033b3e <_NanoFatalErrorHandler+0x78>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40033b2a:	68 84 6a 03 40       	push   $0x40036a84
40033b2f:	eb f1                	jmp    40033b22 <_NanoFatalErrorHandler+0x5c>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
40033b31:	56                   	push   %esi
40033b32:	68 aa 6a 03 40       	push   $0x40036aaa
40033b37:	e8 ff db ff ff       	call   4003173b <printk>
40033b3c:	58                   	pop    %eax
40033b3d:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
40033b3e:	8b 47 04             	mov    0x4(%edi),%eax
40033b41:	8b 4f 2c             	mov    0x2c(%edi),%ecx
40033b44:	89 45 f0             	mov    %eax,-0x10(%ebp)
40033b47:	8b 47 10             	mov    0x10(%edi),%eax
40033b4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
40033b4d:	8b 47 0c             	mov    0xc(%edi),%eax
40033b50:	89 45 e8             	mov    %eax,-0x18(%ebp)
40033b53:	8b 47 14             	mov    0x14(%edi),%eax
40033b56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40033b59:	8b 47 1c             	mov    0x1c(%edi),%eax
40033b5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
40033b5f:	8b 47 08             	mov    0x8(%edi),%eax
40033b62:	89 45 dc             	mov    %eax,-0x24(%ebp)
40033b65:	8b 47 18             	mov    0x18(%edi),%eax
40033b68:	8b 17                	mov    (%edi),%edx
40033b6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
40033b6d:	8b 47 24             	mov    0x24(%edi),%eax
40033b70:	89 4d cc             	mov    %ecx,-0x34(%ebp)
40033b73:	89 55 d0             	mov    %edx,-0x30(%ebp)
40033b76:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40033b79:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
40033b7d:	e8 b3 05 00 00       	call   40034135 <k_current_get>
40033b82:	8b 55 d0             	mov    -0x30(%ebp),%edx
40033b85:	8b 4d cc             	mov    -0x34(%ebp),%ecx
40033b88:	51                   	push   %ecx
40033b89:	52                   	push   %edx
40033b8a:	ff 75 f0             	pushl  -0x10(%ebp)
40033b8d:	ff 75 ec             	pushl  -0x14(%ebp)
40033b90:	ff 75 e8             	pushl  -0x18(%ebp)
40033b93:	ff 75 e4             	pushl  -0x1c(%ebp)
40033b96:	ff 75 e0             	pushl  -0x20(%ebp)
40033b99:	ff 75 dc             	pushl  -0x24(%ebp)
40033b9c:	ff 75 d8             	pushl  -0x28(%ebp)
40033b9f:	ff 75 d4             	pushl  -0x2c(%ebp)
40033ba2:	53                   	push   %ebx
40033ba3:	50                   	push   %eax
40033ba4:	68 cd 6a 03 40       	push   $0x40036acd
40033ba9:	e8 8d db ff ff       	call   4003173b <printk>
40033bae:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
40033bb1:	89 fa                	mov    %edi,%edx
40033bb3:	89 f0                	mov    %esi,%eax
40033bb5:	e8 60 fd ff ff       	call   4003391a <_SysFatalErrorHandler>

40033bba <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
40033bba:	55                   	push   %ebp
40033bbb:	89 e5                	mov    %esp,%ebp
40033bbd:	56                   	push   %esi
40033bbe:	89 c6                	mov    %eax,%esi
40033bc0:	53                   	push   %ebx
40033bc1:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
40033bc3:	50                   	push   %eax
40033bc4:	68 6c 6b 03 40       	push   $0x40036b6c
40033bc9:	e8 6d db ff ff       	call   4003173b <printk>
40033bce:	59                   	pop    %ecx
40033bcf:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
40033bd0:	b8 00 7d 02 00       	mov    $0x27d00,%eax
40033bd5:	0f a3 f0             	bt     %esi,%eax
40033bd8:	73 0f                	jae    40033be9 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
40033bda:	ff 73 20             	pushl  0x20(%ebx)
40033bdd:	68 84 6b 03 40       	push   $0x40036b84
40033be2:	e8 54 db ff ff       	call   4003173b <printk>
40033be7:	58                   	pop    %eax
40033be8:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
40033be9:	89 da                	mov    %ebx,%edx
40033beb:	b8 06 00 00 00       	mov    $0x6,%eax
40033bf0:	e8 d1 fe ff ff       	call   40033ac6 <_NanoFatalErrorHandler>

40033bf5 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
40033bf5:	55                   	push   %ebp
40033bf6:	89 c2                	mov    %eax,%edx
40033bf8:	89 e5                	mov    %esp,%ebp
40033bfa:	31 c0                	xor    %eax,%eax
40033bfc:	e8 b9 ff ff ff       	call   40033bba <generic_exc_handle>

40033c01 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
40033c01:	55                   	push   %ebp
40033c02:	89 c2                	mov    %eax,%edx
40033c04:	89 e5                	mov    %esp,%ebp
40033c06:	b8 02 00 00 00       	mov    $0x2,%eax
40033c0b:	e8 aa ff ff ff       	call   40033bba <generic_exc_handle>

40033c10 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
40033c10:	55                   	push   %ebp
40033c11:	89 c2                	mov    %eax,%edx
40033c13:	89 e5                	mov    %esp,%ebp
40033c15:	b8 04 00 00 00       	mov    $0x4,%eax
40033c1a:	e8 9b ff ff ff       	call   40033bba <generic_exc_handle>

40033c1f <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
40033c1f:	55                   	push   %ebp
40033c20:	89 c2                	mov    %eax,%edx
40033c22:	89 e5                	mov    %esp,%ebp
40033c24:	b8 05 00 00 00       	mov    $0x5,%eax
40033c29:	e8 8c ff ff ff       	call   40033bba <generic_exc_handle>

40033c2e <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
40033c2e:	55                   	push   %ebp
40033c2f:	89 c2                	mov    %eax,%edx
40033c31:	89 e5                	mov    %esp,%ebp
40033c33:	b8 06 00 00 00       	mov    $0x6,%eax
40033c38:	e8 7d ff ff ff       	call   40033bba <generic_exc_handle>

40033c3d <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
40033c3d:	55                   	push   %ebp
40033c3e:	89 c2                	mov    %eax,%edx
40033c40:	89 e5                	mov    %esp,%ebp
40033c42:	b8 07 00 00 00       	mov    $0x7,%eax
40033c47:	e8 6e ff ff ff       	call   40033bba <generic_exc_handle>

40033c4c <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
40033c4c:	55                   	push   %ebp
40033c4d:	89 c2                	mov    %eax,%edx
40033c4f:	89 e5                	mov    %esp,%ebp
40033c51:	b8 08 00 00 00       	mov    $0x8,%eax
40033c56:	e8 5f ff ff ff       	call   40033bba <generic_exc_handle>

40033c5b <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
40033c5b:	55                   	push   %ebp
40033c5c:	89 c2                	mov    %eax,%edx
40033c5e:	89 e5                	mov    %esp,%ebp
40033c60:	b8 0a 00 00 00       	mov    $0xa,%eax
40033c65:	e8 50 ff ff ff       	call   40033bba <generic_exc_handle>

40033c6a <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
40033c6a:	55                   	push   %ebp
40033c6b:	89 c2                	mov    %eax,%edx
40033c6d:	89 e5                	mov    %esp,%ebp
40033c6f:	b8 0b 00 00 00       	mov    $0xb,%eax
40033c74:	e8 41 ff ff ff       	call   40033bba <generic_exc_handle>

40033c79 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
40033c79:	55                   	push   %ebp
40033c7a:	89 c2                	mov    %eax,%edx
40033c7c:	89 e5                	mov    %esp,%ebp
40033c7e:	b8 0c 00 00 00       	mov    $0xc,%eax
40033c83:	e8 32 ff ff ff       	call   40033bba <generic_exc_handle>

40033c88 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
40033c88:	55                   	push   %ebp
40033c89:	89 c2                	mov    %eax,%edx
40033c8b:	89 e5                	mov    %esp,%ebp
40033c8d:	b8 0d 00 00 00       	mov    $0xd,%eax
40033c92:	e8 23 ff ff ff       	call   40033bba <generic_exc_handle>

40033c97 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
40033c97:	55                   	push   %ebp
40033c98:	89 c2                	mov    %eax,%edx
40033c9a:	89 e5                	mov    %esp,%ebp
40033c9c:	b8 0e 00 00 00       	mov    $0xe,%eax
40033ca1:	e8 14 ff ff ff       	call   40033bba <generic_exc_handle>

40033ca6 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
40033ca6:	55                   	push   %ebp
40033ca7:	89 c2                	mov    %eax,%edx
40033ca9:	89 e5                	mov    %esp,%ebp
40033cab:	b8 10 00 00 00       	mov    $0x10,%eax
40033cb0:	e8 05 ff ff ff       	call   40033bba <generic_exc_handle>

40033cb5 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
40033cb5:	55                   	push   %ebp
40033cb6:	89 c2                	mov    %eax,%edx
40033cb8:	89 e5                	mov    %esp,%ebp
40033cba:	b8 11 00 00 00       	mov    $0x11,%eax
40033cbf:	e8 f6 fe ff ff       	call   40033bba <generic_exc_handle>

40033cc4 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
40033cc4:	55                   	push   %ebp
40033cc5:	89 c2                	mov    %eax,%edx
40033cc7:	89 e5                	mov    %esp,%ebp
40033cc9:	b8 12 00 00 00       	mov    $0x12,%eax
40033cce:	e8 e7 fe ff ff       	call   40033bba <generic_exc_handle>

40033cd3 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
40033cd3:	55                   	push   %ebp
40033cd4:	89 e5                	mov    %esp,%ebp
40033cd6:	56                   	push   %esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033cd7:	8d 70 01             	lea    0x1(%eax),%esi
{
40033cda:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033cdb:	8b 1c 85 e0 6b 03 40 	mov    0x40036be0(,%eax,4),%ebx
40033ce2:	3b 1c b5 e0 6b 03 40 	cmp    0x40036be0(,%esi,4),%ebx
40033ce9:	73 0c                	jae    40033cf7 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
40033ceb:	8b 13                	mov    (%ebx),%edx
40033ced:	89 d8                	mov    %ebx,%eax
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033cef:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
40033cf2:	ff 52 04             	call   *0x4(%edx)
40033cf5:	eb eb                	jmp    40033ce2 <_sys_device_do_config_level+0xf>
	}
}
40033cf7:	5b                   	pop    %ebx
40033cf8:	5e                   	pop    %esi
40033cf9:	5d                   	pop    %ebp
40033cfa:	c3                   	ret    

40033cfb <device_get_binding>:

struct device *device_get_binding(const char *name)
{
40033cfb:	55                   	push   %ebp
40033cfc:	89 e5                	mov    %esp,%ebp
40033cfe:	56                   	push   %esi
40033cff:	89 c6                	mov    %eax,%esi
40033d01:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40033d02:	bb f4 66 00 a8       	mov    $0xa80066f4,%ebx
40033d07:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033d0d:	74 1c                	je     40033d2b <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033d0f:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
40033d13:	75 05                	jne    40033d1a <device_get_binding+0x1f>
	for (info = __device_init_start; info != __device_init_end; info++) {
40033d15:	83 c3 0c             	add    $0xc,%ebx
40033d18:	eb ed                	jmp    40033d07 <device_get_binding+0xc>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033d1a:	8b 03                	mov    (%ebx),%eax
40033d1c:	8b 10                	mov    (%eax),%edx
40033d1e:	89 f0                	mov    %esi,%eax
40033d20:	e8 47 0d 00 00       	call   40034a6c <strcmp>
40033d25:	85 c0                	test   %eax,%eax
40033d27:	75 ec                	jne    40033d15 <device_get_binding+0x1a>
40033d29:	eb 02                	jmp    40033d2d <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
40033d2b:	31 db                	xor    %ebx,%ebx
}
40033d2d:	89 d8                	mov    %ebx,%eax
40033d2f:	5b                   	pop    %ebx
40033d30:	5e                   	pop    %esi
40033d31:	5d                   	pop    %ebp
40033d32:	c3                   	ret    

40033d33 <device_busy_set>:
40033d33:	55                   	push   %ebp
40033d34:	89 e5                	mov    %esp,%ebp
40033d36:	5d                   	pop    %ebp
40033d37:	c3                   	ret    

40033d38 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
40033d38:	55                   	push   %ebp
40033d39:	89 e5                	mov    %esp,%ebp
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
40033d3b:	5d                   	pop    %ebp
40033d3c:	c3                   	ret    

40033d3d <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
40033d3d:	55                   	push   %ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40033d3e:	b8 02 00 00 00       	mov    $0x2,%eax
{
40033d43:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40033d45:	e8 89 ff ff ff       	call   40033cd3 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40033d4a:	b8 05 00 00 00       	mov    $0x5,%eax
40033d4f:	e8 7f ff ff ff       	call   40033cd3 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
40033d54:	b8 06 00 00 00       	mov    $0x6,%eax
40033d59:	e8 75 ff ff ff       	call   40033cd3 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
40033d5e:	b8 07 00 00 00       	mov    $0x7,%eax
40033d63:	e8 6b ff ff ff       	call   40033cd3 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
40033d68:	b8 03 00 00 00       	mov    $0x3,%eax
40033d6d:	e8 61 ff ff ff       	call   40033cd3 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
40033d72:	e8 ac 08 00 00       	call   40034623 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
40033d77:	e8 5c ca ff ff       	call   400307d8 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}
40033d7c:	5d                   	pop    %ebp
	_main_thread->base.user_options &= ~K_ESSENTIAL;
40033d7d:	80 25 e4 81 00 a8 fe 	andb   $0xfe,0xa80081e4
}
40033d84:	c3                   	ret    

40033d85 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40033d85:	55                   	push   %ebp
40033d86:	89 e5                	mov    %esp,%ebp
40033d88:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
40033d8b:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
40033d8e:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
40033d92:	a3 c8 76 00 a8       	mov    %eax,0xa80076c8
	dummy_thread->base.user_options = K_ESSENTIAL;
40033d97:	b8 1c 00 00 00       	mov    $0x1c,%eax
40033d9c:	8d 90 c0 76 00 a8    	lea    -0x57ff8940(%eax),%edx
40033da2:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
40033da5:	89 90 b8 76 00 a8    	mov    %edx,-0x57ff8948(%eax)
	list->tail = (sys_dnode_t *)list;
40033dab:	89 90 bc 76 00 a8    	mov    %edx,-0x57ff8944(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
40033db1:	3d 1c 01 00 00       	cmp    $0x11c,%eax
40033db6:	75 e4                	jne    40033d9c <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033db8:	6a 01                	push   $0x1
40033dba:	b9 3d 3d 03 40       	mov    $0x40033d3d,%ecx
40033dbf:	6a 00                	push   $0x0
40033dc1:	ba 00 04 00 00       	mov    $0x400,%edx
40033dc6:	6a 00                	push   $0x0
40033dc8:	b8 dc 81 00 a8       	mov    $0xa80081dc,%eax
40033dcd:	6a 00                	push   $0x0
40033dcf:	6a 00                	push   $0x0
	_ready_q.cache = _main_thread;
40033dd1:	c7 05 d4 76 00 a8 dc 	movl   $0xa80081dc,0xa80076d4
40033dd8:	81 00 a8 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033ddb:	e8 7f fc ff ff       	call   40033a5f <_new_thread>
40033de0:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_main_thread);
40033de3:	b8 dc 81 00 a8       	mov    $0xa80081dc,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033de8:	80 25 e5 81 00 a8 fb 	andb   $0xfb,0xa80081e5
40033def:	e8 2c 01 00 00       	call   40033f20 <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
40033df4:	b9 30 34 03 40       	mov    $0x40033430,%ecx
40033df9:	ba 00 01 00 00       	mov    $0x100,%edx
40033dfe:	6a 01                	push   $0x1
40033e00:	b8 dc 80 00 a8       	mov    $0xa80080dc,%eax
40033e05:	6a 0f                	push   $0xf
40033e07:	6a 00                	push   $0x0
40033e09:	6a 00                	push   $0x0
40033e0b:	6a 00                	push   $0x0
40033e0d:	e8 4d fc ff ff       	call   40033a5f <_new_thread>
40033e12:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_idle_thread);
40033e15:	b8 dc 80 00 a8       	mov    $0xa80080dc,%eax
40033e1a:	80 25 e5 80 00 a8 fb 	andb   $0xfb,0xa80080e5
40033e21:	e8 fa 00 00 00       	call   40033f20 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
40033e26:	b8 04 00 00 00       	mov    $0x4,%eax
	list->head = (sys_dnode_t *)list;
40033e2b:	c7 05 cc 76 00 a8 cc 	movl   $0xa80076cc,0xa80076cc
40033e32:	76 00 a8 
	list->tail = (sys_dnode_t *)list;
40033e35:	c7 05 d0 76 00 a8 cc 	movl   $0xa80076cc,0xa80076d0
40033e3c:	76 00 a8 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
40033e3f:	c7 05 c0 76 00 a8 00 	movl   $0x0,0xa80076c0
40033e46:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
40033e49:	c7 05 c4 76 00 a8 dc 	movl   $0xa80080dc,0xa80076c4
40033e50:	80 00 a8 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
40033e53:	c7 05 c0 78 00 a8 00 	movl   $0x800,0xa80078c0
40033e5a:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
40033e5d:	c7 05 a4 78 00 a8 94 	movl   $0x40033994,0xa80078a4
40033e64:	39 03 40 
40033e67:	e8 67 fe ff ff       	call   40033cd3 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40033e6c:	31 c0                	xor    %eax,%eax
40033e6e:	e8 60 fe ff ff       	call   40033cd3 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
40033e73:	b8 01 00 00 00       	mov    $0x1,%eax
40033e78:	e8 56 fe ff ff       	call   40033cd3 <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
40033e7d:	68 08 6c 03 40       	push   $0x40036c08
40033e82:	68 24 6c 03 40       	push   $0x40036c24
40033e87:	e8 af d8 ff ff       	call   4003173b <printk>
40033e8c:	58                   	pop    %eax
40033e8d:	5a                   	pop    %edx
	__asm__ volatile (
40033e8e:	9c                   	pushf  
40033e8f:	fa                   	cli    
40033e90:	58                   	pop    %eax
	_Swap(irq_lock());
40033e91:	e8 95 fb ff ff       	call   40033a2b <_Swap>

40033e96 <_get_highest_ready_prio>:
{
40033e96:	55                   	push   %ebp
40033e97:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40033e99:	0f bc 05 d8 76 00 a8 	bsf    0xa80076d8,%eax
40033ea0:	75 05                	jne    40033ea7 <_get_highest_ready_prio+0x11>
40033ea2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
40033ea7:	83 e8 10             	sub    $0x10,%eax
}
40033eaa:	5d                   	pop    %ebp
40033eab:	c3                   	ret    

40033eac <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
40033eac:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
40033ead:	89 42 08             	mov    %eax,0x8(%edx)
{
40033eb0:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
40033eb2:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
40033eb5:	53                   	push   %ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
40033eb6:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033ebb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033ebe:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033ec0:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033ec3:	74 07                	je     40033ecc <_add_timeout+0x20>
40033ec5:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
40033eca:	75 1d                	jne    40033ee9 <_add_timeout+0x3d>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
40033ecc:	c7 02 cc 76 00 a8    	movl   $0xa80076cc,(%edx)
	node->prev = list->tail;
40033ed2:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
40033ed7:	89 42 04             	mov    %eax,0x4(%edx)

	list->tail->next = node;
40033eda:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
40033edf:	89 10                	mov    %edx,(%eax)
	list->tail = node;
40033ee1:	89 15 d0 76 00 a8    	mov    %edx,0xa80076d0
40033ee7:	eb 34                	jmp    40033f1d <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
40033ee9:	8b 4a 10             	mov    0x10(%edx),%ecx
40033eec:	8b 58 10             	mov    0x10(%eax),%ebx
40033eef:	39 d9                	cmp    %ebx,%ecx
40033ef1:	7f 17                	jg     40033f0a <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
40033ef3:	29 cb                	sub    %ecx,%ebx
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
40033ef5:	8b 48 04             	mov    0x4(%eax),%ecx
40033ef8:	89 58 10             	mov    %ebx,0x10(%eax)
40033efb:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
40033efe:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
40033f00:	8b 48 04             	mov    0x4(%eax),%ecx
40033f03:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
40033f05:	89 50 04             	mov    %edx,0x4(%eax)
40033f08:	eb 13                	jmp    40033f1d <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
40033f0a:	29 d9                	sub    %ebx,%ecx
40033f0c:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
40033f0f:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
40033f15:	74 b5                	je     40033ecc <_add_timeout+0x20>
40033f17:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033f19:	85 c0                	test   %eax,%eax
40033f1b:	eb ad                	jmp    40033eca <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
40033f1d:	5b                   	pop    %ebx
40033f1e:	5d                   	pop    %ebp
40033f1f:	c3                   	ret    

40033f20 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
40033f20:	55                   	push   %ebp
40033f21:	89 e5                	mov    %esp,%ebp
40033f23:	56                   	push   %esi
40033f24:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033f25:	bb 01 00 00 00       	mov    $0x1,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033f2a:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
40033f2e:	8d 4a 10             	lea    0x10(%edx),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033f31:	89 ce                	mov    %ecx,%esi
40033f33:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033f36:	d3 e3                	shl    %cl,%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
40033f38:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx
	node->prev = list->tail;
40033f3f:	83 c2 14             	add    $0x14,%edx
	*bmap |= _get_ready_q_prio_bit(prio);
40033f42:	09 1c b5 d8 76 00 a8 	or     %ebx,-0x57ff8928(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
40033f49:	89 08                	mov    %ecx,(%eax)
40033f4b:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40033f52:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40033f55:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40033f5c:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40033f5e:	89 04 d5 c0 76 00 a8 	mov    %eax,-0x57ff8940(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033f65:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
40033f6b:	8a 5a 0a             	mov    0xa(%edx),%bl
40033f6e:	38 58 0a             	cmp    %bl,0xa(%eax)
40033f71:	7c 02                	jl     40033f75 <_add_thread_to_ready_q+0x55>
40033f73:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
40033f75:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033f76:	a3 d4 76 00 a8       	mov    %eax,0xa80076d4
}
40033f7b:	5e                   	pop    %esi
40033f7c:	5d                   	pop    %ebp
40033f7d:	c3                   	ret    

40033f7e <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
40033f7e:	55                   	push   %ebp
40033f7f:	89 e5                	mov    %esp,%ebp
40033f81:	53                   	push   %ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40033f82:	8b 48 04             	mov    0x4(%eax),%ecx
40033f85:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033f87:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40033f8b:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
40033f8d:	8b 18                	mov    (%eax),%ebx
40033f8f:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
40033f92:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
40033f99:	3b 0c d5 5c 77 00 a8 	cmp    -0x57ff88a4(,%edx,8),%ecx
40033fa0:	75 1c                	jne    40033fbe <_remove_thread_from_ready_q+0x40>
		_clear_ready_q_prio_bit(thread->base.prio);
40033fa2:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033fa6:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033fa9:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033fae:	89 cb                	mov    %ecx,%ebx
40033fb0:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033fb3:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
40033fb5:	f7 d2                	not    %edx
40033fb7:	21 14 9d d8 76 00 a8 	and    %edx,-0x57ff8928(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033fbe:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
40033fc4:	39 d0                	cmp    %edx,%eax
40033fc6:	75 0c                	jne    40033fd4 <_remove_thread_from_ready_q+0x56>
	int prio = _get_highest_ready_prio();
40033fc8:	e8 c9 fe ff ff       	call   40033e96 <_get_highest_ready_prio>
40033fcd:	8b 14 c5 5c 77 00 a8 	mov    -0x57ff88a4(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
40033fd4:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40033fd5:	89 15 d4 76 00 a8    	mov    %edx,0xa80076d4
}
40033fdb:	5d                   	pop    %ebp
40033fdc:	c3                   	ret    

40033fdd <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
40033fdd:	55                   	push   %ebp
40033fde:	89 e5                	mov    %esp,%ebp
40033fe0:	57                   	push   %edi
40033fe1:	56                   	push   %esi
40033fe2:	53                   	push   %ebx
	return list->head == list;
40033fe3:	8b 1a                	mov    (%edx),%ebx
40033fe5:	89 cf                	mov    %ecx,%edi
	return sys_dlist_is_empty(list) ? NULL : list->head;
40033fe7:	39 da                	cmp    %ebx,%edx
40033fe9:	75 0b                	jne    40033ff6 <_pend_thread+0x19>
40033feb:	31 db                	xor    %ebx,%ebx
40033fed:	eb 07                	jmp    40033ff6 <_pend_thread+0x19>
	return (node == list->tail) ? NULL : node->next;
40033fef:	3b 5a 04             	cmp    0x4(%edx),%ebx
40033ff2:	74 20                	je     40034014 <_pend_thread+0x37>
40033ff4:	8b 1b                	mov    (%ebx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
40033ff6:	85 db                	test   %ebx,%ebx
40033ff8:	74 1a                	je     40034014 <_pend_thread+0x37>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
40033ffa:	8a 4b 0a             	mov    0xa(%ebx),%cl
40033ffd:	38 48 0a             	cmp    %cl,0xa(%eax)
40034000:	7d ed                	jge    40033fef <_pend_thread+0x12>
		node->prev = insert_point->prev;
40034002:	8b 73 04             	mov    0x4(%ebx),%esi
		node->next = insert_point;
40034005:	89 18                	mov    %ebx,(%eax)
		node->prev = insert_point->prev;
40034007:	89 70 04             	mov    %esi,0x4(%eax)
		insert_point->prev->next = node;
4003400a:	8b 73 04             	mov    0x4(%ebx),%esi
4003400d:	89 06                	mov    %eax,(%esi)
		insert_point->prev = node;
4003400f:	89 43 04             	mov    %eax,0x4(%ebx)
40034012:	eb 10                	jmp    40034024 <_pend_thread+0x47>
	node->next = list;
40034014:	89 10                	mov    %edx,(%eax)
	node->prev = list->tail;
40034016:	8b 5a 04             	mov    0x4(%edx),%ebx
40034019:	89 58 04             	mov    %ebx,0x4(%eax)
	list->tail->next = node;
4003401c:	8b 5a 04             	mov    0x4(%edx),%ebx
4003401f:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
40034021:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state |= _THREAD_PENDING;
40034024:	80 48 09 02          	orb    $0x2,0x9(%eax)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
40034028:	83 ff ff             	cmp    $0xffffffff,%edi
4003402b:	74 1f                	je     4003404c <_pend_thread+0x6f>
4003402d:	89 d1                	mov    %edx,%ecx
4003402f:	89 c3                	mov    %eax,%ebx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40034031:	8d 70 10             	lea    0x10(%eax),%esi
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40034034:	31 d2                	xor    %edx,%edx
40034036:	8d 47 09             	lea    0x9(%edi),%eax
40034039:	bf 0a 00 00 00       	mov    $0xa,%edi
4003403e:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
40034040:	40                   	inc    %eax
40034041:	89 f2                	mov    %esi,%edx
40034043:	50                   	push   %eax
40034044:	89 d8                	mov    %ebx,%eax
40034046:	e8 61 fe ff ff       	call   40033eac <_add_timeout>
4003404b:	58                   	pop    %eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
4003404c:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003404f:	5b                   	pop    %ebx
40034050:	5e                   	pop    %esi
40034051:	5f                   	pop    %edi
40034052:	5d                   	pop    %ebp
40034053:	c3                   	ret    

40034054 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
40034054:	55                   	push   %ebp
40034055:	89 e5                	mov    %esp,%ebp
40034057:	56                   	push   %esi
40034058:	53                   	push   %ebx
40034059:	89 c3                	mov    %eax,%ebx
	_remove_thread_from_ready_q(_current);
4003405b:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
40034060:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
40034062:	e8 17 ff ff ff       	call   40033f7e <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
40034067:	89 f1                	mov    %esi,%ecx
40034069:	89 da                	mov    %ebx,%edx
4003406b:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
}
40034070:	5b                   	pop    %ebx
40034071:	5e                   	pop    %esi
40034072:	5d                   	pop    %ebp
	_pend_thread(_current, wait_q, timeout);
40034073:	e9 65 ff ff ff       	jmp    40033fdd <_pend_thread>

40034078 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
40034078:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
40034079:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
4003407e:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
40034080:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40034084:	e8 0d fe ff ff       	call   40033e96 <_get_highest_ready_prio>
#else
	return 0;
#endif
}
40034089:	5d                   	pop    %ebp
	return prio1 < prio2;
4003408a:	39 c2                	cmp    %eax,%edx
4003408c:	0f 9f c0             	setg   %al
4003408f:	0f b6 c0             	movzbl %al,%eax
40034092:	c3                   	ret    

40034093 <_reschedule_threads>:
{
40034093:	89 c1                	mov    %eax,%ecx
	return _is_preempt(_current) && __must_switch_threads();
40034095:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
4003409a:	55                   	push   %ebp
4003409b:	89 e5                	mov    %esp,%ebp
4003409d:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
400340a2:	77 09                	ja     400340ad <_reschedule_threads+0x1a>
400340a4:	e8 cf ff ff ff       	call   40034078 <__must_switch_threads>
400340a9:	85 c0                	test   %eax,%eax
400340ab:	75 09                	jne    400340b6 <_reschedule_threads+0x23>
400340ad:	0f ba e1 09          	bt     $0x9,%ecx
400340b1:	73 0b                	jae    400340be <_reschedule_threads+0x2b>
	__asm__ volatile (
400340b3:	fb                   	sti    
}
400340b4:	eb 08                	jmp    400340be <_reschedule_threads+0x2b>
		_Swap(key);
400340b6:	89 c8                	mov    %ecx,%eax
}
400340b8:	5d                   	pop    %ebp
		_Swap(key);
400340b9:	e9 6d f9 ff ff       	jmp    40033a2b <_Swap>
}
400340be:	5d                   	pop    %ebp
400340bf:	c3                   	ret    

400340c0 <k_sched_unlock>:
{
400340c0:	55                   	push   %ebp
400340c1:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
400340c3:	9c                   	pushf  
400340c4:	fa                   	cli    
400340c5:	58                   	pop    %eax
	++_current->base.sched_locked;
400340c6:	8b 15 c8 76 00 a8    	mov    0xa80076c8,%edx
400340cc:	fe 42 0b             	incb   0xb(%edx)
}
400340cf:	5d                   	pop    %ebp
	_reschedule_threads(key);
400340d0:	e9 be ff ff ff       	jmp    40034093 <_reschedule_threads>

400340d5 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
400340d5:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
400340d9:	8d 0c d5 5c 77 00 a8 	lea    -0x57ff88a4(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
400340e0:	3b 41 04             	cmp    0x4(%ecx),%eax
400340e3:	74 4f                	je     40034134 <_move_thread_to_end_of_prio_q+0x5f>
{
400340e5:	55                   	push   %ebp
	node->prev = list->tail;
400340e6:	83 c2 14             	add    $0x14,%edx
400340e9:	89 e5                	mov    %esp,%ebp
400340eb:	56                   	push   %esi
400340ec:	53                   	push   %ebx
	node->prev->next = node->next;
400340ed:	8b 58 04             	mov    0x4(%eax),%ebx
400340f0:	8b 30                	mov    (%eax),%esi
400340f2:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
400340f4:	8b 30                	mov    (%eax),%esi
400340f6:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
400340f9:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
400340fb:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
40034102:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40034105:	8b 0c d5 c0 76 00 a8 	mov    -0x57ff8940(,%edx,8),%ecx
4003410c:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
4003410e:	89 04 d5 c0 76 00 a8 	mov    %eax,-0x57ff8940(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40034115:	8b 15 d4 76 00 a8    	mov    0xa80076d4,%edx
4003411b:	39 d0                	cmp    %edx,%eax
4003411d:	75 0c                	jne    4003412b <_move_thread_to_end_of_prio_q+0x56>
	int prio = _get_highest_ready_prio();
4003411f:	e8 72 fd ff ff       	call   40033e96 <_get_highest_ready_prio>
40034124:	8b 14 c5 5c 77 00 a8 	mov    -0x57ff88a4(,%eax,8),%edx
#endif
}
4003412b:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
4003412c:	89 15 d4 76 00 a8    	mov    %edx,0xa80076d4
}
40034132:	5e                   	pop    %esi
40034133:	5d                   	pop    %ebp
40034134:	c3                   	ret    

40034135 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
40034135:	55                   	push   %ebp
	return _current;
}
40034136:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
4003413b:	89 e5                	mov    %esp,%ebp
}
4003413d:	5d                   	pop    %ebp
4003413e:	c3                   	ret    

4003413f <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003413f:	8a 50 09             	mov    0x9(%eax),%dl
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
40034142:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034143:	88 d1                	mov    %dl,%cl
{
40034145:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034147:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
4003414a:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003414d:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40034150:	75 0c                	jne    4003415e <_ready_thread+0x1f>
40034152:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40034156:	75 06                	jne    4003415e <_ready_thread+0x1f>
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
	}
}
40034158:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40034159:	e9 c2 fd ff ff       	jmp    40033f20 <_add_thread_to_ready_q>
}
4003415e:	5d                   	pop    %ebp
4003415f:	c3                   	ret    

40034160 <_unpend_first_thread>:
}

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
40034160:	55                   	push   %ebp
	if (_handling_timeouts) {
40034161:	8b 15 c4 78 00 a8    	mov    0xa80078c4,%edx
{
40034167:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
40034169:	85 d2                	test   %edx,%edx
4003416b:	8b 08                	mov    (%eax),%ecx
4003416d:	74 1f                	je     4003418e <_unpend_first_thread+0x2e>
	return list->head == list;
4003416f:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
40034171:	39 c8                	cmp    %ecx,%eax
40034173:	75 11                	jne    40034186 <_unpend_first_thread+0x26>
40034175:	31 d2                	xor    %edx,%edx
40034177:	eb 0d                	jmp    40034186 <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
40034179:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
4003417d:	75 1b                	jne    4003419a <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
4003417f:	3b 50 04             	cmp    0x4(%eax),%edx
40034182:	74 06                	je     4003418a <_unpend_first_thread+0x2a>
40034184:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
40034186:	85 d2                	test   %edx,%edx
40034188:	75 ef                	jne    40034179 <_unpend_first_thread+0x19>
4003418a:	31 d2                	xor    %edx,%edx
4003418c:	eb 1c                	jmp    400341aa <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003418e:	31 d2                	xor    %edx,%edx
40034190:	39 c8                	cmp    %ecx,%eax
40034192:	74 16                	je     400341aa <_unpend_first_thread+0x4a>
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
40034194:	85 c9                	test   %ecx,%ecx
40034196:	74 12                	je     400341aa <_unpend_first_thread+0x4a>
40034198:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
4003419a:	8b 42 04             	mov    0x4(%edx),%eax
4003419d:	8b 0a                	mov    (%edx),%ecx
4003419f:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
400341a1:	8b 0a                	mov    (%edx),%ecx
400341a3:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
400341a6:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
400341aa:	89 d0                	mov    %edx,%eax
400341ac:	5d                   	pop    %ebp
400341ad:	c3                   	ret    

400341ae <_abort_timeout>:
{
400341ae:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
400341af:	8b 48 10             	mov    0x10(%eax),%ecx
{
400341b2:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
400341b4:	83 f9 ff             	cmp    $0xffffffff,%ecx
400341b7:	74 24                	je     400341dd <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
400341b9:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
400341bf:	74 05                	je     400341c6 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
400341c1:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
400341c3:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
400341c6:	8b 50 04             	mov    0x4(%eax),%edx
400341c9:	8b 08                	mov    (%eax),%ecx
400341cb:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
400341cd:	8b 08                	mov    (%eax),%ecx
400341cf:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
400341d2:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
400341d9:	31 c0                	xor    %eax,%eax
400341db:	eb 03                	jmp    400341e0 <_abort_timeout+0x32>
		return _INACTIVE;
400341dd:	83 c8 ff             	or     $0xffffffff,%eax
}
400341e0:	5d                   	pop    %ebp
400341e1:	c3                   	ret    

400341e2 <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
400341e2:	55                   	push   %ebp
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
400341e3:	89 50 08             	mov    %edx,0x8(%eax)
{
400341e6:	89 e5                	mov    %esp,%ebp
	sem->limit = limit;
400341e8:	89 48 0c             	mov    %ecx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
400341eb:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
400341ed:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
400341f0:	5d                   	pop    %ebp
400341f1:	c3                   	ret    

400341f2 <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
400341f2:	55                   	push   %ebp
400341f3:	89 e5                	mov    %esp,%ebp
400341f5:	57                   	push   %edi
400341f6:	56                   	push   %esi
400341f7:	89 c6                	mov    %eax,%esi
400341f9:	53                   	push   %ebx
400341fa:	9c                   	pushf  
400341fb:	fa                   	cli    
400341fc:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
400341fd:	e8 5e ff ff ff       	call   40034160 <_unpend_first_thread>
	if (!thread) {
40034202:	85 c0                	test   %eax,%eax
40034204:	75 12                	jne    40034218 <k_sem_give+0x26>
	sem->count += (sem->count != sem->limit);
40034206:	8b 56 08             	mov    0x8(%esi),%edx
40034209:	31 c0                	xor    %eax,%eax
4003420b:	39 56 0c             	cmp    %edx,0xc(%esi)
4003420e:	0f 95 c0             	setne  %al
40034211:	01 d0                	add    %edx,%eax
40034213:	89 46 08             	mov    %eax,0x8(%esi)
40034216:	eb 43                	jmp    4003425b <k_sem_give+0x69>
40034218:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
4003421a:	8d 40 10             	lea    0x10(%eax),%eax
4003421d:	e8 8c ff ff ff       	call   400341ae <_abort_timeout>
	_ready_thread(thread);
40034222:	89 d8                	mov    %ebx,%eax
40034224:	e8 16 ff ff ff       	call   4003413f <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
40034229:	8b 43 28             	mov    0x28(%ebx),%eax
4003422c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
40034232:	83 3d c0 76 00 a8 00 	cmpl   $0x0,0xa80076c0
40034239:	75 20                	jne    4003425b <k_sem_give+0x69>
	return _is_preempt(_current) && __must_switch_threads();
4003423b:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40034240:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40034245:	77 14                	ja     4003425b <k_sem_give+0x69>
40034247:	e8 2c fe ff ff       	call   40034078 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
4003424c:	85 c0                	test   %eax,%eax
4003424e:	74 0b                	je     4003425b <k_sem_give+0x69>
		_Swap(key);
40034250:	89 f8                	mov    %edi,%eax
	} else {
		irq_unlock(key);
	}
}
40034252:	5b                   	pop    %ebx
40034253:	5e                   	pop    %esi
40034254:	5f                   	pop    %edi
40034255:	5d                   	pop    %ebp
		_Swap(key);
40034256:	e9 d0 f7 ff ff       	jmp    40033a2b <_Swap>
4003425b:	0f ba e7 09          	bt     $0x9,%edi
4003425f:	73 01                	jae    40034262 <k_sem_give+0x70>
	__asm__ volatile (
40034261:	fb                   	sti    
}
40034262:	5b                   	pop    %ebx
40034263:	5e                   	pop    %esi
40034264:	5f                   	pop    %edi
40034265:	5d                   	pop    %ebp
40034266:	c3                   	ret    

40034267 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
40034267:	55                   	push   %ebp
40034268:	89 e5                	mov    %esp,%ebp
4003426a:	53                   	push   %ebx
	__asm__ volatile (
4003426b:	9c                   	pushf  
4003426c:	fa                   	cli    
4003426d:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
4003426e:	8b 48 08             	mov    0x8(%eax),%ecx
40034271:	85 c9                	test   %ecx,%ecx
40034273:	74 08                	je     4003427d <k_sem_take+0x16>
		sem->count--;
40034275:	49                   	dec    %ecx
40034276:	89 48 08             	mov    %ecx,0x8(%eax)
		irq_unlock(key);
		return 0;
40034279:	31 c0                	xor    %eax,%eax
4003427b:	eb 09                	jmp    40034286 <k_sem_take+0x1f>
	}

	if (timeout == K_NO_WAIT) {
4003427d:	85 d2                	test   %edx,%edx
4003427f:	75 0e                	jne    4003428f <k_sem_take+0x28>
		irq_unlock(key);
		return -EBUSY;
40034281:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
40034286:	0f ba e3 09          	bt     $0x9,%ebx
4003428a:	73 11                	jae    4003429d <k_sem_take+0x36>
	__asm__ volatile (
4003428c:	fb                   	sti    
4003428d:	eb 0e                	jmp    4003429d <k_sem_take+0x36>
	}

	_pend_current_thread(&sem->wait_q, timeout);
4003428f:	e8 c0 fd ff ff       	call   40034054 <_pend_current_thread>

	return _Swap(key);
40034294:	89 d8                	mov    %ebx,%eax
}
40034296:	5b                   	pop    %ebx
40034297:	5d                   	pop    %ebp
	return _Swap(key);
40034298:	e9 8e f7 ff ff       	jmp    40033a2b <_Swap>
}
4003429d:	5b                   	pop    %ebx
4003429e:	5d                   	pop    %ebp
4003429f:	c3                   	ret    

400342a0 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
400342a0:	55                   	push   %ebp
400342a1:	89 e5                	mov    %esp,%ebp
400342a3:	57                   	push   %edi
400342a4:	56                   	push   %esi
400342a5:	53                   	push   %ebx
400342a6:	83 ec 08             	sub    $0x8,%esp
400342a9:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
400342ab:	9c                   	pushf  
400342ac:	fa                   	cli    
400342ad:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
400342ae:	89 df                	mov    %ebx,%edi
400342b0:	c1 ff 1f             	sar    $0x1f,%edi
400342b3:	01 1d cc 78 00 a8    	add    %ebx,0xa80078cc
400342b9:	11 3d d0 78 00 a8    	adc    %edi,0xa80078d0
400342bf:	0f ba e0 09          	bt     $0x9,%eax
400342c3:	73 01                	jae    400342c6 <_nano_sys_clock_tick_announce+0x26>
	__asm__ volatile (
400342c5:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
400342c6:	8d 4d ec             	lea    -0x14(%ebp),%ecx
400342c9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
400342cc:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
400342cf:	9c                   	pushf  
400342d0:	fa                   	cli    
400342d1:	5e                   	pop    %esi
	return list->head == list;
400342d2:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
400342d7:	89 f2                	mov    %esi,%edx
	if (!head) {
400342d9:	85 c0                	test   %eax,%eax
400342db:	74 07                	je     400342e4 <_nano_sys_clock_tick_announce+0x44>
400342dd:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
400342e2:	75 10                	jne    400342f4 <_nano_sys_clock_tick_announce+0x54>
400342e4:	0f ba e6 09          	bt     $0x9,%esi
400342e8:	0f 83 07 01 00 00    	jae    400343f5 <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
400342ee:	fb                   	sti    
400342ef:	e9 01 01 00 00       	jmp    400343f5 <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
400342f4:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
400342f7:	c7 05 c4 78 00 a8 01 	movl   $0x1,0xa80078c4
400342fe:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40034301:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
40034305:	75 3e                	jne    40034345 <_nano_sys_clock_tick_announce+0xa5>
	node->prev->next = node->next;
40034307:	8b 70 04             	mov    0x4(%eax),%esi
4003430a:	8b 38                	mov    (%eax),%edi
4003430c:	0f ba e2 09          	bt     $0x9,%edx
40034310:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
40034312:	8b 38                	mov    (%eax),%edi
40034314:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
40034317:	8b 75 ec             	mov    -0x14(%ebp),%esi
4003431a:	89 30                	mov    %esi,(%eax)
	node->prev = list;
4003431c:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
4003431f:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
40034322:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
40034325:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
40034328:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
4003432f:	73 01                	jae    40034332 <_nano_sys_clock_tick_announce+0x92>
40034331:	fb                   	sti    
	__asm__ volatile (
40034332:	9c                   	pushf  
40034333:	fa                   	cli    
40034334:	5a                   	pop    %edx
	return list->head == list;
40034335:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003433a:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
4003433f:	74 04                	je     40034345 <_nano_sys_clock_tick_announce+0xa5>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40034341:	85 c0                	test   %eax,%eax
40034343:	75 bc                	jne    40034301 <_nano_sys_clock_tick_announce+0x61>
40034345:	0f ba e2 09          	bt     $0x9,%edx
40034349:	73 01                	jae    4003434c <_nano_sys_clock_tick_announce+0xac>
	__asm__ volatile (
4003434b:	fb                   	sti    
	return list->head == list;
4003434c:	8b 55 ec             	mov    -0x14(%ebp),%edx
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
4003434f:	39 ca                	cmp    %ecx,%edx
40034351:	74 04                	je     40034357 <_nano_sys_clock_tick_announce+0xb7>
40034353:	85 d2                	test   %edx,%edx
40034355:	75 0f                	jne    40034366 <_nano_sys_clock_tick_announce+0xc6>
	_handling_timeouts = 0;
40034357:	c7 05 c4 78 00 a8 00 	movl   $0x0,0xa80078c4
4003435e:	00 00 00 
40034361:	e9 8f 00 00 00       	jmp    400343f5 <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
40034366:	31 f6                	xor    %esi,%esi
40034368:	3b 55 f0             	cmp    -0x10(%ebp),%edx
4003436b:	74 4d                	je     400343ba <_nano_sys_clock_tick_announce+0x11a>
4003436d:	8b 32                	mov    (%edx),%esi
4003436f:	eb 49                	jmp    400343ba <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
40034371:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
40034375:	74 17                	je     4003438e <_nano_sys_clock_tick_announce+0xee>
	node->prev->next = node->next;
40034377:	8b 50 04             	mov    0x4(%eax),%edx
4003437a:	8b 08                	mov    (%eax),%ecx
4003437c:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003437e:	8b 08                	mov    (%eax),%ecx
40034380:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
40034383:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003438a:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003438e:	8a 50 09             	mov    0x9(%eax),%dl
40034391:	88 d1                	mov    %dl,%cl
40034393:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40034396:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034399:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
4003439c:	74 3b                	je     400343d9 <_nano_sys_clock_tick_announce+0x139>
4003439e:	0f ba e7 09          	bt     $0x9,%edi
400343a2:	73 01                	jae    400343a5 <_nano_sys_clock_tick_announce+0x105>
400343a4:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
400343a5:	85 f6                	test   %esi,%esi
400343a7:	74 ae                	je     40034357 <_nano_sys_clock_tick_announce+0xb7>
	return (node == list->tail) ? NULL : node->next;
400343a9:	31 c0                	xor    %eax,%eax
400343ab:	39 75 f0             	cmp    %esi,-0x10(%ebp)
400343ae:	74 02                	je     400343b2 <_nano_sys_clock_tick_announce+0x112>
400343b0:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
400343b2:	85 f6                	test   %esi,%esi
400343b4:	74 a1                	je     40034357 <_nano_sys_clock_tick_announce+0xb7>
400343b6:	89 f2                	mov    %esi,%edx
400343b8:	89 c6                	mov    %eax,%esi
	node->prev->next = node->next;
400343ba:	8b 42 04             	mov    0x4(%edx),%eax
400343bd:	8b 0a                	mov    (%edx),%ecx
400343bf:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
400343c1:	8b 0a                	mov    (%edx),%ecx
400343c3:	89 41 04             	mov    %eax,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
400343c6:	8b 42 08             	mov    0x8(%edx),%eax
	__asm__ volatile (
400343c9:	9c                   	pushf  
400343ca:	fa                   	cli    
400343cb:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
400343cc:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
400343d3:	85 c0                	test   %eax,%eax
400343d5:	75 9a                	jne    40034371 <_nano_sys_clock_tick_announce+0xd1>
400343d7:	eb 08                	jmp    400343e1 <_nano_sys_clock_tick_announce+0x141>
400343d9:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
400343dd:	75 bf                	jne    4003439e <_nano_sys_clock_tick_announce+0xfe>
400343df:	eb 64                	jmp    40034445 <_nano_sys_clock_tick_announce+0x1a5>
400343e1:	0f ba e7 09          	bt     $0x9,%edi
400343e5:	73 01                	jae    400343e8 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
400343e7:	fb                   	sti    
		if (timeout->func) {
400343e8:	8b 4a 14             	mov    0x14(%edx),%ecx
400343eb:	85 c9                	test   %ecx,%ecx
400343ed:	74 b6                	je     400343a5 <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
400343ef:	89 d0                	mov    %edx,%eax
400343f1:	ff d1                	call   *%ecx
400343f3:	eb b0                	jmp    400343a5 <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
400343f5:	a1 e0 77 00 a8       	mov    0xa80077e0,%eax
400343fa:	85 c0                	test   %eax,%eax
400343fc:	74 51                	je     4003444f <_nano_sys_clock_tick_announce+0x1af>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
400343fe:	8b 15 c8 76 00 a8    	mov    0xa80076c8,%edx
40034404:	0f be 52 0a          	movsbl 0xa(%edx),%edx
40034408:	39 15 dc 77 00 a8    	cmp    %edx,0xa80077dc
4003440e:	7f 3f                	jg     4003444f <_nano_sys_clock_tick_announce+0x1af>
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
40034410:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
40034413:	03 1d c8 78 00 a8    	add    0xa80078c8,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
40034419:	39 d8                	cmp    %ebx,%eax
4003441b:	7e 08                	jle    40034425 <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
4003441d:	89 1d c8 78 00 a8    	mov    %ebx,0xa80078c8
40034423:	eb 2a                	jmp    4003444f <_nano_sys_clock_tick_announce+0x1af>
		_time_slice_elapsed = 0;
40034425:	c7 05 c8 78 00 a8 00 	movl   $0x0,0xa80078c8
4003442c:	00 00 00 
	__asm__ volatile (
4003442f:	9c                   	pushf  
40034430:	fa                   	cli    
40034431:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
40034432:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40034437:	e8 99 fc ff ff       	call   400340d5 <_move_thread_to_end_of_prio_q>
4003443c:	0f ba e3 09          	bt     $0x9,%ebx
40034440:	73 0d                	jae    4003444f <_nano_sys_clock_tick_announce+0x1af>
	__asm__ volatile (
40034442:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
40034443:	eb 0a                	jmp    4003444f <_nano_sys_clock_tick_announce+0x1af>
		_add_thread_to_ready_q(thread);
40034445:	e8 d6 fa ff ff       	call   40033f20 <_add_thread_to_ready_q>
4003444a:	e9 4f ff ff ff       	jmp    4003439e <_nano_sys_clock_tick_announce+0xfe>
4003444f:	58                   	pop    %eax
40034450:	5a                   	pop    %edx
40034451:	5b                   	pop    %ebx
40034452:	5e                   	pop    %esi
40034453:	5f                   	pop    %edi
40034454:	5d                   	pop    %ebp
40034455:	c3                   	ret    

40034456 <_is_thread_ready>:
{
40034456:	55                   	push   %ebp
40034457:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
40034459:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
4003445d:	75 09                	jne    40034468 <_is_thread_ready+0x12>
4003445f:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
40034463:	0f 94 c0             	sete   %al
40034466:	eb 02                	jmp    4003446a <_is_thread_ready+0x14>
40034468:	31 c0                	xor    %eax,%eax
4003446a:	0f b6 c0             	movzbl %al,%eax
}
4003446d:	5d                   	pop    %ebp
4003446e:	c3                   	ret    

4003446f <_abort_timeout>:
{
4003446f:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40034470:	8b 48 10             	mov    0x10(%eax),%ecx
{
40034473:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40034475:	83 f9 ff             	cmp    $0xffffffff,%ecx
40034478:	74 24                	je     4003449e <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
4003447a:	3b 05 d0 76 00 a8    	cmp    0xa80076d0,%eax
40034480:	74 05                	je     40034487 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40034482:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40034484:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40034487:	8b 50 04             	mov    0x4(%eax),%edx
4003448a:	8b 08                	mov    (%eax),%ecx
4003448c:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003448e:	8b 08                	mov    (%eax),%ecx
40034490:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40034493:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
4003449a:	31 c0                	xor    %eax,%eax
4003449c:	eb 03                	jmp    400344a1 <_abort_timeout+0x32>
		return _INACTIVE;
4003449e:	83 c8 ff             	or     $0xffffffff,%eax
}
400344a1:	5d                   	pop    %ebp
400344a2:	c3                   	ret    

400344a3 <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
400344a3:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
400344a4:	85 d2                	test   %edx,%edx
{
400344a6:	89 e5                	mov    %esp,%ebp
400344a8:	57                   	push   %edi
400344a9:	56                   	push   %esi
400344aa:	53                   	push   %ebx
400344ab:	51                   	push   %ecx
400344ac:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
400344ae:	75 41                	jne    400344f1 <schedule_new_thread+0x4e>
	__asm__ volatile (
400344b0:	9c                   	pushf  
400344b1:	fa                   	cli    
400344b2:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
400344b3:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
400344b7:	e8 9a ff ff ff       	call   40034456 <_is_thread_ready>
400344bc:	85 c0                	test   %eax,%eax
400344be:	75 09                	jne    400344c9 <schedule_new_thread+0x26>
400344c0:	0f ba e3 09          	bt     $0x9,%ebx
400344c4:	e9 b1 00 00 00       	jmp    4003457a <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
400344c9:	89 c8                	mov    %ecx,%eax
400344cb:	e8 50 fa ff ff       	call   40033f20 <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
400344d0:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
400344d5:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
400344da:	77 e4                	ja     400344c0 <schedule_new_thread+0x1d>
400344dc:	e8 97 fb ff ff       	call   40034078 <__must_switch_threads>
400344e1:	85 c0                	test   %eax,%eax
400344e3:	74 db                	je     400344c0 <schedule_new_thread+0x1d>
			_Swap(key);
400344e5:	89 d8                	mov    %ebx,%eax
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
400344e7:	5a                   	pop    %edx
400344e8:	5b                   	pop    %ebx
400344e9:	5e                   	pop    %esi
400344ea:	5f                   	pop    %edi
400344eb:	5d                   	pop    %ebp
			_Swap(key);
400344ec:	e9 3a f5 ff ff       	jmp    40033a2b <_Swap>
400344f1:	9c                   	pushf  
400344f2:	fa                   	cli    
400344f3:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
400344f6:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
400344fb:	8d 58 10             	lea    0x10(%eax),%ebx
400344fe:	8d 42 09             	lea    0x9(%edx),%eax
40034501:	31 d2                	xor    %edx,%edx
40034503:	f7 f6                	div    %esi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
40034505:	40                   	inc    %eax
	timeout->thread = thread;
40034506:	89 49 18             	mov    %ecx,0x18(%ecx)
40034509:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
4003450c:	a1 cc 76 00 a8       	mov    0xa80076cc,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
40034511:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40034518:	85 c0                	test   %eax,%eax
4003451a:	74 0d                	je     40034529 <schedule_new_thread+0x86>
4003451c:	8b 3d d0 76 00 a8    	mov    0xa80076d0,%edi
40034522:	3d cc 76 00 a8       	cmp    $0xa80076cc,%eax
40034527:	75 19                	jne    40034542 <schedule_new_thread+0x9f>
	node->next = list;
40034529:	c7 41 10 cc 76 00 a8 	movl   $0xa80076cc,0x10(%ecx)
	node->prev = list->tail;
40034530:	a1 d0 76 00 a8       	mov    0xa80076d0,%eax
40034535:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
40034538:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
4003453a:	89 1d d0 76 00 a8    	mov    %ebx,0xa80076d0
40034540:	eb 31                	jmp    40034573 <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
40034542:	8b 51 20             	mov    0x20(%ecx),%edx
40034545:	8b 70 10             	mov    0x10(%eax),%esi
40034548:	39 f2                	cmp    %esi,%edx
4003454a:	7f 18                	jg     40034564 <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
4003454c:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
4003454e:	8b 50 04             	mov    0x4(%eax),%edx
40034551:	89 70 10             	mov    %esi,0x10(%eax)
40034554:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
40034557:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
4003455a:	8b 50 04             	mov    0x4(%eax),%edx
4003455d:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
4003455f:	89 58 04             	mov    %ebx,0x4(%eax)
40034562:	eb 0f                	jmp    40034573 <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
40034564:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
40034566:	39 f8                	cmp    %edi,%eax
40034568:	89 51 20             	mov    %edx,0x20(%ecx)
4003456b:	74 bc                	je     40034529 <schedule_new_thread+0x86>
4003456d:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003456f:	85 c0                	test   %eax,%eax
40034571:	eb b4                	jmp    40034527 <schedule_new_thread+0x84>
40034573:	8b 45 f0             	mov    -0x10(%ebp),%eax
40034576:	0f ba e0 09          	bt     $0x9,%eax
4003457a:	73 01                	jae    4003457d <schedule_new_thread+0xda>
	__asm__ volatile (
4003457c:	fb                   	sti    
}
4003457d:	58                   	pop    %eax
4003457e:	5b                   	pop    %ebx
4003457f:	5e                   	pop    %esi
40034580:	5f                   	pop    %edi
40034581:	5d                   	pop    %ebp
40034582:	c3                   	ret    

40034583 <k_is_in_isr>:
{
40034583:	55                   	push   %ebp
	return _is_in_isr();
40034584:	31 c0                	xor    %eax,%eax
{
40034586:	89 e5                	mov    %esp,%ebp
}
40034588:	5d                   	pop    %ebp
	return _is_in_isr();
40034589:	83 3d c0 76 00 a8 00 	cmpl   $0x0,0xa80076c0
40034590:	0f 95 c0             	setne  %al
}
40034593:	c3                   	ret    

40034594 <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
40034594:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
{
40034599:	55                   	push   %ebp
4003459a:	89 e5                	mov    %esp,%ebp
}
4003459c:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
4003459d:	8a 40 08             	mov    0x8(%eax),%al
400345a0:	83 e0 01             	and    $0x1,%eax
}
400345a3:	c3                   	ret    

400345a4 <_thread_entry>:
{
400345a4:	55                   	push   %ebp
400345a5:	89 e5                	mov    %esp,%ebp
400345a7:	53                   	push   %ebx
400345a8:	89 c3                	mov    %eax,%ebx
400345aa:	89 d0                	mov    %edx,%eax
400345ac:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
400345ae:	8b 4d 08             	mov    0x8(%ebp),%ecx
400345b1:	ff d3                	call   *%ebx
	if (_is_thread_essential()) {
400345b3:	e8 dc ff ff ff       	call   40034594 <_is_thread_essential>
400345b8:	85 c0                	test   %eax,%eax
400345ba:	74 0f                	je     400345cb <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
400345bc:	ba a0 6b 03 40       	mov    $0x40036ba0,%edx
400345c1:	b8 03 00 00 00       	mov    $0x3,%eax
400345c6:	e8 fb f4 ff ff       	call   40033ac6 <_NanoFatalErrorHandler>
	k_thread_abort(_current);
400345cb:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
400345d0:	e8 fa 00 00 00       	call   400346cf <k_thread_abort>

400345d5 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
400345d5:	55                   	push   %ebp
400345d6:	89 e5                	mov    %esp,%ebp
400345d8:	53                   	push   %ebx
400345d9:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
400345db:	8b 40 30             	mov    0x30(%eax),%eax
400345de:	85 c0                	test   %eax,%eax
400345e0:	74 02                	je     400345e4 <_k_thread_single_abort+0xf>
		thread->fn_abort();
400345e2:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
400345e4:	89 d8                	mov    %ebx,%eax
400345e6:	e8 6b fe ff ff       	call   40034456 <_is_thread_ready>
400345eb:	85 c0                	test   %eax,%eax
400345ed:	74 09                	je     400345f8 <_k_thread_single_abort+0x23>
		_remove_thread_from_ready_q(thread);
400345ef:	89 d8                	mov    %ebx,%eax
400345f1:	e8 88 f9 ff ff       	call   40033f7e <_remove_thread_from_ready_q>
400345f6:	eb 24                	jmp    4003461c <_k_thread_single_abort+0x47>
	} else {
		if (_is_thread_pending(thread)) {
400345f8:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
400345fc:	74 10                	je     4003460e <_k_thread_single_abort+0x39>
	node->prev->next = node->next;
400345fe:	8b 43 04             	mov    0x4(%ebx),%eax
40034601:	8b 13                	mov    (%ebx),%edx
40034603:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
40034605:	8b 13                	mov    (%ebx),%edx
40034607:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003460a:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
4003460e:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
40034612:	74 08                	je     4003461c <_k_thread_single_abort+0x47>
	return _abort_timeout(&thread->base.timeout);
40034614:	8d 43 10             	lea    0x10(%ebx),%eax
40034617:	e8 53 fe ff ff       	call   4003446f <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
4003461c:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
40034620:	5b                   	pop    %ebx
40034621:	5d                   	pop    %ebp
40034622:	c3                   	ret    

40034623 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
40034623:	55                   	push   %ebp
40034624:	89 e5                	mov    %esp,%ebp
40034626:	56                   	push   %esi
40034627:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
40034628:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
4003462d:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40034633:	73 29                	jae    4003465e <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
40034635:	ff 73 1c             	pushl  0x1c(%ebx)
40034638:	ff 73 18             	pushl  0x18(%ebx)
4003463b:	ff 73 14             	pushl  0x14(%ebx)
4003463e:	ff 73 10             	pushl  0x10(%ebx)
40034641:	ff 73 0c             	pushl  0xc(%ebx)
40034644:	8b 03                	mov    (%ebx),%eax
40034646:	8b 4b 08             	mov    0x8(%ebx),%ecx
40034649:	8b 53 04             	mov    0x4(%ebx),%edx
4003464c:	e8 0e f4 ff ff       	call   40033a5f <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
40034651:	8b 03                	mov    (%ebx),%eax
		_new_thread(
40034653:	83 c4 14             	add    $0x14,%esp
		thread_data->thread->init_data = thread_data;
40034656:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
40034659:	83 c3 2c             	add    $0x2c,%ebx
4003465c:	eb cf                	jmp    4003462d <_init_static_threads+0xa>
	--_current->base.sched_locked;
4003465e:	a1 c8 76 00 a8       	mov    0xa80076c8,%eax
40034663:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
40034666:	9c                   	pushf  
40034667:	fa                   	cli    
40034668:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
40034669:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
4003466e:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40034674:	73 14                	jae    4003468a <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
40034676:	8b 53 20             	mov    0x20(%ebx),%edx
40034679:	83 fa ff             	cmp    $0xffffffff,%edx
4003467c:	74 07                	je     40034685 <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
4003467e:	8b 03                	mov    (%ebx),%eax
40034680:	e8 1e fe ff ff       	call   400344a3 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
40034685:	83 c3 2c             	add    $0x2c,%ebx
40034688:	eb e4                	jmp    4003466e <_init_static_threads+0x4b>
4003468a:	0f ba e6 09          	bt     $0x9,%esi
4003468e:	73 01                	jae    40034691 <_init_static_threads+0x6e>
	__asm__ volatile (
40034690:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
40034691:	8d 65 f8             	lea    -0x8(%ebp),%esp
40034694:	5b                   	pop    %ebx
40034695:	5e                   	pop    %esi
40034696:	5d                   	pop    %ebp
	k_sched_unlock();
40034697:	e9 24 fa ff ff       	jmp    400340c0 <k_sched_unlock>

4003469c <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
4003469c:	55                   	push   %ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;
4003469d:	88 48 09             	mov    %cl,0x9(%eax)
{
400346a0:	89 e5                	mov    %esp,%ebp
400346a2:	53                   	push   %ebx

	thread_base->prio = priority;
400346a3:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
400346a6:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	thread_base->user_options = (uint8_t)options;
400346aa:	8a 5d 08             	mov    0x8(%ebp),%bl
	t->delta_ticks_from_prev = _INACTIVE;
400346ad:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
400346b4:	88 58 08             	mov    %bl,0x8(%eax)
	t->wait_q = NULL;
400346b7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
400346be:	5b                   	pop    %ebx
	t->thread = NULL;
400346bf:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
400346c6:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
400346cd:	5d                   	pop    %ebp
400346ce:	c3                   	ret    

400346cf <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
400346cf:	55                   	push   %ebp
400346d0:	89 e5                	mov    %esp,%ebp
400346d2:	56                   	push   %esi
400346d3:	89 c6                	mov    %eax,%esi
400346d5:	53                   	push   %ebx
	__asm__ volatile (
400346d6:	9c                   	pushf  
400346d7:	fa                   	cli    
400346d8:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
400346d9:	e8 f7 fe ff ff       	call   400345d5 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
		_Swap(key);
400346de:	89 d8                	mov    %ebx,%eax
	if (_current == thread) {
400346e0:	3b 35 c8 76 00 a8    	cmp    0xa80076c8,%esi
400346e6:	75 05                	jne    400346ed <k_thread_abort+0x1e>
		_Swap(key);
400346e8:	e8 3e f3 ff ff       	call   40033a2b <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
}
400346ed:	5b                   	pop    %ebx
400346ee:	5e                   	pop    %esi
400346ef:	5d                   	pop    %ebp
	_reschedule_threads(key);
400346f0:	e9 9e f9 ff ff       	jmp    40034093 <_reschedule_threads>

400346f5 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
400346f5:	8a 50 09             	mov    0x9(%eax),%dl
{
400346f8:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
400346f9:	88 d1                	mov    %dl,%cl
{
400346fb:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
400346fd:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40034700:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034703:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40034706:	75 0c                	jne    40034714 <_ready_thread+0x1f>
40034708:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003470c:	75 06                	jne    40034714 <_ready_thread+0x1f>
}
4003470e:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
4003470f:	e9 0c f8 ff ff       	jmp    40033f20 <_add_thread_to_ready_q>
}
40034714:	5d                   	pop    %ebp
40034715:	c3                   	ret    

40034716 <_add_timeout.constprop.7>:
	timeout->thread = thread;
40034716:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003471d:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
40034720:	55                   	push   %ebp
	return list->head == list;
40034721:	8b 15 cc 76 00 a8    	mov    0xa80076cc,%edx
40034727:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40034729:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003472c:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003472d:	85 d2                	test   %edx,%edx
4003472f:	74 08                	je     40034739 <_add_timeout.constprop.7+0x23>
40034731:	81 fa cc 76 00 a8    	cmp    $0xa80076cc,%edx
40034737:	75 1e                	jne    40034757 <_add_timeout.constprop.7+0x41>
	node->next = list;
40034739:	c7 00 cc 76 00 a8    	movl   $0xa80076cc,(%eax)
	node->prev = list->tail;
4003473f:	8b 15 d0 76 00 a8    	mov    0xa80076d0,%edx
40034745:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
40034748:	8b 15 d0 76 00 a8    	mov    0xa80076d0,%edx
4003474e:	89 02                	mov    %eax,(%edx)
	list->tail = node;
40034750:	a3 d0 76 00 a8       	mov    %eax,0xa80076d0
40034755:	eb 34                	jmp    4003478b <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
40034757:	8b 48 10             	mov    0x10(%eax),%ecx
4003475a:	8b 5a 10             	mov    0x10(%edx),%ebx
4003475d:	39 d9                	cmp    %ebx,%ecx
4003475f:	7f 17                	jg     40034778 <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
40034761:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
40034763:	8b 4a 04             	mov    0x4(%edx),%ecx
40034766:	89 5a 10             	mov    %ebx,0x10(%edx)
40034769:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
4003476c:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
4003476e:	8b 4a 04             	mov    0x4(%edx),%ecx
40034771:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
40034773:	89 42 04             	mov    %eax,0x4(%edx)
40034776:	eb 13                	jmp    4003478b <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
40034778:	29 d9                	sub    %ebx,%ecx
4003477a:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
4003477d:	3b 15 d0 76 00 a8    	cmp    0xa80076d0,%edx
40034783:	74 b4                	je     40034739 <_add_timeout.constprop.7+0x23>
40034785:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40034787:	85 d2                	test   %edx,%edx
40034789:	eb ac                	jmp    40034737 <_add_timeout.constprop.7+0x21>
}
4003478b:	5b                   	pop    %ebx
4003478c:	5d                   	pop    %ebp
4003478d:	c3                   	ret    

4003478e <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
4003478e:	55                   	push   %ebp
4003478f:	89 e5                	mov    %esp,%ebp
40034791:	56                   	push   %esi
40034792:	53                   	push   %ebx
40034793:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
40034795:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
40034799:	7e 15                	jle    400347b0 <_timer_expiration_handler+0x22>
4003479b:	9c                   	pushf  
4003479c:	fa                   	cli    
4003479d:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
4003479e:	8b 48 28             	mov    0x28(%eax),%ecx
400347a1:	8d 50 18             	lea    0x18(%eax),%edx
400347a4:	e8 6d ff ff ff       	call   40034716 <_add_timeout.constprop.7>
400347a9:	0f ba e6 09          	bt     $0x9,%esi
400347ad:	73 01                	jae    400347b0 <_timer_expiration_handler+0x22>
	__asm__ volatile (
400347af:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
400347b0:	8b 53 20             	mov    0x20(%ebx),%edx
	timer->status += 1;
400347b3:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
400347b6:	85 d2                	test   %edx,%edx
400347b8:	74 04                	je     400347be <_timer_expiration_handler+0x30>
		timer->expiry_fn(timer);
400347ba:	89 d8                	mov    %ebx,%eax
400347bc:	ff d2                	call   *%edx
	return list->head == list;
400347be:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
400347c1:	85 f6                	test   %esi,%esi
400347c3:	74 31                	je     400347f6 <_timer_expiration_handler+0x68>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
400347c5:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
400347c8:	39 de                	cmp    %ebx,%esi
400347ca:	74 2a                	je     400347f6 <_timer_expiration_handler+0x68>
	node->prev->next = node->next;
400347cc:	8b 46 04             	mov    0x4(%esi),%eax
400347cf:	8b 16                	mov    (%esi),%edx
400347d1:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
400347d3:	8b 16                	mov    (%esi),%edx
400347d5:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
400347d8:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
400347dc:	9c                   	pushf  
400347dd:	fa                   	cli    
400347de:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
400347df:	89 f0                	mov    %esi,%eax
400347e1:	e8 0f ff ff ff       	call   400346f5 <_ready_thread>
400347e6:	0f ba e3 09          	bt     $0x9,%ebx
400347ea:	73 01                	jae    400347ed <_timer_expiration_handler+0x5f>
	__asm__ volatile (
400347ec:	fb                   	sti    
400347ed:	8b 46 28             	mov    0x28(%esi),%eax
400347f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
400347f6:	5b                   	pop    %ebx
400347f7:	5e                   	pop    %esi
400347f8:	5d                   	pop    %ebp
400347f9:	c3                   	ret    

400347fa <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
400347fa:	55                   	push   %ebp
400347fb:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
400347fd:	5d                   	pop    %ebp
400347fe:	c3                   	ret    

400347ff <malloc>:
400347ff:	53                   	push   %ebx
40034800:	89 c3                	mov    %eax,%ebx
40034802:	e8 7c 02 00 00       	call   40034a83 <__getreent>
40034807:	89 da                	mov    %ebx,%edx
40034809:	5b                   	pop    %ebx
4003480a:	e9 c9 00 00 00       	jmp    400348d8 <_malloc_r>

4003480f <free>:
4003480f:	53                   	push   %ebx
40034810:	89 c3                	mov    %eax,%ebx
40034812:	e8 6c 02 00 00       	call   40034a83 <__getreent>
40034817:	89 da                	mov    %ebx,%edx
40034819:	5b                   	pop    %ebx
4003481a:	e9 00 00 00 00       	jmp    4003481f <_free_r>

4003481f <_free_r>:
4003481f:	85 d2                	test   %edx,%edx
40034821:	0f 84 b0 00 00 00    	je     400348d7 <_free_r+0xb8>
40034827:	8d 4a fc             	lea    -0x4(%edx),%ecx
4003482a:	8b 52 fc             	mov    -0x4(%edx),%edx
4003482d:	85 d2                	test   %edx,%edx
4003482f:	79 02                	jns    40034833 <_free_r+0x14>
40034831:	01 d1                	add    %edx,%ecx
40034833:	8b 15 e4 67 00 a8    	mov    0xa80067e4,%edx
40034839:	85 d2                	test   %edx,%edx
4003483b:	75 0e                	jne    4003484b <_free_r+0x2c>
4003483d:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
40034844:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
4003484a:	c3                   	ret    
4003484b:	57                   	push   %edi
4003484c:	39 ca                	cmp    %ecx,%edx
4003484e:	56                   	push   %esi
4003484f:	53                   	push   %ebx
40034850:	53                   	push   %ebx
40034851:	76 20                	jbe    40034873 <_free_r+0x54>
40034853:	8b 01                	mov    (%ecx),%eax
40034855:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
40034858:	39 da                	cmp    %ebx,%edx
4003485a:	75 0c                	jne    40034868 <_free_r+0x49>
4003485c:	03 02                	add    (%edx),%eax
4003485e:	89 01                	mov    %eax,(%ecx)
40034860:	8b 42 04             	mov    0x4(%edx),%eax
40034863:	89 41 04             	mov    %eax,0x4(%ecx)
40034866:	eb 03                	jmp    4003486b <_free_r+0x4c>
40034868:	89 51 04             	mov    %edx,0x4(%ecx)
4003486b:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
40034871:	eb 60                	jmp    400348d3 <_free_r+0xb4>
40034873:	8b 72 04             	mov    0x4(%edx),%esi
40034876:	85 f6                	test   %esi,%esi
40034878:	0f 95 44 24 03       	setne  0x3(%esp)
4003487d:	39 ce                	cmp    %ecx,%esi
4003487f:	0f 96 c3             	setbe  %bl
40034882:	84 5c 24 03          	test   %bl,0x3(%esp)
40034886:	74 04                	je     4003488c <_free_r+0x6d>
40034888:	89 f2                	mov    %esi,%edx
4003488a:	eb e7                	jmp    40034873 <_free_r+0x54>
4003488c:	8b 1a                	mov    (%edx),%ebx
4003488e:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
40034891:	39 cf                	cmp    %ecx,%edi
40034893:	75 19                	jne    400348ae <_free_r+0x8f>
40034895:	8b 01                	mov    (%ecx),%eax
40034897:	01 d8                	add    %ebx,%eax
40034899:	89 02                	mov    %eax,(%edx)
4003489b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
4003489e:	39 ce                	cmp    %ecx,%esi
400348a0:	75 31                	jne    400348d3 <_free_r+0xb4>
400348a2:	03 06                	add    (%esi),%eax
400348a4:	89 02                	mov    %eax,(%edx)
400348a6:	8b 46 04             	mov    0x4(%esi),%eax
400348a9:	89 42 04             	mov    %eax,0x4(%edx)
400348ac:	eb 25                	jmp    400348d3 <_free_r+0xb4>
400348ae:	76 08                	jbe    400348b8 <_free_r+0x99>
400348b0:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
400348b6:	eb 1b                	jmp    400348d3 <_free_r+0xb4>
400348b8:	8b 01                	mov    (%ecx),%eax
400348ba:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
400348bd:	39 de                	cmp    %ebx,%esi
400348bf:	75 0c                	jne    400348cd <_free_r+0xae>
400348c1:	03 06                	add    (%esi),%eax
400348c3:	89 01                	mov    %eax,(%ecx)
400348c5:	8b 46 04             	mov    0x4(%esi),%eax
400348c8:	89 41 04             	mov    %eax,0x4(%ecx)
400348cb:	eb 03                	jmp    400348d0 <_free_r+0xb1>
400348cd:	89 71 04             	mov    %esi,0x4(%ecx)
400348d0:	89 4a 04             	mov    %ecx,0x4(%edx)
400348d3:	58                   	pop    %eax
400348d4:	5b                   	pop    %ebx
400348d5:	5e                   	pop    %esi
400348d6:	5f                   	pop    %edi
400348d7:	c3                   	ret    

400348d8 <_malloc_r>:
400348d8:	57                   	push   %edi
400348d9:	8d 7a 03             	lea    0x3(%edx),%edi
400348dc:	83 e7 fc             	and    $0xfffffffc,%edi
400348df:	56                   	push   %esi
400348e0:	83 c7 08             	add    $0x8,%edi
400348e3:	53                   	push   %ebx
400348e4:	89 c6                	mov    %eax,%esi
400348e6:	83 ff 0c             	cmp    $0xc,%edi
400348e9:	73 05                	jae    400348f0 <_malloc_r+0x18>
400348eb:	bf 0c 00 00 00       	mov    $0xc,%edi
400348f0:	89 f8                	mov    %edi,%eax
400348f2:	c1 e8 1f             	shr    $0x1f,%eax
400348f5:	75 0c                	jne    40034903 <_malloc_r+0x2b>
400348f7:	8b 0d e4 67 00 a8    	mov    0xa80067e4,%ecx
400348fd:	39 fa                	cmp    %edi,%edx
400348ff:	89 c8                	mov    %ecx,%eax
40034901:	76 18                	jbe    4003491b <_malloc_r+0x43>
40034903:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
40034909:	31 c0                	xor    %eax,%eax
4003490b:	e9 97 00 00 00       	jmp    400349a7 <_malloc_r+0xcf>
40034910:	8b 10                	mov    (%eax),%edx
40034912:	29 fa                	sub    %edi,%edx
40034914:	79 0b                	jns    40034921 <_malloc_r+0x49>
40034916:	89 c1                	mov    %eax,%ecx
40034918:	8b 40 04             	mov    0x4(%eax),%eax
4003491b:	85 c0                	test   %eax,%eax
4003491d:	75 f1                	jne    40034910 <_malloc_r+0x38>
4003491f:	eb 26                	jmp    40034947 <_malloc_r+0x6f>
40034921:	83 fa 0b             	cmp    $0xb,%edx
40034924:	76 09                	jbe    4003492f <_malloc_r+0x57>
40034926:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
40034929:	89 10                	mov    %edx,(%eax)
4003492b:	89 39                	mov    %edi,(%ecx)
4003492d:	eb 4d                	jmp    4003497c <_malloc_r+0xa4>
4003492f:	39 c1                	cmp    %eax,%ecx
40034931:	75 0a                	jne    4003493d <_malloc_r+0x65>
40034933:	8b 41 04             	mov    0x4(%ecx),%eax
40034936:	a3 e4 67 00 a8       	mov    %eax,0xa80067e4
4003493b:	eb 3f                	jmp    4003497c <_malloc_r+0xa4>
4003493d:	8b 50 04             	mov    0x4(%eax),%edx
40034940:	89 51 04             	mov    %edx,0x4(%ecx)
40034943:	89 c1                	mov    %eax,%ecx
40034945:	eb 35                	jmp    4003497c <_malloc_r+0xa4>
40034947:	83 3d e0 67 00 a8 00 	cmpl   $0x0,0xa80067e0
4003494e:	75 0e                	jne    4003495e <_malloc_r+0x86>
40034950:	31 d2                	xor    %edx,%edx
40034952:	89 f0                	mov    %esi,%eax
40034954:	e8 6a 00 00 00       	call   400349c3 <_sbrk_r>
40034959:	a3 e0 67 00 a8       	mov    %eax,0xa80067e0
4003495e:	89 fa                	mov    %edi,%edx
40034960:	89 f0                	mov    %esi,%eax
40034962:	e8 5c 00 00 00       	call   400349c3 <_sbrk_r>
40034967:	83 f8 ff             	cmp    $0xffffffff,%eax
4003496a:	74 97                	je     40034903 <_malloc_r+0x2b>
4003496c:	8d 48 03             	lea    0x3(%eax),%ecx
4003496f:	89 cb                	mov    %ecx,%ebx
40034971:	83 e3 fc             	and    $0xfffffffc,%ebx
40034974:	39 d8                	cmp    %ebx,%eax
40034976:	75 1c                	jne    40034994 <_malloc_r+0xbc>
40034978:	89 3b                	mov    %edi,(%ebx)
4003497a:	89 d9                	mov    %ebx,%ecx
4003497c:	8d 41 0b             	lea    0xb(%ecx),%eax
4003497f:	8d 51 04             	lea    0x4(%ecx),%edx
40034982:	83 e0 f8             	and    $0xfffffff8,%eax
40034985:	89 c6                	mov    %eax,%esi
40034987:	29 d6                	sub    %edx,%esi
40034989:	74 1c                	je     400349a7 <_malloc_r+0xcf>
4003498b:	89 f3                	mov    %esi,%ebx
4003498d:	f7 db                	neg    %ebx
4003498f:	89 1c 31             	mov    %ebx,(%ecx,%esi,1)
40034992:	eb 13                	jmp    400349a7 <_malloc_r+0xcf>
40034994:	89 da                	mov    %ebx,%edx
40034996:	29 c2                	sub    %eax,%edx
40034998:	89 f0                	mov    %esi,%eax
4003499a:	e8 24 00 00 00       	call   400349c3 <_sbrk_r>
4003499f:	40                   	inc    %eax
400349a0:	75 d6                	jne    40034978 <_malloc_r+0xa0>
400349a2:	e9 5c ff ff ff       	jmp    40034903 <_malloc_r+0x2b>
400349a7:	5b                   	pop    %ebx
400349a8:	5e                   	pop    %esi
400349a9:	5f                   	pop    %edi
400349aa:	c3                   	ret    

400349ab <iprintf>:
400349ab:	e8 d3 00 00 00       	call   40034a83 <__getreent>
400349b0:	8d 4c 24 08          	lea    0x8(%esp),%ecx
400349b4:	8b 50 08             	mov    0x8(%eax),%edx
400349b7:	51                   	push   %ecx
400349b8:	8b 4c 24 08          	mov    0x8(%esp),%ecx
400349bc:	e8 e8 07 00 00       	call   400351a9 <_vfiprintf_r>
400349c1:	5a                   	pop    %edx
400349c2:	c3                   	ret    

400349c3 <_sbrk_r>:
400349c3:	53                   	push   %ebx
400349c4:	89 c3                	mov    %eax,%ebx
400349c6:	89 d0                	mov    %edx,%eax
400349c8:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
400349cf:	00 00 00 
400349d2:	e8 23 ca ff ff       	call   400313fa <_sbrk>
400349d7:	83 f8 ff             	cmp    $0xffffffff,%eax
400349da:	75 0c                	jne    400349e8 <_sbrk_r+0x25>
400349dc:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
400349e2:	85 d2                	test   %edx,%edx
400349e4:	74 02                	je     400349e8 <_sbrk_r+0x25>
400349e6:	89 13                	mov    %edx,(%ebx)
400349e8:	5b                   	pop    %ebx
400349e9:	c3                   	ret    

400349ea <sniprintf>:
400349ea:	57                   	push   %edi
400349eb:	56                   	push   %esi
400349ec:	53                   	push   %ebx
400349ed:	83 ec 68             	sub    $0x68,%esp
400349f0:	8b 5c 24 7c          	mov    0x7c(%esp),%ebx
400349f4:	8b 7c 24 78          	mov    0x78(%esp),%edi
400349f8:	e8 86 00 00 00       	call   40034a83 <__getreent>
400349fd:	85 db                	test   %ebx,%ebx
400349ff:	89 c6                	mov    %eax,%esi
40034a01:	79 0b                	jns    40034a0e <sniprintf+0x24>
40034a03:	c7 00 8b 00 00 00    	movl   $0x8b,(%eax)
40034a09:	83 c8 ff             	or     $0xffffffff,%eax
40034a0c:	eb 57                	jmp    40034a65 <sniprintf+0x7b>
40034a0e:	66 c7 44 24 0c 08 02 	movw   $0x208,0xc(%esp)
40034a15:	89 3c 24             	mov    %edi,(%esp)
40034a18:	89 7c 24 10          	mov    %edi,0x10(%esp)
40034a1c:	b8 00 00 00 00       	mov    $0x0,%eax
40034a21:	74 03                	je     40034a26 <sniprintf+0x3c>
40034a23:	8d 43 ff             	lea    -0x1(%ebx),%eax
40034a26:	89 44 24 08          	mov    %eax,0x8(%esp)
40034a2a:	89 44 24 14          	mov    %eax,0x14(%esp)
40034a2e:	8d 84 24 84 00 00 00 	lea    0x84(%esp),%eax
40034a35:	66 c7 44 24 0e ff ff 	movw   $0xffff,0xe(%esp)
40034a3c:	50                   	push   %eax
40034a3d:	89 f0                	mov    %esi,%eax
40034a3f:	8b 8c 24 84 00 00 00 	mov    0x84(%esp),%ecx
40034a46:	8d 54 24 04          	lea    0x4(%esp),%edx
40034a4a:	e8 22 01 00 00       	call   40034b71 <_svfiprintf_r>
40034a4f:	5a                   	pop    %edx
40034a50:	83 f8 ff             	cmp    $0xffffffff,%eax
40034a53:	7d 06                	jge    40034a5b <sniprintf+0x71>
40034a55:	c7 06 8b 00 00 00    	movl   $0x8b,(%esi)
40034a5b:	85 db                	test   %ebx,%ebx
40034a5d:	74 06                	je     40034a65 <sniprintf+0x7b>
40034a5f:	8b 14 24             	mov    (%esp),%edx
40034a62:	c6 02 00             	movb   $0x0,(%edx)
40034a65:	83 c4 68             	add    $0x68,%esp
40034a68:	5b                   	pop    %ebx
40034a69:	5e                   	pop    %esi
40034a6a:	5f                   	pop    %edi
40034a6b:	c3                   	ret    

40034a6c <strcmp>:
40034a6c:	8a 08                	mov    (%eax),%cl
40034a6e:	84 c9                	test   %cl,%cl
40034a70:	74 08                	je     40034a7a <strcmp+0xe>
40034a72:	3a 0a                	cmp    (%edx),%cl
40034a74:	75 04                	jne    40034a7a <strcmp+0xe>
40034a76:	40                   	inc    %eax
40034a77:	42                   	inc    %edx
40034a78:	eb f2                	jmp    40034a6c <strcmp>
40034a7a:	0f b6 12             	movzbl (%edx),%edx
40034a7d:	0f b6 c1             	movzbl %cl,%eax
40034a80:	29 d0                	sub    %edx,%eax
40034a82:	c3                   	ret    

40034a83 <__getreent>:
40034a83:	a1 00 64 00 a8       	mov    0xa8006400,%eax
40034a88:	c3                   	ret    

40034a89 <__ssputs_r>:
40034a89:	55                   	push   %ebp
40034a8a:	57                   	push   %edi
40034a8b:	56                   	push   %esi
40034a8c:	53                   	push   %ebx
40034a8d:	83 ec 08             	sub    $0x8,%esp
40034a90:	89 d3                	mov    %edx,%ebx
40034a92:	8b 7a 08             	mov    0x8(%edx),%edi
40034a95:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40034a99:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
40034a9d:	0f 87 a8 00 00 00    	ja     40034b4b <__ssputs_r+0xc2>
40034aa3:	8b 4a 0c             	mov    0xc(%edx),%ecx
40034aa6:	66 f7 c1 80 04       	test   $0x480,%cx
40034aab:	0f 84 9a 00 00 00    	je     40034b4b <__ssputs_r+0xc2>
40034ab1:	8b 7a 10             	mov    0x10(%edx),%edi
40034ab4:	89 c5                	mov    %eax,%ebp
40034ab6:	8b 02                	mov    (%edx),%eax
40034ab8:	be 02 00 00 00       	mov    $0x2,%esi
40034abd:	29 f8                	sub    %edi,%eax
40034abf:	89 04 24             	mov    %eax,(%esp)
40034ac2:	6b 42 14 03          	imul   $0x3,0x14(%edx),%eax
40034ac6:	99                   	cltd   
40034ac7:	f7 fe                	idiv   %esi
40034ac9:	89 c6                	mov    %eax,%esi
40034acb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034acf:	8b 04 24             	mov    (%esp),%eax
40034ad2:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
40034ad6:	39 f0                	cmp    %esi,%eax
40034ad8:	76 02                	jbe    40034adc <__ssputs_r+0x53>
40034ada:	89 c6                	mov    %eax,%esi
40034adc:	80 e5 04             	and    $0x4,%ch
40034adf:	74 29                	je     40034b0a <__ssputs_r+0x81>
40034ae1:	89 f2                	mov    %esi,%edx
40034ae3:	89 e8                	mov    %ebp,%eax
40034ae5:	e8 ee fd ff ff       	call   400348d8 <_malloc_r>
40034aea:	89 c7                	mov    %eax,%edi
40034aec:	85 c0                	test   %eax,%eax
40034aee:	74 35                	je     40034b25 <__ssputs_r+0x9c>
40034af0:	8b 53 10             	mov    0x10(%ebx),%edx
40034af3:	8b 0c 24             	mov    (%esp),%ecx
40034af6:	e8 6f b5 ff ff       	call   4003006a <memcpy>
40034afb:	8b 43 0c             	mov    0xc(%ebx),%eax
40034afe:	66 25 7f fb          	and    $0xfb7f,%ax
40034b02:	0c 80                	or     $0x80,%al
40034b04:	66 89 43 0c          	mov    %ax,0xc(%ebx)
40034b08:	eb 2c                	jmp    40034b36 <__ssputs_r+0xad>
40034b0a:	89 fa                	mov    %edi,%edx
40034b0c:	89 f1                	mov    %esi,%ecx
40034b0e:	89 e8                	mov    %ebp,%eax
40034b10:	e8 0b 0e 00 00       	call   40035920 <_realloc_r>
40034b15:	89 c7                	mov    %eax,%edi
40034b17:	85 c0                	test   %eax,%eax
40034b19:	75 1b                	jne    40034b36 <__ssputs_r+0xad>
40034b1b:	8b 53 10             	mov    0x10(%ebx),%edx
40034b1e:	89 e8                	mov    %ebp,%eax
40034b20:	e8 fa fc ff ff       	call   4003481f <_free_r>
40034b25:	c7 45 00 0c 00 00 00 	movl   $0xc,0x0(%ebp)
40034b2c:	83 c8 ff             	or     $0xffffffff,%eax
40034b2f:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
40034b34:	eb 33                	jmp    40034b69 <__ssputs_r+0xe0>
40034b36:	89 7b 10             	mov    %edi,0x10(%ebx)
40034b39:	89 73 14             	mov    %esi,0x14(%ebx)
40034b3c:	03 3c 24             	add    (%esp),%edi
40034b3f:	2b 34 24             	sub    (%esp),%esi
40034b42:	89 3b                	mov    %edi,(%ebx)
40034b44:	89 73 08             	mov    %esi,0x8(%ebx)
40034b47:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
40034b4b:	39 7c 24 1c          	cmp    %edi,0x1c(%esp)
40034b4f:	73 04                	jae    40034b55 <__ssputs_r+0xcc>
40034b51:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
40034b55:	89 f9                	mov    %edi,%ecx
40034b57:	8b 54 24 04          	mov    0x4(%esp),%edx
40034b5b:	8b 03                	mov    (%ebx),%eax
40034b5d:	e8 39 b5 ff ff       	call   4003009b <memmove>
40034b62:	29 7b 08             	sub    %edi,0x8(%ebx)
40034b65:	01 3b                	add    %edi,(%ebx)
40034b67:	31 c0                	xor    %eax,%eax
40034b69:	83 c4 08             	add    $0x8,%esp
40034b6c:	5b                   	pop    %ebx
40034b6d:	5e                   	pop    %esi
40034b6e:	5f                   	pop    %edi
40034b6f:	5d                   	pop    %ebp
40034b70:	c3                   	ret    

40034b71 <_svfiprintf_r>:
40034b71:	55                   	push   %ebp
40034b72:	57                   	push   %edi
40034b73:	56                   	push   %esi
40034b74:	53                   	push   %ebx
40034b75:	83 ec 68             	sub    $0x68,%esp
40034b78:	89 c5                	mov    %eax,%ebp
40034b7a:	89 d6                	mov    %edx,%esi
40034b7c:	89 cf                	mov    %ecx,%edi
40034b7e:	f6 42 0c 80          	testb  $0x80,0xc(%edx)
40034b82:	74 2f                	je     40034bb3 <_svfiprintf_r+0x42>
40034b84:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
40034b88:	75 29                	jne    40034bb3 <_svfiprintf_r+0x42>
40034b8a:	ba 40 00 00 00       	mov    $0x40,%edx
40034b8f:	e8 44 fd ff ff       	call   400348d8 <_malloc_r>
40034b94:	89 06                	mov    %eax,(%esi)
40034b96:	89 46 10             	mov    %eax,0x10(%esi)
40034b99:	85 c0                	test   %eax,%eax
40034b9b:	75 0f                	jne    40034bac <_svfiprintf_r+0x3b>
40034b9d:	c7 45 00 0c 00 00 00 	movl   $0xc,0x0(%ebp)
40034ba4:	83 c8 ff             	or     $0xffffffff,%eax
40034ba7:	e9 27 02 00 00       	jmp    40034dd3 <_svfiprintf_r+0x262>
40034bac:	c7 46 14 40 00 00 00 	movl   $0x40,0x14(%esi)
40034bb3:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
40034bba:	00 
40034bbb:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
40034bc0:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
40034bc5:	89 fb                	mov    %edi,%ebx
40034bc7:	8a 03                	mov    (%ebx),%al
40034bc9:	84 c0                	test   %al,%al
40034bcb:	0f 95 c2             	setne  %dl
40034bce:	3c 25                	cmp    $0x25,%al
40034bd0:	0f 95 c0             	setne  %al
40034bd3:	20 c2                	and    %al,%dl
40034bd5:	88 54 24 07          	mov    %dl,0x7(%esp)
40034bd9:	74 03                	je     40034bde <_svfiprintf_r+0x6d>
40034bdb:	43                   	inc    %ebx
40034bdc:	eb e9                	jmp    40034bc7 <_svfiprintf_r+0x56>
40034bde:	89 d8                	mov    %ebx,%eax
40034be0:	29 f8                	sub    %edi,%eax
40034be2:	89 44 24 08          	mov    %eax,0x8(%esp)
40034be6:	74 1c                	je     40034c04 <_svfiprintf_r+0x93>
40034be8:	50                   	push   %eax
40034be9:	89 f9                	mov    %edi,%ecx
40034beb:	89 f2                	mov    %esi,%edx
40034bed:	89 e8                	mov    %ebp,%eax
40034bef:	e8 95 fe ff ff       	call   40034a89 <__ssputs_r>
40034bf4:	59                   	pop    %ecx
40034bf5:	40                   	inc    %eax
40034bf6:	0f 84 ca 01 00 00    	je     40034dc6 <_svfiprintf_r+0x255>
40034bfc:	8b 44 24 08          	mov    0x8(%esp),%eax
40034c00:	01 44 24 20          	add    %eax,0x20(%esp)
40034c04:	80 3b 00             	cmpb   $0x0,(%ebx)
40034c07:	0f 84 b9 01 00 00    	je     40034dc6 <_svfiprintf_r+0x255>
40034c0d:	43                   	inc    %ebx
40034c0e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
40034c15:	00 
40034c16:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
40034c1d:	00 
40034c1e:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034c25:	ff 
40034c26:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
40034c2d:	00 
40034c2e:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
40034c33:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
40034c3a:	00 
40034c3b:	0f be 13             	movsbl (%ebx),%edx
40034c3e:	b9 05 00 00 00       	mov    $0x5,%ecx
40034c43:	b8 52 6c 03 40       	mov    $0x40036c52,%eax
40034c48:	e8 36 b4 ff ff       	call   40030083 <memchr>
40034c4d:	85 c0                	test   %eax,%eax
40034c4f:	74 15                	je     40034c66 <_svfiprintf_r+0xf5>
40034c51:	2d 52 6c 03 40       	sub    $0x40036c52,%eax
40034c56:	ba 01 00 00 00       	mov    $0x1,%edx
40034c5b:	88 c1                	mov    %al,%cl
40034c5d:	43                   	inc    %ebx
40034c5e:	d3 e2                	shl    %cl,%edx
40034c60:	09 54 24 0c          	or     %edx,0xc(%esp)
40034c64:	eb d5                	jmp    40034c3b <_svfiprintf_r+0xca>
40034c66:	8b 44 24 0c          	mov    0xc(%esp),%eax
40034c6a:	a8 10                	test   $0x10,%al
40034c6c:	74 05                	je     40034c73 <_svfiprintf_r+0x102>
40034c6e:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40034c73:	a8 08                	test   $0x8,%al
40034c75:	74 05                	je     40034c7c <_svfiprintf_r+0x10b>
40034c77:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
40034c7c:	80 3b 2a             	cmpb   $0x2a,(%ebx)
40034c7f:	74 08                	je     40034c89 <_svfiprintf_r+0x118>
40034c81:	8b 44 24 18          	mov    0x18(%esp),%eax
40034c85:	31 c9                	xor    %ecx,%ecx
40034c87:	eb 27                	jmp    40034cb0 <_svfiprintf_r+0x13f>
40034c89:	8b 54 24 7c          	mov    0x7c(%esp),%edx
40034c8d:	8d 4a 04             	lea    0x4(%edx),%ecx
40034c90:	8b 12                	mov    (%edx),%edx
40034c92:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
40034c96:	85 d2                	test   %edx,%edx
40034c98:	78 06                	js     40034ca0 <_svfiprintf_r+0x12f>
40034c9a:	89 54 24 18          	mov    %edx,0x18(%esp)
40034c9e:	eb 0d                	jmp    40034cad <_svfiprintf_r+0x13c>
40034ca0:	f7 da                	neg    %edx
40034ca2:	83 c8 02             	or     $0x2,%eax
40034ca5:	89 54 24 18          	mov    %edx,0x18(%esp)
40034ca9:	89 44 24 0c          	mov    %eax,0xc(%esp)
40034cad:	43                   	inc    %ebx
40034cae:	eb 1d                	jmp    40034ccd <_svfiprintf_r+0x15c>
40034cb0:	0f be 13             	movsbl (%ebx),%edx
40034cb3:	83 ea 30             	sub    $0x30,%edx
40034cb6:	83 fa 09             	cmp    $0x9,%edx
40034cb9:	77 0a                	ja     40034cc5 <_svfiprintf_r+0x154>
40034cbb:	6b c0 0a             	imul   $0xa,%eax,%eax
40034cbe:	43                   	inc    %ebx
40034cbf:	01 d0                	add    %edx,%eax
40034cc1:	b1 01                	mov    $0x1,%cl
40034cc3:	eb eb                	jmp    40034cb0 <_svfiprintf_r+0x13f>
40034cc5:	84 c9                	test   %cl,%cl
40034cc7:	74 04                	je     40034ccd <_svfiprintf_r+0x15c>
40034cc9:	89 44 24 18          	mov    %eax,0x18(%esp)
40034ccd:	80 3b 2e             	cmpb   $0x2e,(%ebx)
40034cd0:	75 56                	jne    40034d28 <_svfiprintf_r+0x1b7>
40034cd2:	8d 43 01             	lea    0x1(%ebx),%eax
40034cd5:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
40034cd9:	75 1e                	jne    40034cf9 <_svfiprintf_r+0x188>
40034cdb:	8b 44 24 7c          	mov    0x7c(%esp),%eax
40034cdf:	83 c3 02             	add    $0x2,%ebx
40034ce2:	8d 50 04             	lea    0x4(%eax),%edx
40034ce5:	8b 00                	mov    (%eax),%eax
40034ce7:	89 54 24 7c          	mov    %edx,0x7c(%esp)
40034ceb:	85 c0                	test   %eax,%eax
40034ced:	79 35                	jns    40034d24 <_svfiprintf_r+0x1b3>
40034cef:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034cf6:	ff 
40034cf7:	eb 2f                	jmp    40034d28 <_svfiprintf_r+0x1b7>
40034cf9:	89 c3                	mov    %eax,%ebx
40034cfb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
40034d02:	00 
40034d03:	31 c0                	xor    %eax,%eax
40034d05:	0f be 13             	movsbl (%ebx),%edx
40034d08:	83 ea 30             	sub    $0x30,%edx
40034d0b:	83 fa 09             	cmp    $0x9,%edx
40034d0e:	77 0d                	ja     40034d1d <_svfiprintf_r+0x1ac>
40034d10:	6b c0 0a             	imul   $0xa,%eax,%eax
40034d13:	43                   	inc    %ebx
40034d14:	01 d0                	add    %edx,%eax
40034d16:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
40034d1b:	eb e8                	jmp    40034d05 <_svfiprintf_r+0x194>
40034d1d:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
40034d22:	74 04                	je     40034d28 <_svfiprintf_r+0x1b7>
40034d24:	89 44 24 10          	mov    %eax,0x10(%esp)
40034d28:	0f be 13             	movsbl (%ebx),%edx
40034d2b:	b9 03 00 00 00       	mov    $0x3,%ecx
40034d30:	b8 58 6c 03 40       	mov    $0x40036c58,%eax
40034d35:	e8 49 b3 ff ff       	call   40030083 <memchr>
40034d3a:	85 c0                	test   %eax,%eax
40034d3c:	74 13                	je     40034d51 <_svfiprintf_r+0x1e0>
40034d3e:	2d 58 6c 03 40       	sub    $0x40036c58,%eax
40034d43:	ba 40 00 00 00       	mov    $0x40,%edx
40034d48:	88 c1                	mov    %al,%cl
40034d4a:	43                   	inc    %ebx
40034d4b:	d3 e2                	shl    %cl,%edx
40034d4d:	09 54 24 0c          	or     %edx,0xc(%esp)
40034d51:	0f be 13             	movsbl (%ebx),%edx
40034d54:	b9 06 00 00 00       	mov    $0x6,%ecx
40034d59:	b8 5c 6c 03 40       	mov    $0x40036c5c,%eax
40034d5e:	88 54 24 24          	mov    %dl,0x24(%esp)
40034d62:	e8 1c b3 ff ff       	call   40030083 <memchr>
40034d67:	8d 7b 01             	lea    0x1(%ebx),%edi
40034d6a:	85 c0                	test   %eax,%eax
40034d6c:	74 29                	je     40034d97 <_svfiprintf_r+0x226>
40034d6e:	b8 00 00 00 00       	mov    $0x0,%eax
40034d73:	85 c0                	test   %eax,%eax
40034d75:	75 07                	jne    40034d7e <_svfiprintf_r+0x20d>
40034d77:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
40034d7c:	eb 3c                	jmp    40034dba <_svfiprintf_r+0x249>
40034d7e:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034d82:	89 f1                	mov    %esi,%ecx
40034d84:	50                   	push   %eax
40034d85:	68 89 4a 03 40       	push   $0x40034a89
40034d8a:	8d 54 24 14          	lea    0x14(%esp),%edx
40034d8e:	89 e8                	mov    %ebp,%eax
40034d90:	e8 6b b2 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
40034d95:	eb 17                	jmp    40034dae <_svfiprintf_r+0x23d>
40034d97:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034d9b:	89 f1                	mov    %esi,%ecx
40034d9d:	50                   	push   %eax
40034d9e:	68 89 4a 03 40       	push   $0x40034a89
40034da3:	8d 54 24 14          	lea    0x14(%esp),%edx
40034da7:	89 e8                	mov    %ebp,%eax
40034da9:	e8 09 01 00 00       	call   40034eb7 <_printf_i>
40034dae:	89 44 24 08          	mov    %eax,0x8(%esp)
40034db2:	58                   	pop    %eax
40034db3:	5a                   	pop    %edx
40034db4:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
40034db8:	74 0c                	je     40034dc6 <_svfiprintf_r+0x255>
40034dba:	8b 04 24             	mov    (%esp),%eax
40034dbd:	01 44 24 20          	add    %eax,0x20(%esp)
40034dc1:	e9 ff fd ff ff       	jmp    40034bc5 <_svfiprintf_r+0x54>
40034dc6:	83 c8 ff             	or     $0xffffffff,%eax
40034dc9:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
40034dcd:	75 04                	jne    40034dd3 <_svfiprintf_r+0x262>
40034dcf:	8b 44 24 20          	mov    0x20(%esp),%eax
40034dd3:	83 c4 68             	add    $0x68,%esp
40034dd6:	5b                   	pop    %ebx
40034dd7:	5e                   	pop    %esi
40034dd8:	5f                   	pop    %edi
40034dd9:	5d                   	pop    %ebp
40034dda:	c3                   	ret    

40034ddb <_printf_common>:
40034ddb:	55                   	push   %ebp
40034ddc:	57                   	push   %edi
40034ddd:	56                   	push   %esi
40034dde:	53                   	push   %ebx
40034ddf:	53                   	push   %ebx
40034de0:	89 d3                	mov    %edx,%ebx
40034de2:	89 c5                	mov    %eax,%ebp
40034de4:	8b 52 08             	mov    0x8(%edx),%edx
40034de7:	8b 43 10             	mov    0x10(%ebx),%eax
40034dea:	89 ce                	mov    %ecx,%esi
40034dec:	39 d0                	cmp    %edx,%eax
40034dee:	7d 02                	jge    40034df2 <_printf_common+0x17>
40034df0:	89 d0                	mov    %edx,%eax
40034df2:	89 06                	mov    %eax,(%esi)
40034df4:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034df8:	74 03                	je     40034dfd <_printf_common+0x22>
40034dfa:	40                   	inc    %eax
40034dfb:	89 06                	mov    %eax,(%esi)
40034dfd:	f6 03 20             	testb  $0x20,(%ebx)
40034e00:	74 03                	je     40034e05 <_printf_common+0x2a>
40034e02:	83 06 02             	addl   $0x2,(%esi)
40034e05:	8b 3b                	mov    (%ebx),%edi
40034e07:	83 e7 06             	and    $0x6,%edi
40034e0a:	75 26                	jne    40034e32 <_printf_common+0x57>
40034e0c:	8d 43 19             	lea    0x19(%ebx),%eax
40034e0f:	89 04 24             	mov    %eax,(%esp)
40034e12:	eb 15                	jmp    40034e29 <_printf_common+0x4e>
40034e14:	6a 01                	push   $0x1
40034e16:	89 e8                	mov    %ebp,%eax
40034e18:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40034e1c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034e20:	ff 54 24 20          	call   *0x20(%esp)
40034e24:	5a                   	pop    %edx
40034e25:	40                   	inc    %eax
40034e26:	74 3c                	je     40034e64 <_printf_common+0x89>
40034e28:	47                   	inc    %edi
40034e29:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e2c:	2b 06                	sub    (%esi),%eax
40034e2e:	39 c7                	cmp    %eax,%edi
40034e30:	7c e2                	jl     40034e14 <_printf_common+0x39>
40034e32:	31 c0                	xor    %eax,%eax
40034e34:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40034e38:	0f 95 c0             	setne  %al
40034e3b:	f6 03 20             	testb  $0x20,(%ebx)
40034e3e:	74 12                	je     40034e52 <_printf_common+0x77>
40034e40:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
40034e45:	8d 50 01             	lea    0x1(%eax),%edx
40034e48:	8a 4b 45             	mov    0x45(%ebx),%cl
40034e4b:	83 c0 02             	add    $0x2,%eax
40034e4e:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
40034e52:	50                   	push   %eax
40034e53:	8d 4b 43             	lea    0x43(%ebx),%ecx
40034e56:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034e5a:	89 e8                	mov    %ebp,%eax
40034e5c:	ff 54 24 20          	call   *0x20(%esp)
40034e60:	5f                   	pop    %edi
40034e61:	40                   	inc    %eax
40034e62:	75 05                	jne    40034e69 <_printf_common+0x8e>
40034e64:	83 c8 ff             	or     $0xffffffff,%eax
40034e67:	eb 48                	jmp    40034eb1 <_printf_common+0xd6>
40034e69:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e6c:	2b 06                	sub    (%esi),%eax
40034e6e:	89 c6                	mov    %eax,%esi
40034e70:	8b 03                	mov    (%ebx),%eax
40034e72:	83 e0 06             	and    $0x6,%eax
40034e75:	83 f8 04             	cmp    $0x4,%eax
40034e78:	75 07                	jne    40034e81 <_printf_common+0xa6>
40034e7a:	89 f0                	mov    %esi,%eax
40034e7c:	c1 e8 1f             	shr    $0x1f,%eax
40034e7f:	74 02                	je     40034e83 <_printf_common+0xa8>
40034e81:	31 f6                	xor    %esi,%esi
40034e83:	8b 43 08             	mov    0x8(%ebx),%eax
40034e86:	8b 53 10             	mov    0x10(%ebx),%edx
40034e89:	39 d0                	cmp    %edx,%eax
40034e8b:	7e 04                	jle    40034e91 <_printf_common+0xb6>
40034e8d:	29 d0                	sub    %edx,%eax
40034e8f:	01 c6                	add    %eax,%esi
40034e91:	31 ff                	xor    %edi,%edi
40034e93:	83 c3 1a             	add    $0x1a,%ebx
40034e96:	39 fe                	cmp    %edi,%esi
40034e98:	74 15                	je     40034eaf <_printf_common+0xd4>
40034e9a:	6a 01                	push   $0x1
40034e9c:	89 d9                	mov    %ebx,%ecx
40034e9e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
40034ea2:	89 e8                	mov    %ebp,%eax
40034ea4:	ff 54 24 20          	call   *0x20(%esp)
40034ea8:	59                   	pop    %ecx
40034ea9:	40                   	inc    %eax
40034eaa:	74 b8                	je     40034e64 <_printf_common+0x89>
40034eac:	47                   	inc    %edi
40034ead:	eb e7                	jmp    40034e96 <_printf_common+0xbb>
40034eaf:	31 c0                	xor    %eax,%eax
40034eb1:	5a                   	pop    %edx
40034eb2:	5b                   	pop    %ebx
40034eb3:	5e                   	pop    %esi
40034eb4:	5f                   	pop    %edi
40034eb5:	5d                   	pop    %ebp
40034eb6:	c3                   	ret    

40034eb7 <_printf_i>:
40034eb7:	55                   	push   %ebp
40034eb8:	57                   	push   %edi
40034eb9:	56                   	push   %esi
40034eba:	53                   	push   %ebx
40034ebb:	83 ec 0c             	sub    $0xc,%esp
40034ebe:	89 d3                	mov    %edx,%ebx
40034ec0:	8d 6a 43             	lea    0x43(%edx),%ebp
40034ec3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40034ec7:	8a 4a 18             	mov    0x18(%edx),%cl
40034eca:	89 04 24             	mov    %eax,(%esp)
40034ecd:	80 f9 6e             	cmp    $0x6e,%cl
40034ed0:	8b 44 24 24          	mov    0x24(%esp),%eax
40034ed4:	0f 84 83 01 00 00    	je     4003505d <_printf_i+0x1a6>
40034eda:	7f 35                	jg     40034f11 <_printf_i+0x5a>
40034edc:	80 f9 63             	cmp    $0x63,%cl
40034edf:	74 60                	je     40034f41 <_printf_i+0x8a>
40034ee1:	7f 1f                	jg     40034f02 <_printf_i+0x4b>
40034ee3:	84 c9                	test   %cl,%cl
40034ee5:	0f 84 9d 01 00 00    	je     40035088 <_printf_i+0x1d1>
40034eeb:	80 f9 58             	cmp    $0x58,%cl
40034eee:	0f 85 c5 01 00 00    	jne    400350b9 <_printf_i+0x202>
40034ef4:	c6 42 45 58          	movb   $0x58,0x45(%edx)
40034ef8:	bf 63 6c 03 40       	mov    $0x40036c63,%edi
40034efd:	e9 c2 00 00 00       	jmp    40034fc4 <_printf_i+0x10d>
40034f02:	80 f9 64             	cmp    $0x64,%cl
40034f05:	74 4e                	je     40034f55 <_printf_i+0x9e>
40034f07:	80 f9 69             	cmp    $0x69,%cl
40034f0a:	74 49                	je     40034f55 <_printf_i+0x9e>
40034f0c:	e9 a8 01 00 00       	jmp    400350b9 <_printf_i+0x202>
40034f11:	80 f9 73             	cmp    $0x73,%cl
40034f14:	0f 84 79 01 00 00    	je     40035093 <_printf_i+0x1dc>
40034f1a:	7f 16                	jg     40034f32 <_printf_i+0x7b>
40034f1c:	80 f9 6f             	cmp    $0x6f,%cl
40034f1f:	74 65                	je     40034f86 <_printf_i+0xcf>
40034f21:	80 f9 70             	cmp    $0x70,%cl
40034f24:	0f 85 8f 01 00 00    	jne    400350b9 <_printf_i+0x202>
40034f2a:	83 0a 20             	orl    $0x20,(%edx)
40034f2d:	e9 89 00 00 00       	jmp    40034fbb <_printf_i+0x104>
40034f32:	80 f9 75             	cmp    $0x75,%cl
40034f35:	74 4f                	je     40034f86 <_printf_i+0xcf>
40034f37:	80 f9 78             	cmp    $0x78,%cl
40034f3a:	74 7f                	je     40034fbb <_printf_i+0x104>
40034f3c:	e9 78 01 00 00       	jmp    400350b9 <_printf_i+0x202>
40034f41:	8d 72 42             	lea    0x42(%edx),%esi
40034f44:	8b 10                	mov    (%eax),%edx
40034f46:	8d 4a 04             	lea    0x4(%edx),%ecx
40034f49:	89 08                	mov    %ecx,(%eax)
40034f4b:	8b 02                	mov    (%edx),%eax
40034f4d:	88 43 42             	mov    %al,0x42(%ebx)
40034f50:	e9 6a 01 00 00       	jmp    400350bf <_printf_i+0x208>
40034f55:	8b 0b                	mov    (%ebx),%ecx
40034f57:	8b 10                	mov    (%eax),%edx
40034f59:	f6 c1 80             	test   $0x80,%cl
40034f5c:	74 07                	je     40034f65 <_printf_i+0xae>
40034f5e:	8d 4a 04             	lea    0x4(%edx),%ecx
40034f61:	89 08                	mov    %ecx,(%eax)
40034f63:	eb 0f                	jmp    40034f74 <_printf_i+0xbd>
40034f65:	80 e1 40             	and    $0x40,%cl
40034f68:	8d 4a 04             	lea    0x4(%edx),%ecx
40034f6b:	89 08                	mov    %ecx,(%eax)
40034f6d:	74 05                	je     40034f74 <_printf_i+0xbd>
40034f6f:	0f bf 02             	movswl (%edx),%eax
40034f72:	eb 02                	jmp    40034f76 <_printf_i+0xbf>
40034f74:	8b 02                	mov    (%edx),%eax
40034f76:	85 c0                	test   %eax,%eax
40034f78:	0f 89 83 00 00 00    	jns    40035001 <_printf_i+0x14a>
40034f7e:	f7 d8                	neg    %eax
40034f80:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
40034f84:	eb 7b                	jmp    40035001 <_printf_i+0x14a>
40034f86:	8b 33                	mov    (%ebx),%esi
40034f88:	8b 10                	mov    (%eax),%edx
40034f8a:	f7 c6 80 00 00 00    	test   $0x80,%esi
40034f90:	74 07                	je     40034f99 <_printf_i+0xe2>
40034f92:	8d 72 04             	lea    0x4(%edx),%esi
40034f95:	89 30                	mov    %esi,(%eax)
40034f97:	eb 0f                	jmp    40034fa8 <_printf_i+0xf1>
40034f99:	83 e6 40             	and    $0x40,%esi
40034f9c:	8d 72 04             	lea    0x4(%edx),%esi
40034f9f:	89 30                	mov    %esi,(%eax)
40034fa1:	74 05                	je     40034fa8 <_printf_i+0xf1>
40034fa3:	0f b7 02             	movzwl (%edx),%eax
40034fa6:	eb 02                	jmp    40034faa <_printf_i+0xf3>
40034fa8:	8b 02                	mov    (%edx),%eax
40034faa:	bf 63 6c 03 40       	mov    $0x40036c63,%edi
40034faf:	80 f9 6f             	cmp    $0x6f,%cl
40034fb2:	74 42                	je     40034ff6 <_printf_i+0x13f>
40034fb4:	b9 0a 00 00 00       	mov    $0xa,%ecx
40034fb9:	eb 40                	jmp    40034ffb <_printf_i+0x144>
40034fbb:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
40034fbf:	bf 74 6c 03 40       	mov    $0x40036c74,%edi
40034fc4:	8b 08                	mov    (%eax),%ecx
40034fc6:	8b 13                	mov    (%ebx),%edx
40034fc8:	f6 c2 80             	test   $0x80,%dl
40034fcb:	8d 71 04             	lea    0x4(%ecx),%esi
40034fce:	89 30                	mov    %esi,(%eax)
40034fd0:	75 0a                	jne    40034fdc <_printf_i+0x125>
40034fd2:	f6 c2 40             	test   $0x40,%dl
40034fd5:	74 05                	je     40034fdc <_printf_i+0x125>
40034fd7:	0f b7 01             	movzwl (%ecx),%eax
40034fda:	eb 02                	jmp    40034fde <_printf_i+0x127>
40034fdc:	8b 01                	mov    (%ecx),%eax
40034fde:	f6 c2 01             	test   $0x1,%dl
40034fe1:	74 05                	je     40034fe8 <_printf_i+0x131>
40034fe3:	83 ca 20             	or     $0x20,%edx
40034fe6:	89 13                	mov    %edx,(%ebx)
40034fe8:	b9 10 00 00 00       	mov    $0x10,%ecx
40034fed:	85 c0                	test   %eax,%eax
40034fef:	75 0a                	jne    40034ffb <_printf_i+0x144>
40034ff1:	83 23 df             	andl   $0xffffffdf,(%ebx)
40034ff4:	eb 05                	jmp    40034ffb <_printf_i+0x144>
40034ff6:	b9 08 00 00 00       	mov    $0x8,%ecx
40034ffb:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
40034fff:	eb 0a                	jmp    4003500b <_printf_i+0x154>
40035001:	bf 63 6c 03 40       	mov    $0x40036c63,%edi
40035006:	b9 0a 00 00 00       	mov    $0xa,%ecx
4003500b:	8b 53 04             	mov    0x4(%ebx),%edx
4003500e:	89 53 08             	mov    %edx,0x8(%ebx)
40035011:	85 d2                	test   %edx,%edx
40035013:	78 12                	js     40035027 <_printf_i+0x170>
40035015:	83 23 fb             	andl   $0xfffffffb,(%ebx)
40035018:	85 c0                	test   %eax,%eax
4003501a:	75 13                	jne    4003502f <_printf_i+0x178>
4003501c:	89 ee                	mov    %ebp,%esi
4003501e:	85 d2                	test   %edx,%edx
40035020:	74 1d                	je     4003503f <_printf_i+0x188>
40035022:	e9 14 01 00 00       	jmp    4003513b <_printf_i+0x284>
40035027:	85 c0                	test   %eax,%eax
40035029:	0f 84 0c 01 00 00    	je     4003513b <_printf_i+0x284>
4003502f:	89 ee                	mov    %ebp,%esi
40035031:	31 d2                	xor    %edx,%edx
40035033:	4e                   	dec    %esi
40035034:	f7 f1                	div    %ecx
40035036:	85 c0                	test   %eax,%eax
40035038:	8a 14 17             	mov    (%edi,%edx,1),%dl
4003503b:	88 16                	mov    %dl,(%esi)
4003503d:	75 f2                	jne    40035031 <_printf_i+0x17a>
4003503f:	83 f9 08             	cmp    $0x8,%ecx
40035042:	75 12                	jne    40035056 <_printf_i+0x19f>
40035044:	f6 03 01             	testb  $0x1,(%ebx)
40035047:	74 0d                	je     40035056 <_printf_i+0x19f>
40035049:	8b 43 10             	mov    0x10(%ebx),%eax
4003504c:	39 43 04             	cmp    %eax,0x4(%ebx)
4003504f:	7f 05                	jg     40035056 <_printf_i+0x19f>
40035051:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
40035055:	4e                   	dec    %esi
40035056:	29 f5                	sub    %esi,%ebp
40035058:	89 6b 10             	mov    %ebp,0x10(%ebx)
4003505b:	eb 6d                	jmp    400350ca <_printf_i+0x213>
4003505d:	8b 32                	mov    (%edx),%esi
4003505f:	8b 4b 14             	mov    0x14(%ebx),%ecx
40035062:	f7 c6 80 00 00 00    	test   $0x80,%esi
40035068:	8b 10                	mov    (%eax),%edx
4003506a:	74 09                	je     40035075 <_printf_i+0x1be>
4003506c:	8d 72 04             	lea    0x4(%edx),%esi
4003506f:	89 30                	mov    %esi,(%eax)
40035071:	8b 02                	mov    (%edx),%eax
40035073:	eb 11                	jmp    40035086 <_printf_i+0x1cf>
40035075:	83 e6 40             	and    $0x40,%esi
40035078:	8d 72 04             	lea    0x4(%edx),%esi
4003507b:	89 30                	mov    %esi,(%eax)
4003507d:	8b 02                	mov    (%edx),%eax
4003507f:	74 05                	je     40035086 <_printf_i+0x1cf>
40035081:	66 89 08             	mov    %cx,(%eax)
40035084:	eb 02                	jmp    40035088 <_printf_i+0x1d1>
40035086:	89 08                	mov    %ecx,(%eax)
40035088:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
4003508f:	89 ee                	mov    %ebp,%esi
40035091:	eb 37                	jmp    400350ca <_printf_i+0x213>
40035093:	8b 10                	mov    (%eax),%edx
40035095:	8d 4a 04             	lea    0x4(%edx),%ecx
40035098:	89 08                	mov    %ecx,(%eax)
4003509a:	8b 4b 04             	mov    0x4(%ebx),%ecx
4003509d:	8b 32                	mov    (%edx),%esi
4003509f:	31 d2                	xor    %edx,%edx
400350a1:	89 f0                	mov    %esi,%eax
400350a3:	e8 db af ff ff       	call   40030083 <memchr>
400350a8:	85 c0                	test   %eax,%eax
400350aa:	74 05                	je     400350b1 <_printf_i+0x1fa>
400350ac:	29 f0                	sub    %esi,%eax
400350ae:	89 43 04             	mov    %eax,0x4(%ebx)
400350b1:	8b 43 04             	mov    0x4(%ebx),%eax
400350b4:	89 43 10             	mov    %eax,0x10(%ebx)
400350b7:	eb 0d                	jmp    400350c6 <_printf_i+0x20f>
400350b9:	8d 73 42             	lea    0x42(%ebx),%esi
400350bc:	88 4b 42             	mov    %cl,0x42(%ebx)
400350bf:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
400350c6:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
400350ca:	ff 74 24 20          	pushl  0x20(%esp)
400350ce:	ff 74 24 08          	pushl  0x8(%esp)
400350d2:	89 da                	mov    %ebx,%edx
400350d4:	8d 4c 24 10          	lea    0x10(%esp),%ecx
400350d8:	8b 44 24 08          	mov    0x8(%esp),%eax
400350dc:	e8 fa fc ff ff       	call   40034ddb <_printf_common>
400350e1:	5f                   	pop    %edi
400350e2:	40                   	inc    %eax
400350e3:	5d                   	pop    %ebp
400350e4:	75 05                	jne    400350eb <_printf_i+0x234>
400350e6:	83 c8 ff             	or     $0xffffffff,%eax
400350e9:	eb 5d                	jmp    40035148 <_printf_i+0x291>
400350eb:	ff 73 10             	pushl  0x10(%ebx)
400350ee:	89 f1                	mov    %esi,%ecx
400350f0:	8b 54 24 08          	mov    0x8(%esp),%edx
400350f4:	8b 44 24 04          	mov    0x4(%esp),%eax
400350f8:	ff 54 24 24          	call   *0x24(%esp)
400350fc:	59                   	pop    %ecx
400350fd:	40                   	inc    %eax
400350fe:	74 e6                	je     400350e6 <_printf_i+0x22f>
40035100:	f6 03 02             	testb  $0x2,(%ebx)
40035103:	74 27                	je     4003512c <_printf_i+0x275>
40035105:	31 f6                	xor    %esi,%esi
40035107:	8d 7b 19             	lea    0x19(%ebx),%edi
4003510a:	eb 15                	jmp    40035121 <_printf_i+0x26a>
4003510c:	6a 01                	push   $0x1
4003510e:	89 f9                	mov    %edi,%ecx
40035110:	8b 54 24 08          	mov    0x8(%esp),%edx
40035114:	8b 44 24 04          	mov    0x4(%esp),%eax
40035118:	ff 54 24 24          	call   *0x24(%esp)
4003511c:	5a                   	pop    %edx
4003511d:	40                   	inc    %eax
4003511e:	74 c6                	je     400350e6 <_printf_i+0x22f>
40035120:	46                   	inc    %esi
40035121:	8b 43 0c             	mov    0xc(%ebx),%eax
40035124:	2b 44 24 08          	sub    0x8(%esp),%eax
40035128:	39 c6                	cmp    %eax,%esi
4003512a:	7c e0                	jl     4003510c <_printf_i+0x255>
4003512c:	8b 54 24 08          	mov    0x8(%esp),%edx
40035130:	8b 43 0c             	mov    0xc(%ebx),%eax
40035133:	39 d0                	cmp    %edx,%eax
40035135:	7d 11                	jge    40035148 <_printf_i+0x291>
40035137:	89 d0                	mov    %edx,%eax
40035139:	eb 0d                	jmp    40035148 <_printf_i+0x291>
4003513b:	8a 07                	mov    (%edi),%al
4003513d:	8d 73 42             	lea    0x42(%ebx),%esi
40035140:	88 43 42             	mov    %al,0x42(%ebx)
40035143:	e9 f7 fe ff ff       	jmp    4003503f <_printf_i+0x188>
40035148:	83 c4 0c             	add    $0xc,%esp
4003514b:	5b                   	pop    %ebx
4003514c:	5e                   	pop    %esi
4003514d:	5f                   	pop    %edi
4003514e:	5d                   	pop    %ebp
4003514f:	c3                   	ret    

40035150 <__sfputc_r>:
40035150:	53                   	push   %ebx
40035151:	8b 59 08             	mov    0x8(%ecx),%ebx
40035154:	4b                   	dec    %ebx
40035155:	89 59 08             	mov    %ebx,0x8(%ecx)
40035158:	85 db                	test   %ebx,%ebx
4003515a:	79 10                	jns    4003516c <__sfputc_r+0x1c>
4003515c:	3b 59 18             	cmp    0x18(%ecx),%ebx
4003515f:	7c 05                	jl     40035166 <__sfputc_r+0x16>
40035161:	80 fa 0a             	cmp    $0xa,%dl
40035164:	75 06                	jne    4003516c <__sfputc_r+0x1c>
40035166:	5b                   	pop    %ebx
40035167:	e9 cf 02 00 00       	jmp    4003543b <__swbuf_r>
4003516c:	8b 01                	mov    (%ecx),%eax
4003516e:	8d 58 01             	lea    0x1(%eax),%ebx
40035171:	89 19                	mov    %ebx,(%ecx)
40035173:	88 10                	mov    %dl,(%eax)
40035175:	5b                   	pop    %ebx
40035176:	0f b6 c2             	movzbl %dl,%eax
40035179:	c3                   	ret    

4003517a <__sfputs_r>:
4003517a:	55                   	push   %ebp
4003517b:	57                   	push   %edi
4003517c:	56                   	push   %esi
4003517d:	53                   	push   %ebx
4003517e:	8b 74 24 14          	mov    0x14(%esp),%esi
40035182:	89 c7                	mov    %eax,%edi
40035184:	89 d5                	mov    %edx,%ebp
40035186:	89 cb                	mov    %ecx,%ebx
40035188:	01 ce                	add    %ecx,%esi
4003518a:	39 f3                	cmp    %esi,%ebx
4003518c:	74 14                	je     400351a2 <__sfputs_r+0x28>
4003518e:	0f be 13             	movsbl (%ebx),%edx
40035191:	89 e9                	mov    %ebp,%ecx
40035193:	89 f8                	mov    %edi,%eax
40035195:	e8 b6 ff ff ff       	call   40035150 <__sfputc_r>
4003519a:	43                   	inc    %ebx
4003519b:	83 f8 ff             	cmp    $0xffffffff,%eax
4003519e:	75 ea                	jne    4003518a <__sfputs_r+0x10>
400351a0:	eb 02                	jmp    400351a4 <__sfputs_r+0x2a>
400351a2:	31 c0                	xor    %eax,%eax
400351a4:	5b                   	pop    %ebx
400351a5:	5e                   	pop    %esi
400351a6:	5f                   	pop    %edi
400351a7:	5d                   	pop    %ebp
400351a8:	c3                   	ret    

400351a9 <_vfiprintf_r>:
400351a9:	55                   	push   %ebp
400351aa:	57                   	push   %edi
400351ab:	56                   	push   %esi
400351ac:	53                   	push   %ebx
400351ad:	83 ec 68             	sub    $0x68,%esp
400351b0:	89 c5                	mov    %eax,%ebp
400351b2:	89 d6                	mov    %edx,%esi
400351b4:	89 cf                	mov    %ecx,%edi
400351b6:	85 c0                	test   %eax,%eax
400351b8:	74 0b                	je     400351c5 <_vfiprintf_r+0x1c>
400351ba:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400351be:	75 05                	jne    400351c5 <_vfiprintf_r+0x1c>
400351c0:	e8 93 05 00 00       	call   40035758 <__sinit>
400351c5:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
400351c9:	74 1d                	je     400351e8 <_vfiprintf_r+0x3f>
400351cb:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
400351cf:	74 17                	je     400351e8 <_vfiprintf_r+0x3f>
400351d1:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
400351d8:	00 
400351d9:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
400351de:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
400351e3:	e9 9b 00 00 00       	jmp    40035283 <_vfiprintf_r+0xda>
400351e8:	89 f2                	mov    %esi,%edx
400351ea:	89 e8                	mov    %ebp,%eax
400351ec:	e8 d8 02 00 00       	call   400354c9 <__swsetup_r>
400351f1:	85 c0                	test   %eax,%eax
400351f3:	74 dc                	je     400351d1 <_vfiprintf_r+0x28>
400351f5:	83 c8 ff             	or     $0xffffffff,%eax
400351f8:	e9 36 02 00 00       	jmp    40035433 <_vfiprintf_r+0x28a>
400351fd:	8b 54 24 7c          	mov    0x7c(%esp),%edx
40035201:	8d 4a 04             	lea    0x4(%edx),%ecx
40035204:	8b 12                	mov    (%edx),%edx
40035206:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
4003520a:	85 d2                	test   %edx,%edx
4003520c:	0f 88 39 01 00 00    	js     4003534b <_vfiprintf_r+0x1a2>
40035212:	89 54 24 18          	mov    %edx,0x18(%esp)
40035216:	43                   	inc    %ebx
40035217:	80 3b 2e             	cmpb   $0x2e,(%ebx)
4003521a:	0f 84 63 01 00 00    	je     40035383 <_vfiprintf_r+0x1da>
40035220:	0f be 13             	movsbl (%ebx),%edx
40035223:	b9 03 00 00 00       	mov    $0x3,%ecx
40035228:	b8 58 6c 03 40       	mov    $0x40036c58,%eax
4003522d:	e8 51 ae ff ff       	call   40030083 <memchr>
40035232:	85 c0                	test   %eax,%eax
40035234:	74 13                	je     40035249 <_vfiprintf_r+0xa0>
40035236:	2d 58 6c 03 40       	sub    $0x40036c58,%eax
4003523b:	ba 40 00 00 00       	mov    $0x40,%edx
40035240:	88 c1                	mov    %al,%cl
40035242:	43                   	inc    %ebx
40035243:	d3 e2                	shl    %cl,%edx
40035245:	09 54 24 0c          	or     %edx,0xc(%esp)
40035249:	0f be 13             	movsbl (%ebx),%edx
4003524c:	b9 06 00 00 00       	mov    $0x6,%ecx
40035251:	b8 5c 6c 03 40       	mov    $0x40036c5c,%eax
40035256:	88 54 24 24          	mov    %dl,0x24(%esp)
4003525a:	e8 24 ae ff ff       	call   40030083 <memchr>
4003525f:	8d 7b 01             	lea    0x1(%ebx),%edi
40035262:	85 c0                	test   %eax,%eax
40035264:	0f 84 94 01 00 00    	je     400353fe <_vfiprintf_r+0x255>
4003526a:	b8 00 00 00 00       	mov    $0x0,%eax
4003526f:	85 c0                	test   %eax,%eax
40035271:	0f 85 6e 01 00 00    	jne    400353e5 <_vfiprintf_r+0x23c>
40035277:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
4003527c:	8b 04 24             	mov    (%esp),%eax
4003527f:	01 44 24 20          	add    %eax,0x20(%esp)
40035283:	89 fb                	mov    %edi,%ebx
40035285:	8a 03                	mov    (%ebx),%al
40035287:	84 c0                	test   %al,%al
40035289:	0f 95 c2             	setne  %dl
4003528c:	3c 25                	cmp    $0x25,%al
4003528e:	0f 95 c0             	setne  %al
40035291:	20 c2                	and    %al,%dl
40035293:	88 54 24 07          	mov    %dl,0x7(%esp)
40035297:	74 03                	je     4003529c <_vfiprintf_r+0xf3>
40035299:	43                   	inc    %ebx
4003529a:	eb e9                	jmp    40035285 <_vfiprintf_r+0xdc>
4003529c:	89 d8                	mov    %ebx,%eax
4003529e:	29 f8                	sub    %edi,%eax
400352a0:	89 44 24 08          	mov    %eax,0x8(%esp)
400352a4:	74 1c                	je     400352c2 <_vfiprintf_r+0x119>
400352a6:	50                   	push   %eax
400352a7:	89 f9                	mov    %edi,%ecx
400352a9:	89 f2                	mov    %esi,%edx
400352ab:	89 e8                	mov    %ebp,%eax
400352ad:	e8 c8 fe ff ff       	call   4003517a <__sfputs_r>
400352b2:	59                   	pop    %ecx
400352b3:	40                   	inc    %eax
400352b4:	0f 84 6b 01 00 00    	je     40035425 <_vfiprintf_r+0x27c>
400352ba:	8b 44 24 08          	mov    0x8(%esp),%eax
400352be:	01 44 24 20          	add    %eax,0x20(%esp)
400352c2:	80 3b 00             	cmpb   $0x0,(%ebx)
400352c5:	0f 84 5a 01 00 00    	je     40035425 <_vfiprintf_r+0x27c>
400352cb:	43                   	inc    %ebx
400352cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
400352d3:	00 
400352d4:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
400352db:	00 
400352dc:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
400352e3:	ff 
400352e4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
400352eb:	00 
400352ec:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
400352f1:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
400352f8:	00 
400352f9:	0f be 13             	movsbl (%ebx),%edx
400352fc:	b9 05 00 00 00       	mov    $0x5,%ecx
40035301:	b8 52 6c 03 40       	mov    $0x40036c52,%eax
40035306:	e8 78 ad ff ff       	call   40030083 <memchr>
4003530b:	85 c0                	test   %eax,%eax
4003530d:	74 15                	je     40035324 <_vfiprintf_r+0x17b>
4003530f:	2d 52 6c 03 40       	sub    $0x40036c52,%eax
40035314:	ba 01 00 00 00       	mov    $0x1,%edx
40035319:	88 c1                	mov    %al,%cl
4003531b:	43                   	inc    %ebx
4003531c:	d3 e2                	shl    %cl,%edx
4003531e:	09 54 24 0c          	or     %edx,0xc(%esp)
40035322:	eb d5                	jmp    400352f9 <_vfiprintf_r+0x150>
40035324:	8b 44 24 0c          	mov    0xc(%esp),%eax
40035328:	a8 10                	test   $0x10,%al
4003532a:	74 05                	je     40035331 <_vfiprintf_r+0x188>
4003532c:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40035331:	a8 08                	test   $0x8,%al
40035333:	74 05                	je     4003533a <_vfiprintf_r+0x191>
40035335:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
4003533a:	80 3b 2a             	cmpb   $0x2a,(%ebx)
4003533d:	0f 84 ba fe ff ff    	je     400351fd <_vfiprintf_r+0x54>
40035343:	8b 44 24 18          	mov    0x18(%esp),%eax
40035347:	31 c9                	xor    %ecx,%ecx
40035349:	eb 12                	jmp    4003535d <_vfiprintf_r+0x1b4>
4003534b:	f7 da                	neg    %edx
4003534d:	83 c8 02             	or     $0x2,%eax
40035350:	89 54 24 18          	mov    %edx,0x18(%esp)
40035354:	89 44 24 0c          	mov    %eax,0xc(%esp)
40035358:	e9 b9 fe ff ff       	jmp    40035216 <_vfiprintf_r+0x6d>
4003535d:	0f be 13             	movsbl (%ebx),%edx
40035360:	83 ea 30             	sub    $0x30,%edx
40035363:	83 fa 09             	cmp    $0x9,%edx
40035366:	77 0a                	ja     40035372 <_vfiprintf_r+0x1c9>
40035368:	6b c0 0a             	imul   $0xa,%eax,%eax
4003536b:	43                   	inc    %ebx
4003536c:	01 d0                	add    %edx,%eax
4003536e:	b1 01                	mov    $0x1,%cl
40035370:	eb eb                	jmp    4003535d <_vfiprintf_r+0x1b4>
40035372:	84 c9                	test   %cl,%cl
40035374:	0f 84 9d fe ff ff    	je     40035217 <_vfiprintf_r+0x6e>
4003537a:	89 44 24 18          	mov    %eax,0x18(%esp)
4003537e:	e9 94 fe ff ff       	jmp    40035217 <_vfiprintf_r+0x6e>
40035383:	8d 43 01             	lea    0x1(%ebx),%eax
40035386:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
4003538a:	75 21                	jne    400353ad <_vfiprintf_r+0x204>
4003538c:	8b 44 24 7c          	mov    0x7c(%esp),%eax
40035390:	83 c3 02             	add    $0x2,%ebx
40035393:	8d 50 04             	lea    0x4(%eax),%edx
40035396:	8b 00                	mov    (%eax),%eax
40035398:	89 54 24 7c          	mov    %edx,0x7c(%esp)
4003539c:	85 c0                	test   %eax,%eax
4003539e:	79 3c                	jns    400353dc <_vfiprintf_r+0x233>
400353a0:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
400353a7:	ff 
400353a8:	e9 73 fe ff ff       	jmp    40035220 <_vfiprintf_r+0x77>
400353ad:	89 c3                	mov    %eax,%ebx
400353af:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
400353b6:	00 
400353b7:	31 c0                	xor    %eax,%eax
400353b9:	0f be 13             	movsbl (%ebx),%edx
400353bc:	83 ea 30             	sub    $0x30,%edx
400353bf:	83 fa 09             	cmp    $0x9,%edx
400353c2:	77 0d                	ja     400353d1 <_vfiprintf_r+0x228>
400353c4:	6b c0 0a             	imul   $0xa,%eax,%eax
400353c7:	43                   	inc    %ebx
400353c8:	01 d0                	add    %edx,%eax
400353ca:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
400353cf:	eb e8                	jmp    400353b9 <_vfiprintf_r+0x210>
400353d1:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
400353d6:	0f 84 44 fe ff ff    	je     40035220 <_vfiprintf_r+0x77>
400353dc:	89 44 24 10          	mov    %eax,0x10(%esp)
400353e0:	e9 3b fe ff ff       	jmp    40035220 <_vfiprintf_r+0x77>
400353e5:	8d 44 24 7c          	lea    0x7c(%esp),%eax
400353e9:	89 f1                	mov    %esi,%ecx
400353eb:	50                   	push   %eax
400353ec:	68 7a 51 03 40       	push   $0x4003517a
400353f1:	8d 54 24 14          	lea    0x14(%esp),%edx
400353f5:	89 e8                	mov    %ebp,%eax
400353f7:	e8 04 ac fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
400353fc:	eb 17                	jmp    40035415 <_vfiprintf_r+0x26c>
400353fe:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40035402:	89 f1                	mov    %esi,%ecx
40035404:	50                   	push   %eax
40035405:	68 7a 51 03 40       	push   $0x4003517a
4003540a:	8d 54 24 14          	lea    0x14(%esp),%edx
4003540e:	89 e8                	mov    %ebp,%eax
40035410:	e8 a2 fa ff ff       	call   40034eb7 <_printf_i>
40035415:	89 44 24 08          	mov    %eax,0x8(%esp)
40035419:	58                   	pop    %eax
4003541a:	5a                   	pop    %edx
4003541b:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
4003541f:	0f 85 57 fe ff ff    	jne    4003527c <_vfiprintf_r+0xd3>
40035425:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
40035429:	0f 85 c6 fd ff ff    	jne    400351f5 <_vfiprintf_r+0x4c>
4003542f:	8b 44 24 20          	mov    0x20(%esp),%eax
40035433:	83 c4 68             	add    $0x68,%esp
40035436:	5b                   	pop    %ebx
40035437:	5e                   	pop    %esi
40035438:	5f                   	pop    %edi
40035439:	5d                   	pop    %ebp
4003543a:	c3                   	ret    

4003543b <__swbuf_r>:
4003543b:	55                   	push   %ebp
4003543c:	85 c0                	test   %eax,%eax
4003543e:	57                   	push   %edi
4003543f:	89 d5                	mov    %edx,%ebp
40035441:	56                   	push   %esi
40035442:	89 c6                	mov    %eax,%esi
40035444:	53                   	push   %ebx
40035445:	89 cb                	mov    %ecx,%ebx
40035447:	74 0b                	je     40035454 <__swbuf_r+0x19>
40035449:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003544d:	75 05                	jne    40035454 <__swbuf_r+0x19>
4003544f:	e8 04 03 00 00       	call   40035758 <__sinit>
40035454:	8b 43 18             	mov    0x18(%ebx),%eax
40035457:	f6 43 0c 08          	testb  $0x8,0xc(%ebx)
4003545b:	89 43 08             	mov    %eax,0x8(%ebx)
4003545e:	74 17                	je     40035477 <__swbuf_r+0x3c>
40035460:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40035464:	74 11                	je     40035477 <__swbuf_r+0x3c>
40035466:	89 e8                	mov    %ebp,%eax
40035468:	0f b6 f8             	movzbl %al,%edi
4003546b:	8b 03                	mov    (%ebx),%eax
4003546d:	2b 43 10             	sub    0x10(%ebx),%eax
40035470:	3b 43 14             	cmp    0x14(%ebx),%eax
40035473:	7c 21                	jl     40035496 <__swbuf_r+0x5b>
40035475:	eb 12                	jmp    40035489 <__swbuf_r+0x4e>
40035477:	89 da                	mov    %ebx,%edx
40035479:	89 f0                	mov    %esi,%eax
4003547b:	e8 49 00 00 00       	call   400354c9 <__swsetup_r>
40035480:	85 c0                	test   %eax,%eax
40035482:	74 e2                	je     40035466 <__swbuf_r+0x2b>
40035484:	83 cf ff             	or     $0xffffffff,%edi
40035487:	eb 39                	jmp    400354c2 <__swbuf_r+0x87>
40035489:	89 da                	mov    %ebx,%edx
4003548b:	89 f0                	mov    %esi,%eax
4003548d:	e8 23 02 00 00       	call   400356b5 <_fflush_r>
40035492:	85 c0                	test   %eax,%eax
40035494:	75 ee                	jne    40035484 <__swbuf_r+0x49>
40035496:	8b 13                	mov    (%ebx),%edx
40035498:	ff 4b 08             	decl   0x8(%ebx)
4003549b:	8d 4a 01             	lea    0x1(%edx),%ecx
4003549e:	40                   	inc    %eax
4003549f:	89 0b                	mov    %ecx,(%ebx)
400354a1:	89 e9                	mov    %ebp,%ecx
400354a3:	88 0a                	mov    %cl,(%edx)
400354a5:	3b 43 14             	cmp    0x14(%ebx),%eax
400354a8:	74 0b                	je     400354b5 <__swbuf_r+0x7a>
400354aa:	83 ff 0a             	cmp    $0xa,%edi
400354ad:	75 13                	jne    400354c2 <__swbuf_r+0x87>
400354af:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
400354b3:	74 0d                	je     400354c2 <__swbuf_r+0x87>
400354b5:	89 da                	mov    %ebx,%edx
400354b7:	89 f0                	mov    %esi,%eax
400354b9:	e8 f7 01 00 00       	call   400356b5 <_fflush_r>
400354be:	85 c0                	test   %eax,%eax
400354c0:	75 c2                	jne    40035484 <__swbuf_r+0x49>
400354c2:	5b                   	pop    %ebx
400354c3:	89 f8                	mov    %edi,%eax
400354c5:	5e                   	pop    %esi
400354c6:	5f                   	pop    %edi
400354c7:	5d                   	pop    %ebp
400354c8:	c3                   	ret    

400354c9 <__swsetup_r>:
400354c9:	56                   	push   %esi
400354ca:	89 c6                	mov    %eax,%esi
400354cc:	53                   	push   %ebx
400354cd:	89 d3                	mov    %edx,%ebx
400354cf:	e8 af f5 ff ff       	call   40034a83 <__getreent>
400354d4:	85 c0                	test   %eax,%eax
400354d6:	74 0b                	je     400354e3 <__swsetup_r+0x1a>
400354d8:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400354dc:	75 05                	jne    400354e3 <__swsetup_r+0x1a>
400354de:	e8 75 02 00 00       	call   40035758 <__sinit>
400354e3:	8b 43 0c             	mov    0xc(%ebx),%eax
400354e6:	a8 08                	test   $0x8,%al
400354e8:	75 4c                	jne    40035536 <__swsetup_r+0x6d>
400354ea:	a8 10                	test   $0x10,%al
400354ec:	75 12                	jne    40035500 <__swsetup_r+0x37>
400354ee:	83 c8 40             	or     $0x40,%eax
400354f1:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
400354f7:	66 89 43 0c          	mov    %ax,0xc(%ebx)
400354fb:	e9 8c 00 00 00       	jmp    4003558c <__swsetup_r+0xc3>
40035500:	a8 04                	test   $0x4,%al
40035502:	74 2d                	je     40035531 <__swsetup_r+0x68>
40035504:	8b 53 30             	mov    0x30(%ebx),%edx
40035507:	85 d2                	test   %edx,%edx
40035509:	74 15                	je     40035520 <__swsetup_r+0x57>
4003550b:	8d 43 40             	lea    0x40(%ebx),%eax
4003550e:	39 c2                	cmp    %eax,%edx
40035510:	74 07                	je     40035519 <__swsetup_r+0x50>
40035512:	89 f0                	mov    %esi,%eax
40035514:	e8 06 f3 ff ff       	call   4003481f <_free_r>
40035519:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40035520:	66 83 63 0c db       	andw   $0xffdb,0xc(%ebx)
40035525:	8b 43 10             	mov    0x10(%ebx),%eax
40035528:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003552f:	89 03                	mov    %eax,(%ebx)
40035531:	66 83 4b 0c 08       	orw    $0x8,0xc(%ebx)
40035536:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003553a:	75 16                	jne    40035552 <__swsetup_r+0x89>
4003553c:	8b 43 0c             	mov    0xc(%ebx),%eax
4003553f:	66 25 80 02          	and    $0x280,%ax
40035543:	66 3d 00 02          	cmp    $0x200,%ax
40035547:	74 09                	je     40035552 <__swsetup_r+0x89>
40035549:	89 da                	mov    %ebx,%edx
4003554b:	89 f0                	mov    %esi,%eax
4003554d:	e8 2e 03 00 00       	call   40035880 <__smakebuf_r>
40035552:	8b 53 0c             	mov    0xc(%ebx),%edx
40035555:	f6 c2 01             	test   $0x1,%dl
40035558:	74 11                	je     4003556b <__swsetup_r+0xa2>
4003555a:	8b 43 14             	mov    0x14(%ebx),%eax
4003555d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
40035564:	f7 d8                	neg    %eax
40035566:	89 43 18             	mov    %eax,0x18(%ebx)
40035569:	eb 0d                	jmp    40035578 <__swsetup_r+0xaf>
4003556b:	31 c0                	xor    %eax,%eax
4003556d:	f6 c2 02             	test   $0x2,%dl
40035570:	75 03                	jne    40035575 <__swsetup_r+0xac>
40035572:	8b 43 14             	mov    0x14(%ebx),%eax
40035575:	89 43 08             	mov    %eax,0x8(%ebx)
40035578:	31 c0                	xor    %eax,%eax
4003557a:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
4003557e:	75 0f                	jne    4003558f <__swsetup_r+0xc6>
40035580:	f6 c2 80             	test   $0x80,%dl
40035583:	74 0a                	je     4003558f <__swsetup_r+0xc6>
40035585:	83 ca 40             	or     $0x40,%edx
40035588:	66 89 53 0c          	mov    %dx,0xc(%ebx)
4003558c:	83 c8 ff             	or     $0xffffffff,%eax
4003558f:	5b                   	pop    %ebx
40035590:	5e                   	pop    %esi
40035591:	c3                   	ret    

40035592 <__sflush_r>:
40035592:	55                   	push   %ebp
40035593:	57                   	push   %edi
40035594:	56                   	push   %esi
40035595:	53                   	push   %ebx
40035596:	89 c6                	mov    %eax,%esi
40035598:	8b 42 0c             	mov    0xc(%edx),%eax
4003559b:	89 d3                	mov    %edx,%ebx
4003559d:	a8 08                	test   $0x8,%al
4003559f:	0f 85 cc 00 00 00    	jne    40035671 <__sflush_r+0xdf>
400355a5:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
400355a9:	7f 0a                	jg     400355b5 <__sflush_r+0x23>
400355ab:	83 7a 3c 00          	cmpl   $0x0,0x3c(%edx)
400355af:	0f 8e b8 00 00 00    	jle    4003566d <__sflush_r+0xdb>
400355b5:	8b 6b 28             	mov    0x28(%ebx),%ebp
400355b8:	85 ed                	test   %ebp,%ebp
400355ba:	0f 84 ad 00 00 00    	je     4003566d <__sflush_r+0xdb>
400355c0:	8b 3e                	mov    (%esi),%edi
400355c2:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
400355c8:	f6 c4 10             	test   $0x10,%ah
400355cb:	74 05                	je     400355d2 <__sflush_r+0x40>
400355cd:	8b 43 50             	mov    0x50(%ebx),%eax
400355d0:	eb 29                	jmp    400355fb <__sflush_r+0x69>
400355d2:	31 c9                	xor    %ecx,%ecx
400355d4:	8b 53 1c             	mov    0x1c(%ebx),%edx
400355d7:	89 f0                	mov    %esi,%eax
400355d9:	6a 01                	push   $0x1
400355db:	ff d5                	call   *%ebp
400355dd:	5d                   	pop    %ebp
400355de:	83 f8 ff             	cmp    $0xffffffff,%eax
400355e1:	75 18                	jne    400355fb <__sflush_r+0x69>
400355e3:	8b 16                	mov    (%esi),%edx
400355e5:	85 d2                	test   %edx,%edx
400355e7:	74 12                	je     400355fb <__sflush_r+0x69>
400355e9:	83 fa 1d             	cmp    $0x1d,%edx
400355ec:	74 09                	je     400355f7 <__sflush_r+0x65>
400355ee:	83 fa 16             	cmp    $0x16,%edx
400355f1:	0f 85 95 00 00 00    	jne    4003568c <__sflush_r+0xfa>
400355f7:	89 3e                	mov    %edi,(%esi)
400355f9:	eb 72                	jmp    4003566d <__sflush_r+0xdb>
400355fb:	f6 43 0c 04          	testb  $0x4,0xc(%ebx)
400355ff:	74 0c                	je     4003560d <__sflush_r+0x7b>
40035601:	2b 43 04             	sub    0x4(%ebx),%eax
40035604:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
40035608:	74 03                	je     4003560d <__sflush_r+0x7b>
4003560a:	2b 43 3c             	sub    0x3c(%ebx),%eax
4003560d:	89 c1                	mov    %eax,%ecx
4003560f:	8b 53 1c             	mov    0x1c(%ebx),%edx
40035612:	89 f0                	mov    %esi,%eax
40035614:	6a 00                	push   $0x0
40035616:	ff 53 28             	call   *0x28(%ebx)
40035619:	59                   	pop    %ecx
4003561a:	83 f8 ff             	cmp    $0xffffffff,%eax
4003561d:	75 11                	jne    40035630 <__sflush_r+0x9e>
4003561f:	8b 16                	mov    (%esi),%edx
40035621:	83 fa 1d             	cmp    $0x1d,%edx
40035624:	77 66                	ja     4003568c <__sflush_r+0xfa>
40035626:	b9 01 00 40 20       	mov    $0x20400001,%ecx
4003562b:	0f a3 d1             	bt     %edx,%ecx
4003562e:	73 5c                	jae    4003568c <__sflush_r+0xfa>
40035630:	8b 53 10             	mov    0x10(%ebx),%edx
40035633:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
4003563a:	89 13                	mov    %edx,(%ebx)
4003563c:	f6 43 0d 10          	testb  $0x10,0xd(%ebx)
40035640:	74 0d                	je     4003564f <__sflush_r+0xbd>
40035642:	83 f8 ff             	cmp    $0xffffffff,%eax
40035645:	75 05                	jne    4003564c <__sflush_r+0xba>
40035647:	83 3e 00             	cmpl   $0x0,(%esi)
4003564a:	75 03                	jne    4003564f <__sflush_r+0xbd>
4003564c:	89 43 50             	mov    %eax,0x50(%ebx)
4003564f:	8b 53 30             	mov    0x30(%ebx),%edx
40035652:	89 3e                	mov    %edi,(%esi)
40035654:	85 d2                	test   %edx,%edx
40035656:	74 15                	je     4003566d <__sflush_r+0xdb>
40035658:	8d 43 40             	lea    0x40(%ebx),%eax
4003565b:	39 c2                	cmp    %eax,%edx
4003565d:	74 07                	je     40035666 <__sflush_r+0xd4>
4003565f:	89 f0                	mov    %esi,%eax
40035661:	e8 b9 f1 ff ff       	call   4003481f <_free_r>
40035666:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
4003566d:	31 c0                	xor    %eax,%eax
4003566f:	eb 3f                	jmp    400356b0 <__sflush_r+0x11e>
40035671:	8b 6a 10             	mov    0x10(%edx),%ebp
40035674:	85 ed                	test   %ebp,%ebp
40035676:	74 f5                	je     4003566d <__sflush_r+0xdb>
40035678:	8b 3a                	mov    (%edx),%edi
4003567a:	89 2a                	mov    %ebp,(%edx)
4003567c:	29 ef                	sub    %ebp,%edi
4003567e:	31 d2                	xor    %edx,%edx
40035680:	a8 03                	test   $0x3,%al
40035682:	75 03                	jne    40035687 <__sflush_r+0xf5>
40035684:	8b 53 14             	mov    0x14(%ebx),%edx
40035687:	89 53 08             	mov    %edx,0x8(%ebx)
4003568a:	eb 1e                	jmp    400356aa <__sflush_r+0x118>
4003568c:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
40035691:	83 c8 ff             	or     $0xffffffff,%eax
40035694:	eb 1a                	jmp    400356b0 <__sflush_r+0x11e>
40035696:	8b 53 1c             	mov    0x1c(%ebx),%edx
40035699:	89 e9                	mov    %ebp,%ecx
4003569b:	89 f0                	mov    %esi,%eax
4003569d:	57                   	push   %edi
4003569e:	ff 53 24             	call   *0x24(%ebx)
400356a1:	5a                   	pop    %edx
400356a2:	85 c0                	test   %eax,%eax
400356a4:	7e e6                	jle    4003568c <__sflush_r+0xfa>
400356a6:	01 c5                	add    %eax,%ebp
400356a8:	29 c7                	sub    %eax,%edi
400356aa:	85 ff                	test   %edi,%edi
400356ac:	7f e8                	jg     40035696 <__sflush_r+0x104>
400356ae:	eb bd                	jmp    4003566d <__sflush_r+0xdb>
400356b0:	5b                   	pop    %ebx
400356b1:	5e                   	pop    %esi
400356b2:	5f                   	pop    %edi
400356b3:	5d                   	pop    %ebp
400356b4:	c3                   	ret    

400356b5 <_fflush_r>:
400356b5:	53                   	push   %ebx
400356b6:	85 c0                	test   %eax,%eax
400356b8:	53                   	push   %ebx
400356b9:	89 c3                	mov    %eax,%ebx
400356bb:	74 11                	je     400356ce <_fflush_r+0x19>
400356bd:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
400356c1:	75 0b                	jne    400356ce <_fflush_r+0x19>
400356c3:	89 14 24             	mov    %edx,(%esp)
400356c6:	e8 8d 00 00 00       	call   40035758 <__sinit>
400356cb:	8b 14 24             	mov    (%esp),%edx
400356ce:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
400356d3:	74 09                	je     400356de <_fflush_r+0x29>
400356d5:	89 d8                	mov    %ebx,%eax
400356d7:	59                   	pop    %ecx
400356d8:	5b                   	pop    %ebx
400356d9:	e9 b4 fe ff ff       	jmp    40035592 <__sflush_r>
400356de:	31 c0                	xor    %eax,%eax
400356e0:	5a                   	pop    %edx
400356e1:	5b                   	pop    %ebx
400356e2:	c3                   	ret    

400356e3 <_cleanup_r>:
400356e3:	ba b5 56 03 40       	mov    $0x400356b5,%edx
400356e8:	e9 d7 00 00 00       	jmp    400357c4 <_fwalk_reent>

400356ed <std.isra.0>:
400356ed:	53                   	push   %ebx
400356ee:	89 c3                	mov    %eax,%ebx
400356f0:	66 89 50 0c          	mov    %dx,0xc(%eax)
400356f4:	66 89 48 0e          	mov    %cx,0xe(%eax)
400356f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
400356fe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
40035705:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
4003570c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
40035713:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
4003571a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40035721:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40035728:	b9 08 00 00 00       	mov    $0x8,%ecx
4003572d:	8d 40 5c             	lea    0x5c(%eax),%eax
40035730:	31 d2                	xor    %edx,%edx
40035732:	e8 3e a9 ff ff       	call   40030075 <memset>
40035737:	89 5b 1c             	mov    %ebx,0x1c(%ebx)
4003573a:	c7 43 20 75 59 03 40 	movl   $0x40035975,0x20(%ebx)
40035741:	c7 43 24 97 59 03 40 	movl   $0x40035997,0x24(%ebx)
40035748:	c7 43 28 d4 59 03 40 	movl   $0x400359d4,0x28(%ebx)
4003574f:	c7 43 2c fd 59 03 40 	movl   $0x400359fd,0x2c(%ebx)
40035756:	5b                   	pop    %ebx
40035757:	c3                   	ret    

40035758 <__sinit>:
40035758:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
4003575c:	75 65                	jne    400357c3 <__sinit+0x6b>
4003575e:	53                   	push   %ebx
4003575f:	89 c3                	mov    %eax,%ebx
40035761:	c7 40 3c e3 56 03 40 	movl   $0x400356e3,0x3c(%eax)
40035768:	c7 80 4c 01 00 00 00 	movl   $0x0,0x14c(%eax)
4003576f:	00 00 00 
40035772:	c7 80 50 01 00 00 03 	movl   $0x3,0x150(%eax)
40035779:	00 00 00 
4003577c:	8d 80 58 01 00 00    	lea    0x158(%eax),%eax
40035782:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
40035788:	31 c9                	xor    %ecx,%ecx
4003578a:	8b 43 04             	mov    0x4(%ebx),%eax
4003578d:	ba 04 00 00 00       	mov    $0x4,%edx
40035792:	e8 56 ff ff ff       	call   400356ed <std.isra.0>
40035797:	8b 43 08             	mov    0x8(%ebx),%eax
4003579a:	b9 01 00 00 00       	mov    $0x1,%ecx
4003579f:	ba 09 00 00 00       	mov    $0x9,%edx
400357a4:	e8 44 ff ff ff       	call   400356ed <std.isra.0>
400357a9:	8b 43 0c             	mov    0xc(%ebx),%eax
400357ac:	b9 02 00 00 00       	mov    $0x2,%ecx
400357b1:	ba 12 00 00 00       	mov    $0x12,%edx
400357b6:	e8 32 ff ff ff       	call   400356ed <std.isra.0>
400357bb:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
400357c2:	5b                   	pop    %ebx
400357c3:	c3                   	ret    

400357c4 <_fwalk_reent>:
400357c4:	55                   	push   %ebp
400357c5:	57                   	push   %edi
400357c6:	56                   	push   %esi
400357c7:	53                   	push   %ebx
400357c8:	83 ec 08             	sub    $0x8,%esp
400357cb:	89 c5                	mov    %eax,%ebp
400357cd:	89 d1                	mov    %edx,%ecx
400357cf:	8d 98 4c 01 00 00    	lea    0x14c(%eax),%ebx
400357d5:	31 ff                	xor    %edi,%edi
400357d7:	85 db                	test   %ebx,%ebx
400357d9:	74 35                	je     40035810 <_fwalk_reent+0x4c>
400357db:	8b 43 04             	mov    0x4(%ebx),%eax
400357de:	8b 73 08             	mov    0x8(%ebx),%esi
400357e1:	89 04 24             	mov    %eax,(%esp)
400357e4:	ff 0c 24             	decl   (%esp)
400357e7:	78 23                	js     4003580c <_fwalk_reent+0x48>
400357e9:	66 83 7e 0c 01       	cmpw   $0x1,0xc(%esi)
400357ee:	76 17                	jbe    40035807 <_fwalk_reent+0x43>
400357f0:	66 83 7e 0e ff       	cmpw   $0xffff,0xe(%esi)
400357f5:	74 10                	je     40035807 <_fwalk_reent+0x43>
400357f7:	89 f2                	mov    %esi,%edx
400357f9:	89 e8                	mov    %ebp,%eax
400357fb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
400357ff:	ff d1                	call   *%ecx
40035801:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40035805:	09 c7                	or     %eax,%edi
40035807:	83 c6 68             	add    $0x68,%esi
4003580a:	eb d8                	jmp    400357e4 <_fwalk_reent+0x20>
4003580c:	8b 1b                	mov    (%ebx),%ebx
4003580e:	eb c7                	jmp    400357d7 <_fwalk_reent+0x13>
40035810:	83 c4 08             	add    $0x8,%esp
40035813:	89 f8                	mov    %edi,%eax
40035815:	5b                   	pop    %ebx
40035816:	5e                   	pop    %esi
40035817:	5f                   	pop    %edi
40035818:	5d                   	pop    %ebp
40035819:	c3                   	ret    

4003581a <__swhatbuf_r>:
4003581a:	57                   	push   %edi
4003581b:	56                   	push   %esi
4003581c:	53                   	push   %ebx
4003581d:	89 d7                	mov    %edx,%edi
4003581f:	83 ec 3c             	sub    $0x3c,%esp
40035822:	89 cb                	mov    %ecx,%ebx
40035824:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035828:	66 85 d2             	test   %dx,%dx
4003582b:	8b 74 24 4c          	mov    0x4c(%esp),%esi
4003582f:	79 1f                	jns    40035850 <__swhatbuf_r+0x36>
40035831:	8b 47 0c             	mov    0xc(%edi),%eax
40035834:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
4003583a:	66 25 80 00          	and    $0x80,%ax
4003583e:	66 83 f8 01          	cmp    $0x1,%ax
40035842:	19 c0                	sbb    %eax,%eax
40035844:	25 c0 03 00 00       	and    $0x3c0,%eax
40035849:	83 c0 40             	add    $0x40,%eax
4003584c:	89 03                	mov    %eax,(%ebx)
4003584e:	eb 27                	jmp    40035877 <__swhatbuf_r+0x5d>
40035850:	89 e1                	mov    %esp,%ecx
40035852:	e8 03 02 00 00       	call   40035a5a <_fstat_r>
40035857:	85 c0                	test   %eax,%eax
40035859:	78 d6                	js     40035831 <__swhatbuf_r+0x17>
4003585b:	8b 44 24 04          	mov    0x4(%esp),%eax
4003585f:	25 00 f0 00 00       	and    $0xf000,%eax
40035864:	3d 00 20 00 00       	cmp    $0x2000,%eax
40035869:	0f 94 c0             	sete   %al
4003586c:	0f b6 c0             	movzbl %al,%eax
4003586f:	89 06                	mov    %eax,(%esi)
40035871:	c7 03 00 04 00 00    	movl   $0x400,(%ebx)
40035877:	83 c4 3c             	add    $0x3c,%esp
4003587a:	31 c0                	xor    %eax,%eax
4003587c:	5b                   	pop    %ebx
4003587d:	5e                   	pop    %esi
4003587e:	5f                   	pop    %edi
4003587f:	c3                   	ret    

40035880 <__smakebuf_r>:
40035880:	f6 42 0c 02          	testb  $0x2,0xc(%edx)
40035884:	74 10                	je     40035896 <__smakebuf_r+0x16>
40035886:	8d 42 43             	lea    0x43(%edx),%eax
40035889:	c7 42 14 01 00 00 00 	movl   $0x1,0x14(%edx)
40035890:	89 02                	mov    %eax,(%edx)
40035892:	89 42 10             	mov    %eax,0x10(%edx)
40035895:	c3                   	ret    
40035896:	57                   	push   %edi
40035897:	56                   	push   %esi
40035898:	53                   	push   %ebx
40035899:	89 c6                	mov    %eax,%esi
4003589b:	83 ec 08             	sub    $0x8,%esp
4003589e:	89 d3                	mov    %edx,%ebx
400358a0:	8d 44 24 04          	lea    0x4(%esp),%eax
400358a4:	50                   	push   %eax
400358a5:	89 f0                	mov    %esi,%eax
400358a7:	8d 4c 24 04          	lea    0x4(%esp),%ecx
400358ab:	e8 6a ff ff ff       	call   4003581a <__swhatbuf_r>
400358b0:	8b 54 24 04          	mov    0x4(%esp),%edx
400358b4:	89 c7                	mov    %eax,%edi
400358b6:	89 f0                	mov    %esi,%eax
400358b8:	e8 1b f0 ff ff       	call   400348d8 <_malloc_r>
400358bd:	5a                   	pop    %edx
400358be:	85 c0                	test   %eax,%eax
400358c0:	75 20                	jne    400358e2 <__smakebuf_r+0x62>
400358c2:	8b 43 0c             	mov    0xc(%ebx),%eax
400358c5:	f6 c4 02             	test   $0x2,%ah
400358c8:	75 4f                	jne    40035919 <__smakebuf_r+0x99>
400358ca:	83 c8 02             	or     $0x2,%eax
400358cd:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
400358d4:	66 89 43 0c          	mov    %ax,0xc(%ebx)
400358d8:	8d 43 43             	lea    0x43(%ebx),%eax
400358db:	89 03                	mov    %eax,(%ebx)
400358dd:	89 43 10             	mov    %eax,0x10(%ebx)
400358e0:	eb 37                	jmp    40035919 <__smakebuf_r+0x99>
400358e2:	c7 46 3c e3 56 03 40 	movl   $0x400356e3,0x3c(%esi)
400358e9:	89 03                	mov    %eax,(%ebx)
400358eb:	89 43 10             	mov    %eax,0x10(%ebx)
400358ee:	8b 04 24             	mov    (%esp),%eax
400358f1:	66 81 4b 0c 80 00    	orw    $0x80,0xc(%ebx)
400358f7:	89 43 14             	mov    %eax,0x14(%ebx)
400358fa:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
400358ff:	74 14                	je     40035915 <__smakebuf_r+0x95>
40035901:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
40035905:	89 f0                	mov    %esi,%eax
40035907:	e8 77 01 00 00       	call   40035a83 <_isatty_r>
4003590c:	85 c0                	test   %eax,%eax
4003590e:	74 05                	je     40035915 <__smakebuf_r+0x95>
40035910:	66 83 4b 0c 01       	orw    $0x1,0xc(%ebx)
40035915:	66 09 7b 0c          	or     %di,0xc(%ebx)
40035919:	83 c4 08             	add    $0x8,%esp
4003591c:	5b                   	pop    %ebx
4003591d:	5e                   	pop    %esi
4003591e:	5f                   	pop    %edi
4003591f:	c3                   	ret    

40035920 <_realloc_r>:
40035920:	85 d2                	test   %edx,%edx
40035922:	75 07                	jne    4003592b <_realloc_r+0xb>
40035924:	89 ca                	mov    %ecx,%edx
40035926:	e9 ad ef ff ff       	jmp    400348d8 <_malloc_r>
4003592b:	55                   	push   %ebp
4003592c:	85 c9                	test   %ecx,%ecx
4003592e:	57                   	push   %edi
4003592f:	89 cd                	mov    %ecx,%ebp
40035931:	56                   	push   %esi
40035932:	89 c6                	mov    %eax,%esi
40035934:	53                   	push   %ebx
40035935:	89 d3                	mov    %edx,%ebx
40035937:	75 09                	jne    40035942 <_realloc_r+0x22>
40035939:	e8 e1 ee ff ff       	call   4003481f <_free_r>
4003593e:	31 ff                	xor    %edi,%edi
40035940:	eb 2c                	jmp    4003596e <_realloc_r+0x4e>
40035942:	e8 90 01 00 00       	call   40035ad7 <_malloc_usable_size_r>
40035947:	89 df                	mov    %ebx,%edi
40035949:	39 c5                	cmp    %eax,%ebp
4003594b:	76 21                	jbe    4003596e <_realloc_r+0x4e>
4003594d:	89 ea                	mov    %ebp,%edx
4003594f:	89 f0                	mov    %esi,%eax
40035951:	e8 82 ef ff ff       	call   400348d8 <_malloc_r>
40035956:	89 c7                	mov    %eax,%edi
40035958:	85 c0                	test   %eax,%eax
4003595a:	74 12                	je     4003596e <_realloc_r+0x4e>
4003595c:	89 da                	mov    %ebx,%edx
4003595e:	89 e9                	mov    %ebp,%ecx
40035960:	e8 05 a7 ff ff       	call   4003006a <memcpy>
40035965:	89 da                	mov    %ebx,%edx
40035967:	89 f0                	mov    %esi,%eax
40035969:	e8 b1 ee ff ff       	call   4003481f <_free_r>
4003596e:	5b                   	pop    %ebx
4003596f:	89 f8                	mov    %edi,%eax
40035971:	5e                   	pop    %esi
40035972:	5f                   	pop    %edi
40035973:	5d                   	pop    %ebp
40035974:	c3                   	ret    

40035975 <__sread>:
40035975:	53                   	push   %ebx
40035976:	89 d3                	mov    %edx,%ebx
40035978:	0f bf 52 0e          	movswl 0xe(%edx),%edx
4003597c:	ff 74 24 08          	pushl  0x8(%esp)
40035980:	e8 61 01 00 00       	call   40035ae6 <_read_r>
40035985:	5a                   	pop    %edx
40035986:	85 c0                	test   %eax,%eax
40035988:	78 05                	js     4003598f <__sread+0x1a>
4003598a:	01 43 50             	add    %eax,0x50(%ebx)
4003598d:	eb 06                	jmp    40035995 <__sread+0x20>
4003598f:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
40035995:	5b                   	pop    %ebx
40035996:	c3                   	ret    

40035997 <__swrite>:
40035997:	55                   	push   %ebp
40035998:	57                   	push   %edi
40035999:	56                   	push   %esi
4003599a:	53                   	push   %ebx
4003599b:	89 c6                	mov    %eax,%esi
4003599d:	89 d3                	mov    %edx,%ebx
4003599f:	89 cf                	mov    %ecx,%edi
400359a1:	8b 6c 24 14          	mov    0x14(%esp),%ebp
400359a5:	f6 42 0d 01          	testb  $0x1,0xd(%edx)
400359a9:	74 0e                	je     400359b9 <__swrite+0x22>
400359ab:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400359af:	31 c9                	xor    %ecx,%ecx
400359b1:	6a 02                	push   $0x2
400359b3:	e8 f2 00 00 00       	call   40035aaa <_lseek_r>
400359b8:	58                   	pop    %eax
400359b9:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400359bf:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
400359c3:	89 f9                	mov    %edi,%ecx
400359c5:	89 f0                	mov    %esi,%eax
400359c7:	89 6c 24 14          	mov    %ebp,0x14(%esp)
400359cb:	5b                   	pop    %ebx
400359cc:	5e                   	pop    %esi
400359cd:	5f                   	pop    %edi
400359ce:	5d                   	pop    %ebp
400359cf:	e9 32 00 00 00       	jmp    40035a06 <_write_r>

400359d4 <__sseek>:
400359d4:	53                   	push   %ebx
400359d5:	89 d3                	mov    %edx,%ebx
400359d7:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400359db:	ff 74 24 08          	pushl  0x8(%esp)
400359df:	e8 c6 00 00 00       	call   40035aaa <_lseek_r>
400359e4:	5a                   	pop    %edx
400359e5:	83 f8 ff             	cmp    $0xffffffff,%eax
400359e8:	75 08                	jne    400359f2 <__sseek+0x1e>
400359ea:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400359f0:	eb 09                	jmp    400359fb <__sseek+0x27>
400359f2:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
400359f8:	89 43 50             	mov    %eax,0x50(%ebx)
400359fb:	5b                   	pop    %ebx
400359fc:	c3                   	ret    

400359fd <__sclose>:
400359fd:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035a01:	e9 2d 00 00 00       	jmp    40035a33 <_close_r>

40035a06 <_write_r>:
40035a06:	53                   	push   %ebx
40035a07:	89 c3                	mov    %eax,%ebx
40035a09:	89 d0                	mov    %edx,%eax
40035a0b:	89 ca                	mov    %ecx,%edx
40035a0d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035a11:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035a18:	00 00 00 
40035a1b:	e8 7e b9 ff ff       	call   4003139e <_write>
40035a20:	83 f8 ff             	cmp    $0xffffffff,%eax
40035a23:	75 0c                	jne    40035a31 <_write_r+0x2b>
40035a25:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035a2b:	85 d2                	test   %edx,%edx
40035a2d:	74 02                	je     40035a31 <_write_r+0x2b>
40035a2f:	89 13                	mov    %edx,(%ebx)
40035a31:	5b                   	pop    %ebx
40035a32:	c3                   	ret    

40035a33 <_close_r>:
40035a33:	53                   	push   %ebx
40035a34:	89 c3                	mov    %eax,%ebx
40035a36:	89 d0                	mov    %edx,%eax
40035a38:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035a3f:	00 00 00 
40035a42:	e8 a4 b9 ff ff       	call   400313eb <_close>
40035a47:	83 f8 ff             	cmp    $0xffffffff,%eax
40035a4a:	75 0c                	jne    40035a58 <_close_r+0x25>
40035a4c:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035a52:	85 d2                	test   %edx,%edx
40035a54:	74 02                	je     40035a58 <_close_r+0x25>
40035a56:	89 13                	mov    %edx,(%ebx)
40035a58:	5b                   	pop    %ebx
40035a59:	c3                   	ret    

40035a5a <_fstat_r>:
40035a5a:	53                   	push   %ebx
40035a5b:	89 c3                	mov    %eax,%ebx
40035a5d:	89 d0                	mov    %edx,%eax
40035a5f:	89 ca                	mov    %ecx,%edx
40035a61:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035a68:	00 00 00 
40035a6b:	e8 6d b9 ff ff       	call   400313dd <_fstat>
40035a70:	83 f8 ff             	cmp    $0xffffffff,%eax
40035a73:	75 0c                	jne    40035a81 <_fstat_r+0x27>
40035a75:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035a7b:	85 d2                	test   %edx,%edx
40035a7d:	74 02                	je     40035a81 <_fstat_r+0x27>
40035a7f:	89 13                	mov    %edx,(%ebx)
40035a81:	5b                   	pop    %ebx
40035a82:	c3                   	ret    

40035a83 <_isatty_r>:
40035a83:	53                   	push   %ebx
40035a84:	89 c3                	mov    %eax,%ebx
40035a86:	89 d0                	mov    %edx,%eax
40035a88:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035a8f:	00 00 00 
40035a92:	e8 3c b9 ff ff       	call   400313d3 <_isatty>
40035a97:	83 f8 ff             	cmp    $0xffffffff,%eax
40035a9a:	75 0c                	jne    40035aa8 <_isatty_r+0x25>
40035a9c:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035aa2:	85 d2                	test   %edx,%edx
40035aa4:	74 02                	je     40035aa8 <_isatty_r+0x25>
40035aa6:	89 13                	mov    %edx,(%ebx)
40035aa8:	5b                   	pop    %ebx
40035aa9:	c3                   	ret    

40035aaa <_lseek_r>:
40035aaa:	53                   	push   %ebx
40035aab:	89 c3                	mov    %eax,%ebx
40035aad:	89 d0                	mov    %edx,%eax
40035aaf:	89 ca                	mov    %ecx,%edx
40035ab1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035ab5:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035abc:	00 00 00 
40035abf:	e8 2f b9 ff ff       	call   400313f3 <_lseek>
40035ac4:	83 f8 ff             	cmp    $0xffffffff,%eax
40035ac7:	75 0c                	jne    40035ad5 <_lseek_r+0x2b>
40035ac9:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035acf:	85 d2                	test   %edx,%edx
40035ad1:	74 02                	je     40035ad5 <_lseek_r+0x2b>
40035ad3:	89 13                	mov    %edx,(%ebx)
40035ad5:	5b                   	pop    %ebx
40035ad6:	c3                   	ret    

40035ad7 <_malloc_usable_size_r>:
40035ad7:	8b 4a fc             	mov    -0x4(%edx),%ecx
40035ada:	85 c9                	test   %ecx,%ecx
40035adc:	8d 41 fc             	lea    -0x4(%ecx),%eax
40035adf:	79 04                	jns    40035ae5 <_malloc_usable_size_r+0xe>
40035ae1:	03 44 0a fc          	add    -0x4(%edx,%ecx,1),%eax
40035ae5:	c3                   	ret    

40035ae6 <_read_r>:
40035ae6:	53                   	push   %ebx
40035ae7:	89 c3                	mov    %eax,%ebx
40035ae9:	89 d0                	mov    %edx,%eax
40035aeb:	89 ca                	mov    %ecx,%edx
40035aed:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035af1:	c7 05 d4 78 00 a8 00 	movl   $0x0,0xa80078d4
40035af8:	00 00 00 
40035afb:	e8 73 b8 ff ff       	call   40031373 <_read>
40035b00:	83 f8 ff             	cmp    $0xffffffff,%eax
40035b03:	75 0c                	jne    40035b11 <_read_r+0x2b>
40035b05:	8b 15 d4 78 00 a8    	mov    0xa80078d4,%edx
40035b0b:	85 d2                	test   %edx,%edx
40035b0d:	74 02                	je     40035b11 <_read_r+0x2b>
40035b0f:	89 13                	mov    %edx,(%ebx)
40035b11:	5b                   	pop    %ebx
40035b12:	c3                   	ret    

40035b13 <_handle_exc_0_vector_0_stub>:
40035b13:	6a 00                	push   $0x0
40035b15:	68 f5 3b 03 40       	push   $0x40033bf5
40035b1a:	e9 75 de ff ff       	jmp    40033994 <_exception_enter>

40035b1f <_handle_exc_2_vector_2_stub>:
40035b1f:	6a 00                	push   $0x0
40035b21:	68 01 3c 03 40       	push   $0x40033c01
40035b26:	e9 69 de ff ff       	jmp    40033994 <_exception_enter>

40035b2b <_handle_exc_4_vector_4_stub>:
40035b2b:	6a 00                	push   $0x0
40035b2d:	68 10 3c 03 40       	push   $0x40033c10
40035b32:	e9 5d de ff ff       	jmp    40033994 <_exception_enter>

40035b37 <_handle_exc_5_vector_5_stub>:
40035b37:	6a 00                	push   $0x0
40035b39:	68 1f 3c 03 40       	push   $0x40033c1f
40035b3e:	e9 51 de ff ff       	jmp    40033994 <_exception_enter>

40035b43 <_handle_exc_6_vector_6_stub>:
40035b43:	6a 00                	push   $0x0
40035b45:	68 2e 3c 03 40       	push   $0x40033c2e
40035b4a:	e9 45 de ff ff       	jmp    40033994 <_exception_enter>

40035b4f <_handle_exc_7_vector_7_stub>:
40035b4f:	6a 00                	push   $0x0
40035b51:	68 3d 3c 03 40       	push   $0x40033c3d
40035b56:	e9 39 de ff ff       	jmp    40033994 <_exception_enter>

40035b5b <_handle_exc_8_vector_8_stub>:
40035b5b:	68 4c 3c 03 40       	push   $0x40033c4c
40035b60:	e9 2f de ff ff       	jmp    40033994 <_exception_enter>

40035b65 <_handle_exc_10_vector_10_stub>:
40035b65:	68 5b 3c 03 40       	push   $0x40033c5b
40035b6a:	e9 25 de ff ff       	jmp    40033994 <_exception_enter>

40035b6f <_handle_exc_11_vector_11_stub>:
40035b6f:	68 6a 3c 03 40       	push   $0x40033c6a
40035b74:	e9 1b de ff ff       	jmp    40033994 <_exception_enter>

40035b79 <_handle_exc_12_vector_12_stub>:
40035b79:	68 79 3c 03 40       	push   $0x40033c79
40035b7e:	e9 11 de ff ff       	jmp    40033994 <_exception_enter>

40035b83 <_handle_exc_13_vector_13_stub>:
40035b83:	68 88 3c 03 40       	push   $0x40033c88
40035b88:	e9 07 de ff ff       	jmp    40033994 <_exception_enter>

40035b8d <_handle_exc_14_vector_14_stub>:
40035b8d:	68 97 3c 03 40       	push   $0x40033c97
40035b92:	e9 fd dd ff ff       	jmp    40033994 <_exception_enter>

40035b97 <_handle_exc_16_vector_16_stub>:
40035b97:	6a 00                	push   $0x0
40035b99:	68 a6 3c 03 40       	push   $0x40033ca6
40035b9e:	e9 f1 dd ff ff       	jmp    40033994 <_exception_enter>

40035ba3 <_handle_exc_17_vector_17_stub>:
40035ba3:	68 b5 3c 03 40       	push   $0x40033cb5
40035ba8:	e9 e7 dd ff ff       	jmp    40033994 <_exception_enter>

40035bad <_handle_exc_18_vector_18_stub>:
40035bad:	6a 00                	push   $0x0
40035baf:	68 c4 3c 03 40       	push   $0x40033cc4
40035bb4:	e9 db dd ff ff       	jmp    40033994 <_exception_enter>
