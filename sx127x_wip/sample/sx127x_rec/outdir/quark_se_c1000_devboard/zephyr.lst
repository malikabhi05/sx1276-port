
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
4003000c:	0f 01 1d 4c 00 03 40 	lidtl  0x4003004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
40030013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
4003001c:	bc bc 78 00 a8       	mov    $0xa80078bc,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
40030021:	81 c4 00 08 00 00    	add    $0x800,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030027:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003002c:	be a8 6f 03 40       	mov    $0x40036fa8,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030031:	b9 f5 00 00 00       	mov    $0xf5,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
40030038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003003a:	bf e0 67 00 a8       	mov    $0xa80067e0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
4003003f:	b9 36 04 00 00       	mov    $0x436,%ecx
	cld
40030044:	fc                   	cld    
	rep
40030045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030047:	e9 8a 3d 00 00       	jmp    40033dd6 <_Cstart>

4003004c <_Idt>:
4003004c:	ff 07 28 67 03 40 66 90 66 90 66 90 66 90 66 90     ..(g.@f.f.f.f.f.
4003005c:	66 90 66 90                                         f.f.

40030060 <_thread_entry_wrapper>:
40030060:	58                   	pop    %eax
40030061:	5a                   	pop    %edx
40030062:	59                   	pop    %ecx
40030063:	6a 00                	push   $0x0
40030065:	e9 8b 45 00 00       	jmp    400345f5 <_thread_entry>

4003006a <memset>:
4003006a:	57                   	push   %edi
4003006b:	89 c7                	mov    %eax,%edi
4003006d:	0f b6 c2             	movzbl %dl,%eax
40030070:	89 fa                	mov    %edi,%edx
40030072:	f3 aa                	rep stos %al,%es:(%edi)
40030074:	89 d0                	mov    %edx,%eax
40030076:	5f                   	pop    %edi
40030077:	c3                   	ret    

40030078 <memchr>:
40030078:	57                   	push   %edi
40030079:	89 c7                	mov    %eax,%edi
4003007b:	89 d0                	mov    %edx,%eax
4003007d:	31 d2                	xor    %edx,%edx
4003007f:	85 c9                	test   %ecx,%ecx
40030081:	74 09                	je     4003008c <L20>
40030083:	f2 ae                	repnz scas %es:(%edi),%al
40030085:	0f 95 c2             	setne  %dl
40030088:	4f                   	dec    %edi
40030089:	4a                   	dec    %edx
4003008a:	21 fa                	and    %edi,%edx

4003008c <L20>:
4003008c:	89 d0                	mov    %edx,%eax
4003008e:	5f                   	pop    %edi
4003008f:	c3                   	ret    

40030090 <__udivdi3>:
40030090:	55                   	push   %ebp
40030091:	89 e5                	mov    %esp,%ebp
40030093:	57                   	push   %edi
40030094:	56                   	push   %esi
40030095:	53                   	push   %ebx
40030096:	83 ec 10             	sub    $0x10,%esp
40030099:	89 45 f0             	mov    %eax,-0x10(%ebp)
4003009c:	8b 45 08             	mov    0x8(%ebp),%eax
4003009f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400300a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
400300a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300a8:	89 d6                	mov    %edx,%esi
400300aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
400300ad:	89 d9                	mov    %ebx,%ecx
400300af:	89 d0                	mov    %edx,%eax
400300b1:	85 db                	test   %ebx,%ebx
400300b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
400300b6:	75 30                	jne    400300e8 <__udivdi3+0x58>
400300b8:	89 d7                	mov    %edx,%edi
400300ba:	39 f2                	cmp    %esi,%edx
400300bc:	76 07                	jbe    400300c5 <__udivdi3+0x35>
400300be:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300c1:	89 f2                	mov    %esi,%edx
400300c3:	eb 1a                	jmp    400300df <__udivdi3+0x4f>
400300c5:	85 d2                	test   %edx,%edx
400300c7:	75 0b                	jne    400300d4 <__udivdi3+0x44>
400300c9:	b8 01 00 00 00       	mov    $0x1,%eax
400300ce:	31 d2                	xor    %edx,%edx
400300d0:	f7 f7                	div    %edi
400300d2:	89 c7                	mov    %eax,%edi
400300d4:	31 d2                	xor    %edx,%edx
400300d6:	89 f0                	mov    %esi,%eax
400300d8:	f7 f7                	div    %edi
400300da:	89 c1                	mov    %eax,%ecx
400300dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
400300df:	f7 f7                	div    %edi
400300e1:	89 c3                	mov    %eax,%ebx
400300e3:	e9 92 00 00 00       	jmp    4003017a <__udivdi3+0xea>
400300e8:	39 f3                	cmp    %esi,%ebx
400300ea:	0f 87 82 00 00 00    	ja     40030172 <__udivdi3+0xe2>
400300f0:	0f bd f3             	bsr    %ebx,%esi
400300f3:	89 75 f0             	mov    %esi,-0x10(%ebp)
400300f6:	83 75 f0 1f          	xorl   $0x1f,-0x10(%ebp)
400300fa:	75 15                	jne    40030111 <__udivdi3+0x81>
400300fc:	39 c3                	cmp    %eax,%ebx
400300fe:	b9 00 00 00 00       	mov    $0x0,%ecx
40030103:	72 05                	jb     4003010a <__udivdi3+0x7a>
40030105:	3b 55 ec             	cmp    -0x14(%ebp),%edx
40030108:	77 6a                	ja     40030174 <__udivdi3+0xe4>
4003010a:	bb 01 00 00 00       	mov    $0x1,%ebx
4003010f:	eb 69                	jmp    4003017a <__udivdi3+0xea>
40030111:	be 20 00 00 00       	mov    $0x20,%esi
40030116:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030119:	2b 75 f0             	sub    -0x10(%ebp),%esi
4003011c:	89 d7                	mov    %edx,%edi
4003011e:	d3 e3                	shl    %cl,%ebx
40030120:	89 f1                	mov    %esi,%ecx
40030122:	d3 ef                	shr    %cl,%edi
40030124:	89 f9                	mov    %edi,%ecx
40030126:	09 d9                	or     %ebx,%ecx
40030128:	8b 5d ec             	mov    -0x14(%ebp),%ebx
4003012b:	89 4d e8             	mov    %ecx,-0x18(%ebp)
4003012e:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030131:	d3 e2                	shl    %cl,%edx
40030133:	89 55 e4             	mov    %edx,-0x1c(%ebp)
40030136:	89 f1                	mov    %esi,%ecx
40030138:	89 c2                	mov    %eax,%edx
4003013a:	d3 ea                	shr    %cl,%edx
4003013c:	8a 4d f0             	mov    -0x10(%ebp),%cl
4003013f:	d3 e0                	shl    %cl,%eax
40030141:	89 f1                	mov    %esi,%ecx
40030143:	d3 eb                	shr    %cl,%ebx
40030145:	09 c3                	or     %eax,%ebx
40030147:	89 d8                	mov    %ebx,%eax
40030149:	f7 75 e8             	divl   -0x18(%ebp)
4003014c:	89 d6                	mov    %edx,%esi
4003014e:	89 c7                	mov    %eax,%edi
40030150:	89 c3                	mov    %eax,%ebx
40030152:	f7 65 e4             	mull   -0x1c(%ebp)
40030155:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030158:	39 d6                	cmp    %edx,%esi
4003015a:	72 11                	jb     4003016d <__udivdi3+0xdd>
4003015c:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003015f:	8a 4d f0             	mov    -0x10(%ebp),%cl
40030162:	d3 e0                	shl    %cl,%eax
40030164:	3b 45 e8             	cmp    -0x18(%ebp),%eax
40030167:	73 0f                	jae    40030178 <__udivdi3+0xe8>
40030169:	39 d6                	cmp    %edx,%esi
4003016b:	75 0b                	jne    40030178 <__udivdi3+0xe8>
4003016d:	8d 5f ff             	lea    -0x1(%edi),%ebx
40030170:	eb 06                	jmp    40030178 <__udivdi3+0xe8>
40030172:	31 c9                	xor    %ecx,%ecx
40030174:	31 db                	xor    %ebx,%ebx
40030176:	eb 02                	jmp    4003017a <__udivdi3+0xea>
40030178:	31 c9                	xor    %ecx,%ecx
4003017a:	89 d8                	mov    %ebx,%eax
4003017c:	89 ca                	mov    %ecx,%edx
4003017e:	83 c4 10             	add    $0x10,%esp
40030181:	5b                   	pop    %ebx
40030182:	5e                   	pop    %esi
40030183:	5f                   	pop    %edi
40030184:	5d                   	pop    %ebp
40030185:	c3                   	ret    

40030186 <__divdf3>:
40030186:	55                   	push   %ebp
40030187:	89 d1                	mov    %edx,%ecx
40030189:	c1 e9 14             	shr    $0x14,%ecx
4003018c:	89 e5                	mov    %esp,%ebp
4003018e:	57                   	push   %edi
4003018f:	56                   	push   %esi
40030190:	53                   	push   %ebx
40030191:	89 d3                	mov    %edx,%ebx
40030193:	c1 ea 1f             	shr    $0x1f,%edx
40030196:	83 ec 24             	sub    $0x24,%esp
40030199:	89 55 d4             	mov    %edx,-0x2c(%ebp)
4003019c:	8b 75 0c             	mov    0xc(%ebp),%esi
4003019f:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
400301a3:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
400301a9:	89 75 e0             	mov    %esi,-0x20(%ebp)
400301ac:	66 81 e1 ff 07       	and    $0x7ff,%cx
400301b1:	8b 7d 08             	mov    0x8(%ebp),%edi
400301b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
400301b7:	89 c6                	mov    %eax,%esi
400301b9:	74 29                	je     400301e4 <__divdf3+0x5e>
400301bb:	66 81 f9 ff 07       	cmp    $0x7ff,%cx
400301c0:	0f 84 85 00 00 00    	je     4003024b <__divdf3+0xc5>
400301c6:	c1 e8 1d             	shr    $0x1d,%eax
400301c9:	c1 e3 03             	shl    $0x3,%ebx
400301cc:	0d 00 00 80 00       	or     $0x800000,%eax
400301d1:	0f b7 c9             	movzwl %cx,%ecx
400301d4:	c1 e6 03             	shl    $0x3,%esi
400301d7:	09 d8                	or     %ebx,%eax
400301d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
400301dc:	8d 81 01 fc ff ff    	lea    -0x3ff(%ecx),%eax
400301e2:	eb 5b                	jmp    4003023f <__divdf3+0xb9>
400301e4:	09 de                	or     %ebx,%esi
400301e6:	89 75 f0             	mov    %esi,-0x10(%ebp)
400301e9:	74 7a                	je     40030265 <__divdf3+0xdf>
400301eb:	85 db                	test   %ebx,%ebx
400301ed:	74 08                	je     400301f7 <__divdf3+0x71>
400301ef:	0f bd d3             	bsr    %ebx,%edx
400301f2:	83 f2 1f             	xor    $0x1f,%edx
400301f5:	eb 09                	jmp    40030200 <__divdf3+0x7a>
400301f7:	0f bd d0             	bsr    %eax,%edx
400301fa:	83 f2 1f             	xor    $0x1f,%edx
400301fd:	83 c2 20             	add    $0x20,%edx
40030200:	8d 72 f5             	lea    -0xb(%edx),%esi
40030203:	83 fe 1c             	cmp    $0x1c,%esi
40030206:	7f 26                	jg     4003022e <__divdf3+0xa8>
40030208:	8d 4a f8             	lea    -0x8(%edx),%ecx
4003020b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
4003020e:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030211:	d3 e3                	shl    %cl,%ebx
40030213:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40030218:	29 f1                	sub    %esi,%ecx
4003021a:	89 c6                	mov    %eax,%esi
4003021c:	d3 ee                	shr    %cl,%esi
4003021e:	89 f1                	mov    %esi,%ecx
40030220:	09 d9                	or     %ebx,%ecx
40030222:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40030225:	8a 4d ec             	mov    -0x14(%ebp),%cl
40030228:	d3 e0                	shl    %cl,%eax
4003022a:	89 c6                	mov    %eax,%esi
4003022c:	eb 0a                	jmp    40030238 <__divdf3+0xb2>
4003022e:	8d 4a d8             	lea    -0x28(%edx),%ecx
40030231:	31 f6                	xor    %esi,%esi
40030233:	d3 e0                	shl    %cl,%eax
40030235:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030238:	b8 0d fc ff ff       	mov    $0xfffffc0d,%eax
4003023d:	29 d0                	sub    %edx,%eax
4003023f:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030242:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
40030249:	eb 3c                	jmp    40030287 <__divdf3+0x101>
4003024b:	09 d8                	or     %ebx,%eax
4003024d:	89 45 f0             	mov    %eax,-0x10(%ebp)
40030250:	74 25                	je     40030277 <__divdf3+0xf1>
40030252:	89 5d f0             	mov    %ebx,-0x10(%ebp)
40030255:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
4003025c:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
40030263:	eb 22                	jmp    40030287 <__divdf3+0x101>
40030265:	31 f6                	xor    %esi,%esi
40030267:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
4003026e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40030275:	eb 10                	jmp    40030287 <__divdf3+0x101>
40030277:	31 f6                	xor    %esi,%esi
40030279:	c7 45 e8 ff 07 00 00 	movl   $0x7ff,-0x18(%ebp)
40030280:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
40030287:	8b 4d e0             	mov    -0x20(%ebp),%ecx
4003028a:	89 cb                	mov    %ecx,%ebx
4003028c:	89 c8                	mov    %ecx,%eax
4003028e:	c1 e9 1f             	shr    $0x1f,%ecx
40030291:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
40030297:	c1 e8 14             	shr    $0x14,%eax
4003029a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
4003029d:	0f b6 55 d0          	movzbl -0x30(%ebp),%edx
400302a1:	66 25 ff 07          	and    $0x7ff,%ax
400302a5:	89 55 d8             	mov    %edx,-0x28(%ebp)
400302a8:	74 2f                	je     400302d9 <__divdf3+0x153>
400302aa:	66 3d ff 07          	cmp    $0x7ff,%ax
400302ae:	0f 84 83 00 00 00    	je     40030337 <__divdf3+0x1b1>
400302b4:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
400302bb:	89 fb                	mov    %edi,%ebx
400302bd:	c1 eb 1d             	shr    $0x1d,%ebx
400302c0:	81 cb 00 00 80 00    	or     $0x800000,%ebx
400302c6:	0f b7 c0             	movzwl %ax,%eax
400302c9:	09 cb                	or     %ecx,%ebx
400302cb:	2d ff 03 00 00       	sub    $0x3ff,%eax
400302d0:	8d 0c fd 00 00 00 00 	lea    0x0(,%edi,8),%ecx
400302d7:	eb 5a                	jmp    40030333 <__divdf3+0x1ad>
400302d9:	89 f9                	mov    %edi,%ecx
400302db:	09 d9                	or     %ebx,%ecx
400302dd:	74 6c                	je     4003034b <__divdf3+0x1c5>
400302df:	85 db                	test   %ebx,%ebx
400302e1:	74 08                	je     400302eb <__divdf3+0x165>
400302e3:	0f bd c3             	bsr    %ebx,%eax
400302e6:	83 f0 1f             	xor    $0x1f,%eax
400302e9:	eb 09                	jmp    400302f4 <__divdf3+0x16e>
400302eb:	0f bd c7             	bsr    %edi,%eax
400302ee:	83 f0 1f             	xor    $0x1f,%eax
400302f1:	83 c0 20             	add    $0x20,%eax
400302f4:	8d 50 f5             	lea    -0xb(%eax),%edx
400302f7:	89 55 e0             	mov    %edx,-0x20(%ebp)
400302fa:	83 fa 1c             	cmp    $0x1c,%edx
400302fd:	7f 22                	jg     40030321 <__divdf3+0x19b>
400302ff:	8d 50 f8             	lea    -0x8(%eax),%edx
40030302:	89 55 dc             	mov    %edx,-0x24(%ebp)
40030305:	89 fa                	mov    %edi,%edx
40030307:	8a 4d dc             	mov    -0x24(%ebp),%cl
4003030a:	d3 e3                	shl    %cl,%ebx
4003030c:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40030311:	2b 4d e0             	sub    -0x20(%ebp),%ecx
40030314:	d3 ea                	shr    %cl,%edx
40030316:	8a 4d dc             	mov    -0x24(%ebp),%cl
40030319:	09 d3                	or     %edx,%ebx
4003031b:	d3 e7                	shl    %cl,%edi
4003031d:	89 f9                	mov    %edi,%ecx
4003031f:	eb 09                	jmp    4003032a <__divdf3+0x1a4>
40030321:	8d 48 d8             	lea    -0x28(%eax),%ecx
40030324:	d3 e7                	shl    %cl,%edi
40030326:	89 fb                	mov    %edi,%ebx
40030328:	31 c9                	xor    %ecx,%ecx
4003032a:	bf 0d fc ff ff       	mov    $0xfffffc0d,%edi
4003032f:	29 c7                	sub    %eax,%edi
40030331:	89 f8                	mov    %edi,%eax
40030333:	31 ff                	xor    %edi,%edi
40030335:	eb 2b                	jmp    40030362 <__divdf3+0x1dc>
40030337:	89 f9                	mov    %edi,%ecx
40030339:	09 d9                	or     %ebx,%ecx
4003033b:	74 19                	je     40030356 <__divdf3+0x1d0>
4003033d:	89 f9                	mov    %edi,%ecx
4003033f:	b8 ff 07 00 00       	mov    $0x7ff,%eax
40030344:	bf 03 00 00 00       	mov    $0x3,%edi
40030349:	eb 17                	jmp    40030362 <__divdf3+0x1dc>
4003034b:	31 db                	xor    %ebx,%ebx
4003034d:	31 c0                	xor    %eax,%eax
4003034f:	bf 01 00 00 00       	mov    $0x1,%edi
40030354:	eb 0c                	jmp    40030362 <__divdf3+0x1dc>
40030356:	31 db                	xor    %ebx,%ebx
40030358:	b8 ff 07 00 00       	mov    $0x7ff,%eax
4003035d:	bf 02 00 00 00       	mov    $0x2,%edi
40030362:	8a 55 d0             	mov    -0x30(%ebp),%dl
40030365:	33 55 d4             	xor    -0x2c(%ebp),%edx
40030368:	0f b6 d2             	movzbl %dl,%edx
4003036b:	89 55 e0             	mov    %edx,-0x20(%ebp)
4003036e:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030371:	29 c2                	sub    %eax,%edx
40030373:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030376:	c1 e0 02             	shl    $0x2,%eax
40030379:	89 55 dc             	mov    %edx,-0x24(%ebp)
4003037c:	09 f8                	or     %edi,%eax
4003037e:	48                   	dec    %eax
4003037f:	83 f8 0e             	cmp    $0xe,%eax
40030382:	77 07                	ja     4003038b <__divdf3+0x205>
40030384:	ff 24 85 98 58 03 40 	jmp    *0x40035898(,%eax,4)
4003038b:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
4003038e:	77 06                	ja     40030396 <__divdf3+0x210>
40030390:	75 1c                	jne    400303ae <__divdf3+0x228>
40030392:	39 ce                	cmp    %ecx,%esi
40030394:	72 18                	jb     400303ae <__divdf3+0x228>
40030396:	8b 55 f0             	mov    -0x10(%ebp),%edx
40030399:	89 f0                	mov    %esi,%eax
4003039b:	c1 e2 1f             	shl    $0x1f,%edx
4003039e:	c1 e6 1f             	shl    $0x1f,%esi
400303a1:	d1 e8                	shr    %eax
400303a3:	89 f7                	mov    %esi,%edi
400303a5:	89 d6                	mov    %edx,%esi
400303a7:	09 c6                	or     %eax,%esi
400303a9:	d1 6d f0             	shrl   -0x10(%ebp)
400303ac:	eb 05                	jmp    400303b3 <__divdf3+0x22d>
400303ae:	ff 4d dc             	decl   -0x24(%ebp)
400303b1:	31 ff                	xor    %edi,%edi
400303b3:	c1 e3 08             	shl    $0x8,%ebx
400303b6:	89 c8                	mov    %ecx,%eax
400303b8:	c1 e8 18             	shr    $0x18,%eax
400303bb:	c1 e1 08             	shl    $0x8,%ecx
400303be:	09 d8                	or     %ebx,%eax
400303c0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
400303c3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
400303c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
400303c9:	89 ca                	mov    %ecx,%edx
400303cb:	89 f0                	mov    %esi,%eax
400303cd:	f7 75 ec             	divl   -0x14(%ebp)
400303d0:	89 d1                	mov    %edx,%ecx
400303d2:	89 c6                	mov    %eax,%esi
400303d4:	89 55 f0             	mov    %edx,-0x10(%ebp)
400303d7:	f7 65 e8             	mull   -0x18(%ebp)
400303da:	89 45 d8             	mov    %eax,-0x28(%ebp)
400303dd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
400303e0:	39 d1                	cmp    %edx,%ecx
400303e2:	72 06                	jb     400303ea <__divdf3+0x264>
400303e4:	75 47                	jne    4003042d <__divdf3+0x2a7>
400303e6:	39 c7                	cmp    %eax,%edi
400303e8:	73 43                	jae    4003042d <__divdf3+0x2a7>
400303ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
400303ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
400303f0:	8d 5e ff             	lea    -0x1(%esi),%ebx
400303f3:	01 f8                	add    %edi,%eax
400303f5:	11 ca                	adc    %ecx,%edx
400303f7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400303fa:	89 55 f0             	mov    %edx,-0x10(%ebp)
400303fd:	89 c7                	mov    %eax,%edi
400303ff:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40030402:	72 07                	jb     4003040b <__divdf3+0x285>
40030404:	75 29                	jne    4003042f <__divdf3+0x2a9>
40030406:	39 45 e8             	cmp    %eax,-0x18(%ebp)
40030409:	77 24                	ja     4003042f <__divdf3+0x2a9>
4003040b:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
4003040e:	77 0a                	ja     4003041a <__divdf3+0x294>
40030410:	75 1d                	jne    4003042f <__divdf3+0x2a9>
40030412:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030415:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
40030418:	76 15                	jbe    4003042f <__divdf3+0x2a9>
4003041a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
4003041d:	8b 7d e8             	mov    -0x18(%ebp),%edi
40030420:	8d 5e fe             	lea    -0x2(%esi),%ebx
40030423:	03 7d e4             	add    -0x1c(%ebp),%edi
40030426:	11 d1                	adc    %edx,%ecx
40030428:	89 4d f0             	mov    %ecx,-0x10(%ebp)
4003042b:	eb 02                	jmp    4003042f <__divdf3+0x2a9>
4003042d:	89 f3                	mov    %esi,%ebx
4003042f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40030432:	83 ce ff             	or     $0xffffffff,%esi
40030435:	2b 7d d8             	sub    -0x28(%ebp),%edi
40030438:	1b 4d d4             	sbb    -0x2c(%ebp),%ecx
4003043b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
4003043e:	0f 84 dc 00 00 00    	je     40030520 <__divdf3+0x39a>
40030444:	89 f8                	mov    %edi,%eax
40030446:	89 ca                	mov    %ecx,%edx
40030448:	f7 75 ec             	divl   -0x14(%ebp)
4003044b:	89 d1                	mov    %edx,%ecx
4003044d:	89 c7                	mov    %eax,%edi
4003044f:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030452:	f7 65 e8             	mull   -0x18(%ebp)
40030455:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40030458:	89 55 d0             	mov    %edx,-0x30(%ebp)
4003045b:	39 d1                	cmp    %edx,%ecx
4003045d:	72 06                	jb     40030465 <__divdf3+0x2df>
4003045f:	75 50                	jne    400304b1 <__divdf3+0x32b>
40030461:	85 c0                	test   %eax,%eax
40030463:	74 4c                	je     400304b1 <__divdf3+0x32b>
40030465:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030468:	8d 77 ff             	lea    -0x1(%edi),%esi
4003046b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
4003046e:	8b 55 e8             	mov    -0x18(%ebp),%edx
40030471:	83 c2 00             	add    $0x0,%edx
40030474:	13 4d e4             	adc    -0x1c(%ebp),%ecx
40030477:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
4003047a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
4003047d:	89 55 d8             	mov    %edx,-0x28(%ebp)
40030480:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
40030483:	72 07                	jb     4003048c <__divdf3+0x306>
40030485:	75 33                	jne    400304ba <__divdf3+0x334>
40030487:	39 55 e8             	cmp    %edx,-0x18(%ebp)
4003048a:	77 2e                	ja     400304ba <__divdf3+0x334>
4003048c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
4003048f:	39 4d d0             	cmp    %ecx,-0x30(%ebp)
40030492:	77 07                	ja     4003049b <__divdf3+0x315>
40030494:	75 24                	jne    400304ba <__divdf3+0x334>
40030496:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
40030499:	76 1f                	jbe    400304ba <__divdf3+0x334>
4003049b:	8d 77 fe             	lea    -0x2(%edi),%esi
4003049e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
400304a1:	8b 7d ec             	mov    -0x14(%ebp),%edi
400304a4:	01 d1                	add    %edx,%ecx
400304a6:	13 7d e4             	adc    -0x1c(%ebp),%edi
400304a9:	89 7d f0             	mov    %edi,-0x10(%ebp)
400304ac:	89 4d d8             	mov    %ecx,-0x28(%ebp)
400304af:	eb 09                	jmp    400304ba <__divdf3+0x334>
400304b1:	89 fe                	mov    %edi,%esi
400304b3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
400304ba:	8b 7d d0             	mov    -0x30(%ebp),%edi
400304bd:	39 7d f0             	cmp    %edi,-0x10(%ebp)
400304c0:	75 08                	jne    400304ca <__divdf3+0x344>
400304c2:	8b 7d d4             	mov    -0x2c(%ebp),%edi
400304c5:	39 7d d8             	cmp    %edi,-0x28(%ebp)
400304c8:	74 56                	je     40030520 <__divdf3+0x39a>
400304ca:	83 ce 01             	or     $0x1,%esi
400304cd:	eb 51                	jmp    40030520 <__divdf3+0x39a>
400304cf:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
400304d2:	0f 87 65 01 00 00    	ja     4003063d <__divdf3+0x4b7>
400304d8:	75 08                	jne    400304e2 <__divdf3+0x35c>
400304da:	39 ce                	cmp    %ecx,%esi
400304dc:	0f 87 66 01 00 00    	ja     40030648 <__divdf3+0x4c2>
400304e2:	89 ce                	mov    %ecx,%esi
400304e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
400304e7:	e9 59 01 00 00       	jmp    40030645 <__divdf3+0x4bf>
400304ec:	8b 45 d8             	mov    -0x28(%ebp),%eax
400304ef:	89 ce                	mov    %ecx,%esi
400304f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
400304f4:	89 7d ec             	mov    %edi,-0x14(%ebp)
400304f7:	eb 09                	jmp    40030502 <__divdf3+0x37c>
400304f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
400304fc:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400304ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
40030502:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
40030506:	0f 84 51 01 00 00    	je     4003065d <__divdf3+0x4d7>
4003050c:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
40030510:	0f 84 2c 01 00 00    	je     40030642 <__divdf3+0x4bc>
40030516:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
4003051a:	0f 84 37 01 00 00    	je     40030657 <__divdf3+0x4d1>
40030520:	8b 45 dc             	mov    -0x24(%ebp),%eax
40030523:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
40030529:	85 d2                	test   %edx,%edx
4003052b:	7e 4d                	jle    4003057a <__divdf3+0x3f4>
4003052d:	f7 c6 07 00 00 00    	test   $0x7,%esi
40030533:	74 10                	je     40030545 <__divdf3+0x3bf>
40030535:	89 f0                	mov    %esi,%eax
40030537:	83 e0 0f             	and    $0xf,%eax
4003053a:	83 f8 04             	cmp    $0x4,%eax
4003053d:	74 06                	je     40030545 <__divdf3+0x3bf>
4003053f:	83 c6 04             	add    $0x4,%esi
40030542:	83 d3 00             	adc    $0x0,%ebx
40030545:	0f ba e3 18          	bt     $0x18,%ebx
40030549:	73 0f                	jae    4003055a <__divdf3+0x3d4>
4003054b:	8b 55 dc             	mov    -0x24(%ebp),%edx
4003054e:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
40030554:	81 c2 00 04 00 00    	add    $0x400,%edx
4003055a:	81 fa fe 07 00 00    	cmp    $0x7fe,%edx
40030560:	0f 8f f7 00 00 00    	jg     4003065d <__divdf3+0x4d7>
40030566:	c1 ee 03             	shr    $0x3,%esi
40030569:	89 d8                	mov    %ebx,%eax
4003056b:	c1 e0 1d             	shl    $0x1d,%eax
4003056e:	09 c6                	or     %eax,%esi
40030570:	89 d8                	mov    %ebx,%eax
40030572:	c1 e8 03             	shr    $0x3,%eax
40030575:	e9 fd 00 00 00       	jmp    40030677 <__divdf3+0x4f1>
4003057a:	b9 01 00 00 00       	mov    $0x1,%ecx
4003057f:	89 c8                	mov    %ecx,%eax
40030581:	29 d0                	sub    %edx,%eax
40030583:	83 f8 38             	cmp    $0x38,%eax
40030586:	0f 8f 8c 00 00 00    	jg     40030618 <__divdf3+0x492>
4003058c:	83 f8 1f             	cmp    $0x1f,%eax
4003058f:	7f 30                	jg     400305c1 <__divdf3+0x43b>
40030591:	ba 20 00 00 00       	mov    $0x20,%edx
40030596:	89 df                	mov    %ebx,%edi
40030598:	29 c2                	sub    %eax,%edx
4003059a:	88 d1                	mov    %dl,%cl
4003059c:	d3 e7                	shl    %cl,%edi
4003059e:	89 7d f0             	mov    %edi,-0x10(%ebp)
400305a1:	88 c1                	mov    %al,%cl
400305a3:	89 f7                	mov    %esi,%edi
400305a5:	d3 ef                	shr    %cl,%edi
400305a7:	89 f9                	mov    %edi,%ecx
400305a9:	8b 7d f0             	mov    -0x10(%ebp),%edi
400305ac:	09 cf                	or     %ecx,%edi
400305ae:	88 d1                	mov    %dl,%cl
400305b0:	d3 e6                	shl    %cl,%esi
400305b2:	31 d2                	xor    %edx,%edx
400305b4:	88 c1                	mov    %al,%cl
400305b6:	85 f6                	test   %esi,%esi
400305b8:	0f 95 c2             	setne  %dl
400305bb:	09 d7                	or     %edx,%edi
400305bd:	d3 eb                	shr    %cl,%ebx
400305bf:	eb 28                	jmp    400305e9 <__divdf3+0x463>
400305c1:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
400305c6:	89 df                	mov    %ebx,%edi
400305c8:	29 d1                	sub    %edx,%ecx
400305ca:	31 d2                	xor    %edx,%edx
400305cc:	d3 ef                	shr    %cl,%edi
400305ce:	83 f8 20             	cmp    $0x20,%eax
400305d1:	74 0b                	je     400305de <__divdf3+0x458>
400305d3:	b9 40 00 00 00       	mov    $0x40,%ecx
400305d8:	29 c1                	sub    %eax,%ecx
400305da:	d3 e3                	shl    %cl,%ebx
400305dc:	89 da                	mov    %ebx,%edx
400305de:	31 c0                	xor    %eax,%eax
400305e0:	09 f2                	or     %esi,%edx
400305e2:	0f 95 c0             	setne  %al
400305e5:	09 c7                	or     %eax,%edi
400305e7:	31 db                	xor    %ebx,%ebx
400305e9:	f7 c7 07 00 00 00    	test   $0x7,%edi
400305ef:	74 10                	je     40030601 <__divdf3+0x47b>
400305f1:	89 f8                	mov    %edi,%eax
400305f3:	83 e0 0f             	and    $0xf,%eax
400305f6:	83 f8 04             	cmp    $0x4,%eax
400305f9:	74 06                	je     40030601 <__divdf3+0x47b>
400305fb:	83 c7 04             	add    $0x4,%edi
400305fe:	83 d3 00             	adc    $0x0,%ebx
40030601:	0f ba e3 17          	bt     $0x17,%ebx
40030605:	72 61                	jb     40030668 <__divdf3+0x4e2>
40030607:	89 de                	mov    %ebx,%esi
40030609:	89 d8                	mov    %ebx,%eax
4003060b:	c1 ef 03             	shr    $0x3,%edi
4003060e:	c1 e6 1d             	shl    $0x1d,%esi
40030611:	c1 e8 03             	shr    $0x3,%eax
40030614:	09 fe                	or     %edi,%esi
40030616:	eb 5d                	jmp    40030675 <__divdf3+0x4ef>
40030618:	09 de                	or     %ebx,%esi
4003061a:	74 57                	je     40030673 <__divdf3+0x4ed>
4003061c:	31 db                	xor    %ebx,%ebx
4003061e:	89 ce                	mov    %ecx,%esi
40030620:	83 c6 04             	add    $0x4,%esi
40030623:	83 d3 00             	adc    $0x0,%ebx
40030626:	c1 ee 03             	shr    $0x3,%esi
40030629:	89 d8                	mov    %ebx,%eax
4003062b:	eb 48                	jmp    40030675 <__divdf3+0x4ef>
4003062d:	bb 00 00 08 00       	mov    $0x80000,%ebx
40030632:	31 f6                	xor    %esi,%esi
40030634:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
4003063b:	eb 0b                	jmp    40030648 <__divdf3+0x4c2>
4003063d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40030640:	eb 06                	jmp    40030648 <__divdf3+0x4c2>
40030642:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030645:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030648:	89 d8                	mov    %ebx,%eax
4003064a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
4003064d:	0d 00 00 08 00       	or     $0x80000,%eax
40030652:	89 7d e0             	mov    %edi,-0x20(%ebp)
40030655:	eb 0a                	jmp    40030661 <__divdf3+0x4db>
40030657:	31 c0                	xor    %eax,%eax
40030659:	31 f6                	xor    %esi,%esi
4003065b:	eb 18                	jmp    40030675 <__divdf3+0x4ef>
4003065d:	31 c0                	xor    %eax,%eax
4003065f:	31 f6                	xor    %esi,%esi
40030661:	ba ff 07 00 00       	mov    $0x7ff,%edx
40030666:	eb 0f                	jmp    40030677 <__divdf3+0x4f1>
40030668:	31 c0                	xor    %eax,%eax
4003066a:	31 f6                	xor    %esi,%esi
4003066c:	ba 01 00 00 00       	mov    $0x1,%edx
40030671:	eb 04                	jmp    40030677 <__divdf3+0x4f1>
40030673:	31 c0                	xor    %eax,%eax
40030675:	31 d2                	xor    %edx,%edx
40030677:	31 db                	xor    %ebx,%ebx
40030679:	25 ff ff 0f 00       	and    $0xfffff,%eax
4003067e:	89 f1                	mov    %esi,%ecx
40030680:	89 c6                	mov    %eax,%esi
40030682:	89 d8                	mov    %ebx,%eax
40030684:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
4003068a:	c1 e2 14             	shl    $0x14,%edx
4003068d:	25 00 00 f0 ff       	and    $0xfff00000,%eax
40030692:	09 f0                	or     %esi,%eax
40030694:	25 ff ff 0f 80       	and    $0x800fffff,%eax
40030699:	09 d0                	or     %edx,%eax
4003069b:	8b 55 e0             	mov    -0x20(%ebp),%edx
4003069e:	c1 e2 1f             	shl    $0x1f,%edx
400306a1:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
400306a6:	83 c4 24             	add    $0x24,%esp
400306a9:	09 d0                	or     %edx,%eax
400306ab:	89 c3                	mov    %eax,%ebx
400306ad:	89 c8                	mov    %ecx,%eax
400306af:	89 da                	mov    %ebx,%edx
400306b1:	5b                   	pop    %ebx
400306b2:	5e                   	pop    %esi
400306b3:	5f                   	pop    %edi
400306b4:	5d                   	pop    %ebp
400306b5:	c3                   	ret    

400306b6 <__ledf2>:
400306b6:	55                   	push   %ebp
400306b7:	89 e5                	mov    %esp,%ebp
400306b9:	57                   	push   %edi
400306ba:	56                   	push   %esi
400306bb:	53                   	push   %ebx
400306bc:	83 ec 14             	sub    $0x14,%esp
400306bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
400306c2:	89 d0                	mov    %edx,%eax
400306c4:	89 d7                	mov    %edx,%edi
400306c6:	c1 e8 14             	shr    $0x14,%eax
400306c9:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
400306cf:	c1 ea 1f             	shr    $0x1f,%edx
400306d2:	25 ff 07 00 00       	and    $0x7ff,%eax
400306d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
400306da:	89 55 e0             	mov    %edx,-0x20(%ebp)
400306dd:	8b 45 08             	mov    0x8(%ebp),%eax
400306e0:	8b 55 0c             	mov    0xc(%ebp),%edx
400306e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400306e6:	89 d0                	mov    %edx,%eax
400306e8:	c1 e8 14             	shr    $0x14,%eax
400306eb:	89 d6                	mov    %edx,%esi
400306ed:	25 ff 07 00 00       	and    $0x7ff,%eax
400306f2:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
400306f8:	c1 ea 1f             	shr    $0x1f,%edx
400306fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
400306fe:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
40030705:	75 10                	jne    40030717 <__ledf2+0x61>
40030707:	8b 4d f0             	mov    -0x10(%ebp),%ecx
4003070a:	b8 02 00 00 00       	mov    $0x2,%eax
4003070f:	09 f9                	or     %edi,%ecx
40030711:	0f 85 a8 00 00 00    	jne    400307bf <__ledf2+0x109>
40030717:	81 7d e4 ff 07 00 00 	cmpl   $0x7ff,-0x1c(%ebp)
4003071e:	75 10                	jne    40030730 <__ledf2+0x7a>
40030720:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030723:	b8 02 00 00 00       	mov    $0x2,%eax
40030728:	09 f3                	or     %esi,%ebx
4003072a:	0f 85 8f 00 00 00    	jne    400307bf <__ledf2+0x109>
40030730:	31 db                	xor    %ebx,%ebx
40030732:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030736:	75 08                	jne    40030740 <__ledf2+0x8a>
40030738:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003073b:	09 f8                	or     %edi,%eax
4003073d:	0f 94 c3             	sete   %bl
40030740:	31 c9                	xor    %ecx,%ecx
40030742:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
40030746:	75 08                	jne    40030750 <__ledf2+0x9a>
40030748:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003074b:	09 f0                	or     %esi,%eax
4003074d:	0f 94 c1             	sete   %cl
40030750:	84 db                	test   %bl,%bl
40030752:	74 06                	je     4003075a <__ledf2+0xa4>
40030754:	31 c0                	xor    %eax,%eax
40030756:	84 c9                	test   %cl,%cl
40030758:	75 65                	jne    400307bf <__ledf2+0x109>
4003075a:	0f b6 d2             	movzbl %dl,%edx
4003075d:	84 db                	test   %bl,%bl
4003075f:	74 0b                	je     4003076c <__ledf2+0xb6>
40030761:	83 c8 ff             	or     $0xffffffff,%eax
40030764:	85 d2                	test   %edx,%edx
40030766:	74 57                	je     400307bf <__ledf2+0x109>
40030768:	89 d0                	mov    %edx,%eax
4003076a:	eb 53                	jmp    400307bf <__ledf2+0x109>
4003076c:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
40030770:	84 c9                	test   %cl,%cl
40030772:	75 29                	jne    4003079d <__ledf2+0xe7>
40030774:	39 d0                	cmp    %edx,%eax
40030776:	75 1d                	jne    40030795 <__ledf2+0xdf>
40030778:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
4003077b:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
4003077e:	7f 15                	jg     40030795 <__ledf2+0xdf>
40030780:	7c 32                	jl     400307b4 <__ledf2+0xfe>
40030782:	39 f7                	cmp    %esi,%edi
40030784:	77 0f                	ja     40030795 <__ledf2+0xdf>
40030786:	8b 5d ec             	mov    -0x14(%ebp),%ebx
40030789:	0f 94 c2             	sete   %dl
4003078c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
4003078f:	76 13                	jbe    400307a4 <__ledf2+0xee>
40030791:	84 d2                	test   %dl,%dl
40030793:	74 0f                	je     400307a4 <__ledf2+0xee>
40030795:	85 c0                	test   %eax,%eax
40030797:	0f 95 c0             	setne  %al
4003079a:	0f b6 c0             	movzbl %al,%eax
4003079d:	f7 d8                	neg    %eax
4003079f:	83 c8 01             	or     $0x1,%eax
400307a2:	eb 1b                	jmp    400307bf <__ledf2+0x109>
400307a4:	39 f7                	cmp    %esi,%edi
400307a6:	72 0c                	jb     400307b4 <__ledf2+0xfe>
400307a8:	8b 7d ec             	mov    -0x14(%ebp),%edi
400307ab:	39 7d f0             	cmp    %edi,-0x10(%ebp)
400307ae:	73 0d                	jae    400307bd <__ledf2+0x107>
400307b0:	84 d2                	test   %dl,%dl
400307b2:	74 09                	je     400307bd <__ledf2+0x107>
400307b4:	85 c0                	test   %eax,%eax
400307b6:	75 07                	jne    400307bf <__ledf2+0x109>
400307b8:	83 c8 ff             	or     $0xffffffff,%eax
400307bb:	eb 02                	jmp    400307bf <__ledf2+0x109>
400307bd:	31 c0                	xor    %eax,%eax
400307bf:	83 c4 14             	add    $0x14,%esp
400307c2:	5b                   	pop    %ebx
400307c3:	5e                   	pop    %esi
400307c4:	5f                   	pop    %edi
400307c5:	5d                   	pop    %ebp
400307c6:	c3                   	ret    

400307c7 <__fixdfsi>:
400307c7:	55                   	push   %ebp
400307c8:	89 e5                	mov    %esp,%ebp
400307ca:	56                   	push   %esi
400307cb:	53                   	push   %ebx
400307cc:	89 d3                	mov    %edx,%ebx
400307ce:	c1 eb 14             	shr    $0x14,%ebx
400307d1:	89 c6                	mov    %eax,%esi
400307d3:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
400307d9:	89 d0                	mov    %edx,%eax
400307db:	c1 ea 1f             	shr    $0x1f,%edx
400307de:	25 ff ff 0f 00       	and    $0xfffff,%eax
400307e3:	81 fb fe 03 00 00    	cmp    $0x3fe,%ebx
400307e9:	7e 40                	jle    4003082b <__fixdfsi+0x64>
400307eb:	81 fb 1d 04 00 00    	cmp    $0x41d,%ebx
400307f1:	7e 08                	jle    400307fb <__fixdfsi+0x34>
400307f3:	8d 82 ff ff ff 7f    	lea    0x7fffffff(%edx),%eax
400307f9:	eb 32                	jmp    4003082d <__fixdfsi+0x66>
400307fb:	b9 33 04 00 00       	mov    $0x433,%ecx
40030800:	0d 00 00 10 00       	or     $0x100000,%eax
40030805:	29 d9                	sub    %ebx,%ecx
40030807:	83 f9 1f             	cmp    $0x1f,%ecx
4003080a:	7f 0e                	jg     4003081a <__fixdfsi+0x53>
4003080c:	d3 ee                	shr    %cl,%esi
4003080e:	8d 8b ed fb ff ff    	lea    -0x413(%ebx),%ecx
40030814:	d3 e0                	shl    %cl,%eax
40030816:	09 f0                	or     %esi,%eax
40030818:	eb 09                	jmp    40030823 <__fixdfsi+0x5c>
4003081a:	b9 13 04 00 00       	mov    $0x413,%ecx
4003081f:	29 d9                	sub    %ebx,%ecx
40030821:	d3 e8                	shr    %cl,%eax
40030823:	84 d2                	test   %dl,%dl
40030825:	74 06                	je     4003082d <__fixdfsi+0x66>
40030827:	f7 d8                	neg    %eax
40030829:	eb 02                	jmp    4003082d <__fixdfsi+0x66>
4003082b:	31 c0                	xor    %eax,%eax
4003082d:	5b                   	pop    %ebx
4003082e:	5e                   	pop    %esi
4003082f:	5d                   	pop    %ebp
40030830:	c3                   	ret    

40030831 <__floatsidf>:
40030831:	55                   	push   %ebp
40030832:	85 c0                	test   %eax,%eax
40030834:	89 e5                	mov    %esp,%ebp
40030836:	57                   	push   %edi
40030837:	56                   	push   %esi
40030838:	53                   	push   %ebx
40030839:	74 43                	je     4003087e <__floatsidf+0x4d>
4003083b:	99                   	cltd   
4003083c:	89 c7                	mov    %eax,%edi
4003083e:	31 d0                	xor    %edx,%eax
40030840:	29 d0                	sub    %edx,%eax
40030842:	ba 1e 04 00 00       	mov    $0x41e,%edx
40030847:	0f bd f0             	bsr    %eax,%esi
4003084a:	bb 33 04 00 00       	mov    $0x433,%ebx
4003084f:	c1 ef 1f             	shr    $0x1f,%edi
40030852:	83 f6 1f             	xor    $0x1f,%esi
40030855:	29 f2                	sub    %esi,%edx
40030857:	29 d3                	sub    %edx,%ebx
40030859:	83 fb 1f             	cmp    $0x1f,%ebx
4003085c:	7f 11                	jg     4003086f <__floatsidf+0x3e>
4003085e:	b9 0b 00 00 00       	mov    $0xb,%ecx
40030863:	29 f1                	sub    %esi,%ecx
40030865:	89 c6                	mov    %eax,%esi
40030867:	d3 ee                	shr    %cl,%esi
40030869:	88 d9                	mov    %bl,%cl
4003086b:	d3 e0                	shl    %cl,%eax
4003086d:	eb 17                	jmp    40030886 <__floatsidf+0x55>
4003086f:	b9 13 04 00 00       	mov    $0x413,%ecx
40030874:	29 d1                	sub    %edx,%ecx
40030876:	d3 e0                	shl    %cl,%eax
40030878:	89 c6                	mov    %eax,%esi
4003087a:	31 c0                	xor    %eax,%eax
4003087c:	eb 08                	jmp    40030886 <__floatsidf+0x55>
4003087e:	31 f6                	xor    %esi,%esi
40030880:	31 c0                	xor    %eax,%eax
40030882:	31 d2                	xor    %edx,%edx
40030884:	31 ff                	xor    %edi,%edi
40030886:	31 db                	xor    %ebx,%ebx
40030888:	89 c1                	mov    %eax,%ecx
4003088a:	89 f0                	mov    %esi,%eax
4003088c:	89 de                	mov    %ebx,%esi
4003088e:	25 ff ff 0f 00       	and    $0xfffff,%eax
40030893:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
40030899:	09 c6                	or     %eax,%esi
4003089b:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
400308a1:	81 e6 ff ff 0f 80    	and    $0x800fffff,%esi
400308a7:	5b                   	pop    %ebx
400308a8:	c1 e2 14             	shl    $0x14,%edx
400308ab:	89 c8                	mov    %ecx,%eax
400308ad:	c1 e7 1f             	shl    $0x1f,%edi
400308b0:	09 f2                	or     %esi,%edx
400308b2:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
400308b8:	5e                   	pop    %esi
400308b9:	09 fa                	or     %edi,%edx
400308bb:	5f                   	pop    %edi
400308bc:	5d                   	pop    %ebp
400308bd:	c3                   	ret    

400308be <main>:

int counter = 0;

uint8_t buffer[10] = {0};

void main() {
400308be:	55                   	push   %ebp
400308bf:	89 e5                	mov    %esp,%ebp
    printf("LoRa Receiver\n");
400308c1:	68 d4 58 03 40       	push   $0x400358d4
400308c6:	e8 31 41 00 00       	call   400349fc <iprintf>
400308cb:	58                   	pop    %eax

    // start initialization
    LoRaClass();
400308cc:	e8 c8 27 00 00       	call   40033099 <LoRaClass>
    // call pinset
    // ss, reset, dio0
    // 101
    //setPins(10, 3, 2);
    // c1000
    setPins(60, 82, 72);
400308d1:	b9 48 00 00 00       	mov    $0x48,%ecx
400308d6:	ba 52 00 00 00       	mov    $0x52,%edx
400308db:	b8 3c 00 00 00       	mov    $0x3c,%eax
400308e0:	e8 41 28 00 00       	call   40033126 <setPins>

    // complete initialization by finishing pin setup and
    // setting frequency
    init(915e6);
400308e5:	b8 c0 ca 89 36       	mov    $0x3689cac0,%eax
400308ea:	e8 db 2d 00 00       	call   400336ca <init>
    //begin(914984144);

    dumpRegisters();
400308ef:	e8 51 29 00 00       	call   40033245 <dumpRegisters>

    int packet_size = 0;

#if 1
    printf("Receiver\n");
400308f4:	68 d9 58 03 40       	push   $0x400358d9
400308f9:	e8 fe 40 00 00       	call   400349fc <iprintf>
400308fe:	58                   	pop    %eax
    while(1) {

        // receive packet actually
        packet_size = parsePacket(0);
400308ff:	31 c0                	xor    %eax,%eax
40030901:	e8 8a 2b 00 00       	call   40033490 <parsePacket>
        if(packet_size) {
40030906:	85 c0                	test   %eax,%eax
40030908:	74 f5                	je     400308ff <main+0x41>
            printf("Received a packet yayy!! packet size: %d\n", packet_size);
4003090a:	50                   	push   %eax
4003090b:	68 e3 58 03 40       	push   $0x400358e3

            while(available()) {
                printf("value: %x\n", SX1276read());
40030910:	e8 e7 40 00 00       	call   400349fc <iprintf>
40030915:	59                   	pop    %ecx
40030916:	58                   	pop    %eax
            while(available()) {
40030917:	e8 ee 28 00 00       	call   4003320a <available>
4003091c:	85 c0                	test   %eax,%eax
4003091e:	74 0d                	je     4003092d <main+0x6f>
                printf("value: %x\n", SX1276read());
40030920:	e8 fd 28 00 00       	call   40033222 <SX1276read>
40030925:	50                   	push   %eax
40030926:	68 0d 59 03 40       	push   $0x4003590d
4003092b:	eb e3                	jmp    40030910 <main+0x52>
            }
            printf("With RSSI: %d\n", packetRssi(MODEM_LORA));
4003092d:	b8 01 00 00 00       	mov    $0x1,%eax
40030932:	e8 74 28 00 00       	call   400331ab <packetRssi>
40030937:	50                   	push   %eax
40030938:	68 18 59 03 40       	push   $0x40035918
4003093d:	e8 ba 40 00 00       	call   400349fc <iprintf>
40030942:	58                   	pop    %eax
40030943:	5a                   	pop    %edx
40030944:	eb b9                	jmp    400308ff <main+0x41>

40030946 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
40030946:	55                   	push   %ebp
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
40030947:	83 f8 0a             	cmp    $0xa,%eax
{
4003094a:	89 e5                	mov    %esp,%ebp
4003094c:	53                   	push   %ebx
4003094d:	89 c3                	mov    %eax,%ebx
	if ('\n' == c) {
4003094f:	75 10                	jne    40030961 <console_out+0x1b>
		uart_poll_out(uart_console_dev, '\r');
40030951:	a1 e8 67 00 a8       	mov    0xa80067e8,%eax
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;

	return api->poll_out(dev, out_char);
40030956:	ba 0d 00 00 00       	mov    $0xd,%edx
4003095b:	8b 48 04             	mov    0x4(%eax),%ecx
4003095e:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
40030961:	a1 e8 67 00 a8       	mov    0xa80067e8,%eax
40030966:	0f b6 d3             	movzbl %bl,%edx
40030969:	8b 48 04             	mov    0x4(%eax),%ecx
4003096c:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
4003096f:	89 d8                	mov    %ebx,%eax
40030971:	5b                   	pop    %ebx
40030972:	5d                   	pop    %ebp
40030973:	c3                   	ret    

40030974 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
40030974:	55                   	push   %ebp
	__stdout_hook_install(console_out);
40030975:	b8 46 09 03 40       	mov    $0x40030946,%eax
{
4003097a:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
4003097c:	e8 ad 0a 00 00       	call   4003142e <__stdout_hook_install>
	__printk_hook_install(console_out);
40030981:	b8 46 09 03 40       	mov    $0x40030946,%eax
}
40030986:	5d                   	pop    %ebp
	__printk_hook_install(console_out);
40030987:	e9 23 0c 00 00       	jmp    400315af <__printk_hook_install>

4003098c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
4003098c:	55                   	push   %ebp

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
4003098d:	b8 27 59 03 40       	mov    $0x40035927,%eax
{
40030992:	89 e5                	mov    %esp,%ebp
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40030994:	e8 b3 33 00 00       	call   40033d4c <device_get_binding>
40030999:	a3 e8 67 00 a8       	mov    %eax,0xa80067e8
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
4003099e:	e8 d1 ff ff ff       	call   40030974 <uart_console_hook_install>

	return 0;
}
400309a3:	31 c0                	xor    %eax,%eax
400309a5:	5d                   	pop    %ebp
400309a6:	c3                   	ret    

400309a7 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
400309a7:	55                   	push   %ebp
400309a8:	89 e5                	mov    %esp,%ebp
400309aa:	56                   	push   %esi
400309ab:	53                   	push   %ebx
400309ac:	89 c6                	mov    %eax,%esi
400309ae:	83 ec 0c             	sub    $0xc,%esp
	const struct uart_qmsi_config_info *config = dev->config->config_info;
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
400309b1:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
	const struct uart_qmsi_config_info *config = dev->config->config_info;
400309b8:	8b 00                	mov    (%eax),%eax
400309ba:	8b 58 08             	mov    0x8(%eax),%ebx
	cfg.baud_divisor = config->baud_divisor;
400309bd:	8b 43 08             	mov    0x8(%ebx),%eax
400309c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cfg.hw_fc = config->hw_fc;
400309c3:	8a 43 0c             	mov    0xc(%ebx),%al
400309c6:	88 45 f4             	mov    %al,-0xc(%ebp)

	clk_periph_enable(config->clock_gate);
400309c9:	8b 43 04             	mov    0x4(%ebx),%eax
400309cc:	e8 9e 0e 00 00       	call   4003186f <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
400309d1:	8d 55 ec             	lea    -0x14(%ebp),%edx
400309d4:	8b 03                	mov    (%ebx),%eax
400309d6:	e8 db 0f 00 00       	call   400319b6 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
400309db:	c7 46 04 60 59 03 40 	movl   $0x40035960,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
400309e2:	83 c4 0c             	add    $0xc,%esp
400309e5:	31 c0                	xor    %eax,%eax
400309e7:	5b                   	pop    %ebx
400309e8:	5e                   	pop    %esi
400309e9:	5d                   	pop    %ebp
400309ea:	c3                   	ret    

400309eb <uart_qmsi_err_check>:
{
400309eb:	55                   	push   %ebp
400309ec:	89 e5                	mov    %esp,%ebp
400309ee:	52                   	push   %edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
400309ef:	8b 00                	mov    (%eax),%eax
	qm_uart_get_status(instance, &status);
400309f1:	8d 55 fc             	lea    -0x4(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
400309f4:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_get_status(instance, &status);
400309f7:	8b 00                	mov    (%eax),%eax
400309f9:	e8 25 10 00 00       	call   40031a23 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
400309fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
40030a01:	83 e0 1e             	and    $0x1e,%eax
}
40030a04:	c9                   	leave  
40030a05:	c3                   	ret    

40030a06 <uart_qmsi_poll_out>:
{
40030a06:	55                   	push   %ebp
40030a07:	89 e5                	mov    %esp,%ebp
40030a09:	53                   	push   %ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030a0a:	8b 00                	mov    (%eax),%eax
{
40030a0c:	89 d3                	mov    %edx,%ebx
	qm_uart_write(instance, data);
40030a0e:	0f b6 d2             	movzbl %dl,%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030a11:	8b 40 08             	mov    0x8(%eax),%eax
	qm_uart_write(instance, data);
40030a14:	8b 00                	mov    (%eax),%eax
40030a16:	e8 49 10 00 00       	call   40031a64 <qm_uart_write>
}
40030a1b:	88 d8                	mov    %bl,%al
40030a1d:	5b                   	pop    %ebx
40030a1e:	5d                   	pop    %ebp
40030a1f:	c3                   	ret    

40030a20 <uart_qmsi_poll_in>:
{
40030a20:	55                   	push   %ebp
40030a21:	89 e5                	mov    %esp,%ebp
40030a23:	56                   	push   %esi
40030a24:	53                   	push   %ebx
40030a25:	51                   	push   %ecx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030a26:	8b 00                	mov    (%eax),%eax
{
40030a28:	89 d6                	mov    %edx,%esi
	qm_uart_get_status(instance, &status);
40030a2a:	8d 55 f4             	lea    -0xc(%ebp),%edx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
40030a2d:	8b 40 08             	mov    0x8(%eax),%eax
40030a30:	8b 18                	mov    (%eax),%ebx
	qm_uart_get_status(instance, &status);
40030a32:	89 d8                	mov    %ebx,%eax
40030a34:	e8 ea 0f 00 00       	call   40031a23 <qm_uart_get_status>
		return -1;
40030a39:	83 c8 ff             	or     $0xffffffff,%eax
	if (!(status & QM_UART_RX_BUSY))
40030a3c:	f6 45 f4 40          	testb  $0x40,-0xc(%ebp)
40030a40:	74 0d                	je     40030a4f <uart_qmsi_poll_in+0x2f>
	qm_uart_read(instance, data, NULL);
40030a42:	31 c9                	xor    %ecx,%ecx
40030a44:	89 f2                	mov    %esi,%edx
40030a46:	89 d8                	mov    %ebx,%eax
40030a48:	e8 3a 10 00 00       	call   40031a87 <qm_uart_read>
	return 0;
40030a4d:	31 c0                	xor    %eax,%eax
}
40030a4f:	5a                   	pop    %edx
40030a50:	5b                   	pop    %ebx
40030a51:	5e                   	pop    %esi
40030a52:	5d                   	pop    %ebp
40030a53:	c3                   	ret    

40030a54 <_timer_int_handler>:

	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick * _sys_idle_elapsed_ticks;
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
40030a54:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
{
40030a59:	55                   	push   %ebp
	accumulated_cycle_count += cycles_per_tick;
40030a5a:	01 05 fc 67 00 a8    	add    %eax,0xa80067fc

	_sys_clock_tick_announce();
40030a60:	a1 e8 66 00 a8       	mov    0xa80066e8,%eax
{
40030a65:	89 e5                	mov    %esp,%ebp
#endif /*CONFIG_TICKLESS_IDLE*/

}
40030a67:	5d                   	pop    %ebp
	_sys_clock_tick_announce();
40030a68:	e9 84 38 00 00       	jmp    400342f1 <_nano_sys_clock_tick_announce>

40030a6d <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40030a6d:	a1 ec 66 00 a8       	mov    0xa80066ec,%eax
{
40030a72:	55                   	push   %ebp
	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40030a73:	a3 b8 78 00 a8       	mov    %eax,0xa80078b8
{
40030a78:	89 e5                	mov    %esp,%ebp
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
40030a7a:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
40030a7f:	83 e0 f0             	and    $0xfffffff0,%eax
40030a82:	83 c8 0b             	or     $0xb,%eax
40030a85:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
40030a8a:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
40030a8f:	48                   	dec    %eax
	*_REG_TIMER_ICR = count;
40030a90:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
40030a95:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
40030a9a:	0d 00 00 02 00       	or     $0x20000,%eax
40030a9f:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
40030aa4:	0f b6 05 68 6f 03 40 	movzbl 0x40036f68,%eax
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
40030aab:	31 c9                	xor    %ecx,%ecx
40030aad:	ba 40 00 00 00       	mov    $0x40,%edx
40030ab2:	e8 7b 01 00 00       	call   40030c32 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
40030ab7:	b8 40 00 00 00       	mov    $0x40,%eax
40030abc:	e8 93 01 00 00       	call   40030c54 <_arch_irq_enable>

	return 0;
}
40030ac1:	31 c0                	xor    %eax,%eax
40030ac3:	5d                   	pop    %ebp
40030ac4:	c3                   	ret    

40030ac5 <_timer_int_handler_irq64_stub>:
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
40030ac5:	6a 00                	push   $0x0
40030ac7:	68 54 0a 03 40       	push   $0x40030a54
40030acc:	e9 3e 2f 00 00       	jmp    40033a0f <_interrupt_enter>

40030ad1 <qm_spi_master_1_isr_irq3_stub>:
40030ad1:	6a 00                	push   $0x0
40030ad3:	68 5a 1f 03 40       	push   $0x40031f5a
40030ad8:	e9 32 2f 00 00       	jmp    40033a0f <_interrupt_enter>

40030add <qm_spi_master_0_isr_irq2_stub>:
40030add:	6a 00                	push   $0x0
40030adf:	68 4f 1f 03 40       	push   $0x40031f4f
40030ae4:	e9 26 2f 00 00       	jmp    40033a0f <_interrupt_enter>

40030ae9 <qm_aon_gpio_0_isr_irq31_stub>:
40030ae9:	6a 00                	push   $0x0
40030aeb:	68 c6 18 03 40       	push   $0x400318c6
40030af0:	e9 1a 2f 00 00       	jmp    40033a0f <_interrupt_enter>

40030af5 <qm_gpio_0_isr_irq8_stub>:
40030af5:	6a 00                	push   $0x0
40030af7:	68 bb 18 03 40       	push   $0x400318bb
40030afc:	e9 0e 2f 00 00       	jmp    40033a0f <_interrupt_enter>

40030b01 <_timer_cycle_get_32>:
	 * in the Initial Count Register (ICR).
	 */

#if !defined(CONFIG_TICKLESS_IDLE)
	/* The value in the ICR always matches cycles_per_tick. */
	val = accumulated_cycle_count - current_count_register_get() +
40030b01:	a1 b8 78 00 a8       	mov    0xa80078b8,%eax
{
40030b06:	55                   	push   %ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030b07:	03 05 fc 67 00 a8    	add    0xa80067fc,%eax
	return *_REG_TIMER_CCR;
40030b0d:	8b 15 90 03 e0 fe    	mov    0xfee00390,%edx
{
40030b13:	89 e5                	mov    %esp,%ebp
	val = accumulated_cycle_count - current_count_register_get() +
40030b15:	29 d0                	sub    %edx,%eax
	val = accumulated_cycle_count - current_count_register_get() +
	      initial_count_register_get();
#endif

	return val;
}
40030b17:	5d                   	pop    %ebp
40030b18:	c3                   	ret    

40030b19 <_loapic_init>:
 * @return N/A
 *
 */

static int _loapic_init(struct device *unused)
{
40030b19:	55                   	push   %ebp
40030b1a:	89 e5                	mov    %esp,%ebp
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
40030b1c:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */
	sys_write32(sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR)
40030b21:	80 cc 01             	or     $0x1,%ah
	__asm__ volatile("movl	%0, %1;\n\t"
40030b24:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
		    | LOAPIC_ENABLE, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR);

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40030b29:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
40030b2e:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
40030b35:	ff ff ff 
			LOAPIC_MAXLVT_MASK) >> 16;
40030b38:	c1 f8 10             	sar    $0x10,%eax
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
40030b3b:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
40030b42:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
40030b45:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
40030b4c:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
40030b4f:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
40030b56:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
40030b59:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx
40030b5f:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030b65:	80 ce 07             	or     $0x7,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
40030b68:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
40030b6e:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
40030b74:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030b7a:	80 ce 04             	or     $0x4,%dh
	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
40030b7d:	0f b6 c0             	movzbl %al,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
40030b80:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030b86:	83 f8 03             	cmp    $0x3,%eax
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
40030b89:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
40030b90:	00 01 00 
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
40030b93:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
40030b9a:	00 01 00 
	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030b9d:	7e 19                	jle    40030bb8 <_loapic_init+0x9f>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
40030b9f:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
40030ba6:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
40030ba9:	83 f8 04             	cmp    $0x4,%eax
40030bac:	74 0a                	je     40030bb8 <_loapic_init+0x9f>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
40030bae:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
40030bb5:	00 01 00 
		| (LOAPIC_SPURIOUS_VECTOR_ID & 0xFF);
#endif

	/* discard a pending interrupt if any */
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
40030bb8:	e8 98 2d 00 00       	call   40033955 <_lakemont_eoi>
#else
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
#endif

	return 0;
}
40030bbd:	31 c0                	xor    %eax,%eax
40030bbf:	5d                   	pop    %ebp
40030bc0:	c3                   	ret    

40030bc1 <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
40030bc1:	55                   	push   %ebp
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030bc2:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030bc7:	c1 e0 04             	shl    $0x4,%eax
{
40030bca:	89 e5                	mov    %esp,%ebp
40030bcc:	53                   	push   %ebx
	__asm__ volatile (
40030bcd:	9c                   	pushf  
40030bce:	fa                   	cli    
40030bcf:	5b                   	pop    %ebx

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
40030bd0:	8b 08                	mov    (%eax),%ecx
40030bd2:	30 c9                	xor    %cl,%cl
40030bd4:	09 ca                	or     %ecx,%edx
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
40030bd6:	0f ba e3 09          	bt     $0x9,%ebx
40030bda:	89 10                	mov    %edx,(%eax)
40030bdc:	73 01                	jae    40030bdf <_loapic_int_vec_set+0x1e>
	__asm__ volatile (
40030bde:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030bdf:	5b                   	pop    %ebx
40030be0:	5d                   	pop    %ebp
40030be1:	c3                   	ret    

40030be2 <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
40030be2:	55                   	push   %ebp
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));
40030be3:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030be8:	c1 e0 04             	shl    $0x4,%eax
{
40030beb:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030bed:	9c                   	pushf  
40030bee:	fa                   	cli    
40030bef:	59                   	pop    %ecx

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
40030bf0:	8b 10                	mov    (%eax),%edx
40030bf2:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
40030bf8:	0f ba e1 09          	bt     $0x9,%ecx
40030bfc:	89 10                	mov    %edx,(%eax)
40030bfe:	73 01                	jae    40030c01 <_loapic_irq_enable+0x1f>
	__asm__ volatile (
40030c00:	fb                   	sti    
	irq_unlock(oldLevel);
}
40030c01:	5d                   	pop    %ebp
40030c02:	c3                   	ret    

40030c03 <__irq_controller_isr_vector_get>:
 *
 * @return The vector of the interrupt that is currently being processed, or -1
 * if no IRQ is being serviced.
 */
int __irq_controller_isr_vector_get(void)
{
40030c03:	55                   	push   %ebp
40030c04:	b9 70 01 e0 fe       	mov    $0xfee00170,%ecx
40030c09:	89 e5                	mov    %esp,%ebp
	int pReg, block;

	/* Block 0 bits never lit up as these are all exception or reserved
	 * vectors
	 */
	for (block = 7; likely(block > 0); block--) {
40030c0b:	b8 07 00 00 00       	mov    $0x7,%eax
	__asm__ volatile("movl	%1, %0;\n\t"
40030c10:	8b 11                	mov    (%ecx),%edx
		pReg = sys_read32(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR +
				  (block * 0x10));
		if (pReg) {
40030c12:	85 d2                	test   %edx,%edx
40030c14:	74 11                	je     40030c27 <__irq_controller_isr_vector_get+0x24>
	__asm__ volatile (
40030c16:	0f bd d2             	bsr    %edx,%edx
40030c19:	75 05                	jne    40030c20 <__irq_controller_isr_vector_get+0x1d>
40030c1b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
			return (block * 32) + (find_msb_set(pReg) - 1);
40030c20:	c1 e0 05             	shl    $0x5,%eax
40030c23:	01 d0                	add    %edx,%eax
40030c25:	eb 09                	jmp    40030c30 <__irq_controller_isr_vector_get+0x2d>
40030c27:	83 e9 10             	sub    $0x10,%ecx
	for (block = 7; likely(block > 0); block--) {
40030c2a:	48                   	dec    %eax
40030c2b:	75 e3                	jne    40030c10 <__irq_controller_isr_vector_get+0xd>
		}

	}
	return -1;
40030c2d:	83 c8 ff             	or     $0xffffffff,%eax
}
40030c30:	5d                   	pop    %ebp
40030c31:	c3                   	ret    

40030c32 <__irq_controller_irq_config>:
 * @param flags interrupt flags
 *
 */
void __irq_controller_irq_config(unsigned int vector, unsigned int irq,
				 uint32_t flags)
{
40030c32:	55                   	push   %ebp
	__ASSERT(irq >= 0 && irq <= HARDWARE_IRQ_LIMIT, "invalid irq line");

	if (IS_IOAPIC_IRQ(irq)) {
40030c33:	83 fa 3f             	cmp    $0x3f,%edx
{
40030c36:	89 e5                	mov    %esp,%ebp
40030c38:	53                   	push   %ebx
40030c39:	89 c3                	mov    %eax,%ebx
40030c3b:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
40030c3d:	77 09                	ja     40030c48 <__irq_controller_irq_config+0x16>
		_ioapic_irq_set(irq, vector, flags);
40030c3f:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
40030c41:	5b                   	pop    %ebx
40030c42:	5d                   	pop    %ebp
		_ioapic_irq_set(irq, vector, flags);
40030c43:	e9 a9 00 00 00       	jmp    40030cf1 <_ioapic_irq_set>
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030c48:	89 da                	mov    %ebx,%edx
40030c4a:	83 e8 40             	sub    $0x40,%eax
}
40030c4d:	5b                   	pop    %ebx
40030c4e:	5d                   	pop    %ebp
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030c4f:	e9 6d ff ff ff       	jmp    40030bc1 <_loapic_int_vec_set>

40030c54 <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
40030c54:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030c55:	83 f8 3f             	cmp    $0x3f,%eax
{
40030c58:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030c5a:	77 06                	ja     40030c62 <_arch_irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
40030c5c:	5d                   	pop    %ebp
		_ioapic_irq_enable(irq);
40030c5d:	e9 7f 00 00 00       	jmp    40030ce1 <_ioapic_irq_enable>
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
40030c62:	83 e8 40             	sub    $0x40,%eax
}
40030c65:	5d                   	pop    %ebp
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
40030c66:	e9 77 ff ff ff       	jmp    40030be2 <_loapic_irq_enable>

40030c6b <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
40030c6b:	55                   	push   %ebp
40030c6c:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40030c6e:	9c                   	pushf  
40030c6f:	fa                   	cli    
40030c70:	59                   	pop    %ecx
40030c71:	0f ba e1 09          	bt     $0x9,%ecx

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
40030c75:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
40030c7a:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
40030c80:	73 01                	jae    40030c83 <__IoApicSet+0x18>
	__asm__ volatile (
40030c82:	fb                   	sti    

	irq_unlock(key);
}
40030c83:	5d                   	pop    %ebp
40030c84:	c3                   	ret    

40030c85 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
40030c85:	55                   	push   %ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030c86:	01 c0                	add    %eax,%eax
{
40030c88:	89 e5                	mov    %esp,%ebp
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030c8a:	83 c0 10             	add    $0x10,%eax
{
40030c8d:	56                   	push   %esi
40030c8e:	53                   	push   %ebx
	__asm__ volatile (
40030c8f:	9c                   	pushf  
40030c90:	fa                   	cli    
40030c91:	5e                   	pop    %esi
40030c92:	0f ba e6 09          	bt     $0x9,%esi
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
40030c96:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
40030c9b:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
40030ca1:	73 01                	jae    40030ca4 <_IoApicRedUpdateLo+0x1f>
	__asm__ volatile (
40030ca3:	fb                   	sti    
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
40030ca4:	31 da                	xor    %ebx,%edx
40030ca6:	21 ca                	and    %ecx,%edx
40030ca8:	31 da                	xor    %ebx,%edx
}
40030caa:	5b                   	pop    %ebx
40030cab:	5e                   	pop    %esi
40030cac:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
40030cad:	e9 b9 ff ff ff       	jmp    40030c6b <__IoApicSet>

40030cb2 <_ioapic_init>:
{
40030cb2:	55                   	push   %ebp
40030cb3:	89 e5                	mov    %esp,%ebp
40030cb5:	53                   	push   %ebx
40030cb6:	bb 11 00 00 00       	mov    $0x11,%ebx
	__IoApicSet(offset, upper32);
40030cbb:	31 d2                	xor    %edx,%edx
40030cbd:	89 d8                	mov    %ebx,%eax
40030cbf:	e8 a7 ff ff ff       	call   40030c6b <__IoApicSet>
	__IoApicSet(offset, lower32);
40030cc4:	8d 43 ff             	lea    -0x1(%ebx),%eax
40030cc7:	ba 00 00 01 00       	mov    $0x10000,%edx
40030ccc:	83 c3 02             	add    $0x2,%ebx
40030ccf:	e8 97 ff ff ff       	call   40030c6b <__IoApicSet>
	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
40030cd4:	81 fb 91 00 00 00    	cmp    $0x91,%ebx
40030cda:	75 df                	jne    40030cbb <_ioapic_init+0x9>
}
40030cdc:	31 c0                	xor    %eax,%eax
40030cde:	5b                   	pop    %ebx
40030cdf:	5d                   	pop    %ebp
40030ce0:	c3                   	ret    

40030ce1 <_ioapic_irq_enable>:
{
40030ce1:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030ce2:	b9 00 00 01 00       	mov    $0x10000,%ecx
40030ce7:	31 d2                	xor    %edx,%edx
{
40030ce9:	89 e5                	mov    %esp,%ebp
}
40030ceb:	5d                   	pop    %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030cec:	e9 94 ff ff ff       	jmp    40030c85 <_IoApicRedUpdateLo>

40030cf1 <_ioapic_irq_set>:
{
40030cf1:	55                   	push   %ebp
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030cf2:	81 c9 00 00 01 00    	or     $0x10000,%ecx
{
40030cf8:	89 e5                	mov    %esp,%ebp
40030cfa:	56                   	push   %esi
40030cfb:	53                   	push   %ebx
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030cfc:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
		   (vector & IOAPIC_VEC_MASK) | flags;
40030cff:	0f b6 f2             	movzbl %dl,%esi
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
40030d02:	8d 43 11             	lea    0x11(%ebx),%eax
	__IoApicSet(offset, upper32);
40030d05:	31 d2                	xor    %edx,%edx
	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030d07:	09 ce                	or     %ecx,%esi
	__IoApicSet(offset, upper32);
40030d09:	e8 5d ff ff ff       	call   40030c6b <__IoApicSet>
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030d0e:	8d 43 10             	lea    0x10(%ebx),%eax
	__IoApicSet(offset, lower32);
40030d11:	89 f2                	mov    %esi,%edx
}
40030d13:	5b                   	pop    %ebx
40030d14:	5e                   	pop    %esi
40030d15:	5d                   	pop    %ebp
	__IoApicSet(offset, lower32);
40030d16:	e9 50 ff ff ff       	jmp    40030c6b <__IoApicSet>

40030d1b <spi_qmsi_configure>:
	gpio_pin_write(gpio, config->cs_pin, !active);
}

static int spi_qmsi_configure(struct device *dev,
				struct spi_config *config)
{
40030d1b:	55                   	push   %ebp
40030d1c:	89 e5                	mov    %esp,%ebp
40030d1e:	56                   	push   %esi
40030d1f:	53                   	push   %ebx
40030d20:	51                   	push   %ecx
	struct spi_qmsi_runtime *context = dev->driver_data;
40030d21:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_spi_config_t *cfg = &context->cfg;

	cfg->frame_size = SPI_WORD_SIZE_GET(config->config) - 1;
40030d24:	8b 02                	mov    (%edx),%eax
40030d26:	89 c1                	mov    %eax,%ecx
40030d28:	c1 e9 04             	shr    $0x4,%ecx
40030d2b:	0f b6 c9             	movzbl %cl,%ecx
40030d2e:	49                   	dec    %ecx
40030d2f:	89 4b 14             	mov    %ecx,0x14(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030d32:	89 c1                	mov    %eax,%ecx
40030d34:	83 e1 07             	and    $0x7,%ecx
40030d37:	49                   	dec    %ecx
40030d38:	88 4d f7             	mov    %cl,-0x9(%ebp)
40030d3b:	31 c9                	xor    %ecx,%ecx
40030d3d:	80 7d f7 02          	cmpb   $0x2,-0x9(%ebp)
40030d41:	77 0a                	ja     40030d4d <spi_qmsi_configure+0x32>
40030d43:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
40030d47:	8a 89 8c 59 03 40    	mov    0x4003598c(%ecx),%cl
	/* As loopback is implemented inside the controller,
	 * the bus mode doesn't matter.
	 */
	context->loopback = SPI_MODE(config->config) & SPI_MODE_LOOP;
40030d4d:	c1 e8 02             	shr    $0x2,%eax
40030d50:	83 e0 01             	and    $0x1,%eax
40030d53:	88 43 2c             	mov    %al,0x2c(%ebx)
	cfg->clk_divider = config->max_sys_freq;
40030d56:	8b 42 04             	mov    0x4(%edx),%eax
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030d59:	0f b6 f1             	movzbl %cl,%esi
	cfg->clk_divider = config->max_sys_freq;
40030d5c:	66 89 43 24          	mov    %ax,0x24(%ebx)
	cfg->bus_mode = config_to_bmode(SPI_MODE(config->config));
40030d60:	89 73 1c             	mov    %esi,0x1c(%ebx)

	/* Will set the configuration before the transfer starts */
	return 0;
}
40030d63:	5a                   	pop    %edx
40030d64:	31 c0                	xor    %eax,%eax
40030d66:	5b                   	pop    %ebx
40030d67:	5e                   	pop    %esi
40030d68:	5d                   	pop    %ebp
40030d69:	c3                   	ret    

40030d6a <spi_qmsi_slave_select>:
	context->rc = error;
	k_sem_give(&context->device_sync_sem);
}

static int spi_qmsi_slave_select(struct device *dev, uint32_t slave)
{
40030d6a:	55                   	push   %ebp
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
	qm_spi_t spi = spi_config->spi;

	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030d6b:	8d 4a ff             	lea    -0x1(%edx),%ecx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030d6e:	8b 00                	mov    (%eax),%eax
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030d70:	ba 01 00 00 00       	mov    $0x1,%edx
40030d75:	d3 e2                	shl    %cl,%edx
	qm_spi_t spi = spi_config->spi;
40030d77:	8b 40 08             	mov    0x8(%eax),%eax
{
40030d7a:	89 e5                	mov    %esp,%ebp
	return qm_spi_slave_select(spi, 1 << (slave - 1)) ? -EIO : 0;
40030d7c:	8b 00                	mov    (%eax),%eax
40030d7e:	e8 4e 10 00 00       	call   40031dd1 <qm_spi_slave_select>
40030d83:	85 c0                	test   %eax,%eax
40030d85:	74 05                	je     40030d8c <spi_qmsi_slave_select+0x22>
40030d87:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030d8c:	5d                   	pop    %ebp
40030d8d:	c3                   	ret    

40030d8e <spi_qmsi_init>:
#else
#define spi_master_set_power_state(...)
#endif

static int spi_qmsi_init(struct device *dev)
{
40030d8e:	55                   	push   %ebp
40030d8f:	89 e5                	mov    %esp,%ebp
40030d91:	57                   	push   %edi
40030d92:	56                   	push   %esi
40030d93:	53                   	push   %ebx
40030d94:	83 ec 08             	sub    $0x8,%esp
40030d97:	89 45 ec             	mov    %eax,-0x14(%ebp)
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030d9a:	8b 00                	mov    (%eax),%eax
40030d9c:	8b 70 08             	mov    0x8(%eax),%esi
	struct spi_qmsi_runtime *context = dev->driver_data;
40030d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030da2:	8b 40 08             	mov    0x8(%eax),%eax
40030da5:	89 45 f0             	mov    %eax,-0x10(%ebp)

	switch (spi_config->spi) {
40030da8:	8b 06                	mov    (%esi),%eax
40030daa:	85 c0                	test   %eax,%eax
40030dac:	74 40                	je     40030dee <spi_qmsi_init+0x60>
40030dae:	48                   	dec    %eax
40030daf:	0f 85 ea 00 00 00    	jne    40030e9f <spi_qmsi_init+0x111>
40030db5:	0f b6 05 2b 6f 03 40 	movzbl 0x40036f2b,%eax
40030dbc:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030dc1:	ba 03 00 00 00       	mov    $0x3,%edx
40030dc6:	e8 67 fe ff ff       	call   40030c32 <__irq_controller_irq_config>
#ifdef CONFIG_SPI_1
	case QM_SPI_MST_1:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT),
			    CONFIG_SPI_1_IRQ_PRI, qm_spi_master_1_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_1_INT));
40030dcb:	b8 03 00 00 00       	mov    $0x3,%eax
40030dd0:	e8 7f fe ff ff       	call   40030c54 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M1_REGISTER);
40030dd5:	b8 02 80 00 00       	mov    $0x8002,%eax
40030dda:	e8 90 0a 00 00       	call   4003186f <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030ddf:	a1 58 04 80 b0       	mov    0xb0800458,%eax
40030de4:	83 e0 fe             	and    $0xfffffffe,%eax
40030de7:	a3 58 04 80 b0       	mov    %eax,0xb0800458
				QM_INTERRUPT_ROUTER->spi_master_1_int_mask);
		break;
40030dec:	eb 37                	jmp    40030e25 <spi_qmsi_init+0x97>
40030dee:	0f b6 05 2a 6f 03 40 	movzbl 0x40036f2a,%eax
40030df5:	b9 00 80 00 00       	mov    $0x8000,%ecx
40030dfa:	ba 02 00 00 00       	mov    $0x2,%edx
40030dff:	e8 2e fe ff ff       	call   40030c32 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_SPI_MASTER_0_INT));
40030e04:	b8 02 00 00 00       	mov    $0x2,%eax
40030e09:	e8 46 fe ff ff       	call   40030c54 <_arch_irq_enable>
		clk_periph_enable(CLK_PERIPH_CLK | CLK_PERIPH_SPI_M0_REGISTER);
40030e0e:	b8 02 40 00 00       	mov    $0x4002,%eax
40030e13:	e8 57 0a 00 00       	call   4003186f <clk_periph_enable>
		QM_IR_UNMASK_INTERRUPTS(
40030e18:	a1 54 04 80 b0       	mov    0xb0800454,%eax
40030e1d:	83 e0 fe             	and    $0xfffffffe,%eax
40030e20:	a3 54 04 80 b0       	mov    %eax,0xb0800454
	if (!config->cs_port)
40030e25:	8b 46 04             	mov    0x4(%esi),%eax
40030e28:	85 c0                	test   %eax,%eax
40030e2a:	75 04                	jne    40030e30 <spi_qmsi_init+0xa2>
		return NULL;
40030e2c:	31 db                	xor    %ebx,%ebx
40030e2e:	eb 35                	jmp    40030e65 <spi_qmsi_init+0xd7>
	gpio = device_get_binding(config->cs_port);
40030e30:	e8 17 2f 00 00       	call   40033d4c <device_get_binding>
40030e35:	89 c3                	mov    %eax,%ebx
	if (!gpio)
40030e37:	85 c0                	test   %eax,%eax
40030e39:	74 f1                	je     40030e2c <spi_qmsi_init+0x9e>
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40030e3b:	8b 40 04             	mov    0x4(%eax),%eax
40030e3e:	31 d2                	xor    %edx,%edx
40030e40:	0f b6 4e 08          	movzbl 0x8(%esi),%ecx
40030e44:	89 c7                	mov    %eax,%edi
40030e46:	89 d8                	mov    %ebx,%eax
40030e48:	6a 01                	push   $0x1
40030e4a:	ff 17                	call   *(%edi)
40030e4c:	59                   	pop    %ecx
	if (gpio_pin_configure(gpio, config->cs_pin, GPIO_DIR_OUT) != 0) {
40030e4d:	85 c0                	test   %eax,%eax
40030e4f:	75 db                	jne    40030e2c <spi_qmsi_init+0x9e>
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
40030e51:	8b 4e 08             	mov    0x8(%esi),%ecx
40030e54:	8b 73 04             	mov    0x4(%ebx),%esi
40030e57:	31 d2                	xor    %edx,%edx
40030e59:	89 d8                	mov    %ebx,%eax
40030e5b:	6a 01                	push   $0x1
40030e5d:	ff 56 04             	call   *0x4(%esi)
40030e60:	5a                   	pop    %edx
	if (gpio_pin_write(gpio, config->cs_pin, 1) != 0) {
40030e61:	85 c0                	test   %eax,%eax
40030e63:	75 c7                	jne    40030e2c <spi_qmsi_init+0x9e>

	default:
		return -EIO;
	}

	context->gpio_cs = gpio_cs_init(spi_config);
40030e65:	8b 45 f0             	mov    -0x10(%ebp),%eax

	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40030e68:	83 c9 ff             	or     $0xffffffff,%ecx
40030e6b:	83 c0 04             	add    $0x4,%eax
40030e6e:	31 d2                	xor    %edx,%edx
	context->gpio_cs = gpio_cs_init(spi_config);
40030e70:	89 58 fc             	mov    %ebx,-0x4(%eax)
	k_sem_init(&context->device_sync_sem, 0, UINT_MAX);
40030e73:	e8 bb 33 00 00       	call   40034233 <k_sem_init>
	k_sem_init(&context->sem, 0, UINT_MAX);
40030e78:	8b 45 f0             	mov    -0x10(%ebp),%eax
40030e7b:	8d 58 30             	lea    0x30(%eax),%ebx
40030e7e:	83 c9 ff             	or     $0xffffffff,%ecx
40030e81:	31 d2                	xor    %edx,%edx
40030e83:	89 d8                	mov    %ebx,%eax
40030e85:	e8 a9 33 00 00       	call   40034233 <k_sem_init>
	k_sem_give(&context->sem);
40030e8a:	89 d8                	mov    %ebx,%eax
40030e8c:	e8 b2 33 00 00       	call   40034243 <k_sem_give>

	spi_master_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	dev->driver_api = &spi_qmsi_api;
40030e91:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030e94:	c7 40 04 a8 59 03 40 	movl   $0x400359a8,0x4(%eax)
	return 0;
40030e9b:	31 c0                	xor    %eax,%eax
40030e9d:	eb 05                	jmp    40030ea4 <spi_qmsi_init+0x116>
		return -EIO;
40030e9f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40030ea4:	8d 65 f4             	lea    -0xc(%ebp),%esp
40030ea7:	5b                   	pop    %ebx
40030ea8:	5e                   	pop    %esi
40030ea9:	5f                   	pop    %edi
40030eaa:	5d                   	pop    %ebp
40030eab:	c3                   	ret    

40030eac <spi_control_cs>:
{
40030eac:	55                   	push   %ebp
40030ead:	89 e5                	mov    %esp,%ebp
40030eaf:	56                   	push   %esi
40030eb0:	53                   	push   %ebx
	struct device *gpio = context->gpio_cs;
40030eb1:	8b 48 08             	mov    0x8(%eax),%ecx
40030eb4:	8b 31                	mov    (%ecx),%esi
	if (!gpio)
40030eb6:	85 f6                	test   %esi,%esi
40030eb8:	74 1a                	je     40030ed4 <spi_control_cs+0x28>
	const struct spi_qmsi_config *config = dev->config->config_info;
40030eba:	8b 00                	mov    (%eax),%eax
	gpio_pin_write(gpio, config->cs_pin, !active);
40030ebc:	83 f2 01             	xor    $0x1,%edx
40030ebf:	8b 5e 04             	mov    0x4(%esi),%ebx
40030ec2:	8b 40 08             	mov    0x8(%eax),%eax
40030ec5:	0f b6 d2             	movzbl %dl,%edx
40030ec8:	8b 48 08             	mov    0x8(%eax),%ecx
40030ecb:	52                   	push   %edx
40030ecc:	89 f0                	mov    %esi,%eax
40030ece:	31 d2                	xor    %edx,%edx
40030ed0:	ff 53 04             	call   *0x4(%ebx)
40030ed3:	58                   	pop    %eax
}
40030ed4:	8d 65 f8             	lea    -0x8(%ebp),%esp
40030ed7:	5b                   	pop    %ebx
40030ed8:	5e                   	pop    %esi
40030ed9:	5d                   	pop    %ebp
40030eda:	c3                   	ret    

40030edb <transfer_complete>:
{
40030edb:	55                   	push   %ebp
40030edc:	89 e5                	mov    %esp,%ebp
40030ede:	57                   	push   %edi
40030edf:	56                   	push   %esi
40030ee0:	53                   	push   %ebx
	const struct spi_qmsi_config *spi_config =
40030ee1:	8b 00                	mov    (%eax),%eax
	qm_spi_t spi = spi_config->spi;
40030ee3:	8b 40 08             	mov    0x8(%eax),%eax
	struct device *dev = pending->dev;
40030ee6:	6b 38 1c             	imul   $0x1c,(%eax),%edi
40030ee9:	8b 87 80 68 00 a8    	mov    -0x57ff9780(%edi),%eax
	if (!dev)
40030eef:	85 c0                	test   %eax,%eax
40030ef1:	74 25                	je     40030f18 <transfer_complete+0x3d>
40030ef3:	89 d6                	mov    %edx,%esi
	spi_control_cs(dev, false);
40030ef5:	31 d2                	xor    %edx,%edx
	context = dev->driver_data;
40030ef7:	8b 58 08             	mov    0x8(%eax),%ebx
	spi_control_cs(dev, false);
40030efa:	e8 ad ff ff ff       	call   40030eac <spi_control_cs>
	pending->dev = NULL;
40030eff:	c7 87 80 68 00 a8 00 	movl   $0x0,-0x57ff9780(%edi)
40030f06:	00 00 00 
	k_sem_give(&context->device_sync_sem);
40030f09:	8d 43 04             	lea    0x4(%ebx),%eax
	context->rc = error;
40030f0c:	89 73 28             	mov    %esi,0x28(%ebx)
}
40030f0f:	5b                   	pop    %ebx
40030f10:	5e                   	pop    %esi
40030f11:	5f                   	pop    %edi
40030f12:	5d                   	pop    %ebp
	k_sem_give(&context->device_sync_sem);
40030f13:	e9 2b 33 00 00       	jmp    40034243 <k_sem_give>
}
40030f18:	5b                   	pop    %ebx
40030f19:	5e                   	pop    %esi
40030f1a:	5f                   	pop    %edi
40030f1b:	5d                   	pop    %ebp
40030f1c:	c3                   	ret    

40030f1d <spi_qmsi_transceive>:
{
40030f1d:	55                   	push   %ebp
40030f1e:	89 e5                	mov    %esp,%ebp
40030f20:	57                   	push   %edi
40030f21:	56                   	push   %esi
40030f22:	53                   	push   %ebx
40030f23:	83 ec 14             	sub    $0x14,%esp
40030f26:	89 c3                	mov    %eax,%ebx
	const struct spi_qmsi_config *spi_config = dev->config->config_info;
40030f28:	8b 00                	mov    (%eax),%eax
{
40030f2a:	89 55 e0             	mov    %edx,-0x20(%ebp)
	struct spi_qmsi_runtime *context = dev->driver_data;
40030f2d:	8b 73 08             	mov    0x8(%ebx),%esi
{
40030f30:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	qm_spi_t spi = spi_config->spi;
40030f33:	8b 40 08             	mov    0x8(%eax),%eax
40030f36:	8b 00                	mov    (%eax),%eax
40030f38:	89 45 f0             	mov    %eax,-0x10(%ebp)
	qm_spi_config_t *cfg = &context->cfg;
40030f3b:	8d 46 14             	lea    0x14(%esi),%eax
40030f3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8_t dfs = frame_size_to_dfs(cfg->frame_size);
40030f41:	8b 46 14             	mov    0x14(%esi),%eax
		return 1;
40030f44:	c6 45 ec 01          	movb   $0x1,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_8_BIT)
40030f48:	83 f8 07             	cmp    $0x7,%eax
40030f4b:	76 15                	jbe    40030f62 <spi_qmsi_transceive+0x45>
		return 2;
40030f4d:	c6 45 ec 02          	movb   $0x2,-0x14(%ebp)
	if (frame_size <= QM_SPI_FRAME_SIZE_16_BIT)
40030f51:	83 f8 0f             	cmp    $0xf,%eax
40030f54:	76 0c                	jbe    40030f62 <spi_qmsi_transceive+0x45>
	return 0;
40030f56:	83 f8 20             	cmp    $0x20,%eax
40030f59:	0f 92 c0             	setb   %al
40030f5c:	c1 e0 02             	shl    $0x2,%eax
40030f5f:	88 45 ec             	mov    %al,-0x14(%ebp)
	k_sem_take(&context->sem, K_FOREVER);
40030f62:	8d 4e 30             	lea    0x30(%esi),%ecx
40030f65:	83 ca ff             	or     $0xffffffff,%edx
40030f68:	89 c8                	mov    %ecx,%eax
40030f6a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40030f6d:	e8 46 33 00 00       	call   400342b8 <k_sem_take>
	if (pending_transfers[spi].dev) {
40030f72:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40030f75:	6b 55 f0 1c          	imul   $0x1c,-0x10(%ebp),%edx
40030f79:	8d ba 80 68 00 a8    	lea    -0x57ff9780(%edx),%edi
40030f7f:	83 ba 80 68 00 a8 00 	cmpl   $0x0,-0x57ff9780(%edx)
40030f86:	74 11                	je     40030f99 <spi_qmsi_transceive+0x7c>
		k_sem_give(&context->sem);
40030f88:	89 c8                	mov    %ecx,%eax
40030f8a:	e8 b4 32 00 00       	call   40034243 <k_sem_give>
		return -EBUSY;
40030f8f:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
40030f94:	e9 ed 00 00 00       	jmp    40031086 <spi_qmsi_transceive+0x169>
	k_sem_give(&context->sem);
40030f99:	89 c8                	mov    %ecx,%eax
	pending_transfers[spi].dev = dev;
40030f9b:	89 9a 80 68 00 a8    	mov    %ebx,-0x57ff9780(%edx)
40030fa1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	k_sem_give(&context->sem);
40030fa4:	e8 9a 32 00 00       	call   40034243 <k_sem_give>
	device_busy_set(dev);
40030fa9:	89 d8                	mov    %ebx,%eax
40030fab:	e8 d4 2d 00 00       	call   40033d84 <device_busy_set>
	xfer = &pending_transfers[spi].xfer;
40030fb0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
40030fb3:	8d 82 84 68 00 a8    	lea    -0x57ff977c(%edx),%eax
	xfer->rx_len = rx_buf_len / dfs;
40030fb9:	31 d2                	xor    %edx,%edx
40030fbb:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
	xfer = &pending_transfers[spi].xfer;
40030fbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	xfer->rx = rx_buf;
40030fc2:	8b 45 08             	mov    0x8(%ebp),%eax
40030fc5:	89 47 08             	mov    %eax,0x8(%edi)
	xfer->rx_len = rx_buf_len / dfs;
40030fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
40030fcb:	f7 f1                	div    %ecx
40030fcd:	66 89 47 0e          	mov    %ax,0xe(%edi)
	xfer->tx = (uint8_t *)tx_buf;
40030fd1:	8b 45 e0             	mov    -0x20(%ebp),%eax
	xfer->tx_len = tx_buf_len / dfs;
40030fd4:	31 d2                	xor    %edx,%edx
	xfer->tx = (uint8_t *)tx_buf;
40030fd6:	89 47 04             	mov    %eax,0x4(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030fd9:	8b 45 e8             	mov    -0x18(%ebp),%eax
	xfer->callback_data = dev;
40030fdc:	89 5f 18             	mov    %ebx,0x18(%edi)
	xfer->tx_len = tx_buf_len / dfs;
40030fdf:	f7 f1                	div    %ecx
40030fe1:	66 89 47 0c          	mov    %ax,0xc(%edi)
	xfer->callback = transfer_complete;
40030fe5:	c7 47 14 db 0e 03 40 	movl   $0x40030edb,0x14(%edi)
	if (tx_buf_len == 0)
40030fec:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
40030ff0:	75 09                	jne    40030ffb <spi_qmsi_transceive+0xde>
		cfg->transfer_mode = QM_SPI_TMOD_RX;
40030ff2:	c7 46 18 02 00 00 00 	movl   $0x2,0x18(%esi)
40030ff9:	eb 0c                	jmp    40031007 <spi_qmsi_transceive+0xea>
		cfg->transfer_mode = QM_SPI_TMOD_TX;
40030ffb:	31 c0                	xor    %eax,%eax
40030ffd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
40031001:	0f 94 c0             	sete   %al
40031004:	89 46 18             	mov    %eax,0x18(%esi)
	if (context->loopback)
40031007:	80 7e 2c 00          	cmpb   $0x0,0x2c(%esi)
4003100b:	74 11                	je     4003101e <spi_qmsi_transceive+0x101>
		QM_SPI[spi]->ctrlr0 |= BIT(11);
4003100d:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031010:	8b 14 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edx
40031017:	8b 02                	mov    (%edx),%eax
40031019:	80 cc 08             	or     $0x8,%ah
4003101c:	89 02                	mov    %eax,(%edx)
	rc = qm_spi_set_config(spi, cfg);
4003101e:	8d 56 14             	lea    0x14(%esi),%edx
40031021:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031024:	e8 3b 0d 00 00       	call   40031d64 <qm_spi_set_config>
	if (rc != 0) {
40031029:	85 c0                	test   %eax,%eax
4003102b:	74 0e                	je     4003103b <spi_qmsi_transceive+0x11e>
		device_busy_clear(dev);
4003102d:	89 d8                	mov    %ebx,%eax
4003102f:	e8 55 2d 00 00       	call   40033d89 <device_busy_clear>
		return -EINVAL;
40031034:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
40031039:	eb 4b                	jmp    40031086 <spi_qmsi_transceive+0x169>
	spi_control_cs(dev, true);
4003103b:	ba 01 00 00 00       	mov    $0x1,%edx
40031040:	89 d8                	mov    %ebx,%eax
40031042:	e8 65 fe ff ff       	call   40030eac <spi_control_cs>
	rc = qm_spi_irq_transfer(spi, xfer);
40031047:	8b 55 e4             	mov    -0x1c(%ebp),%edx
4003104a:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003104d:	e8 01 0e 00 00       	call   40031e53 <qm_spi_irq_transfer>
	if (rc != 0) {
40031052:	85 c0                	test   %eax,%eax
40031054:	74 12                	je     40031068 <spi_qmsi_transceive+0x14b>
		spi_control_cs(dev, false);
40031056:	89 d8                	mov    %ebx,%eax
40031058:	31 d2                	xor    %edx,%edx
4003105a:	e8 4d fe ff ff       	call   40030eac <spi_control_cs>
		device_busy_clear(dev);
4003105f:	89 d8                	mov    %ebx,%eax
40031061:	e8 23 2d 00 00       	call   40033d89 <device_busy_clear>
40031066:	eb 19                	jmp    40031081 <spi_qmsi_transceive+0x164>
	k_sem_take(&context->device_sync_sem, K_FOREVER);
40031068:	83 ca ff             	or     $0xffffffff,%edx
4003106b:	8d 46 04             	lea    0x4(%esi),%eax
4003106e:	e8 45 32 00 00       	call   400342b8 <k_sem_take>
	device_busy_clear(dev);
40031073:	89 d8                	mov    %ebx,%eax
40031075:	e8 0f 2d 00 00       	call   40033d89 <device_busy_clear>
	return context->rc ? -EIO : 0;
4003107a:	8b 46 28             	mov    0x28(%esi),%eax
4003107d:	85 c0                	test   %eax,%eax
4003107f:	74 05                	je     40031086 <spi_qmsi_transceive+0x169>
40031081:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40031086:	83 c4 14             	add    $0x14,%esp
40031089:	5b                   	pop    %ebx
4003108a:	5e                   	pop    %esi
4003108b:	5f                   	pop    %edi
4003108c:	5d                   	pop    %ebp
4003108d:	c3                   	ret    

4003108e <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
4003108e:	55                   	push   %ebp
4003108f:	89 e5                	mov    %esp,%ebp
40031091:	57                   	push   %edi
40031092:	56                   	push   %esi
40031093:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
40031094:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
40031097:	89 d6                	mov    %edx,%esi
40031099:	23 71 08             	and    0x8(%ecx),%esi
4003109c:	74 1c                	je     400310ba <gpio_qmsi_callback+0x2c>
4003109e:	8b 19                	mov    (%ecx),%ebx
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
400310a0:	85 db                	test   %ebx,%ebx
400310a2:	74 16                	je     400310ba <gpio_qmsi_callback+0x2c>
400310a4:	89 c7                	mov    %eax,%edi
		if (cb->pin_mask & pins) {
400310a6:	85 73 08             	test   %esi,0x8(%ebx)
400310a9:	74 09                	je     400310b4 <gpio_qmsi_callback+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
400310ab:	89 f1                	mov    %esi,%ecx
400310ad:	89 da                	mov    %ebx,%edx
400310af:	89 f8                	mov    %edi,%eax
400310b1:	ff 53 04             	call   *0x4(%ebx)
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
400310b4:	8b 1b                	mov    (%ebx),%ebx
	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
400310b6:	85 db                	test   %ebx,%ebx
400310b8:	75 ec                	jne    400310a6 <gpio_qmsi_callback+0x18>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
400310ba:	5b                   	pop    %ebx
400310bb:	5e                   	pop    %esi
400310bc:	5f                   	pop    %edi
400310bd:	5d                   	pop    %ebp
400310be:	c3                   	ret    

400310bf <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
400310bf:	55                   	push   %ebp
	if (value) {
400310c0:	84 c9                	test   %cl,%cl
{
400310c2:	89 e5                	mov    %esp,%ebp
400310c4:	0f b6 d2             	movzbl %dl,%edx
	if (value) {
400310c7:	74 05                	je     400310ce <qmsi_write_bit+0xf>


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
400310c9:	0f ab 10             	bts    %edx,(%eax)
400310cc:	eb 03                	jmp    400310d1 <qmsi_write_bit+0x12>
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
400310ce:	0f b3 10             	btr    %edx,(%eax)
		sys_set_bit((uintptr_t) target, bit);
	} else {
		sys_clear_bit((uintptr_t) target, bit);
	}
}
400310d1:	5d                   	pop    %ebp
400310d2:	c3                   	ret    

400310d3 <gpio_qmsi_manage_callback>:

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
400310d3:	8b 40 08             	mov    0x8(%eax),%eax
	if (set) {
400310d6:	84 c9                	test   %cl,%cl
400310d8:	74 11                	je     400310eb <gpio_qmsi_manage_callback+0x18>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
400310da:	8b 08                	mov    (%eax),%ecx
400310dc:	89 0a                	mov    %ecx,(%edx)
	list->head = node;
400310de:	89 10                	mov    %edx,(%eax)

	if (!list->tail) {
400310e0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
400310e4:	75 44                	jne    4003112a <gpio_qmsi_manage_callback+0x57>
		list->tail = list->head;
400310e6:	89 50 04             	mov    %edx,0x4(%eax)
400310e9:	eb 3f                	jmp    4003112a <gpio_qmsi_manage_callback+0x57>
{
400310eb:	55                   	push   %ebp
400310ec:	89 e5                	mov    %esp,%ebp
400310ee:	53                   	push   %ebx
400310ef:	8b 08                	mov    (%eax),%ecx
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
400310f1:	31 db                	xor    %ebx,%ebx
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
400310f3:	85 c9                	test   %ecx,%ecx
400310f5:	74 2e                	je     40031125 <gpio_qmsi_manage_callback+0x52>
		if (test == node) {
400310f7:	39 ca                	cmp    %ecx,%edx
400310f9:	75 24                	jne    4003111f <gpio_qmsi_manage_callback+0x4c>
	if (!prev_node) {
400310fb:	85 db                	test   %ebx,%ebx
400310fd:	8b 0a                	mov    (%edx),%ecx
400310ff:	75 0c                	jne    4003110d <gpio_qmsi_manage_callback+0x3a>
		list->head = node->next;
40031101:	89 08                	mov    %ecx,(%eax)
		if (list->tail == node) {
40031103:	3b 50 04             	cmp    0x4(%eax),%edx
40031106:	75 0f                	jne    40031117 <gpio_qmsi_manage_callback+0x44>
			list->tail = list->head;
40031108:	89 48 04             	mov    %ecx,0x4(%eax)
4003110b:	eb 0a                	jmp    40031117 <gpio_qmsi_manage_callback+0x44>
		prev_node->next = node->next;
4003110d:	89 0b                	mov    %ecx,(%ebx)
		if (list->tail == node) {
4003110f:	3b 50 04             	cmp    0x4(%eax),%edx
40031112:	75 03                	jne    40031117 <gpio_qmsi_manage_callback+0x44>
			list->tail = prev_node;
40031114:	89 58 04             	mov    %ebx,0x4(%eax)
	node->next = NULL;
40031117:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
4003111d:	eb 06                	jmp    40031125 <gpio_qmsi_manage_callback+0x52>
	SYS_SLIST_FOR_EACH_NODE(list, test) {
4003111f:	89 cb                	mov    %ecx,%ebx
40031121:	8b 09                	mov    (%ecx),%ecx
40031123:	eb ce                	jmp    400310f3 <gpio_qmsi_manage_callback+0x20>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
40031125:	31 c0                	xor    %eax,%eax
40031127:	5b                   	pop    %ebx
40031128:	5d                   	pop    %ebp
40031129:	c3                   	ret    
4003112a:	31 c0                	xor    %eax,%eax
4003112c:	c3                   	ret    

4003112d <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
4003112d:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
4003112e:	85 d2                	test   %edx,%edx
{
40031130:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40031132:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031135:	75 0c                	jne    40031143 <gpio_qmsi_enable_callback+0x16>
		context->pin_callbacks |= BIT(pin);
40031137:	ba 01 00 00 00       	mov    $0x1,%edx
4003113c:	d3 e2                	shl    %cl,%edx
4003113e:	09 50 08             	or     %edx,0x8(%eax)
40031141:	eb 07                	jmp    4003114a <gpio_qmsi_enable_callback+0x1d>
	} else {
		context->pin_callbacks = 0xffffffff;
40031143:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
4003114a:	31 c0                	xor    %eax,%eax
4003114c:	5d                   	pop    %ebp
4003114d:	c3                   	ret    

4003114e <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
4003114e:	55                   	push   %ebp

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
4003114f:	85 d2                	test   %edx,%edx
{
40031151:	89 e5                	mov    %esp,%ebp
	struct gpio_qmsi_runtime *context = port->driver_data;
40031153:	8b 40 08             	mov    0x8(%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031156:	75 0c                	jne    40031164 <gpio_qmsi_disable_callback+0x16>
		context->pin_callbacks &= ~BIT(pin);
40031158:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
4003115d:	d3 c2                	rol    %cl,%edx
4003115f:	21 50 08             	and    %edx,0x8(%eax)
40031162:	eb 07                	jmp    4003116b <gpio_qmsi_disable_callback+0x1d>
	} else {
		context->pin_callbacks = 0;
40031164:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
4003116b:	31 c0                	xor    %eax,%eax
4003116d:	5d                   	pop    %ebp
4003116e:	c3                   	ret    

4003116f <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
4003116f:	55                   	push   %ebp
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
40031170:	8b 00                	mov    (%eax),%eax
{
40031172:	89 e5                	mov    %esp,%ebp
	qm_gpio_t gpio = gpio_config->gpio;

	return QM_GPIO[gpio]->gpio_intstatus;
}
40031174:	5d                   	pop    %ebp
	qm_gpio_t gpio = gpio_config->gpio;
40031175:	8b 40 08             	mov    0x8(%eax),%eax
	return QM_GPIO[gpio]->gpio_intstatus;
40031178:	8b 00                	mov    (%eax),%eax
4003117a:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40031181:	8b 40 40             	mov    0x40(%eax),%eax
}
40031184:	c3                   	ret    

40031185 <gpio_qmsi_read>:
{
40031185:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031186:	85 d2                	test   %edx,%edx
{
40031188:	89 e5                	mov    %esp,%ebp
4003118a:	53                   	push   %ebx
4003118b:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
4003118c:	8b 00                	mov    (%eax),%eax
{
4003118e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
40031191:	8b 40 08             	mov    0x8(%eax),%eax
40031194:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
40031196:	75 12                	jne    400311aa <gpio_qmsi_read+0x25>
		qm_gpio_read_pin(gpio, pin, &state);
40031198:	0f b6 d1             	movzbl %cl,%edx
4003119b:	8d 4d f8             	lea    -0x8(%ebp),%ecx
4003119e:	e8 90 07 00 00       	call   40031933 <qm_gpio_read_pin>
		*value = state;
400311a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
400311a6:	89 03                	mov    %eax,(%ebx)
400311a8:	eb 07                	jmp    400311b1 <gpio_qmsi_read+0x2c>
		qm_gpio_read_port(gpio, (uint32_t *const) value);
400311aa:	89 da                	mov    %ebx,%edx
400311ac:	e8 e2 07 00 00       	call   40031993 <qm_gpio_read_port>
}
400311b1:	5a                   	pop    %edx
400311b2:	31 c0                	xor    %eax,%eax
400311b4:	5b                   	pop    %ebx
400311b5:	5d                   	pop    %ebp
400311b6:	c3                   	ret    

400311b7 <gpio_qmsi_write>:
{
400311b7:	55                   	push   %ebp
	if (access_op == GPIO_ACCESS_BY_PIN) {
400311b8:	85 d2                	test   %edx,%edx
{
400311ba:	89 e5                	mov    %esp,%ebp
400311bc:	53                   	push   %ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400311bd:	8b 00                	mov    (%eax),%eax
{
400311bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	qm_gpio_t gpio = gpio_config->gpio;
400311c2:	8b 40 08             	mov    0x8(%eax),%eax
400311c5:	8b 00                	mov    (%eax),%eax
	if (access_op == GPIO_ACCESS_BY_PIN) {
400311c7:	75 15                	jne    400311de <gpio_qmsi_write+0x27>
		if (value) {
400311c9:	85 db                	test   %ebx,%ebx
400311cb:	0f b6 d1             	movzbl %cl,%edx
400311ce:	74 07                	je     400311d7 <gpio_qmsi_write+0x20>
			qm_gpio_set_pin(gpio, pin);
400311d0:	e8 7c 07 00 00       	call   40031951 <qm_gpio_set_pin>
400311d5:	eb 0e                	jmp    400311e5 <gpio_qmsi_write+0x2e>
			qm_gpio_clear_pin(gpio, pin);
400311d7:	e8 96 07 00 00       	call   40031972 <qm_gpio_clear_pin>
400311dc:	eb 07                	jmp    400311e5 <gpio_qmsi_write+0x2e>
		qm_gpio_write_port(gpio, value);
400311de:	89 da                	mov    %ebx,%edx
400311e0:	e8 c1 07 00 00       	call   400319a6 <qm_gpio_write_port>
}
400311e5:	31 c0                	xor    %eax,%eax
400311e7:	5b                   	pop    %ebx
400311e8:	5d                   	pop    %ebp
400311e9:	c3                   	ret    

400311ea <qmsi_pin_config>:
{
400311ea:	55                   	push   %ebp
400311eb:	89 e5                	mov    %esp,%ebp
400311ed:	57                   	push   %edi
400311ee:	56                   	push   %esi
400311ef:	53                   	push   %ebx
400311f0:	83 ec 24             	sub    $0x24,%esp
400311f3:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400311f5:	8b 00                	mov    (%eax),%eax
{
400311f7:	89 ce                	mov    %ecx,%esi
	qm_gpio_port_config_t cfg = { 0 };
400311f9:	8d 7d d4             	lea    -0x2c(%ebp),%edi
400311fc:	b9 08 00 00 00       	mov    $0x8,%ecx
	qm_gpio_t gpio = gpio_config->gpio;
40031201:	8b 40 08             	mov    0x8(%eax),%eax
40031204:	8b 00                	mov    (%eax),%eax
40031206:	89 45 d0             	mov    %eax,-0x30(%ebp)
	qm_gpio_port_config_t cfg = { 0 };
40031209:	31 c0                	xor    %eax,%eax
4003120b:	f3 ab                	rep stos %eax,%es:(%edi)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
4003120d:	8b 45 d0             	mov    -0x30(%ebp),%eax
40031210:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
40031217:	8b 48 04             	mov    0x4(%eax),%ecx
	cfg.callback_data = port;
4003121a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
4003121d:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
40031220:	8b 48 30             	mov    0x30(%eax),%ecx
40031223:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
40031226:	8b 48 38             	mov    0x38(%eax),%ecx
40031229:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
4003122c:	8b 48 3c             	mov    0x3c(%eax),%ecx
4003122f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
40031232:	8b 48 48             	mov    0x48(%eax),%ecx
40031235:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40031238:	8b 40 68             	mov    0x68(%eax),%eax
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
4003123b:	0f b6 da             	movzbl %dl,%ebx
4003123e:	89 f1                	mov    %esi,%ecx
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
40031240:	89 45 e8             	mov    %eax,-0x18(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40031243:	83 e1 01             	and    $0x1,%ecx
40031246:	89 da                	mov    %ebx,%edx
40031248:	8d 45 d4             	lea    -0x2c(%ebp),%eax
	cfg.callback = gpio_qmsi_callback;
4003124b:	c7 45 ec 8e 10 03 40 	movl   $0x4003108e,-0x14(%ebp)
	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
40031252:	e8 68 fe ff ff       	call   400310bf <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 0);
40031257:	31 c9                	xor    %ecx,%ecx
	if (flags & GPIO_INT) {
40031259:	f7 c6 02 00 00 00    	test   $0x2,%esi
4003125f:	74 41                	je     400312a2 <qmsi_pin_config+0xb8>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
40031261:	89 f1                	mov    %esi,%ecx
40031263:	89 da                	mov    %ebx,%edx
40031265:	83 e1 20             	and    $0x20,%ecx
40031268:	8d 45 dc             	lea    -0x24(%ebp),%eax
4003126b:	e8 4f fe ff ff       	call   400310bf <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
40031270:	89 f1                	mov    %esi,%ecx
40031272:	83 e1 04             	and    $0x4,%ecx
40031275:	89 da                	mov    %ebx,%edx
40031277:	8d 45 e0             	lea    -0x20(%ebp),%eax
4003127a:	e8 40 fe ff ff       	call   400310bf <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_debounce, pin,
4003127f:	89 f1                	mov    %esi,%ecx
40031281:	83 e1 10             	and    $0x10,%ecx
40031284:	89 da                	mov    %ebx,%edx
40031286:	8d 45 e4             	lea    -0x1c(%ebp),%eax
		qmsi_write_bit(&cfg.int_bothedge, pin,
40031289:	83 e6 40             	and    $0x40,%esi
		qmsi_write_bit(&cfg.int_debounce, pin,
4003128c:	e8 2e fe ff ff       	call   400310bf <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_bothedge, pin,
40031291:	89 f1                	mov    %esi,%ecx
40031293:	89 da                	mov    %ebx,%edx
40031295:	8d 45 e8             	lea    -0x18(%ebp),%eax
40031298:	e8 22 fe ff ff       	call   400310bf <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_en, pin, 1);
4003129d:	b9 01 00 00 00       	mov    $0x1,%ecx
		qmsi_write_bit(&cfg.int_en, pin, 0);
400312a2:	89 da                	mov    %ebx,%edx
400312a4:	8d 45 d8             	lea    -0x28(%ebp),%eax
400312a7:	e8 13 fe ff ff       	call   400310bf <qmsi_write_bit>
	qm_gpio_set_config(gpio, &cfg);
400312ac:	8d 55 d4             	lea    -0x2c(%ebp),%edx
400312af:	8b 45 d0             	mov    -0x30(%ebp),%eax
400312b2:	e8 1d 06 00 00       	call   400318d4 <qm_gpio_set_config>
}
400312b7:	83 c4 24             	add    $0x24,%esp
400312ba:	5b                   	pop    %ebx
400312bb:	5e                   	pop    %esi
400312bc:	5f                   	pop    %edi
400312bd:	5d                   	pop    %ebp
400312be:	c3                   	ret    

400312bf <gpio_qmsi_config>:
{
400312bf:	55                   	push   %ebp
400312c0:	89 e5                	mov    %esp,%ebp
400312c2:	57                   	push   %edi
400312c3:	56                   	push   %esi
400312c4:	89 c6                	mov    %eax,%esi
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400312c6:	8b 45 08             	mov    0x8(%ebp),%eax
{
400312c9:	53                   	push   %ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400312ca:	83 e0 03             	and    $0x3,%eax
		return -EINVAL;
400312cd:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
400312d2:	83 f8 03             	cmp    $0x3,%eax
400312d5:	74 34                	je     4003130b <gpio_qmsi_config+0x4c>
400312d7:	89 d3                	mov    %edx,%ebx
	if (access_op == GPIO_ACCESS_BY_PIN) {
400312d9:	85 d2                	test   %edx,%edx
400312db:	75 0e                	jne    400312eb <gpio_qmsi_config+0x2c>
400312dd:	89 ca                	mov    %ecx,%edx
		qmsi_pin_config(port, pin, flags);
400312df:	89 f0                	mov    %esi,%eax
400312e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
400312e4:	e8 01 ff ff ff       	call   400311ea <qmsi_pin_config>
400312e9:	eb 20                	jmp    4003130b <gpio_qmsi_config+0x4c>
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
400312eb:	8b 06                	mov    (%esi),%eax
	for (i = 0; i < num_pins; i++) {
400312ed:	31 db                	xor    %ebx,%ebx
	uint8_t num_pins = gpio_config->num_pins;
400312ef:	8b 40 08             	mov    0x8(%eax),%eax
	for (i = 0; i < num_pins; i++) {
400312f2:	0f b6 78 04          	movzbl 0x4(%eax),%edi
400312f6:	39 fb                	cmp    %edi,%ebx
400312f8:	7d 0f                	jge    40031309 <gpio_qmsi_config+0x4a>
		qmsi_pin_config(port, i, flags);
400312fa:	89 da                	mov    %ebx,%edx
400312fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
400312ff:	89 f0                	mov    %esi,%eax
	for (i = 0; i < num_pins; i++) {
40031301:	43                   	inc    %ebx
		qmsi_pin_config(port, i, flags);
40031302:	e8 e3 fe ff ff       	call   400311ea <qmsi_pin_config>
40031307:	eb ed                	jmp    400312f6 <gpio_qmsi_config+0x37>
	return 0;
40031309:	31 db                	xor    %ebx,%ebx
}
4003130b:	89 d8                	mov    %ebx,%eax
4003130d:	5b                   	pop    %ebx
4003130e:	5e                   	pop    %esi
4003130f:	5f                   	pop    %edi
40031310:	5d                   	pop    %ebp
40031311:	c3                   	ret    

40031312 <gpio_qmsi_init>:
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
40031312:	55                   	push   %ebp
40031313:	89 e5                	mov    %esp,%ebp
40031315:	53                   	push   %ebx
40031316:	89 c3                	mov    %eax,%ebx
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
40031318:	8b 00                	mov    (%eax),%eax
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
4003131a:	8b 40 08             	mov    0x8(%eax),%eax
4003131d:	8b 00                	mov    (%eax),%eax
4003131f:	85 c0                	test   %eax,%eax
40031321:	74 32                	je     40031355 <gpio_qmsi_init+0x43>
40031323:	48                   	dec    %eax
40031324:	75 71                	jne    40031397 <gpio_qmsi_init+0x85>
40031326:	0f b6 05 47 6f 03 40 	movzbl 0x40036f47,%eax
4003132d:	b9 00 80 00 00       	mov    $0x8000,%ecx
40031332:	ba 1f 00 00 00       	mov    $0x1f,%edx
40031337:	e8 f6 f8 ff ff       	call   40030c32 <__irq_controller_irq_config>
#ifdef CONFIG_GPIO_QMSI_1
	case QM_AON_GPIO_0:
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_1_IRQ_PRI, qm_aon_gpio_0_isr,
			    0, IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_AON_GPIO_0_INT));
4003133c:	b8 1f 00 00 00       	mov    $0x1f,%eax
40031341:	e8 0e f9 ff ff       	call   40030c54 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
40031346:	a1 d4 04 80 b0       	mov    0xb08004d4,%eax
4003134b:	83 e0 fe             	and    $0xfffffffe,%eax
4003134e:	a3 d4 04 80 b0       	mov    %eax,0xb08004d4
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
40031353:	eb 37                	jmp    4003138c <gpio_qmsi_init+0x7a>
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
40031355:	b8 82 21 00 00       	mov    $0x2182,%eax
4003135a:	e8 10 05 00 00       	call   4003186f <clk_periph_enable>
4003135f:	0f b6 05 30 6f 03 40 	movzbl 0x40036f30,%eax
40031366:	b9 00 80 00 00       	mov    $0x8000,%ecx
4003136b:	ba 08 00 00 00       	mov    $0x8,%edx
40031370:	e8 bd f8 ff ff       	call   40030c32 <__irq_controller_irq_config>
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
40031375:	b8 08 00 00 00       	mov    $0x8,%eax
4003137a:	e8 d5 f8 ff ff       	call   40030c54 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
4003137f:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
40031384:	83 e0 fe             	and    $0xfffffffe,%eax
40031387:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
4003138c:	c7 43 04 b4 59 03 40 	movl   $0x400359b4,0x4(%ebx)
	return 0;
40031393:	31 c0                	xor    %eax,%eax
40031395:	eb 05                	jmp    4003139c <gpio_qmsi_init+0x8a>
		return -EIO;
40031397:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
4003139c:	5b                   	pop    %ebx
4003139d:	5d                   	pop    %ebp
4003139e:	c3                   	ret    

4003139f <pinmux_get>:
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
4003139f:	89 d0                	mov    %edx,%eax
{
400313a1:	55                   	push   %ebp
	uint32_t reg_offset = pin >> 4;
400313a2:	c1 e8 04             	shr    $0x4,%eax
{
400313a5:	89 e5                	mov    %esp,%ebp
400313a7:	53                   	push   %ebx
400313a8:	89 cb                	mov    %ecx,%ebx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400313aa:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
	uint32_t mode_mask = *mux_register & pin_mask;
400313ad:	8b 14 85 30 09 80 b0 	mov    -0x4f7ff6d0(,%eax,4),%edx
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
400313b4:	83 e1 1e             	and    $0x1e,%ecx
400313b7:	b8 03 00 00 00       	mov    $0x3,%eax
400313bc:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
400313be:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
400313c0:	d3 e8                	shr    %cl,%eax
400313c2:	89 03                	mov    %eax,(%ebx)

	*func = mode;

	return 0;
}
400313c4:	31 c0                	xor    %eax,%eax
400313c6:	5b                   	pop    %ebx
400313c7:	5d                   	pop    %ebp
400313c8:	c3                   	ret    

400313c9 <pinmux_initialize>:
	.pullup = pinmux_pullup,
	.input = pinmux_input
};

static int pinmux_initialize(struct device *port)
{
400313c9:	55                   	push   %ebp
	return 0;
}
400313ca:	31 c0                	xor    %eax,%eax
{
400313cc:	89 e5                	mov    %esp,%ebp
}
400313ce:	5d                   	pop    %ebp
400313cf:	c3                   	ret    

400313d0 <pinmux_input>:
{
400313d0:	55                   	push   %ebp
400313d1:	89 d0                	mov    %edx,%eax
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
400313d3:	31 d2                	xor    %edx,%edx
{
400313d5:	89 e5                	mov    %esp,%ebp
	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
400313d7:	84 c9                	test   %cl,%cl
400313d9:	0f 95 c2             	setne  %dl
400313dc:	e8 be 0b 00 00       	call   40031f9f <qm_pmux_input_en>
400313e1:	85 c0                	test   %eax,%eax
400313e3:	74 05                	je     400313ea <pinmux_input+0x1a>
400313e5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
400313ea:	5d                   	pop    %ebp
400313eb:	c3                   	ret    

400313ec <pinmux_pullup>:
{
400313ec:	55                   	push   %ebp
400313ed:	89 d0                	mov    %edx,%eax
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
400313ef:	31 d2                	xor    %edx,%edx
{
400313f1:	89 e5                	mov    %esp,%ebp
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
400313f3:	84 c9                	test   %cl,%cl
400313f5:	0f 95 c2             	setne  %dl
400313f8:	e8 d2 0b 00 00       	call   40031fcf <qm_pmux_pullup_en>
400313fd:	85 c0                	test   %eax,%eax
400313ff:	74 05                	je     40031406 <pinmux_pullup+0x1a>
40031401:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
40031406:	5d                   	pop    %ebp
40031407:	c3                   	ret    

40031408 <pinmux_set>:
{
40031408:	55                   	push   %ebp
40031409:	89 d0                	mov    %edx,%eax
4003140b:	89 e5                	mov    %esp,%ebp
4003140d:	89 ca                	mov    %ecx,%edx
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
4003140f:	e8 54 0b 00 00       	call   40031f68 <qm_pmux_select>
40031414:	85 c0                	test   %eax,%eax
40031416:	74 05                	je     4003141d <pinmux_set+0x15>
40031418:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
4003141d:	5d                   	pop    %ebp
4003141e:	c3                   	ret    

4003141f <_stdin_hook_default>:
{
	_stdout_hook = hook;
}

static unsigned char _stdin_hook_default(void)
{
4003141f:	55                   	push   %ebp
	return 0;
}
40031420:	31 c0                	xor    %eax,%eax
{
40031422:	89 e5                	mov    %esp,%ebp
}
40031424:	5d                   	pop    %ebp
40031425:	c3                   	ret    

40031426 <_stdout_hook_default>:
40031426:	55                   	push   %ebp
40031427:	83 c8 ff             	or     $0xffffffff,%eax
4003142a:	89 e5                	mov    %esp,%ebp
4003142c:	5d                   	pop    %ebp
4003142d:	c3                   	ret    

4003142e <__stdout_hook_install>:
{
4003142e:	55                   	push   %ebp
	_stdout_hook = hook;
4003142f:	a3 c4 66 00 a8       	mov    %eax,0xa80066c4
{
40031434:	89 e5                	mov    %esp,%ebp
}
40031436:	5d                   	pop    %ebp
40031437:	c3                   	ret    

40031438 <_read>:
{
	_stdin_hook = hook;
}

int _read(int fd, char *buf, int nbytes)
{
40031438:	55                   	push   %ebp
40031439:	89 e5                	mov    %esp,%ebp
4003143b:	57                   	push   %edi
4003143c:	89 d7                	mov    %edx,%edi
4003143e:	56                   	push   %esi
4003143f:	89 ce                	mov    %ecx,%esi
40031441:	53                   	push   %ebx
	int i = 0;

	for (i = 0; i < nbytes; i++) {
40031442:	31 db                	xor    %ebx,%ebx
40031444:	39 f3                	cmp    %esi,%ebx
40031446:	7d 14                	jge    4003145c <_read+0x24>
		*(buf + i) = _stdin_hook();
40031448:	ff 15 c0 66 00 a8    	call   *0xa80066c0
4003144e:	88 04 1f             	mov    %al,(%edi,%ebx,1)
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
40031451:	3c 0a                	cmp    $0xa,%al
40031453:	8d 5b 01             	lea    0x1(%ebx),%ebx
40031456:	74 04                	je     4003145c <_read+0x24>
40031458:	3c 0d                	cmp    $0xd,%al
4003145a:	75 e8                	jne    40031444 <_read+0xc>
			i++;
			break;
		}
	}
	return i;
}
4003145c:	89 d8                	mov    %ebx,%eax
4003145e:	5b                   	pop    %ebx
4003145f:	5e                   	pop    %esi
40031460:	5f                   	pop    %edi
40031461:	5d                   	pop    %ebp
40031462:	c3                   	ret    

40031463 <_write>:
FUNC_ALIAS(_read, read, int);

int _write(int fd, char *buf, int nbytes)
{
40031463:	55                   	push   %ebp
40031464:	89 e5                	mov    %esp,%ebp
40031466:	57                   	push   %edi
40031467:	89 d7                	mov    %edx,%edi
40031469:	56                   	push   %esi
4003146a:	89 ce                	mov    %ecx,%esi
4003146c:	53                   	push   %ebx
	int i;

	for (i = 0; i < nbytes; i++) {
4003146d:	31 db                	xor    %ebx,%ebx
4003146f:	39 f3                	cmp    %esi,%ebx
40031471:	7d 1e                	jge    40031491 <_write+0x2e>
		if (*(buf + i) == '\n') {
40031473:	80 3c 1f 0a          	cmpb   $0xa,(%edi,%ebx,1)
40031477:	75 0b                	jne    40031484 <_write+0x21>
			_stdout_hook('\r');
40031479:	b8 0d 00 00 00       	mov    $0xd,%eax
4003147e:	ff 15 c4 66 00 a8    	call   *0xa80066c4
		}
		_stdout_hook(*(buf + i));
40031484:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
	for (i = 0; i < nbytes; i++) {
40031488:	43                   	inc    %ebx
		_stdout_hook(*(buf + i));
40031489:	ff 15 c4 66 00 a8    	call   *0xa80066c4
4003148f:	eb de                	jmp    4003146f <_write+0xc>
	}
	return nbytes;
}
40031491:	5b                   	pop    %ebx
40031492:	89 f0                	mov    %esi,%eax
40031494:	5e                   	pop    %esi
40031495:	5f                   	pop    %edi
40031496:	5d                   	pop    %ebp
40031497:	c3                   	ret    

40031498 <_isatty>:
FUNC_ALIAS(_write, write, int);

int _isatty(int file)
{
40031498:	55                   	push   %ebp
	return 1;
}
40031499:	b8 01 00 00 00       	mov    $0x1,%eax
{
4003149e:	89 e5                	mov    %esp,%ebp
}
400314a0:	5d                   	pop    %ebp
400314a1:	c3                   	ret    

400314a2 <_fstat>:
	return 0;
}
FUNC_ALIAS(_getpid, getpid, int);

int _fstat(int file, struct stat *st)
{
400314a2:	55                   	push   %ebp
	st->st_mode = S_IFCHR;
	return 0;
}
400314a3:	31 c0                	xor    %eax,%eax
{
400314a5:	89 e5                	mov    %esp,%ebp
	st->st_mode = S_IFCHR;
400314a7:	c7 42 04 00 20 00 00 	movl   $0x2000,0x4(%edx)
}
400314ae:	5d                   	pop    %ebp
400314af:	c3                   	ret    

400314b0 <_close>:
	return -1;
}
FUNC_ALIAS(_open, open, int);

int _close(int file)
{
400314b0:	55                   	push   %ebp
	return -1;
}
400314b1:	83 c8 ff             	or     $0xffffffff,%eax
{
400314b4:	89 e5                	mov    %esp,%ebp
}
400314b6:	5d                   	pop    %ebp
400314b7:	c3                   	ret    

400314b8 <_lseek>:
FUNC_ALIAS(_close, close, int);

int _lseek(int file, int ptr, int dir)
{
400314b8:	55                   	push   %ebp
	return 0;
}
400314b9:	31 c0                	xor    %eax,%eax
{
400314bb:	89 e5                	mov    %esp,%ebp
}
400314bd:	5d                   	pop    %ebp
400314be:	c3                   	ret    

400314bf <_sbrk>:
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
	void *ptr = heap_base + heap_sz;
400314bf:	8b 15 ec 68 00 a8    	mov    0xa80068ec,%edx
{
400314c5:	55                   	push   %ebp
400314c6:	89 e5                	mov    %esp,%ebp

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
400314c8:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
400314cb:	b8 00 40 01 a8       	mov    $0xa8014000,%eax
400314d0:	2d bc 85 00 a8       	sub    $0xa80085bc,%eax
400314d5:	39 c1                	cmp    %eax,%ecx
400314d7:	73 0e                	jae    400314e7 <_sbrk+0x28>
	void *ptr = heap_base + heap_sz;
400314d9:	8d 82 bc 85 00 a8    	lea    -0x57ff7a44(%edx),%eax
		heap_sz += count;
400314df:	89 0d ec 68 00 a8    	mov    %ecx,0xa80068ec
		return ptr;
400314e5:	eb 03                	jmp    400314ea <_sbrk+0x2b>
	} else {
		return (void *)-1;
400314e7:	83 c8 ff             	or     $0xffffffff,%eax
	}
}
400314ea:	5d                   	pop    %ebp
400314eb:	c3                   	ret    

400314ec <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
400314ec:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
400314ed:	31 c0                	xor    %eax,%eax
{
400314ef:	89 e5                	mov    %esp,%ebp
}
400314f1:	5d                   	pop    %ebp
400314f2:	c3                   	ret    

400314f3 <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
400314f3:	ff 02                	incl   (%edx)
{
400314f5:	55                   	push   %ebp
400314f6:	89 e5                	mov    %esp,%ebp
	return _char_out(c);
}
400314f8:	5d                   	pop    %ebp
	return _char_out(c);
400314f9:	ff 25 c8 66 00 a8    	jmp    *0xa80066c8

400314ff <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
400314ff:	55                   	push   %ebp
40031500:	89 e5                	mov    %esp,%ebp
40031502:	57                   	push   %edi
40031503:	56                   	push   %esi
40031504:	53                   	push   %ebx
40031505:	83 ec 14             	sub    $0x14,%esp
40031508:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003150b:	8b 75 0c             	mov    0xc(%ebp),%esi
4003150e:	89 55 e0             	mov    %edx,-0x20(%ebp)
40031511:	8b 45 08             	mov    0x8(%ebp),%eax
40031514:	89 75 ec             	mov    %esi,-0x14(%ebp)
40031517:	85 f6                	test   %esi,%esi
40031519:	7f 07                	jg     40031522 <_printk_dec_ulong+0x23>
4003151b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
40031522:	83 f8 01             	cmp    $0x1,%eax
40031525:	89 4d f0             	mov    %ecx,-0x10(%ebp)
40031528:	19 f6                	sbb    %esi,%esi
4003152a:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
40031531:	83 e6 f0             	and    $0xfffffff0,%esi
40031534:	31 ff                	xor    %edi,%edi
40031536:	83 c6 30             	add    $0x30,%esi
40031539:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
4003153e:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
40031541:	72 04                	jb     40031547 <_printk_dec_ulong+0x48>
40031543:	85 ff                	test   %edi,%edi
40031545:	74 1c                	je     40031563 <_printk_dec_ulong+0x64>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
40031547:	8d 4b 01             	lea    0x1(%ebx),%ecx
4003154a:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003154d:	31 d2                	xor    %edx,%edx
4003154f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
40031552:	f7 f1                	div    %ecx
40031554:	83 c0 30             	add    $0x30,%eax
40031557:	8b 55 e0             	mov    -0x20(%ebp),%edx
4003155a:	ff d7                	call   *%edi
			found_largest_digit = 1;
4003155c:	bf 01 00 00 00       	mov    $0x1,%edi
40031561:	eb 14                	jmp    40031577 <_printk_dec_ulong+0x78>
		} else if (remaining <= min_width) {
40031563:	8b 55 e8             	mov    -0x18(%ebp),%edx
40031566:	31 ff                	xor    %edi,%edi
40031568:	39 55 ec             	cmp    %edx,-0x14(%ebp)
4003156b:	7c 0a                	jl     40031577 <_printk_dec_ulong+0x78>
			out((int)(pad_zero ? '0' : ' '), ctx);
4003156d:	8b 55 e0             	mov    -0x20(%ebp),%edx
40031570:	89 f0                	mov    %esi,%eax
40031572:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
40031575:	ff d1                	call   *%ecx
		}
		remaining--;
		remainder %= (pos + 1);
40031577:	8d 4b 01             	lea    0x1(%ebx),%ecx
4003157a:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003157d:	31 d2                	xor    %edx,%edx
		remaining--;
4003157f:	ff 4d e8             	decl   -0x18(%ebp)
		remainder %= (pos + 1);
40031582:	f7 f1                	div    %ecx
40031584:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
40031587:	89 d8                	mov    %ebx,%eax
40031589:	31 d2                	xor    %edx,%edx
4003158b:	b9 0a 00 00 00       	mov    $0xa,%ecx
40031590:	f7 f1                	div    %ecx
40031592:	89 c3                	mov    %eax,%ebx
	while (pos >= 9) {
40031594:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
40031598:	75 a4                	jne    4003153e <_printk_dec_ulong+0x3f>
	}
	out((int)(remainder + 48), ctx);
4003159a:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003159d:	8b 55 e0             	mov    -0x20(%ebp),%edx
400315a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}
400315a3:	83 c4 14             	add    $0x14,%esp
	out((int)(remainder + 48), ctx);
400315a6:	83 c0 30             	add    $0x30,%eax
}
400315a9:	5b                   	pop    %ebx
400315aa:	5e                   	pop    %esi
400315ab:	5f                   	pop    %edi
400315ac:	5d                   	pop    %ebp
	out((int)(remainder + 48), ctx);
400315ad:	ff e1                	jmp    *%ecx

400315af <__printk_hook_install>:
{
400315af:	55                   	push   %ebp
	_char_out = fn;
400315b0:	a3 c8 66 00 a8       	mov    %eax,0xa80066c8
{
400315b5:	89 e5                	mov    %esp,%ebp
}
400315b7:	5d                   	pop    %ebp
400315b8:	c3                   	ret    

400315b9 <_vprintk>:
{
400315b9:	55                   	push   %ebp
400315ba:	89 e5                	mov    %esp,%ebp
400315bc:	57                   	push   %edi
400315bd:	56                   	push   %esi
400315be:	53                   	push   %ebx
400315bf:	83 ec 20             	sub    $0x20,%esp
400315c2:	89 c7                	mov    %eax,%edi
400315c4:	89 55 f0             	mov    %edx,-0x10(%ebp)
400315c7:	89 4d e0             	mov    %ecx,-0x20(%ebp)
400315ca:	8b 75 08             	mov    0x8(%ebp),%esi
	int min_width = -1;
400315cd:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	int pad_zero = 0;
400315d4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int might_format = 0; /* 1 if encountered a '%' */
400315db:	31 db                	xor    %ebx,%ebx
	while (*fmt) {
400315dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
400315e0:	0f be 00             	movsbl (%eax),%eax
400315e3:	84 c0                	test   %al,%al
400315e5:	0f 84 0d 02 00 00    	je     400317f8 <_vprintk+0x23f>
		if (!might_format) {
400315eb:	85 db                	test   %ebx,%ebx
400315ed:	75 12                	jne    40031601 <_vprintk+0x48>
			if (*fmt != '%') {
400315ef:	3c 25                	cmp    $0x25,%al
400315f1:	0f 84 e1 01 00 00    	je     400317d8 <_vprintk+0x21f>
				out((int)*fmt, ctx);
400315f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
400315fa:	ff d7                	call   *%edi
400315fc:	e9 ef 01 00 00       	jmp    400317f0 <_vprintk+0x237>
			switch (*fmt) {
40031601:	3c 68                	cmp    $0x68,%al
40031603:	0f 84 e7 01 00 00    	je     400317f0 <_vprintk+0x237>
40031609:	7f 3a                	jg     40031645 <_vprintk+0x8c>
4003160b:	3c 39                	cmp    $0x39,%al
4003160d:	7f 19                	jg     40031628 <_vprintk+0x6f>
4003160f:	3c 31                	cmp    $0x31,%al
40031611:	0f 8d 89 00 00 00    	jge    400316a0 <_vprintk+0xe7>
40031617:	3c 25                	cmp    $0x25,%al
40031619:	0f 84 96 01 00 00    	je     400317b5 <_vprintk+0x1fc>
4003161f:	3c 30                	cmp    $0x30,%al
40031621:	74 6b                	je     4003168e <_vprintk+0xd5>
40031623:	e9 97 01 00 00       	jmp    400317bf <_vprintk+0x206>
40031628:	3c 63                	cmp    $0x63,%al
4003162a:	0f 84 76 01 00 00    	je     400317a6 <_vprintk+0x1ed>
40031630:	3c 64                	cmp    $0x64,%al
40031632:	0f 84 83 00 00 00    	je     400316bb <_vprintk+0x102>
40031638:	3c 58                	cmp    $0x58,%al
4003163a:	0f 85 7f 01 00 00    	jne    400317bf <_vprintk+0x206>
40031640:	e9 c7 00 00 00       	jmp    4003170c <_vprintk+0x153>
40031645:	3c 73                	cmp    $0x73,%al
40031647:	0f 84 41 01 00 00    	je     4003178e <_vprintk+0x1d5>
4003164d:	7f 1a                	jg     40031669 <_vprintk+0xb0>
4003164f:	3c 6c                	cmp    $0x6c,%al
40031651:	0f 84 99 01 00 00    	je     400317f0 <_vprintk+0x237>
40031657:	3c 70                	cmp    $0x70,%al
40031659:	0f 84 8f 00 00 00    	je     400316ee <_vprintk+0x135>
4003165f:	3c 69                	cmp    $0x69,%al
40031661:	0f 85 58 01 00 00    	jne    400317bf <_vprintk+0x206>
40031667:	eb 52                	jmp    400316bb <_vprintk+0x102>
40031669:	3c 78                	cmp    $0x78,%al
4003166b:	0f 84 9b 00 00 00    	je     4003170c <_vprintk+0x153>
40031671:	3c 7a                	cmp    $0x7a,%al
40031673:	0f 84 77 01 00 00    	je     400317f0 <_vprintk+0x237>
40031679:	3c 75                	cmp    $0x75,%al
4003167b:	0f 85 3e 01 00 00    	jne    400317bf <_vprintk+0x206>
				_printk_dec_ulong(out, ctx, u, pad_zero,
40031681:	ff 75 ec             	pushl  -0x14(%ebp)
				unsigned long u = va_arg(
40031684:	8d 5e 04             	lea    0x4(%esi),%ebx
				_printk_dec_ulong(out, ctx, u, pad_zero,
40031687:	8b 0e                	mov    (%esi),%ecx
40031689:	ff 75 e8             	pushl  -0x18(%ebp)
4003168c:	eb 4d                	jmp    400316db <_vprintk+0x122>
				if (min_width < 0 && pad_zero == 0) {
4003168e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40031691:	c1 e9 1f             	shr    $0x1f,%ecx
40031694:	74 0a                	je     400316a0 <_vprintk+0xe7>
40031696:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
4003169a:	0f 84 4d 01 00 00    	je     400317ed <_vprintk+0x234>
				if (min_width < 0) {
400316a0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
400316a4:	79 05                	jns    400316ab <_vprintk+0xf2>
					min_width = *fmt - '0';
400316a6:	83 e8 30             	sub    $0x30,%eax
400316a9:	eb 08                	jmp    400316b3 <_vprintk+0xfa>
					min_width = 10 * min_width + *fmt - '0';
400316ab:	6b 55 ec 0a          	imul   $0xa,-0x14(%ebp),%edx
400316af:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
400316b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
400316b6:	e9 35 01 00 00       	jmp    400317f0 <_vprintk+0x237>
				long d = va_arg(ap, long);
400316bb:	8d 5e 04             	lea    0x4(%esi),%ebx
400316be:	8b 36                	mov    (%esi),%esi
				if (d < 0) {
400316c0:	85 f6                	test   %esi,%esi
400316c2:	79 0f                	jns    400316d3 <_vprintk+0x11a>
					out((int)'-', ctx);
400316c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316c7:	b8 2d 00 00 00       	mov    $0x2d,%eax
400316cc:	ff d7                	call   *%edi
					min_width--;
400316ce:	ff 4d ec             	decl   -0x14(%ebp)
					d = -d;
400316d1:	f7 de                	neg    %esi
				_printk_dec_ulong(out, ctx, d, pad_zero,
400316d3:	ff 75 ec             	pushl  -0x14(%ebp)
400316d6:	ff 75 e8             	pushl  -0x18(%ebp)
400316d9:	89 f1                	mov    %esi,%ecx
				_printk_dec_ulong(out, ctx, u, pad_zero,
400316db:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316de:	89 f8                	mov    %edi,%eax
400316e0:	e8 1a fe ff ff       	call   400314ff <_printk_dec_ulong>
400316e5:	58                   	pop    %eax
400316e6:	5a                   	pop    %edx
				unsigned long u = va_arg(
400316e7:	89 de                	mov    %ebx,%esi
400316e9:	e9 e6 00 00 00       	jmp    400317d4 <_vprintk+0x21b>
				  out('0', ctx);
400316ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316f1:	b8 30 00 00 00       	mov    $0x30,%eax
400316f6:	ff d7                	call   *%edi
				  out('x', ctx);
400316f8:	8b 55 f0             	mov    -0x10(%ebp),%edx
400316fb:	b8 78 00 00 00       	mov    $0x78,%eax
40031700:	ff d7                	call   *%edi
				  pad_zero = 1;
40031702:	89 5d e8             	mov    %ebx,-0x18(%ebp)
				  min_width = 8;
40031705:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
4003170c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
				unsigned long x = va_arg(
40031710:	8d 46 04             	lea    0x4(%esi),%eax
	int remaining = 8; /* 8 digits max */
40031713:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
				unsigned long x = va_arg(
4003171a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
4003171d:	8b 06                	mov    (%esi),%eax
4003171f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int size = sizeof(num) * 2;
40031722:	be 08 00 00 00       	mov    $0x8,%esi
40031727:	19 c0                	sbb    %eax,%eax
	int found_largest_digit = 0;
40031729:	31 d2                	xor    %edx,%edx
4003172b:	89 45 dc             	mov    %eax,-0x24(%ebp)
4003172e:	83 65 dc f0          	andl   $0xfffffff0,-0x24(%ebp)
40031732:	83 45 dc 30          	addl   $0x30,-0x24(%ebp)
		char nibble = (num >> ((size - 1) << 2) & 0xf);
40031736:	4e                   	dec    %esi
40031737:	8b 45 d8             	mov    -0x28(%ebp),%eax
4003173a:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
40031741:	d3 e8                	shr    %cl,%eax
		if (nibble || found_largest_digit || size == 1) {
40031743:	24 0f                	and    $0xf,%al
40031745:	75 0c                	jne    40031753 <_vprintk+0x19a>
40031747:	85 d2                	test   %edx,%edx
40031749:	75 08                	jne    40031753 <_vprintk+0x19a>
4003174b:	85 f6                	test   %esi,%esi
4003174d:	75 1e                	jne    4003176d <_vprintk+0x1b4>
			nibble += nibble > 9 ? 87 : 48;
4003174f:	b2 30                	mov    $0x30,%dl
40031751:	eb 0c                	jmp    4003175f <_vprintk+0x1a6>
40031753:	3c 09                	cmp    $0x9,%al
40031755:	0f 9f c2             	setg   %dl
40031758:	4a                   	dec    %edx
40031759:	83 e2 d9             	and    $0xffffffd9,%edx
4003175c:	83 c2 57             	add    $0x57,%edx
4003175f:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
40031761:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031764:	0f b6 c0             	movzbl %al,%eax
40031767:	ff d7                	call   *%edi
			found_largest_digit = 1;
40031769:	89 da                	mov    %ebx,%edx
4003176b:	eb 18                	jmp    40031785 <_vprintk+0x1cc>
		if (remaining-- <= min_width) {
4003176d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40031770:	39 45 ec             	cmp    %eax,-0x14(%ebp)
40031773:	8d 48 ff             	lea    -0x1(%eax),%ecx
40031776:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
40031779:	7c 08                	jl     40031783 <_vprintk+0x1ca>
			out((int)(pad_zero ? '0' : ' '), ctx);
4003177b:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003177e:	8b 45 dc             	mov    -0x24(%ebp),%eax
40031781:	ff d7                	call   *%edi
		if (remaining-- <= min_width) {
40031783:	31 d2                	xor    %edx,%edx
	for (; size; size--) {
40031785:	85 f6                	test   %esi,%esi
40031787:	75 ad                	jne    40031736 <_vprintk+0x17d>
				unsigned long x = va_arg(
40031789:	8b 75 d4             	mov    -0x2c(%ebp),%esi
4003178c:	eb 46                	jmp    400317d4 <_vprintk+0x21b>
				char *s = va_arg(ap, char *);
4003178e:	8d 5e 04             	lea    0x4(%esi),%ebx
40031791:	8b 36                	mov    (%esi),%esi
				while (*s)
40031793:	0f be 06             	movsbl (%esi),%eax
40031796:	84 c0                	test   %al,%al
40031798:	0f 84 49 ff ff ff    	je     400316e7 <_vprintk+0x12e>
					out((int)(*s++), ctx);
4003179e:	8b 55 f0             	mov    -0x10(%ebp),%edx
400317a1:	46                   	inc    %esi
400317a2:	ff d7                	call   *%edi
400317a4:	eb ed                	jmp    40031793 <_vprintk+0x1da>
				out(c, ctx);
400317a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
400317a9:	8b 06                	mov    (%esi),%eax
				int c = va_arg(ap, int);
400317ab:	8d 5e 04             	lea    0x4(%esi),%ebx
				out(c, ctx);
400317ae:	ff d7                	call   *%edi
400317b0:	e9 32 ff ff ff       	jmp    400316e7 <_vprintk+0x12e>
				out((int)'%', ctx);
400317b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
400317b8:	b8 25 00 00 00       	mov    $0x25,%eax
400317bd:	eb 13                	jmp    400317d2 <_vprintk+0x219>
				out((int)'%', ctx);
400317bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
400317c2:	b8 25 00 00 00       	mov    $0x25,%eax
400317c7:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
400317c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
400317cc:	0f be 00             	movsbl (%eax),%eax
400317cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
400317d2:	ff d7                	call   *%edi
			might_format = 0;
400317d4:	31 db                	xor    %ebx,%ebx
				break;
400317d6:	eb 18                	jmp    400317f0 <_vprintk+0x237>
				pad_zero = 0;
400317d8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				min_width = -1;
400317df:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				might_format = 1;
400317e6:	bb 01 00 00 00       	mov    $0x1,%ebx
400317eb:	eb 03                	jmp    400317f0 <_vprintk+0x237>
					pad_zero = 1;
400317ed:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		++fmt;
400317f0:	ff 45 e0             	incl   -0x20(%ebp)
400317f3:	e9 e5 fd ff ff       	jmp    400315dd <_vprintk+0x24>
}
400317f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
400317fb:	5b                   	pop    %ebx
400317fc:	5e                   	pop    %esi
400317fd:	5f                   	pop    %edi
400317fe:	5d                   	pop    %ebp
400317ff:	c3                   	ret    

40031800 <printk>:
{
40031800:	55                   	push   %ebp
40031801:	89 e5                	mov    %esp,%ebp
40031803:	50                   	push   %eax
	va_start(ap, fmt);
40031804:	8d 45 0c             	lea    0xc(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031807:	8d 55 fc             	lea    -0x4(%ebp),%edx
4003180a:	50                   	push   %eax
4003180b:	8b 4d 08             	mov    0x8(%ebp),%ecx
4003180e:	b8 f3 14 03 40       	mov    $0x400314f3,%eax
	struct out_context ctx = { 0 };
40031813:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
4003181a:	e8 9a fd ff ff       	call   400315b9 <_vprintk>
}
4003181f:	8b 45 fc             	mov    -0x4(%ebp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
40031822:	5a                   	pop    %edx
}
40031823:	c9                   	leave  
40031824:	c3                   	ret    

40031825 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40031825:	55                   	push   %ebp
40031826:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
40031828:	5d                   	pop    %ebp
40031829:	c3                   	ret    

4003182a <pinmux_initialize>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static int pinmux_initialize(struct device *port)
{
4003182a:	55                   	push   %ebp
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
4003182b:	b8 30 09 80 b0       	mov    $0xb0800930,%eax
{
40031830:	89 e5                	mov    %esp,%ebp
40031832:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  9, PINMUX_FUNC_C);
40031835:	c7 45 ec 55 00 0a 00 	movl   $0xa0055,-0x14(%ebp)
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
4003183c:	c7 45 f0 0a 00 00 00 	movl   $0xa,-0x10(%ebp)
	PIN_CONFIG(mux_config, 41, PINMUX_FUNC_B);
40031843:	c7 45 f4 04 00 05 00 	movl   $0x50004,-0xc(%ebp)
	PIN_CONFIG(mux_config, 63, PINMUX_FUNC_B);
4003184a:	c7 45 f8 00 40 15 40 	movl   $0x40154000,-0x8(%ebp)
	PIN_CONFIG(mux_config, 66, PINMUX_FUNC_B);
40031851:	c7 45 fc 15 00 00 00 	movl   $0x15,-0x4(%ebp)
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
40031858:	8b 94 05 bc f6 7f 4f 	mov    0x4f7ff6bc(%ebp,%eax,1),%edx
	__asm__ volatile("movl	%0, %1;\n\t"
4003185f:	89 10                	mov    %edx,(%eax)
40031861:	83 c0 04             	add    $0x4,%eax
	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
40031864:	3d 44 09 80 b0       	cmp    $0xb0800944,%eax
40031869:	75 ed                	jne    40031858 <pinmux_initialize+0x2e>
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);

	return 0;
}
4003186b:	31 c0                	xor    %eax,%eax
4003186d:	c9                   	leave  
4003186e:	c3                   	ret    

4003186f <clk_periph_enable>:

	return 0;
}

int clk_periph_enable(const clk_periph_t clocks)
{
4003186f:	55                   	push   %ebp
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
40031870:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
{
40031876:	89 e5                	mov    %esp,%ebp
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
40031878:	09 d0                	or     %edx,%eax
4003187a:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
4003187f:	31 c0                	xor    %eax,%eax
40031881:	5d                   	pop    %ebp
40031882:	c3                   	ret    

40031883 <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
40031883:	55                   	push   %ebp
40031884:	89 e5                	mov    %esp,%ebp
40031886:	56                   	push   %esi
40031887:	53                   	push   %ebx
40031888:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
4003188a:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
		qm_power_soc_restore();
	}
#endif

	if (callback[gpio]) {
40031891:	8b 0c 9d f8 68 00 a8 	mov    -0x57ff9708(,%ebx,4),%ecx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
40031898:	8b 70 40             	mov    0x40(%eax),%esi
	if (callback[gpio]) {
4003189b:	85 c9                	test   %ecx,%ecx
4003189d:	74 0b                	je     400318aa <gpio_isr+0x27>
		(*callback[gpio])(callback_data[gpio], int_status);
4003189f:	8b 04 9d f0 68 00 a8 	mov    -0x57ff9710(,%ebx,4),%eax
400318a6:	89 f2                	mov    %esi,%edx
400318a8:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
400318aa:	8b 04 9d cc 66 00 a8 	mov    -0x57ff9934(,%ebx,4),%eax
400318b1:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
}
400318b4:	5b                   	pop    %ebx
	QM_GPIO[gpio]->gpio_porta_eoi;
400318b5:	8b 40 4c             	mov    0x4c(%eax),%eax
}
400318b8:	5e                   	pop    %esi
400318b9:	5d                   	pop    %ebp
400318ba:	c3                   	ret    

400318bb <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
400318bb:	55                   	push   %ebp
	gpio_isr(QM_GPIO_0);
400318bc:	31 c0                	xor    %eax,%eax
{
400318be:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_GPIO_0_INT_VECTOR);
}
400318c0:	5d                   	pop    %ebp
	gpio_isr(QM_GPIO_0);
400318c1:	e9 bd ff ff ff       	jmp    40031883 <gpio_isr>

400318c6 <qm_aon_gpio_0_isr>:

#if (HAS_AON_GPIO)
QM_ISR_DECLARE(qm_aon_gpio_0_isr)
{
400318c6:	55                   	push   %ebp
	gpio_isr(QM_AON_GPIO_0);
400318c7:	b8 01 00 00 00       	mov    $0x1,%eax
{
400318cc:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_AON_GPIO_0_INT_VECTOR);
}
400318ce:	5d                   	pop    %ebp
	gpio_isr(QM_AON_GPIO_0);
400318cf:	e9 af ff ff ff       	jmp    40031883 <gpio_isr>

400318d4 <qm_gpio_set_config>:
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
400318d4:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
400318d5:	8b 0c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ecx
{
400318dc:	89 e5                	mov    %esp,%ebp
400318de:	56                   	push   %esi
400318df:	53                   	push   %ebx

	uint32_t mask = controller->gpio_intmask;
	controller->gpio_intmask = 0xffffffff;

	controller->gpio_swporta_ddr = cfg->direction;
400318e0:	8b 1a                	mov    (%edx),%ebx
	uint32_t mask = controller->gpio_intmask;
400318e2:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
400318e5:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)
	controller->gpio_swporta_ddr = cfg->direction;
400318ec:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
400318ef:	8b 5a 04             	mov    0x4(%edx),%ebx
400318f2:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
400318f5:	8b 5a 08             	mov    0x8(%edx),%ebx
400318f8:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
400318fb:	8b 5a 0c             	mov    0xc(%edx),%ebx
400318fe:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
40031901:	8b 5a 10             	mov    0x10(%edx),%ebx
40031904:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
40031907:	8b 5a 14             	mov    0x14(%edx),%ebx
4003190a:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
4003190d:	8b 59 60             	mov    0x60(%ecx),%ebx
40031910:	83 cb 01             	or     $0x1,%ebx
40031913:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
40031916:	8b 5a 18             	mov    0x18(%edx),%ebx
	callback_data[gpio] = cfg->callback_data;
40031919:	8b 52 1c             	mov    0x1c(%edx),%edx

	controller->gpio_intmask = mask;
4003191c:	89 71 34             	mov    %esi,0x34(%ecx)
	callback[gpio] = cfg->callback;
4003191f:	89 1c 85 f8 68 00 a8 	mov    %ebx,-0x57ff9708(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
40031926:	89 14 85 f0 68 00 a8 	mov    %edx,-0x57ff9710(,%eax,4)

	return 0;
}
4003192d:	5b                   	pop    %ebx
4003192e:	31 c0                	xor    %eax,%eax
40031930:	5e                   	pop    %esi
40031931:	5d                   	pop    %ebp
40031932:	c3                   	ret    

40031933 <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
40031933:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031934:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
4003193b:	89 e5                	mov    %esp,%ebp
4003193d:	53                   	push   %ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
4003193e:	8b 40 50             	mov    0x50(%eax),%eax
{
40031941:	89 cb                	mov    %ecx,%ebx
	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
40031943:	88 d1                	mov    %dl,%cl
40031945:	d3 e8                	shr    %cl,%eax
40031947:	83 e0 01             	and    $0x1,%eax
4003194a:	89 03                	mov    %eax,(%ebx)

	return 0;
}
4003194c:	31 c0                	xor    %eax,%eax
4003194e:	5b                   	pop    %ebx
4003194f:	5d                   	pop    %ebp
40031950:	c3                   	ret    

40031951 <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40031951:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40031952:	88 d1                	mov    %dl,%cl
{
40031954:	89 e5                	mov    %esp,%ebp
40031956:	56                   	push   %esi
40031957:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
40031958:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
4003195f:	b8 01 00 00 00       	mov    $0x1,%eax
40031964:	8b 33                	mov    (%ebx),%esi
40031966:	d3 e0                	shl    %cl,%eax
40031968:	09 f0                	or     %esi,%eax
4003196a:	89 03                	mov    %eax,(%ebx)

	return 0;
}
4003196c:	31 c0                	xor    %eax,%eax
4003196e:	5b                   	pop    %ebx
4003196f:	5e                   	pop    %esi
40031970:	5d                   	pop    %ebp
40031971:	c3                   	ret    

40031972 <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
40031972:	55                   	push   %ebp
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
40031973:	88 d1                	mov    %dl,%cl
{
40031975:	89 e5                	mov    %esp,%ebp
40031977:	56                   	push   %esi
40031978:	53                   	push   %ebx
	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
40031979:	8b 1c 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%ebx
40031980:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
40031985:	8b 33                	mov    (%ebx),%esi
40031987:	d3 c0                	rol    %cl,%eax
40031989:	21 f0                	and    %esi,%eax
4003198b:	89 03                	mov    %eax,(%ebx)

	return 0;
}
4003198d:	31 c0                	xor    %eax,%eax
4003198f:	5b                   	pop    %ebx
40031990:	5e                   	pop    %esi
40031991:	5d                   	pop    %ebp
40031992:	c3                   	ret    

40031993 <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
40031993:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
4003199a:	55                   	push   %ebp
4003199b:	89 e5                	mov    %esp,%ebp

	return 0;
}
4003199d:	5d                   	pop    %ebp
	*port = QM_GPIO[gpio]->gpio_ext_porta;
4003199e:	8b 40 50             	mov    0x50(%eax),%eax
400319a1:	89 02                	mov    %eax,(%edx)
}
400319a3:	31 c0                	xor    %eax,%eax
400319a5:	c3                   	ret    

400319a6 <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
400319a6:	8b 04 85 cc 66 00 a8 	mov    -0x57ff9934(,%eax,4),%eax
{
400319ad:	55                   	push   %ebp
400319ae:	89 e5                	mov    %esp,%ebp
	QM_GPIO[gpio]->gpio_swporta_dr = val;
400319b0:	89 10                	mov    %edx,(%eax)

	return 0;
}
400319b2:	31 c0                	xor    %eax,%eax
400319b4:	5d                   	pop    %ebp
400319b5:	c3                   	ret    

400319b6 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
400319b6:	55                   	push   %ebp
400319b7:	89 e5                	mov    %esp,%ebp
400319b9:	53                   	push   %ebx
400319ba:	51                   	push   %ecx
	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400319bb:	8b 4a 04             	mov    0x4(%edx),%ecx
	qm_uart_reg_t *const regs = QM_UART[uart];
400319be:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400319c5:	89 cb                	mov    %ecx,%ebx
400319c7:	c1 eb 10             	shr    $0x10,%ebx
	regs->lcr = 0;
400319ca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400319d1:	0f b6 db             	movzbl %bl,%ebx
	regs->lcr = QM_UART_LCR_DLAB;
400319d4:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
400319db:	89 58 04             	mov    %ebx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
400319de:	0f b6 dd             	movzbl %ch,%ebx
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
400319e1:	0f b6 c9             	movzbl %cl,%ecx
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
400319e4:	89 18                	mov    %ebx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
400319e6:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
400319ec:	8b 0a                	mov    (%edx),%ecx
400319ee:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
400319f1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
400319f8:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
400319fc:	74 09                	je     40031a07 <qm_uart_set_config+0x51>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
400319fe:	8b 50 10             	mov    0x10(%eax),%edx
40031a01:	83 ca 22             	or     $0x22,%edx
40031a04:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
40031a07:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
40031a0e:	8b 50 04             	mov    0x4(%eax),%edx
40031a11:	80 ca 80             	or     $0x80,%dl
40031a14:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
40031a17:	8b 40 14             	mov    0x14(%eax),%eax
40031a1a:	89 45 f8             	mov    %eax,-0x8(%ebp)

	return 0;
}
40031a1d:	5a                   	pop    %edx
40031a1e:	31 c0                	xor    %eax,%eax
40031a20:	5b                   	pop    %ebx
40031a21:	5d                   	pop    %ebp
40031a22:	c3                   	ret    

40031a23 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
40031a23:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
40031a24:	8b 0c 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%ecx
{
40031a2b:	89 e5                	mov    %esp,%ebp
40031a2d:	56                   	push   %esi
40031a2e:	53                   	push   %ebx
	uint32_t lsr = regs->lsr;
40031a2f:	8b 59 14             	mov    0x14(%ecx),%ebx

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
40031a32:	8b 71 1c             	mov    0x1c(%ecx),%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031a35:	89 d8                	mov    %ebx,%eax
40031a37:	83 e0 1e             	and    $0x1e,%eax
	if (regs->scr & BIT(0)) {
40031a3a:	83 e6 01             	and    $0x1,%esi
	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
40031a3d:	89 02                	mov    %eax,(%edx)
	if (regs->scr & BIT(0)) {
40031a3f:	74 0b                	je     40031a4c <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
40031a41:	8b 41 1c             	mov    0x1c(%ecx),%eax
40031a44:	83 e0 fe             	and    $0xfffffffe,%eax
40031a47:	89 41 1c             	mov    %eax,0x1c(%ecx)
40031a4a:	eb 0a                	jmp    40031a56 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
40031a4c:	f6 c3 40             	test   $0x40,%bl
40031a4f:	75 05                	jne    40031a56 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
40031a51:	83 c8 20             	or     $0x20,%eax
40031a54:	89 02                	mov    %eax,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
40031a56:	80 e3 01             	and    $0x1,%bl
40031a59:	74 03                	je     40031a5e <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
40031a5b:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
40031a5e:	5b                   	pop    %ebx
40031a5f:	31 c0                	xor    %eax,%eax
40031a61:	5e                   	pop    %esi
40031a62:	5d                   	pop    %ebp
40031a63:	c3                   	ret    

40031a64 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
40031a64:	55                   	push   %ebp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
40031a65:	8b 04 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%eax
{
40031a6c:	89 e5                	mov    %esp,%ebp

	while (regs->lsr & QM_UART_LSR_THRE) {
40031a6e:	8b 48 14             	mov    0x14(%eax),%ecx
40031a71:	80 e1 20             	and    $0x20,%cl
40031a74:	75 f8                	jne    40031a6e <qm_uart_write+0xa>
	}
	regs->rbr_thr_dll = data;
40031a76:	0f b6 d2             	movzbl %dl,%edx
40031a79:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
40031a7b:	8b 50 14             	mov    0x14(%eax),%edx
40031a7e:	80 e2 40             	and    $0x40,%dl
40031a81:	74 f8                	je     40031a7b <qm_uart_write+0x17>
	}

	return 0;
}
40031a83:	31 c0                	xor    %eax,%eax
40031a85:	5d                   	pop    %ebp
40031a86:	c3                   	ret    

40031a87 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
40031a87:	55                   	push   %ebp
40031a88:	89 e5                	mov    %esp,%ebp
40031a8a:	56                   	push   %esi
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
40031a8b:	8b 34 85 d4 66 00 a8 	mov    -0x57ff992c(,%eax,4),%esi
{
40031a92:	53                   	push   %ebx

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
		lsr = regs->lsr;
40031a93:	8b 46 14             	mov    0x14(%esi),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
40031a96:	a8 01                	test   $0x1,%al
40031a98:	74 f9                	je     40031a93 <qm_uart_read+0xc>
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
40031a9a:	83 e0 1e             	and    $0x1e,%eax
40031a9d:	89 c3                	mov    %eax,%ebx
40031a9f:	74 0d                	je     40031aae <qm_uart_read+0x27>
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
40031aa1:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		if (status) {
40031aa6:	85 c9                	test   %ecx,%ecx
40031aa8:	74 0a                	je     40031ab4 <qm_uart_read+0x2d>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
40031aaa:	89 19                	mov    %ebx,(%ecx)
40031aac:	eb 06                	jmp    40031ab4 <qm_uart_read+0x2d>
	}
	*data = regs->rbr_thr_dll;
40031aae:	8b 06                	mov    (%esi),%eax
40031ab0:	88 02                	mov    %al,(%edx)

	return 0;
40031ab2:	31 c0                	xor    %eax,%eax
}
40031ab4:	5b                   	pop    %ebx
40031ab5:	5e                   	pop    %esi
40031ab6:	5d                   	pop    %ebp
40031ab7:	c3                   	ret    

40031ab8 <read_frame>:
static dma_context_t dma_context_rx[QM_SPI_NUM];
/* DMA core being used by each SPI controller. */
static qm_dma_t dma_core[QM_SPI_NUM];

static void read_frame(const qm_spi_t spi, uint8_t *const rx_buffer)
{
40031ab8:	55                   	push   %ebp
	const qm_spi_reg_t *const controller = QM_SPI[spi];
40031ab9:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40031ac0:	8a 80 18 69 00 a8    	mov    -0x57ff96e8(%eax),%al
{
40031ac6:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031ac8:	3c 01                	cmp    $0x1,%al
40031aca:	75 07                	jne    40031ad3 <read_frame+0x1b>
		*(uint8_t *)rx_buffer = controller->dr[0];
40031acc:	8b 41 60             	mov    0x60(%ecx),%eax
40031acf:	88 02                	mov    %al,(%edx)
40031ad1:	eb 0e                	jmp    40031ae1 <read_frame+0x29>
	} else if (frame_size == 2) {
40031ad3:	3c 02                	cmp    $0x2,%al
		*(uint16_t *)rx_buffer = controller->dr[0];
40031ad5:	8b 41 60             	mov    0x60(%ecx),%eax
	} else if (frame_size == 2) {
40031ad8:	75 05                	jne    40031adf <read_frame+0x27>
		*(uint16_t *)rx_buffer = controller->dr[0];
40031ada:	66 89 02             	mov    %ax,(%edx)
40031add:	eb 02                	jmp    40031ae1 <read_frame+0x29>
	} else {
		*(uint32_t *)rx_buffer = controller->dr[0];
40031adf:	89 02                	mov    %eax,(%edx)
	}
}
40031ae1:	5d                   	pop    %ebp
40031ae2:	c3                   	ret    

40031ae3 <write_frame>:

static void write_frame(const qm_spi_t spi, const uint8_t *const tx_buffer)
{
40031ae3:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031ae4:	8b 0c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ecx
	const uint8_t frame_size = dfs[spi];
40031aeb:	8a 80 18 69 00 a8    	mov    -0x57ff96e8(%eax),%al
{
40031af1:	89 e5                	mov    %esp,%ebp

	if (frame_size == 1) {
40031af3:	3c 01                	cmp    $0x1,%al
40031af5:	75 05                	jne    40031afc <write_frame+0x19>
		controller->dr[0] = *(uint8_t *)tx_buffer;
40031af7:	0f b6 02             	movzbl (%edx),%eax
40031afa:	eb 0b                	jmp    40031b07 <write_frame+0x24>
	} else if (frame_size == 2) {
40031afc:	3c 02                	cmp    $0x2,%al
40031afe:	75 05                	jne    40031b05 <write_frame+0x22>
		controller->dr[0] = *(uint16_t *)tx_buffer;
40031b00:	0f b7 02             	movzwl (%edx),%eax
40031b03:	eb 02                	jmp    40031b07 <write_frame+0x24>
	} else {
		controller->dr[0] = *(uint32_t *)tx_buffer;
40031b05:	8b 02                	mov    (%edx),%eax
40031b07:	89 41 60             	mov    %eax,0x60(%ecx)
	}
}
40031b0a:	5d                   	pop    %ebp
40031b0b:	c3                   	ret    

40031b0c <handle_spi_overflow_interrupt>:
		controller->txftlr = 0;
	}
}

static void handle_spi_overflow_interrupt(const qm_spi_t spi)
{
40031b0c:	55                   	push   %ebp
	qm_spi_reg_t *const controller = QM_SPI[spi];
	const volatile qm_spi_async_transfer_t *transfer =
40031b0d:	8b 0c 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%ecx
{
40031b14:	89 e5                	mov    %esp,%ebp
40031b16:	56                   	push   %esi
40031b17:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031b18:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	    spi_async_transfer[spi];

	if (transfer->callback) {
40031b1f:	8b 51 10             	mov    0x10(%ecx),%edx
40031b22:	85 d2                	test   %edx,%edx
40031b24:	74 1c                	je     40031b42 <handle_spi_overflow_interrupt+0x36>
		transfer->callback(transfer->callback_data, -EIO,
40031b26:	8b 71 10             	mov    0x10(%ecx),%esi
				   QM_SPI_RX_OVERFLOW, rx_counter[spi]);
40031b29:	0f b7 94 00 1c 69 00 	movzwl -0x57ff96e4(%eax,%eax,1),%edx
40031b30:	a8 
		transfer->callback(transfer->callback_data, -EIO,
40031b31:	8b 41 14             	mov    0x14(%ecx),%eax
40031b34:	52                   	push   %edx
40031b35:	b9 02 00 00 00       	mov    $0x2,%ecx
40031b3a:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
40031b3f:	ff d6                	call   *%esi
40031b41:	58                   	pop    %eax
	}

	/* Clear RX FIFO Overflow interrupt. */
	controller->rxoicr;
40031b42:	8b 43 3c             	mov    0x3c(%ebx),%eax
	controller->imr = QM_SPI_IMR_MASK_ALL;
40031b45:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	controller->ssienr = 0;
40031b4c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
}
40031b53:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031b56:	5b                   	pop    %ebx
40031b57:	5e                   	pop    %esi
40031b58:	5d                   	pop    %ebp
40031b59:	c3                   	ret    

40031b5a <handle_spi_mst_interrupt>:

static void handle_spi_mst_interrupt(const qm_spi_t spi)
{
40031b5a:	55                   	push   %ebp
40031b5b:	89 e5                	mov    %esp,%ebp
40031b5d:	57                   	push   %edi
40031b5e:	56                   	push   %esi
40031b5f:	53                   	push   %ebx
40031b60:	83 ec 0c             	sub    $0xc,%esp
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031b63:	8b 3c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%edi
40031b6a:	89 7d f0             	mov    %edi,-0x10(%ebp)
	const volatile qm_spi_async_transfer_t *transfer =
	    spi_async_transfer[spi];
	const uint32_t int_status = controller->isr;
40031b6d:	8b 4f 30             	mov    0x30(%edi),%ecx
40031b70:	89 4d ec             	mov    %ecx,-0x14(%ebp)

	QM_ASSERT((int_status & (QM_SPI_ISR_TXOIS | QM_SPI_ISR_RXUIS)) == 0);

	/* RX FIFO Overflow interrupt. */
	if (int_status & QM_SPI_ISR_RXOIS) {
40031b73:	80 e1 08             	and    $0x8,%cl
40031b76:	74 0c                	je     40031b84 <handle_spi_mst_interrupt+0x2a>

	if (int_status & QM_SPI_ISR_TXEIS &&
	    transfer->tx_len > tx_counter[spi]) {
		handle_mst_tx_interrupt(spi);
	}
}
40031b78:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031b7b:	5b                   	pop    %ebx
40031b7c:	5e                   	pop    %esi
40031b7d:	5f                   	pop    %edi
40031b7e:	5d                   	pop    %ebp
		handle_spi_overflow_interrupt(spi);
40031b7f:	e9 88 ff ff ff       	jmp    40031b0c <handle_spi_overflow_interrupt>
40031b84:	89 c3                	mov    %eax,%ebx
	const volatile qm_spi_async_transfer_t *transfer =
40031b86:	8b 34 85 2c 69 00 a8 	mov    -0x57ff96d4(,%eax,4),%esi
	if (int_status & QM_SPI_ISR_RXFIS) {
40031b8d:	f6 45 ec 10          	testb  $0x10,-0x14(%ebp)
40031b91:	0f 84 b6 00 00 00    	je     40031c4d <handle_spi_mst_interrupt+0xf3>
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40031b97:	8b 56 04             	mov    0x4(%esi),%edx
40031b9a:	0f b7 8c 00 1c 69 00 	movzwl -0x57ff96e4(%eax,%eax,1),%ecx
40031ba1:	a8 
40031ba2:	0f b6 80 18 69 00 a8 	movzbl -0x57ff96e8(%eax),%eax
40031ba9:	0f af c8             	imul   %eax,%ecx
		rx_buffer += dfs[spi];
40031bac:	89 c7                	mov    %eax,%edi
	uint8_t *rx_buffer = transfer->rx + (rx_counter[spi] * dfs[spi]);
40031bae:	01 d1                	add    %edx,%ecx
	while (controller->rxflr) {
40031bb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031bb3:	8b 40 24             	mov    0x24(%eax),%eax
40031bb6:	85 c0                	test   %eax,%eax
40031bb8:	74 77                	je     40031c31 <handle_spi_mst_interrupt+0xd7>
		read_frame(spi, rx_buffer);
40031bba:	89 ca                	mov    %ecx,%edx
40031bbc:	89 d8                	mov    %ebx,%eax
40031bbe:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031bc1:	e8 f2 fe ff ff       	call   40031ab8 <read_frame>
		rx_counter[spi]++;
40031bc6:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
40031bcd:	a8 
40031bce:	8b 4d e8             	mov    -0x18(%ebp),%ecx
40031bd1:	40                   	inc    %eax
40031bd2:	01 f9                	add    %edi,%ecx
40031bd4:	66 89 84 1b 1c 69 00 	mov    %ax,-0x57ff96e4(%ebx,%ebx,1)
40031bdb:	a8 
		if (transfer->rx_len == rx_counter[spi]) {
40031bdc:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031be0:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
40031be7:	a8 
40031be8:	66 39 c2             	cmp    %ax,%dx
40031beb:	75 c3                	jne    40031bb0 <handle_spi_mst_interrupt+0x56>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40031bed:	8b 45 f0             	mov    -0x10(%ebp),%eax
			if (tmode[spi] == QM_SPI_TMOD_RX) {
40031bf0:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
40031bf7:	02 
40031bf8:	75 2b                	jne    40031c25 <handle_spi_mst_interrupt+0xcb>
				controller->imr = QM_SPI_IMR_MASK_ALL;
40031bfa:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
				controller->ssienr = 0;
40031c01:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				if (transfer->callback) {
40031c08:	8b 46 10             	mov    0x10(%esi),%eax
40031c0b:	85 c0                	test   %eax,%eax
40031c0d:	74 22                	je     40031c31 <handle_spi_mst_interrupt+0xd7>
					transfer->callback(
40031c0f:	8b 46 10             	mov    0x10(%esi),%eax
40031c12:	31 c9                	xor    %ecx,%ecx
					    QM_SPI_IDLE, transfer->rx_len);
40031c14:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
					transfer->callback(
40031c18:	89 c7                	mov    %eax,%edi
40031c1a:	8b 46 14             	mov    0x14(%esi),%eax
40031c1d:	52                   	push   %edx
40031c1e:	31 d2                	xor    %edx,%edx
40031c20:	ff d7                	call   *%edi
40031c22:	5a                   	pop    %edx
40031c23:	eb 0c                	jmp    40031c31 <handle_spi_mst_interrupt+0xd7>
				controller->imr &=
40031c25:	8b 40 2c             	mov    0x2c(%eax),%eax
40031c28:	8b 7d f0             	mov    -0x10(%ebp),%edi
40031c2b:	83 e0 e3             	and    $0xffffffe3,%eax
40031c2e:	89 47 2c             	mov    %eax,0x2c(%edi)
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031c31:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (frames_left <= controller->rxftlr) {
40031c35:	8b 7d f0             	mov    -0x10(%ebp),%edi
	const uint32_t frames_left = transfer->rx_len - rx_counter[spi];
40031c38:	0f b7 94 1b 1c 69 00 	movzwl -0x57ff96e4(%ebx,%ebx,1),%edx
40031c3f:	a8 
40031c40:	29 d0                	sub    %edx,%eax
	if (frames_left <= controller->rxftlr) {
40031c42:	8b 57 1c             	mov    0x1c(%edi),%edx
40031c45:	39 d0                	cmp    %edx,%eax
40031c47:	77 04                	ja     40031c4d <handle_spi_mst_interrupt+0xf3>
		controller->rxftlr = frames_left - 1;
40031c49:	48                   	dec    %eax
40031c4a:	89 47 1c             	mov    %eax,0x1c(%edi)
	if (transfer->rx_len == rx_counter[spi] &&
40031c4d:	66 8b 56 0a          	mov    0xa(%esi),%dx
40031c51:	66 8b 84 1b 1c 69 00 	mov    -0x57ff96e4(%ebx,%ebx,1),%ax
40031c58:	a8 
40031c59:	66 39 c2             	cmp    %ax,%dx
40031c5c:	75 66                	jne    40031cc4 <handle_spi_mst_interrupt+0x16a>
	    transfer->tx_len == tx_counter[spi] &&
40031c5e:	66 8b 56 08          	mov    0x8(%esi),%dx
40031c62:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
40031c69:	a8 
	if (transfer->rx_len == rx_counter[spi] &&
40031c6a:	66 39 c2             	cmp    %ax,%dx
40031c6d:	75 55                	jne    40031cc4 <handle_spi_mst_interrupt+0x16a>
	    (controller->sr & QM_SPI_SR_TFE) &&
40031c6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031c72:	8b 40 28             	mov    0x28(%eax),%eax
	    transfer->tx_len == tx_counter[spi] &&
40031c75:	a8 04                	test   $0x4,%al
40031c77:	74 4b                	je     40031cc4 <handle_spi_mst_interrupt+0x16a>
	    !(controller->sr & QM_SPI_SR_BUSY)) {
40031c79:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031c7c:	8b 40 28             	mov    0x28(%eax),%eax
	    (controller->sr & QM_SPI_SR_TFE) &&
40031c7f:	a8 01                	test   $0x1,%al
40031c81:	75 41                	jne    40031cc4 <handle_spi_mst_interrupt+0x16a>
		controller->imr = QM_SPI_IMR_MASK_ALL;
40031c83:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031c86:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
		controller->ssienr = 0;
40031c8d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (transfer->callback && tmode[spi] != QM_SPI_TMOD_RX) {
40031c94:	8b 46 10             	mov    0x10(%esi),%eax
40031c97:	85 c0                	test   %eax,%eax
40031c99:	0f 84 bd 00 00 00    	je     40031d5c <handle_spi_mst_interrupt+0x202>
40031c9f:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
40031ca6:	02 
40031ca7:	0f 84 af 00 00 00    	je     40031d5c <handle_spi_mst_interrupt+0x202>
			transfer->callback(transfer->callback_data, 0,
40031cad:	8b 5e 10             	mov    0x10(%esi),%ebx
40031cb0:	31 c9                	xor    %ecx,%ecx
					   QM_SPI_IDLE, transfer->tx_len);
40031cb2:	0f b7 56 08          	movzwl 0x8(%esi),%edx
			transfer->callback(transfer->callback_data, 0,
40031cb6:	8b 46 14             	mov    0x14(%esi),%eax
40031cb9:	52                   	push   %edx
40031cba:	31 d2                	xor    %edx,%edx
40031cbc:	ff d3                	call   *%ebx
40031cbe:	58                   	pop    %eax
40031cbf:	e9 98 00 00 00       	jmp    40031d5c <handle_spi_mst_interrupt+0x202>
	if (int_status & QM_SPI_ISR_TXEIS &&
40031cc4:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
40031cc8:	0f 84 8e 00 00 00    	je     40031d5c <handle_spi_mst_interrupt+0x202>
	    transfer->tx_len > tx_counter[spi]) {
40031cce:	66 8b 56 08          	mov    0x8(%esi),%dx
40031cd2:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
40031cd9:	a8 
	if (int_status & QM_SPI_ISR_TXEIS &&
40031cda:	66 39 c2             	cmp    %ax,%dx
40031cdd:	76 7d                	jbe    40031d5c <handle_spi_mst_interrupt+0x202>
	const volatile qm_spi_async_transfer_t *const transfer =
40031cdf:	8b 0c 9d 2c 69 00 a8 	mov    -0x57ff96d4(,%ebx,4),%ecx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031ce6:	8b 3c 9d dc 66 00 a8 	mov    -0x57ff9924(,%ebx,4),%edi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031ced:	0f b6 93 18 69 00 a8 	movzbl -0x57ff96e8(%ebx),%edx
40031cf4:	8b 31                	mov    (%ecx),%esi
		tx_buffer += dfs[spi];
40031cf6:	89 55 ec             	mov    %edx,-0x14(%ebp)
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031cf9:	0f b7 84 1b 24 69 00 	movzwl -0x57ff96dc(%ebx,%ebx,1),%eax
40031d00:	a8 
40031d01:	0f af c2             	imul   %edx,%eax
40031d04:	01 f0                	add    %esi,%eax
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031d06:	8b 77 20             	mov    0x20(%edi),%esi
	const uint8_t *tx_buffer = transfer->tx + (tx_counter[spi] * dfs[spi]);
40031d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    SPI_FIFOS_DEPTH - controller->txflr - controller->rxflr - 1;
40031d0c:	8b 47 24             	mov    0x24(%edi),%eax
40031d0f:	01 f0                	add    %esi,%eax
40031d11:	be 07 00 00 00       	mov    $0x7,%esi
40031d16:	29 c6                	sub    %eax,%esi
	while (frames > 0) {
40031d18:	85 f6                	test   %esi,%esi
40031d1a:	7e 40                	jle    40031d5c <handle_spi_mst_interrupt+0x202>
		write_frame(spi, tx_buffer);
40031d1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
40031d1f:	89 d8                	mov    %ebx,%eax
40031d21:	89 4d e8             	mov    %ecx,-0x18(%ebp)
40031d24:	e8 ba fd ff ff       	call   40031ae3 <write_frame>
		tx_counter[spi]++;
40031d29:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
40031d30:	a8 
40031d31:	8b 4d ec             	mov    -0x14(%ebp),%ecx
40031d34:	40                   	inc    %eax
40031d35:	01 4d f0             	add    %ecx,-0x10(%ebp)
		if (transfer->tx_len == tx_counter[spi]) {
40031d38:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		tx_counter[spi]++;
40031d3b:	66 89 84 1b 24 69 00 	mov    %ax,-0x57ff96dc(%ebx,%ebx,1)
40031d42:	a8 
		frames--;
40031d43:	4e                   	dec    %esi
		if (transfer->tx_len == tx_counter[spi]) {
40031d44:	66 8b 51 08          	mov    0x8(%ecx),%dx
40031d48:	66 8b 84 1b 24 69 00 	mov    -0x57ff96dc(%ebx,%ebx,1),%ax
40031d4f:	a8 
40031d50:	66 39 c2             	cmp    %ax,%dx
40031d53:	75 c3                	jne    40031d18 <handle_spi_mst_interrupt+0x1be>
			controller->txftlr = 0;
40031d55:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%edi)
}
40031d5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
40031d5f:	5b                   	pop    %ebx
40031d60:	5e                   	pop    %esi
40031d61:	5f                   	pop    %edi
40031d62:	5d                   	pop    %ebp
40031d63:	c3                   	ret    

40031d64 <qm_spi_set_config>:
		handle_slv_tx_interrupt(spi);
	}
}

int qm_spi_set_config(const qm_spi_t spi, const qm_spi_config_t *cfg)
{
40031d64:	55                   	push   %ebp
40031d65:	89 e5                	mov    %esp,%ebp
40031d67:	57                   	push   %edi
40031d68:	56                   	push   %esi
40031d69:	53                   	push   %ebx
40031d6a:	51                   	push   %ecx
	QM_CHECK(QM_SPI_SLV_0 == spi
		     ? cfg->transfer_mode != QM_SPI_TMOD_EEPROM_READ
		     : 1,
		 -EINVAL);

	if (0 != QM_SPI[spi]->ssienr) {
40031d6b:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi
40031d72:	8b 4e 08             	mov    0x8(%esi),%ecx
40031d75:	85 c9                	test   %ecx,%ecx
40031d77:	75 4d                	jne    40031dc6 <qm_spi_set_config+0x62>
	}

	qm_spi_reg_t *const controller = QM_SPI[spi];

	/* Apply the selected cfg options. */
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031d79:	8b 3a                	mov    (%edx),%edi
40031d7b:	89 7d f0             	mov    %edi,-0x10(%ebp)
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031d7e:	8b 7a 04             	mov    0x4(%edx),%edi
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031d81:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031d84:	89 f9                	mov    %edi,%ecx
40031d86:	c1 e1 08             	shl    $0x8,%ecx
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031d89:	c1 e3 10             	shl    $0x10,%ebx
40031d8c:	09 cb                	or     %ecx,%ebx
			     (cfg->bus_mode << QM_SPI_CTRLR0_SCPOL_SCPH_OFFSET);
40031d8e:	8b 4a 08             	mov    0x8(%edx),%ecx
40031d91:	c1 e1 06             	shl    $0x6,%ecx
			     (cfg->transfer_mode << QM_SPI_CTRLR0_TMOD_OFFSET) |
40031d94:	09 cb                	or     %ecx,%ebx

	/*
	 * If the device is configured as a slave, an external master will
	 * set the baud rate.
	 */
	if (QM_SPI_SLV_0 != spi) {
40031d96:	83 f8 02             	cmp    $0x2,%eax
	controller->ctrlr0 = (cfg->frame_size << QM_SPI_CTRLR0_DFS_32_OFFSET) |
40031d99:	89 1e                	mov    %ebx,(%esi)
	if (QM_SPI_SLV_0 != spi) {
40031d9b:	74 07                	je     40031da4 <qm_spi_set_config+0x40>
		controller->baudr = cfg->clk_divider;
40031d9d:	0f b7 5a 10          	movzwl 0x10(%edx),%ebx
40031da1:	89 5e 14             	mov    %ebx,0x14(%esi)
	 * - 1 byte for DFS set from 4 to 8 bits;
	 * - 2 bytes for DFS set from 9 to 16 bits;
	 * - 3 bytes for DFS set from 17 to 24 bits;
	 * - 4 bytes for DFS set from 25 to 32 bits.
	 */
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031da4:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	tmode[spi] = cfg->transfer_mode;
	frf[spi] = cfg->frame_format;
40031da7:	8b 52 0c             	mov    0xc(%edx),%edx
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031daa:	c1 e9 03             	shr    $0x3,%ecx
	tmode[spi] = cfg->transfer_mode;
40031dad:	89 3c 85 0c 69 00 a8 	mov    %edi,-0x57ff96f4(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031db4:	41                   	inc    %ecx
	frf[spi] = cfg->frame_format;
40031db5:	89 14 85 00 69 00 a8 	mov    %edx,-0x57ff9700(,%eax,4)
	dfs[spi] = (cfg->frame_size / 8) + 1;
40031dbc:	88 88 18 69 00 a8    	mov    %cl,-0x57ff96e8(%eax)

	return 0;
40031dc2:	31 c0                	xor    %eax,%eax
40031dc4:	eb 05                	jmp    40031dcb <qm_spi_set_config+0x67>
		return -EBUSY;
40031dc6:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031dcb:	5a                   	pop    %edx
40031dcc:	5b                   	pop    %ebx
40031dcd:	5e                   	pop    %esi
40031dce:	5f                   	pop    %edi
40031dcf:	5d                   	pop    %ebp
40031dd0:	c3                   	ret    

40031dd1 <qm_spi_slave_select>:
int qm_spi_slave_select(const qm_spi_t spi, const qm_spi_slave_select_t ss)
{
	QM_CHECK((spi < QM_SPI_NUM) && (spi != QM_SPI_SLV_0), -EINVAL);

	/* Check if the device reports as busy. */
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
40031dd1:	8b 04 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%eax
{
40031dd8:	55                   	push   %ebp
40031dd9:	89 e5                	mov    %esp,%ebp
	if (QM_SPI[spi]->sr & QM_SPI_SR_BUSY) {
40031ddb:	8b 48 28             	mov    0x28(%eax),%ecx
40031dde:	80 e1 01             	and    $0x1,%cl
40031de1:	75 07                	jne    40031dea <qm_spi_slave_select+0x19>
		return -EBUSY;
	}

	QM_SPI[spi]->ser = ss;
40031de3:	89 50 10             	mov    %edx,0x10(%eax)

	return 0;
40031de6:	31 c0                	xor    %eax,%eax
40031de8:	eb 05                	jmp    40031def <qm_spi_slave_select+0x1e>
		return -EBUSY;
40031dea:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
40031def:	5d                   	pop    %ebp
40031df0:	c3                   	ret    

40031df1 <qm_spi_irq_update>:
}

int qm_spi_irq_update(const qm_spi_t spi,
		      const volatile qm_spi_async_transfer_t *const xfer,
		      const qm_spi_update_t update)
{
40031df1:	55                   	push   %ebp
	QM_CHECK((update & QM_SPI_UPDATE_RX) ? (tmode[spi] != QM_SPI_TMOD_TX)
					     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
	spi_async_transfer[spi] = xfer;
40031df2:	89 14 85 2c 69 00 a8 	mov    %edx,-0x57ff96d4(,%eax,4)
{
40031df9:	89 e5                	mov    %esp,%ebp

	if (update == QM_SPI_UPDATE_RX) {
40031dfb:	83 f9 01             	cmp    $0x1,%ecx
{
40031dfe:	53                   	push   %ebx
	qm_spi_reg_t *const controller = QM_SPI[spi];
40031dff:	8b 1c 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%ebx
	if (update == QM_SPI_UPDATE_RX) {
40031e06:	75 13                	jne    40031e1b <qm_spi_irq_update+0x2a>
		rx_counter[spi] = 0;
40031e08:	66 c7 84 00 1c 69 00 	movw   $0x0,-0x57ff96e4(%eax,%eax,1)
40031e0f:	a8 00 00 
		/* Unmask RX interrupt sources. */
		controller->imr =
40031e12:	c7 43 2c 1c 00 00 00 	movl   $0x1c,0x2c(%ebx)
40031e19:	eb 33                	jmp    40031e4e <qm_spi_irq_update+0x5d>
		    QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM | QM_SPI_IMR_RXFIM;
	} else if (update == QM_SPI_UPDATE_TX) {
40031e1b:	83 f9 02             	cmp    $0x2,%ecx
40031e1e:	75 13                	jne    40031e33 <qm_spi_irq_update+0x42>
		tx_counter[spi] = 0;
40031e20:	66 c7 84 00 24 69 00 	movw   $0x0,-0x57ff96dc(%eax,%eax,1)
40031e27:	a8 00 00 
		/* Unmask TX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM;
40031e2a:	c7 43 2c 03 00 00 00 	movl   $0x3,0x2c(%ebx)
40031e31:	eb 1b                	jmp    40031e4e <qm_spi_irq_update+0x5d>
	} else {
		rx_counter[spi] = 0;
40031e33:	66 c7 84 00 1c 69 00 	movw   $0x0,-0x57ff96e4(%eax,%eax,1)
40031e3a:	a8 00 00 
		tx_counter[spi] = 0;
40031e3d:	66 c7 84 00 24 69 00 	movw   $0x0,-0x57ff96dc(%eax,%eax,1)
40031e44:	a8 00 00 
		/* Unmask both TX and RX interrupt sources. */
		controller->imr = QM_SPI_IMR_TXEIM | QM_SPI_IMR_TXOIM |
40031e47:	c7 43 2c 1f 00 00 00 	movl   $0x1f,0x2c(%ebx)
				  QM_SPI_IMR_RXUIM | QM_SPI_IMR_RXOIM |
				  QM_SPI_IMR_RXFIM;
	}

	return 0;
}
40031e4e:	31 c0                	xor    %eax,%eax
40031e50:	5b                   	pop    %ebx
40031e51:	5d                   	pop    %ebp
40031e52:	c3                   	ret    

40031e53 <qm_spi_irq_transfer>:

int qm_spi_irq_transfer(const qm_spi_t spi,
			const volatile qm_spi_async_transfer_t *const xfer)
{
40031e53:	55                   	push   %ebp
40031e54:	89 e5                	mov    %esp,%ebp
40031e56:	57                   	push   %edi
40031e57:	56                   	push   %esi
40031e58:	53                   	push   %ebx
40031e59:	51                   	push   %ecx
40031e5a:	89 c3                	mov    %eax,%ebx
	QM_CHECK(tmode[spi] == QM_SPI_TMOD_TX_RX
		     ? (xfer->tx_len == xfer->rx_len)
		     : 1,
		 -EINVAL);

	qm_spi_reg_t *const controller = QM_SPI[spi];
40031e5c:	8b 34 85 dc 66 00 a8 	mov    -0x57ff9924(,%eax,4),%esi

	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031e63:	8b 04 85 0c 69 00 a8 	mov    -0x57ff96f4(,%eax,4),%eax
40031e6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
40031e6d:	83 e8 02             	sub    $0x2,%eax
40031e70:	83 f8 01             	cmp    $0x1,%eax
{
40031e73:	89 d7                	mov    %edx,%edi
	if ((tmode[spi] == QM_SPI_TMOD_RX) ||
40031e75:	0f 96 c1             	setbe  %cl
40031e78:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
40031e7c:	0f 94 c0             	sete   %al
	qm_spi_update_t update = 0;
40031e7f:	09 c1                	or     %eax,%ecx
40031e81:	0f b6 c9             	movzbl %cl,%ecx
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_RX;
	}
	if ((tmode[spi] == QM_SPI_TMOD_TX) ||
40031e84:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
40031e88:	76 06                	jbe    40031e90 <qm_spi_irq_transfer+0x3d>
40031e8a:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
40031e8e:	75 03                	jne    40031e93 <qm_spi_irq_transfer+0x40>
	    (tmode[spi] == QM_SPI_TMOD_TX_RX) ||
	    (tmode[spi] == QM_SPI_TMOD_EEPROM_READ)) {
		update |= QM_SPI_UPDATE_TX;
40031e90:	83 c9 02             	or     $0x2,%ecx
	}

	rx_counter[spi] = 0;
	tx_counter[spi] = 0;
	qm_spi_irq_update(spi, xfer, update);
40031e93:	89 fa                	mov    %edi,%edx
40031e95:	89 d8                	mov    %ebx,%eax
	rx_counter[spi] = 0;
40031e97:	66 c7 84 1b 1c 69 00 	movw   $0x0,-0x57ff96e4(%ebx,%ebx,1)
40031e9e:	a8 00 00 
	tx_counter[spi] = 0;
40031ea1:	66 c7 84 1b 24 69 00 	movw   $0x0,-0x57ff96dc(%ebx,%ebx,1)
40031ea8:	a8 00 00 
	qm_spi_irq_update(spi, xfer, update);
40031eab:	e8 41 ff ff ff       	call   40031df1 <qm_spi_irq_update>
		 * holds how many bytes the controller solicits, minus 1.
		 * We also set the same into rxftlr, so the controller only
		 * triggers a RX_FIFO_FULL interrupt when all frames are
		 * available at the FIFO for consumption.
		 */
		if (xfer->rx_len) {
40031eb0:	66 8b 47 0a          	mov    0xa(%edi),%ax
	if (QM_SPI_SLV_0 != spi) {
40031eb4:	83 fb 02             	cmp    $0x2,%ebx
40031eb7:	74 2d                	je     40031ee6 <qm_spi_irq_transfer+0x93>
		if (xfer->rx_len) {
40031eb9:	66 85 c0             	test   %ax,%ax
40031ebc:	74 1f                	je     40031edd <qm_spi_irq_transfer+0x8a>
			controller->ctrlr1 = xfer->rx_len - 1;
40031ebe:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031ec2:	48                   	dec    %eax
40031ec3:	89 46 04             	mov    %eax,0x4(%esi)
40031ec6:	b8 05 00 00 00       	mov    $0x5,%eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
40031ecb:	66 8b 57 0a          	mov    0xa(%edi),%dx
						 ? xfer->rx_len - 1
						 : SPI_MST_DEFAULT_RX_THRESHOLD;
40031ecf:	66 83 fa 07          	cmp    $0x7,%dx
40031ed3:	77 05                	ja     40031eda <qm_spi_irq_transfer+0x87>
						 ? xfer->rx_len - 1
40031ed5:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031ed9:	48                   	dec    %eax
			controller->rxftlr = (xfer->rx_len < SPI_FIFOS_DEPTH)
40031eda:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_MST_DEFAULT_TX_THRESHOLD;
40031edd:	c7 46 18 05 00 00 00 	movl   $0x5,0x18(%esi)
40031ee4:	eb 35                	jmp    40031f1b <qm_spi_irq_transfer+0xc8>
	} else {
		if (xfer->rx_len) {
40031ee6:	66 85 c0             	test   %ax,%ax
40031ee9:	74 17                	je     40031f02 <qm_spi_irq_transfer+0xaf>
			controller->rxftlr =
			    (xfer->rx_len < SPI_SLV_DEFAULT_RX_THRESHOLD)
40031eeb:	66 8b 57 0a          	mov    0xa(%edi),%dx
40031eef:	b8 03 00 00 00       	mov    $0x3,%eax
				? xfer->rx_len - 1
				: SPI_SLV_DEFAULT_RX_THRESHOLD;
40031ef4:	66 83 fa 02          	cmp    $0x2,%dx
40031ef8:	77 05                	ja     40031eff <qm_spi_irq_transfer+0xac>
				? xfer->rx_len - 1
40031efa:	0f b7 47 0a          	movzwl 0xa(%edi),%eax
40031efe:	48                   	dec    %eax
			controller->rxftlr =
40031eff:	89 46 1c             	mov    %eax,0x1c(%esi)
		}
		controller->txftlr = SPI_SLV_DEFAULT_TX_THRESHOLD;
40031f02:	c7 46 18 04 00 00 00 	movl   $0x4,0x18(%esi)

		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031f09:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
			/* Enable MISO line. */
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031f0d:	8b 06                	mov    (%esi),%eax
		if (QM_SPI_TMOD_RX != tmode[spi]) {
40031f0f:	74 05                	je     40031f16 <qm_spi_irq_transfer+0xc3>
			controller->ctrlr0 &= ~QM_SPI_CTRLR0_SLV_OE;
40031f11:	80 e4 fb             	and    $0xfb,%ah
40031f14:	eb 03                	jmp    40031f19 <qm_spi_irq_transfer+0xc6>
		} else {
			/* Disable MISO line. */
			controller->ctrlr0 |= QM_SPI_CTRLR0_SLV_OE;
40031f16:	80 cc 04             	or     $0x4,%ah
40031f19:	89 06                	mov    %eax,(%esi)
		}
	}

	/* Enable SPI controller. */
	controller->ssienr = QM_SPI_SSIENR_SSIENR;
40031f1b:	c7 46 08 01 00 00 00 	movl   $0x1,0x8(%esi)

	if ((QM_SPI_SLV_0 != spi && QM_SPI_TMOD_RX == tmode[spi]) &&
40031f22:	83 fb 02             	cmp    $0x2,%ebx
40031f25:	74 20                	je     40031f47 <qm_spi_irq_transfer+0xf4>
40031f27:	83 3c 9d 0c 69 00 a8 	cmpl   $0x2,-0x57ff96f4(,%ebx,4)
40031f2e:	02 
40031f2f:	75 16                	jne    40031f47 <qm_spi_irq_transfer+0xf4>
40031f31:	83 3c 9d 00 69 00 a8 	cmpl   $0x0,-0x57ff9700(,%ebx,4)
40031f38:	00 
40031f39:	75 0c                	jne    40031f47 <qm_spi_irq_transfer+0xf4>
		/*
		 * In RX only, master is required to send
		 * a dummy frame in order to start the
		 * communication.
		 */
		write_frame(spi, (uint8_t *)&tx_dummy_frame);
40031f3b:	ba e0 59 03 40       	mov    $0x400359e0,%edx
40031f40:	89 d8                	mov    %ebx,%eax
40031f42:	e8 9c fb ff ff       	call   40031ae3 <write_frame>
	}

	return 0;
}
40031f47:	5a                   	pop    %edx
40031f48:	31 c0                	xor    %eax,%eax
40031f4a:	5b                   	pop    %ebx
40031f4b:	5e                   	pop    %esi
40031f4c:	5f                   	pop    %edi
40031f4d:	5d                   	pop    %ebp
40031f4e:	c3                   	ret    

40031f4f <qm_spi_master_0_isr>:

QM_ISR_DECLARE(qm_spi_master_0_isr)
{
40031f4f:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031f50:	31 c0                	xor    %eax,%eax
{
40031f52:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_0_INT_VECTOR);
}
40031f54:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_0);
40031f55:	e9 00 fc ff ff       	jmp    40031b5a <handle_spi_mst_interrupt>

40031f5a <qm_spi_master_1_isr>:

#if (QUARK_SE)
QM_ISR_DECLARE(qm_spi_master_1_isr)
{
40031f5a:	55                   	push   %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40031f5b:	b8 01 00 00 00       	mov    $0x1,%eax
{
40031f60:	89 e5                	mov    %esp,%ebp
	QM_ISR_EOI(QM_IRQ_SPI_MASTER_1_INT_VECTOR);
}
40031f62:	5d                   	pop    %ebp
	handle_spi_mst_interrupt(QM_SPI_MST_1);
40031f63:	e9 f2 fb ff ff       	jmp    40031b5a <handle_spi_mst_interrupt>

40031f68 <qm_pmux_select>:
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
	return ((pin % (32 / width)) * width);
40031f68:	89 c1                	mov    %eax,%ecx
}

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
40031f6a:	55                   	push   %ebp
	return (pin / (32 / width));
40031f6b:	c1 e8 04             	shr    $0x4,%eax
	return ((pin % (32 / width)) * width);
40031f6e:	83 e1 0f             	and    $0xf,%ecx
{
40031f71:	89 e5                	mov    %esp,%ebp
	return ((pin % (32 / width)) * width);
40031f73:	01 c9                	add    %ecx,%ecx
{
40031f75:	56                   	push   %esi
40031f76:	53                   	push   %ebx
40031f77:	8d 1c 85 00 09 80 b0 	lea    -0x4f7ff700(,%eax,4),%ebx
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
	uint32_t offs = pin_to_offset(pin, 2);

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
40031f7e:	b8 03 00 00 00       	mov    $0x3,%eax
40031f83:	d3 e0                	shl    %cl,%eax
40031f85:	8b 73 30             	mov    0x30(%ebx),%esi
40031f88:	f7 d0                	not    %eax
40031f8a:	21 f0                	and    %esi,%eax
40031f8c:	89 43 30             	mov    %eax,0x30(%ebx)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40031f8f:	8b 43 30             	mov    0x30(%ebx),%eax
40031f92:	d3 e2                	shl    %cl,%edx
40031f94:	09 c2                	or     %eax,%edx

	return 0;
}
40031f96:	31 c0                	xor    %eax,%eax
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
40031f98:	89 53 30             	mov    %edx,0x30(%ebx)
}
40031f9b:	5b                   	pop    %ebx
40031f9c:	5e                   	pop    %esi
40031f9d:	5d                   	pop    %ebp
40031f9e:	c3                   	ret    

40031f9f <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
40031f9f:	55                   	push   %ebp
40031fa0:	89 c1                	mov    %eax,%ecx
40031fa2:	89 e5                	mov    %esp,%ebp
40031fa4:	53                   	push   %ebx
	return (pin / (32 / width));
40031fa5:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031fa7:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031fac:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031faf:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031fb1:	84 d2                	test   %dl,%dl
40031fb3:	8d 14 9d 00 09 80 b0 	lea    -0x4f7ff700(,%ebx,4),%edx
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031fba:	8b 4a 20             	mov    0x20(%edx),%ecx
	if (enable == false) {
40031fbd:	75 06                	jne    40031fc5 <qm_pmux_input_en+0x26>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
40031fbf:	f7 d0                	not    %eax
40031fc1:	21 c8                	and    %ecx,%eax
40031fc3:	eb 02                	jmp    40031fc7 <qm_pmux_input_en+0x28>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
40031fc5:	09 c8                	or     %ecx,%eax
40031fc7:	89 42 20             	mov    %eax,0x20(%edx)
	}
	return 0;
}
40031fca:	31 c0                	xor    %eax,%eax
40031fcc:	5b                   	pop    %ebx
40031fcd:	5d                   	pop    %ebp
40031fce:	c3                   	ret    

40031fcf <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
40031fcf:	55                   	push   %ebp
40031fd0:	89 c1                	mov    %eax,%ecx
40031fd2:	89 e5                	mov    %esp,%ebp
40031fd4:	53                   	push   %ebx
	return (pin / (32 / width));
40031fd5:	89 c3                	mov    %eax,%ebx
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031fd7:	b8 01 00 00 00       	mov    $0x1,%eax
	return (pin / (32 / width));
40031fdc:	c1 eb 05             	shr    $0x5,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
40031fdf:	d3 e0                	shl    %cl,%eax

	if (enable == false) {
40031fe1:	84 d2                	test   %dl,%dl
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031fe3:	8b 14 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edx
	if (enable == false) {
40031fea:	75 06                	jne    40031ff2 <qm_pmux_pullup_en+0x23>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
40031fec:	f7 d0                	not    %eax
40031fee:	21 d0                	and    %edx,%eax
40031ff0:	eb 02                	jmp    40031ff4 <qm_pmux_pullup_en+0x25>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
40031ff2:	09 d0                	or     %edx,%eax
40031ff4:	89 04 9d 00 09 80 b0 	mov    %eax,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
40031ffb:	31 c0                	xor    %eax,%eax
40031ffd:	5b                   	pop    %ebx
40031ffe:	5d                   	pop    %ebp
40031fff:	c3                   	ret    

40032000 <mraa_init>:
mraa_board_t* plat = NULL;
struct _gpio _internalgpios[4];

mraa_result_t
mraa_init()
{
40032000:	55                   	push   %ebp
40032001:	89 e5                	mov    %esp,%ebp
#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
    plat = mraa_intel_arduino_101_sss();
#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
    plat = mraa_intel_d2k_crb();
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    plat = mraa_intel_quark_se_devboard();
40032003:	e8 3d 05 00 00       	call   40032545 <mraa_intel_quark_se_devboard>
#elif defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD_SS)
    plat = mraa_intel_quark_se_ss_devboard();
#endif
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
}
40032008:	5d                   	pop    %ebp
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40032009:	83 f8 01             	cmp    $0x1,%eax
    plat = mraa_intel_quark_se_devboard();
4003200c:	a3 38 69 00 a8       	mov    %eax,0xa8006938
    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
40032011:	19 c0                	sbb    %eax,%eax
40032013:	83 e0 06             	and    $0x6,%eax
}
40032016:	c3                   	ret    

40032017 <mraa_setup_mux_mapped>:
    return false;
}

mraa_result_t
mraa_setup_mux_mapped(mraa_pin_t meta)
{
40032017:	55                   	push   %ebp
    int mi;
    mraa_result_t ret;
    mraa_gpio_context mux_i = NULL;
    int last_pin = -1;
40032018:	83 c8 ff             	or     $0xffffffff,%eax
{
4003201b:	89 e5                	mov    %esp,%ebp
4003201d:	57                   	push   %edi
4003201e:	56                   	push   %esi
4003201f:	53                   	push   %ebx
40032020:	83 ec 08             	sub    $0x8,%esp
40032023:	8d 7d 08             	lea    0x8(%ebp),%edi
    mraa_gpio_context mux_i = NULL;
40032026:	31 db                	xor    %ebx,%ebx

    for (mi = 0; mi < meta.mux_total; mi++) {
40032028:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
4003202f:	0f b6 55 0a          	movzbl 0xa(%ebp),%edx
40032033:	39 55 ec             	cmp    %edx,-0x14(%ebp)
40032036:	0f 8d 8a 01 00 00    	jge    400321c6 <mraa_setup_mux_mapped+0x1af>

        switch (meta.mux[mi].pincmd) {
4003203c:	80 7f 03 05          	cmpb   $0x5,0x3(%edi)
40032040:	0f 87 6f 01 00 00    	ja     400321b5 <mraa_setup_mux_mapped+0x19e>
40032046:	0f b6 57 03          	movzbl 0x3(%edi),%edx
4003204a:	0f b6 77 04          	movzbl 0x4(%edi),%esi
                    return MRAA_ERROR_INVALID_RESOURCE;
                }
                break;

            case PINCMD_SET_MODE:
                if (meta.mux[mi].pin != last_pin) {
4003204e:	89 75 f0             	mov    %esi,-0x10(%ebp)
40032051:	39 f0                	cmp    %esi,%eax
        switch (meta.mux[mi].pincmd) {
40032053:	ff 24 95 e4 59 03 40 	jmp    *0x400359e4(,%edx,4)
                if (meta.mux[mi].pin != last_pin) {
4003205a:	74 2b                	je     40032087 <mraa_setup_mux_mapped+0x70>
                    if (mux_i != NULL) {
4003205c:	85 db                	test   %ebx,%ebx
4003205e:	74 10                	je     40032070 <mraa_setup_mux_mapped+0x59>
                        mraa_gpio_owner(mux_i, 0);
40032060:	31 d2                	xor    %edx,%edx
40032062:	89 d8                	mov    %ebx,%eax
40032064:	e8 b7 03 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40032069:	89 d8                	mov    %ebx,%eax
4003206b:	e8 cc 03 00 00       	call   4003243c <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40032070:	89 f0                	mov    %esi,%eax
40032072:	e8 dc 01 00 00       	call   40032253 <mraa_gpio_init_raw>
40032077:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40032079:	85 c0                	test   %eax,%eax
4003207b:	75 0a                	jne    40032087 <mraa_setup_mux_mapped+0x70>
                        return MRAA_ERROR_INVALID_HANDLE;
4003207d:	b8 05 00 00 00       	mov    $0x5,%eax
40032082:	e9 57 01 00 00       	jmp    400321de <mraa_setup_mux_mapped+0x1c7>
                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
40032087:	31 d2                	xor    %edx,%edx
40032089:	89 d8                	mov    %ebx,%eax
4003208b:	e8 f1 02 00 00       	call   40032381 <mraa_gpio_dir>
40032090:	e9 c2 00 00 00       	jmp    40032157 <mraa_setup_mux_mapped+0x140>
                if (meta.mux[mi].pin != last_pin) {
40032095:	0f 84 bc 00 00 00    	je     40032157 <mraa_setup_mux_mapped+0x140>
                    if (mux_i != NULL) {
4003209b:	85 db                	test   %ebx,%ebx
4003209d:	74 10                	je     400320af <mraa_setup_mux_mapped+0x98>
                        mraa_gpio_owner(mux_i, 0);
4003209f:	31 d2                	xor    %edx,%edx
400320a1:	89 d8                	mov    %ebx,%eax
400320a3:	e8 78 03 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400320a8:	89 d8                	mov    %ebx,%eax
400320aa:	e8 8d 03 00 00       	call   4003243c <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400320af:	89 f0                	mov    %esi,%eax
400320b1:	e8 9d 01 00 00       	call   40032253 <mraa_gpio_init_raw>
400320b6:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400320b8:	85 c0                	test   %eax,%eax
400320ba:	0f 85 97 00 00 00    	jne    40032157 <mraa_setup_mux_mapped+0x140>
400320c0:	eb bb                	jmp    4003207d <mraa_setup_mux_mapped+0x66>
                if (meta.mux[mi].pin != last_pin) {
400320c2:	74 21                	je     400320e5 <mraa_setup_mux_mapped+0xce>
                    if (mux_i != NULL) {
400320c4:	85 db                	test   %ebx,%ebx
400320c6:	74 10                	je     400320d8 <mraa_setup_mux_mapped+0xc1>
                        mraa_gpio_owner(mux_i, 0);
400320c8:	31 d2                	xor    %edx,%edx
400320ca:	89 d8                	mov    %ebx,%eax
400320cc:	e8 4f 03 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400320d1:	89 d8                	mov    %ebx,%eax
400320d3:	e8 64 03 00 00       	call   4003243c <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
400320d8:	89 f0                	mov    %esi,%eax
400320da:	e8 74 01 00 00       	call   40032253 <mraa_gpio_init_raw>
400320df:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
400320e1:	85 c0                	test   %eax,%eax
400320e3:	74 98                	je     4003207d <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
400320e5:	0f b6 57 05          	movzbl 0x5(%edi),%edx
400320e9:	89 d8                	mov    %ebx,%eax
400320eb:	e8 91 02 00 00       	call   40032381 <mraa_gpio_dir>
400320f0:	e9 a1 00 00 00       	jmp    40032196 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
400320f5:	74 25                	je     4003211c <mraa_setup_mux_mapped+0x105>
                    if (mux_i != NULL) {
400320f7:	85 db                	test   %ebx,%ebx
400320f9:	74 10                	je     4003210b <mraa_setup_mux_mapped+0xf4>
                        mraa_gpio_owner(mux_i, 0);
400320fb:	31 d2                	xor    %edx,%edx
400320fd:	89 d8                	mov    %ebx,%eax
400320ff:	e8 1c 03 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40032104:	89 d8                	mov    %ebx,%eax
40032106:	e8 31 03 00 00       	call   4003243c <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
4003210b:	89 f0                	mov    %esi,%eax
4003210d:	e8 41 01 00 00       	call   40032253 <mraa_gpio_init_raw>
40032112:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40032114:	85 c0                	test   %eax,%eax
40032116:	0f 84 61 ff ff ff    	je     4003207d <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
4003211c:	ba 01 00 00 00       	mov    $0x1,%edx
40032121:	eb 29                	jmp    4003214c <mraa_setup_mux_mapped+0x135>
                if (meta.mux[mi].pin != last_pin) {
40032123:	74 25                	je     4003214a <mraa_setup_mux_mapped+0x133>
                    if (mux_i != NULL) {
40032125:	85 db                	test   %ebx,%ebx
40032127:	74 10                	je     40032139 <mraa_setup_mux_mapped+0x122>
                        mraa_gpio_owner(mux_i, 0);
40032129:	31 d2                	xor    %edx,%edx
4003212b:	89 d8                	mov    %ebx,%eax
4003212d:	e8 ee 02 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40032132:	89 d8                	mov    %ebx,%eax
40032134:	e8 03 03 00 00       	call   4003243c <mraa_gpio_close>
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
40032139:	89 f0                	mov    %esi,%eax
4003213b:	e8 13 01 00 00       	call   40032253 <mraa_gpio_init_raw>
40032140:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40032142:	85 c0                	test   %eax,%eax
40032144:	0f 84 33 ff ff ff    	je     4003207d <mraa_setup_mux_mapped+0x66>
                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
4003214a:	31 d2                	xor    %edx,%edx
4003214c:	89 d8                	mov    %ebx,%eax
4003214e:	e8 2e 02 00 00       	call   40032381 <mraa_gpio_dir>
                if (ret == MRAA_SUCCESS)
40032153:	85 c0                	test   %eax,%eax
40032155:	75 43                	jne    4003219a <mraa_setup_mux_mapped+0x183>
                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
40032157:	0f b6 57 05          	movzbl 0x5(%edi),%edx
4003215b:	89 d8                	mov    %ebx,%eax
4003215d:	e8 95 02 00 00       	call   400323f7 <mraa_gpio_write>
40032162:	eb 32                	jmp    40032196 <mraa_setup_mux_mapped+0x17f>
                if (meta.mux[mi].pin != last_pin) {
40032164:	74 25                	je     4003218b <mraa_setup_mux_mapped+0x174>
                    if (mux_i != NULL) {
40032166:	85 db                	test   %ebx,%ebx
40032168:	74 10                	je     4003217a <mraa_setup_mux_mapped+0x163>
                        mraa_gpio_owner(mux_i, 0);
4003216a:	31 d2                	xor    %edx,%edx
4003216c:	89 d8                	mov    %ebx,%eax
4003216e:	e8 ad 02 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
40032173:	89 d8                	mov    %ebx,%eax
40032175:	e8 c2 02 00 00       	call   4003243c <mraa_gpio_close>
                    }
                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
4003217a:	89 f0                	mov    %esi,%eax
4003217c:	e8 d2 00 00 00       	call   40032253 <mraa_gpio_init_raw>
40032181:	89 c3                	mov    %eax,%ebx
                    if (mux_i == NULL)
40032183:	85 c0                	test   %eax,%eax
40032185:	0f 84 f2 fe ff ff    	je     4003207d <mraa_setup_mux_mapped+0x66>
                        return MRAA_ERROR_INVALID_HANDLE;
                    last_pin = meta.mux[mi].pin;
                }

                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
4003218b:	0f b6 57 05          	movzbl 0x5(%edi),%edx
4003218f:	89 d8                	mov    %ebx,%eax
40032191:	e8 9f 02 00 00       	call   40032435 <mraa_gpio_mode>

                if (ret != MRAA_SUCCESS) {
40032196:	85 c0                	test   %eax,%eax
40032198:	74 1e                	je     400321b8 <mraa_setup_mux_mapped+0x1a1>
                    if (mux_i != NULL) {
4003219a:	85 db                	test   %ebx,%ebx
4003219c:	74 10                	je     400321ae <mraa_setup_mux_mapped+0x197>
                        mraa_gpio_owner(mux_i, 0);
4003219e:	31 d2                	xor    %edx,%edx
400321a0:	89 d8                	mov    %ebx,%eax
400321a2:	e8 79 02 00 00       	call   40032420 <mraa_gpio_owner>
                        mraa_gpio_close(mux_i);
400321a7:	89 d8                	mov    %ebx,%eax
400321a9:	e8 8e 02 00 00       	call   4003243c <mraa_gpio_close>
                    return MRAA_ERROR_INVALID_RESOURCE;
400321ae:	b8 07 00 00 00       	mov    $0x7,%eax
400321b3:	eb 29                	jmp    400321de <mraa_setup_mux_mapped+0x1c7>
        switch (meta.mux[mi].pincmd) {
400321b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (mi = 0; mi < meta.mux_total; mi++) {
400321b8:	ff 45 ec             	incl   -0x14(%ebp)
400321bb:	83 c7 03             	add    $0x3,%edi
400321be:	8b 45 f0             	mov    -0x10(%ebp),%eax
400321c1:	e9 69 fe ff ff       	jmp    4003202f <mraa_setup_mux_mapped+0x18>

    if (mux_i != NULL) {
        mraa_gpio_owner(mux_i, 0);
        mraa_gpio_close(mux_i);
    }
    return MRAA_SUCCESS;
400321c6:	31 c0                	xor    %eax,%eax
    if (mux_i != NULL) {
400321c8:	85 db                	test   %ebx,%ebx
400321ca:	74 12                	je     400321de <mraa_setup_mux_mapped+0x1c7>
        mraa_gpio_owner(mux_i, 0);
400321cc:	31 d2                	xor    %edx,%edx
400321ce:	89 d8                	mov    %ebx,%eax
400321d0:	e8 4b 02 00 00       	call   40032420 <mraa_gpio_owner>
        mraa_gpio_close(mux_i);
400321d5:	89 d8                	mov    %ebx,%eax
400321d7:	e8 60 02 00 00       	call   4003243c <mraa_gpio_close>
    return MRAA_SUCCESS;
400321dc:	31 c0                	xor    %eax,%eax
}
400321de:	5a                   	pop    %edx
400321df:	59                   	pop    %ecx
400321e0:	5b                   	pop    %ebx
400321e1:	5e                   	pop    %esi
400321e2:	5f                   	pop    %edi
400321e3:	5d                   	pop    %ebp
400321e4:	c3                   	ret    

400321e5 <mraa_set_pininfo>:


// Internal functions
mraa_result_t
mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
{
400321e5:	55                   	push   %ebp
400321e6:	89 e5                	mov    %esp,%ebp
400321e8:	53                   	push   %ebx
    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
    pin_info->gpio.pinmap = zephyr_pin;
400321e9:	6b da 44             	imul   $0x44,%edx,%ebx
#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB) || defined(CONFIG_BOARD_QUARK_SE_C1000_DEVBOARD)
    pin_info->uart.pinmap = zephyr_pin;
#endif
    pin_info->pwm.pinmap = zephyr_pin;
    pin_info->gpio.mux_total = 0;
    pin_info->name = name;
400321ec:	42                   	inc    %edx
    pin_info->gpio.pinmap = zephyr_pin;
400321ed:	01 c3                	add    %eax,%ebx
    pin_info->name = name;
400321ef:	6b d2 44             	imul   $0x44,%edx,%edx
    pin_info->gpio.pinmap = zephyr_pin;
400321f2:	88 4b 4c             	mov    %cl,0x4c(%ebx)
    pin_info->uart.pinmap = zephyr_pin;
400321f5:	88 4b 7c             	mov    %cl,0x7c(%ebx)
    pin_info->pwm.pinmap = zephyr_pin;
400321f8:	88 4b 58             	mov    %cl,0x58(%ebx)
    pin_info->name = name;
400321fb:	8b 4d 08             	mov    0x8(%ebp),%ecx
    pin_info->gpio.mux_total = 0;
400321fe:	c6 43 4e 00          	movb   $0x0,0x4e(%ebx)
    pin_info->name = name;
40032202:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
    pin_info->capabilites = caps;
40032205:	8a 45 0c             	mov    0xc(%ebp),%al
40032208:	88 43 48             	mov    %al,0x48(%ebx)
    return MRAA_SUCCESS;
}
4003220b:	31 c0                	xor    %eax,%eax
4003220d:	5b                   	pop    %ebx
4003220e:	5d                   	pop    %ebp
4003220f:	c3                   	ret    

40032210 <mraa_set_board_config>:


void
mraa_set_board_config(mraa_board_t* board)
{
40032210:	55                   	push   %ebp
    memset(board, 0, sizeof(mraa_board_t));
40032211:	b9 48 0d 00 00       	mov    $0xd48,%ecx
{
40032216:	89 e5                	mov    %esp,%ebp
40032218:	53                   	push   %ebx
40032219:	89 c3                	mov    %eax,%ebx
    memset(board, 0, sizeof(mraa_board_t));
4003221b:	31 d2                	xor    %edx,%edx
4003221d:	e8 48 de ff ff       	call   4003006a <memset>
    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
40032222:	c6 03 31             	movb   $0x31,(%ebx)
    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
40032225:	c6 43 01 1f          	movb   $0x1f,0x1(%ebx)
    board->aio_count = CONFIG_MRAA_AIO_COUNT;
40032229:	c6 43 02 00          	movb   $0x0,0x2(%ebx)
    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
4003222d:	c6 43 03 02          	movb   $0x2,0x3(%ebx)
    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
40032231:	c6 43 0b 02          	movb   $0x2,0xb(%ebx)
    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
40032235:	c6 43 1e 01          	movb   $0x1,0x1e(%ebx)
}
40032239:	5b                   	pop    %ebx
4003223a:	5d                   	pop    %ebp
4003223b:	c3                   	ret    

4003223c <gpio_pin_configure>:
{
4003223c:	55                   	push   %ebp
4003223d:	89 e5                	mov    %esp,%ebp
4003223f:	53                   	push   %ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40032240:	8b 58 04             	mov    0x4(%eax),%ebx
40032243:	51                   	push   %ecx
40032244:	0f b6 d2             	movzbl %dl,%edx
40032247:	89 d1                	mov    %edx,%ecx
40032249:	31 d2                	xor    %edx,%edx
4003224b:	ff 13                	call   *(%ebx)
4003224d:	5a                   	pop    %edx
}
4003224e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032251:	c9                   	leave  
40032252:	c3                   	ret    

40032253 <mraa_gpio_init_raw>:
    return dev;
}

mraa_gpio_context
mraa_gpio_init_raw(int gpiopin)
{
40032253:	55                   	push   %ebp
40032254:	89 e5                	mov    %esp,%ebp
40032256:	56                   	push   %esi
40032257:	89 c6                	mov    %eax,%esi
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
40032259:	b8 20 00 00 00       	mov    $0x20,%eax
{
4003225e:	53                   	push   %ebx
    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
4003225f:	e8 ec 25 00 00       	call   40034850 <malloc>
40032264:	89 c3                	mov    %eax,%ebx
    if (!dev) {
40032266:	85 c0                	test   %eax,%eax
40032268:	75 13                	jne    4003227d <mraa_gpio_init_raw+0x2a>
        printf("%s: context allocation failed\n", __FUNCTION__);
4003226a:	68 c8 5a 03 40       	push   $0x40035ac8
4003226f:	68 fc 59 03 40       	push   $0x400359fc
40032274:	e8 83 27 00 00       	call   400349fc <iprintf>
40032279:	58                   	pop    %eax
4003227a:	5a                   	pop    %edx
4003227b:	eb 49                	jmp    400322c6 <mraa_gpio_init_raw+0x73>
        return NULL;
    }

    dev->phy_pin = gpiopin;
4003227d:	89 f0                	mov    %esi,%eax
4003227f:	88 43 01             	mov    %al,0x1(%ebx)
    dev->zdev = device_get_binding(GPIO_DRV_NAME);
40032282:	b8 52 59 03 40       	mov    $0x40035952,%eax
40032287:	e8 c0 1a 00 00       	call   40033d4c <device_get_binding>
4003228c:	89 43 04             	mov    %eax,0x4(%ebx)
//printf("GPIO : %s", GPIO_DRV_NAME);
    if (dev->zdev == NULL) {
4003228f:	85 c0                	test   %eax,%eax
40032291:	74 2a                	je     400322bd <mraa_gpio_init_raw+0x6a>
        free(dev);
        return NULL;
    }
    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
40032293:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
40032297:	b9 01 00 00 00       	mov    $0x1,%ecx
4003229c:	e8 9b ff ff ff       	call   4003223c <gpio_pin_configure>
    if (ret) {
400322a1:	85 c0                	test   %eax,%eax
400322a3:	74 21                	je     400322c6 <mraa_gpio_init_raw+0x73>
        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
400322a5:	0f be 53 01          	movsbl 0x1(%ebx),%edx
400322a9:	52                   	push   %edx
400322aa:	68 52 59 03 40       	push   $0x40035952
400322af:	50                   	push   %eax
400322b0:	68 1b 5a 03 40       	push   $0x40035a1b
400322b5:	e8 42 27 00 00       	call   400349fc <iprintf>
400322ba:	83 c4 10             	add    $0x10,%esp
        free(dev);
400322bd:	89 d8                	mov    %ebx,%eax
        return NULL;
400322bf:	31 db                	xor    %ebx,%ebx
        free(dev);
400322c1:	e8 9a 25 00 00       	call   40034860 <free>
    }
    return dev;
}
400322c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
400322c9:	89 d8                	mov    %ebx,%eax
400322cb:	5b                   	pop    %ebx
400322cc:	5e                   	pop    %esi
400322cd:	5d                   	pop    %ebp
400322ce:	c3                   	ret    

400322cf <mraa_gpio_init>:
{
400322cf:	55                   	push   %ebp
400322d0:	89 e5                	mov    %esp,%ebp
400322d2:	57                   	push   %edi
400322d3:	56                   	push   %esi
400322d4:	53                   	push   %ebx
400322d5:	53                   	push   %ebx
    mraa_board_t* board = plat;
400322d6:	8b 15 38 69 00 a8    	mov    0xa8006938,%edx
    if (board == NULL) {
400322dc:	85 d2                	test   %edx,%edx
400322de:	75 07                	jne    400322e7 <mraa_gpio_init+0x18>
        printf("gpio: platform not initialised\n");
400322e0:	68 3b 5a 03 40       	push   $0x40035a3b
400322e5:	eb 37                	jmp    4003231e <mraa_gpio_init+0x4f>
400322e7:	89 c3                	mov    %eax,%ebx
    if (pin < 0 || pin >= board->phy_pin_count) {
400322e9:	85 c0                	test   %eax,%eax
400322eb:	78 07                	js     400322f4 <mraa_gpio_init+0x25>
400322ed:	0f b6 02             	movzbl (%edx),%eax
400322f0:	39 c3                	cmp    %eax,%ebx
400322f2:	7c 11                	jl     40032305 <mraa_gpio_init+0x36>
        printf("gpio: pin %i beyond platform definition\n", pin);
400322f4:	53                   	push   %ebx
400322f5:	68 5b 5a 03 40       	push   $0x40035a5b
400322fa:	e8 fd 26 00 00       	call   400349fc <iprintf>
400322ff:	5a                   	pop    %edx
40032300:	59                   	pop    %ecx
        return NULL;
40032301:	31 c0                	xor    %eax,%eax
40032303:	eb 74                	jmp    40032379 <mraa_gpio_init+0xaa>
    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
40032305:	b8 59 59 03 40       	mov    $0x40035959,%eax
4003230a:	89 55 f0             	mov    %edx,-0x10(%ebp)
4003230d:	e8 3a 1a 00 00       	call   40033d4c <device_get_binding>
    if (pinmux_dev == NULL) {
40032312:	8b 55 f0             	mov    -0x10(%ebp),%edx
40032315:	85 c0                	test   %eax,%eax
40032317:	75 0d                	jne    40032326 <mraa_gpio_init+0x57>
        printf("Failed to get binding for pinmux\n");
40032319:	68 84 5a 03 40       	push   $0x40035a84
4003231e:	e8 d9 26 00 00       	call   400349fc <iprintf>
40032323:	58                   	pop    %eax
40032324:	eb db                	jmp    40032301 <mraa_gpio_init+0x32>
    if (board->pins[pin].capabilites.gpio != 1) {
40032326:	6b f3 44             	imul   $0x44,%ebx,%esi
40032329:	01 d6                	add    %edx,%esi
4003232b:	f6 46 48 02          	testb  $0x2,0x48(%esi)
4003232f:	75 08                	jne    40032339 <mraa_gpio_init+0x6a>
        printf("gpio: pin %i not capable of gpio\n", pin);
40032331:	53                   	push   %ebx
40032332:	68 a6 5a 03 40       	push   $0x40035aa6
40032337:	eb c1                	jmp    400322fa <mraa_gpio_init+0x2b>
    if (board->pins[pin].gpio.mux_total > 0) {
40032339:	80 7e 4e 00          	cmpb   $0x0,0x4e(%esi)
4003233d:	75 15                	jne    40032354 <mraa_gpio_init+0x85>
    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
4003233f:	6b c3 44             	imul   $0x44,%ebx,%eax
40032342:	0f b6 44 02 4c       	movzbl 0x4c(%edx,%eax,1),%eax
40032347:	e8 07 ff ff ff       	call   40032253 <mraa_gpio_init_raw>
    if (dev) {
4003234c:	85 c0                	test   %eax,%eax
4003234e:	74 29                	je     40032379 <mraa_gpio_init+0xaa>
        dev->pin = pin;
40032350:	88 18                	mov    %bl,(%eax)
40032352:	eb 25                	jmp    40032379 <mraa_gpio_init+0xaa>
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40032354:	83 ec 0c             	sub    $0xc,%esp
40032357:	83 c6 4c             	add    $0x4c,%esi
4003235a:	89 e7                	mov    %esp,%edi
4003235c:	b9 03 00 00 00       	mov    $0x3,%ecx
40032361:	89 55 f0             	mov    %edx,-0x10(%ebp)
40032364:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
40032366:	e8 ac fc ff ff       	call   40032017 <mraa_setup_mux_mapped>
4003236b:	83 c4 0c             	add    $0xc,%esp
4003236e:	89 c1                	mov    %eax,%ecx
40032370:	8b 55 f0             	mov    -0x10(%ebp),%edx
            return NULL;
40032373:	31 c0                	xor    %eax,%eax
        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
40032375:	85 c9                	test   %ecx,%ecx
40032377:	74 c6                	je     4003233f <mraa_gpio_init+0x70>
}
40032379:	8d 65 f4             	lea    -0xc(%ebp),%esp
4003237c:	5b                   	pop    %ebx
4003237d:	5e                   	pop    %esi
4003237e:	5f                   	pop    %edi
4003237f:	5d                   	pop    %ebp
40032380:	c3                   	ret    

40032381 <mraa_gpio_dir>:

mraa_result_t
mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
{
40032381:	55                   	push   %ebp
    int flags = 0;
    uint32_t value = 0;
    switch (dir) {
40032382:	83 fa 01             	cmp    $0x1,%edx
{
40032385:	89 e5                	mov    %esp,%ebp
40032387:	57                   	push   %edi
40032388:	56                   	push   %esi
40032389:	53                   	push   %ebx
    switch (dir) {
4003238a:	74 0e                	je     4003239a <mraa_gpio_dir+0x19>
4003238c:	72 19                	jb     400323a7 <mraa_gpio_dir+0x26>
4003238e:	83 fa 02             	cmp    $0x2,%edx
40032391:	74 0d                	je     400323a0 <mraa_gpio_dir+0x1f>
40032393:	83 fa 03             	cmp    $0x3,%edx
40032396:	75 52                	jne    400323ea <mraa_gpio_dir+0x69>
40032398:	eb 0d                	jmp    400323a7 <mraa_gpio_dir+0x26>
    uint32_t value = 0;
4003239a:	31 ff                	xor    %edi,%edi
        case MRAA_GPIO_OUT:
            flags = GPIO_DIR_OUT;
            break;
        case MRAA_GPIO_IN:
            flags = GPIO_DIR_IN;
4003239c:	31 c9                	xor    %ecx,%ecx
4003239e:	eb 0e                	jmp    400323ae <mraa_gpio_dir+0x2d>
            break;
        case MRAA_GPIO_OUT_HIGH:
            flags = GPIO_DIR_OUT;
            value = 1;
400323a0:	bf 01 00 00 00       	mov    $0x1,%edi
400323a5:	eb 02                	jmp    400323a9 <mraa_gpio_dir+0x28>
    uint32_t value = 0;
400323a7:	31 ff                	xor    %edi,%edi
            flags = GPIO_DIR_OUT;
400323a9:	b9 01 00 00 00       	mov    $0x1,%ecx
400323ae:	89 d3                	mov    %edx,%ebx
400323b0:	89 c6                	mov    %eax,%esi
            value = 0;
            break;
        default:
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
    }
    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
400323b2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
400323b6:	8b 40 04             	mov    0x4(%eax),%eax
400323b9:	e8 7e fe ff ff       	call   4003223c <gpio_pin_configure>
400323be:	85 c0                	test   %eax,%eax
400323c0:	74 07                	je     400323c9 <mraa_gpio_dir+0x48>
        return MRAA_ERROR_UNSPECIFIED;
400323c2:	b8 63 00 00 00       	mov    $0x63,%eax
400323c7:	eb 26                	jmp    400323ef <mraa_gpio_dir+0x6e>
    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
400323c9:	83 eb 02             	sub    $0x2,%ebx
400323cc:	83 fb 01             	cmp    $0x1,%ebx
400323cf:	77 15                	ja     400323e6 <mraa_gpio_dir+0x65>
        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
400323d1:	8b 46 04             	mov    0x4(%esi),%eax
	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
400323d4:	31 d2                	xor    %edx,%edx
400323d6:	0f be 4e 01          	movsbl 0x1(%esi),%ecx
400323da:	8b 58 04             	mov    0x4(%eax),%ebx
400323dd:	57                   	push   %edi
400323de:	ff 53 04             	call   *0x4(%ebx)
400323e1:	5a                   	pop    %edx
400323e2:	85 c0                	test   %eax,%eax
400323e4:	75 dc                	jne    400323c2 <mraa_gpio_dir+0x41>
            return MRAA_ERROR_UNSPECIFIED;
    }
    return MRAA_SUCCESS;
400323e6:	31 c0                	xor    %eax,%eax
400323e8:	eb 05                	jmp    400323ef <mraa_gpio_dir+0x6e>
            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
400323ea:	b8 01 00 00 00       	mov    $0x1,%eax
}
400323ef:	8d 65 f4             	lea    -0xc(%ebp),%esp
400323f2:	5b                   	pop    %ebx
400323f3:	5e                   	pop    %esi
400323f4:	5f                   	pop    %edi
400323f5:	5d                   	pop    %ebp
400323f6:	c3                   	ret    

400323f7 <mraa_gpio_write>:
        return (int) value;
}

mraa_result_t
mraa_gpio_write(mraa_gpio_context dev, int value)
{
400323f7:	55                   	push   %ebp
400323f8:	89 e5                	mov    %esp,%ebp
400323fa:	56                   	push   %esi
400323fb:	53                   	push   %ebx
    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
400323fc:	8b 58 04             	mov    0x4(%eax),%ebx
400323ff:	0f be 48 01          	movsbl 0x1(%eax),%ecx
40032403:	8b 73 04             	mov    0x4(%ebx),%esi
40032406:	89 d8                	mov    %ebx,%eax
40032408:	52                   	push   %edx
40032409:	31 d2                	xor    %edx,%edx
4003240b:	ff 56 04             	call   *0x4(%esi)
4003240e:	5a                   	pop    %edx
        return MRAA_ERROR_UNSPECIFIED;
    return MRAA_SUCCESS;
4003240f:	83 f8 01             	cmp    $0x1,%eax
40032412:	19 c0                	sbb    %eax,%eax
}
40032414:	8d 65 f8             	lea    -0x8(%ebp),%esp
    return MRAA_SUCCESS;
40032417:	f7 d0                	not    %eax
}
40032419:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
4003241a:	83 e0 63             	and    $0x63,%eax
}
4003241d:	5e                   	pop    %esi
4003241e:	5d                   	pop    %ebp
4003241f:	c3                   	ret    

40032420 <mraa_gpio_owner>:
}


mraa_result_t
mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
{
40032420:	55                   	push   %ebp
    if (dev == NULL) {
40032421:	85 c0                	test   %eax,%eax
{
40032423:	89 e5                	mov    %esp,%ebp
    if (dev == NULL) {
40032425:	74 07                	je     4003242e <mraa_gpio_owner+0xe>
        return MRAA_ERROR_INVALID_RESOURCE;
    }
    dev->owner = own;
40032427:	88 50 14             	mov    %dl,0x14(%eax)
    return MRAA_SUCCESS;
4003242a:	31 c0                	xor    %eax,%eax
4003242c:	eb 05                	jmp    40032433 <mraa_gpio_owner+0x13>
        return MRAA_ERROR_INVALID_RESOURCE;
4003242e:	b8 07 00 00 00       	mov    $0x7,%eax
}
40032433:	5d                   	pop    %ebp
40032434:	c3                   	ret    

40032435 <mraa_gpio_mode>:

mraa_result_t
mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
{
40032435:	55                   	push   %ebp
    return MRAA_SUCCESS;
}
40032436:	31 c0                	xor    %eax,%eax
{
40032438:	89 e5                	mov    %esp,%ebp
}
4003243a:	5d                   	pop    %ebp
4003243b:	c3                   	ret    

4003243c <mraa_gpio_close>:
    return dev->pin;
}

mraa_result_t
mraa_gpio_close(mraa_gpio_context dev)
{
4003243c:	55                   	push   %ebp
4003243d:	89 e5                	mov    %esp,%ebp
    free(dev);
4003243f:	e8 1c 24 00 00       	call   40034860 <free>

    return MRAA_SUCCESS;
}
40032444:	31 c0                	xor    %eax,%eax
40032446:	5d                   	pop    %ebp
40032447:	c3                   	ret    

40032448 <spi_configure>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int spi_configure(struct device *dev,
				struct spi_config *config)
{
40032448:	55                   	push   %ebp
	const struct spi_driver_api *api = dev->driver_api;

	return api->configure(dev, config);
40032449:	8b 48 04             	mov    0x4(%eax),%ecx
{
4003244c:	89 e5                	mov    %esp,%ebp
}
4003244e:	5d                   	pop    %ebp
	return api->configure(dev, config);
4003244f:	8b 09                	mov    (%ecx),%ecx
40032451:	ff e1                	jmp    *%ecx

40032453 <spi_transceive>:
 * @retval Negative errno code if failure.
 */
static inline int spi_transceive(struct device *dev,
			  const void *tx_buf, uint32_t tx_buf_len,
			  void *rx_buf, uint32_t rx_buf_len)
{
40032453:	55                   	push   %ebp
40032454:	89 e5                	mov    %esp,%ebp
40032456:	53                   	push   %ebx
	const struct spi_driver_api *api = dev->driver_api;

	return api->transceive(dev, tx_buf, tx_buf_len, rx_buf, rx_buf_len);
40032457:	8b 58 04             	mov    0x4(%eax),%ebx
4003245a:	ff 75 0c             	pushl  0xc(%ebp)
4003245d:	ff 75 08             	pushl  0x8(%ebp)
40032460:	ff 53 08             	call   *0x8(%ebx)
40032463:	5a                   	pop    %edx
40032464:	59                   	pop    %ecx
}
40032465:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032468:	c9                   	leave  
40032469:	c3                   	ret    

4003246a <mraa_spi_init>:

typedef struct spi_config* spi_config_ptr;

mraa_spi_context
mraa_spi_init(int bus)
{
4003246a:	55                   	push   %ebp
4003246b:	89 e5                	mov    %esp,%ebp
4003246d:	56                   	push   %esi
4003246e:	89 c6                	mov    %eax,%esi
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40032470:	b8 10 00 00 00       	mov    $0x10,%eax
{
40032475:	53                   	push   %ebx
    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
40032476:	e8 d5 23 00 00       	call   40034850 <malloc>
4003247b:	89 c3                	mov    %eax,%ebx
    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);

    dev->pinmux_dev = pinmux_dev;
#endif

    dev->busnum = bus;
4003247d:	89 f0                	mov    %esi,%eax
4003247f:	88 03                	mov    %al,(%ebx)
    dev->zdev = device_get_binding(SPI_DRV_NAME);
40032481:	b8 45 59 03 40       	mov    $0x40035945,%eax
40032486:	e8 c1 18 00 00       	call   40033d4c <device_get_binding>
4003248b:	89 43 08             	mov    %eax,0x8(%ebx)
    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
4003248e:	b8 08 00 00 00       	mov    $0x8,%eax
40032493:	e8 b8 23 00 00       	call   40034850 <malloc>
40032498:	89 c6                	mov    %eax,%esi
    // only default settings, can be changed by using the other functions provided
    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
4003249a:	c7 00 83 00 00 00    	movl   $0x83,(%eax)
    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
400324a0:	c7 40 04 80 00 00 00 	movl   $0x80,0x4(%eax)
    dev->config = conf;

    if (spi_configure(dev->zdev, dev->config) != 0) {
400324a7:	89 f2                	mov    %esi,%edx
    dev->config = conf;
400324a9:	89 43 04             	mov    %eax,0x4(%ebx)
    if (spi_configure(dev->zdev, dev->config) != 0) {
400324ac:	8b 43 08             	mov    0x8(%ebx),%eax
400324af:	e8 94 ff ff ff       	call   40032448 <spi_configure>
400324b4:	85 c0                	test   %eax,%eax
400324b6:	74 1d                	je     400324d5 <mraa_spi_init+0x6b>
        printf("Unable to configure the SPI Driver\n");
400324b8:	68 db 5a 03 40       	push   $0x40035adb
400324bd:	e8 3a 25 00 00       	call   400349fc <iprintf>
400324c2:	58                   	pop    %eax
        free(conf);
400324c3:	89 f0                	mov    %esi,%eax
400324c5:	e8 96 23 00 00       	call   40034860 <free>
        free(dev);
400324ca:	89 d8                	mov    %ebx,%eax
400324cc:	e8 8f 23 00 00       	call   40034860 <free>
        return NULL;
400324d1:	31 db                	xor    %ebx,%ebx
400324d3:	eb 14                	jmp    400324e9 <mraa_spi_init+0x7f>
    }

    spi_slave_select(dev->zdev, SPI_SLAVE);
400324d5:	8b 43 08             	mov    0x8(%ebx),%eax
	if (!api->slave_select) {
400324d8:	8b 50 04             	mov    0x4(%eax),%edx
400324db:	8b 4a 04             	mov    0x4(%edx),%ecx
400324de:	85 c9                	test   %ecx,%ecx
400324e0:	74 07                	je     400324e9 <mraa_spi_init+0x7f>
	return api->slave_select(dev, slave);
400324e2:	ba 01 00 00 00       	mov    $0x1,%edx
400324e7:	ff d1                	call   *%ecx

    return dev;
}
400324e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
400324ec:	89 d8                	mov    %ebx,%eax
400324ee:	5b                   	pop    %ebx
400324ef:	5e                   	pop    %esi
400324f0:	5d                   	pop    %ebp
400324f1:	c3                   	ret    

400324f2 <mraa_spi_frequency>:

mraa_result_t
mraa_spi_frequency(mraa_spi_context dev, int hz)
{
    uint32_t freq = 0;
    if (hz > 0) {
400324f2:	85 d2                	test   %edx,%edx
400324f4:	7e 2f                	jle    40032525 <mraa_spi_frequency+0x33>
{
400324f6:	55                   	push   %ebp
400324f7:	89 d1                	mov    %edx,%ecx
400324f9:	89 e5                	mov    %esp,%ebp
400324fb:	56                   	push   %esi
400324fc:	53                   	push   %ebx
400324fd:	89 c3                	mov    %eax,%ebx
        freq = sys_clock_hw_cycles_per_sec / hz;
    } else {
        return MRAA_ERROR_INVALID_PARAMETER;
    }

    dev->config->max_sys_freq = freq;
400324ff:	8b 70 04             	mov    0x4(%eax),%esi
        freq = sys_clock_hw_cycles_per_sec / hz;
40032502:	b8 00 48 e8 01       	mov    $0x1e84800,%eax
40032507:	99                   	cltd   
40032508:	f7 f9                	idiv   %ecx
    dev->config->max_sys_freq = freq;
4003250a:	89 46 04             	mov    %eax,0x4(%esi)
    if (spi_configure(dev->zdev, dev->config) != 0) {
4003250d:	89 f2                	mov    %esi,%edx
4003250f:	8b 43 08             	mov    0x8(%ebx),%eax
40032512:	e8 31 ff ff ff       	call   40032448 <spi_configure>
        return MRAA_ERROR_UNSPECIFIED;
    }

    return MRAA_SUCCESS;
}
40032517:	5b                   	pop    %ebx
    return MRAA_SUCCESS;
40032518:	83 f8 01             	cmp    $0x1,%eax
}
4003251b:	5e                   	pop    %esi
    return MRAA_SUCCESS;
4003251c:	19 c0                	sbb    %eax,%eax
}
4003251e:	5d                   	pop    %ebp
    return MRAA_SUCCESS;
4003251f:	f7 d0                	not    %eax
40032521:	83 e0 63             	and    $0x63,%eax
}
40032524:	c3                   	ret    
        return MRAA_ERROR_INVALID_PARAMETER;
40032525:	b8 04 00 00 00       	mov    $0x4,%eax
4003252a:	c3                   	ret    

4003252b <mraa_spi_transfer_buf>:
    return MRAA_SUCCESS;
}

mraa_result_t
mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
{
4003252b:	55                   	push   %ebp
4003252c:	89 e5                	mov    %esp,%ebp
4003252e:	53                   	push   %ebx
    mraa_result_t ret;
//printf("data %x %x\n", data[0], data[1]);
//k_busy_wait(1000);
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
4003252f:	8b 40 08             	mov    0x8(%eax),%eax
{
40032532:	8b 5d 08             	mov    0x8(%ebp),%ebx
    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
40032535:	53                   	push   %ebx
40032536:	51                   	push   %ecx
40032537:	89 d9                	mov    %ebx,%ecx
40032539:	e8 15 ff ff ff       	call   40032453 <spi_transceive>
4003253e:	5a                   	pop    %edx
4003253f:	59                   	pop    %ecx

    return ret;
}
40032540:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40032543:	c9                   	leave  
40032544:	c3                   	ret    

40032545 <mraa_intel_quark_se_devboard>:
#include "mraa/gpio.h"

static mraa_board_t _board;

mraa_board_t* mraa_intel_quark_se_devboard()
{
40032545:	55                   	push   %ebp
    mraa_board_t* b = &_board;
    mraa_set_board_config(b);
40032546:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
{
4003254b:	89 e5                	mov    %esp,%ebp
4003254d:	57                   	push   %edi
4003254e:	56                   	push   %esi
4003254f:	53                   	push   %ebx
40032550:	83 ec 10             	sub    $0x10,%esp
    mraa_set_board_config(b);
40032553:	e8 b8 fc ff ff       	call   40032210 <mraa_set_board_config>
b->phy_pin_count = 94;
    //b->platform_type = MRAA_INTEL_QUARK_SE_DEVBOARD;

// header - J14
#if 1
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032558:	b9 01 00 00 00       	mov    $0x1,%ecx
4003255d:	ba 01 00 00 00       	mov    $0x1,%edx
40032562:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032567:	6a 00                	push   $0x0
    b->platform_name = "Quark SE Devboard/C1000 x86";
40032569:	c7 05 7c 69 00 a8 ff 	movl   $0x40035aff,0xa800697c
40032570:	5a 03 40 
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032573:	68 1b 5b 03 40       	push   $0x40035b1b
b->phy_pin_count = 94;
40032578:	c6 05 40 69 00 a8 5e 	movb   $0x5e,0xa8006940
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003257f:	e8 61 fc ff ff       	call   400321e5 <mraa_set_pininfo>
40032584:	5a                   	pop    %edx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
40032585:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  1,  1, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003258a:	59                   	pop    %ecx
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
4003258b:	ba 02 00 00 00       	mov    $0x2,%edx
40032590:	b9 02 00 00 00       	mov    $0x2,%ecx
40032595:	6a 00                	push   $0x0
40032597:	68 1b 5b 03 40       	push   $0x40035b1b
4003259c:	e8 44 fc ff ff       	call   400321e5 <mraa_set_pininfo>
400325a1:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325a2:	b9 1f 00 00 00       	mov    $0x1f,%ecx
400325a7:	8a 1d 80 58 03 40    	mov    0x40035880,%bl
400325ad:	ba 03 00 00 00       	mov    $0x3,%edx
400325b2:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  2,  2, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });    
400325b7:	5e                   	pop    %esi
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325b8:	53                   	push   %ebx
400325b9:	68 23 5b 03 40       	push   $0x40035b23
400325be:	e8 22 fc ff ff       	call   400321e5 <mraa_set_pininfo>
400325c3:	5f                   	pop    %edi
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325c4:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  3,  31, "AP_UART0_TXD_GPIO31",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325c6:	58                   	pop    %eax
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325c7:	ba 04 00 00 00       	mov    $0x4,%edx
400325cc:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325d1:	53                   	push   %ebx
400325d2:	68 37 5b 03 40       	push   $0x40035b37
400325d7:	e8 09 fc ff ff       	call   400321e5 <mraa_set_pininfo>
400325dc:	58                   	pop    %eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325dd:	b9 1f 00 00 00       	mov    $0x1f,%ecx
    mraa_set_pininfo(b,  4,  0, "ARDUINO_IO_1_UART_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325e2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325e3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400325e8:	ba 05 00 00 00       	mov    $0x5,%edx
400325ed:	53                   	push   %ebx
400325ee:	68 4d 5b 03 40       	push   $0x40035b4d
400325f3:	e8 ed fb ff ff       	call   400321e5 <mraa_set_pininfo>
400325f8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
400325f9:	ba 06 00 00 00       	mov    $0x6,%edx
400325fe:	b9 12 00 00 00       	mov    $0x12,%ecx
40032603:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  5,  31, "AP_UART0_RXD_ADC18",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032608:	5e                   	pop    %esi
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032609:	53                   	push   %ebx
4003260a:	68 60 5b 03 40       	push   $0x40035b60
4003260f:	e8 d1 fb ff ff       	call   400321e5 <mraa_set_pininfo>
40032614:	5f                   	pop    %edi
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032615:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  6,  18, "ARDUINO_IO_0_UART_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003261a:	58                   	pop    %eax
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003261b:	ba 07 00 00 00       	mov    $0x7,%edx
40032620:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032625:	53                   	push   %ebx
40032626:	68 76 5b 03 40       	push   $0x40035b76
4003262b:	e8 b5 fb ff ff       	call   400321e5 <mraa_set_pininfo>
40032630:	58                   	pop    %eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032631:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  7,  2, "AP_SPI1_SS_CS2_N_UART0_CTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032636:	5a                   	pop    %edx
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032637:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003263c:	ba 08 00 00 00       	mov    $0x8,%edx
40032641:	53                   	push   %ebx
40032642:	68 93 5b 03 40       	push   $0x40035b93
40032647:	e8 99 fb ff ff       	call   400321e5 <mraa_set_pininfo>
4003264c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003264d:	ba 09 00 00 00       	mov    $0x9,%edx
40032652:	b9 03 00 00 00       	mov    $0x3,%ecx
40032657:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  8,  8, "ARDUINO_CTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003265c:	5e                   	pop    %esi
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003265d:	53                   	push   %ebx
4003265e:	68 9f 5b 03 40       	push   $0x40035b9f
40032663:	e8 7d fb ff ff       	call   400321e5 <mraa_set_pininfo>
40032668:	5f                   	pop    %edi
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
40032669:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  9,  3, "AP_SPI1_SS_CS3_N_UART0_RTS_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003266e:	58                   	pop    %eax
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003266f:	ba 0a 00 00 00       	mov    $0xa,%edx
40032674:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032679:	53                   	push   %ebx
4003267a:	68 bc 5b 03 40       	push   $0x40035bbc
4003267f:	e8 61 fb ff ff       	call   400321e5 <mraa_set_pininfo>
40032684:	58                   	pop    %eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032685:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  10, 9, "ARDUINO_RTS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });  // defaults to UART
4003268a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003268b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032690:	ba 0b 00 00 00       	mov    $0xb,%edx
40032695:	6a 00                	push   $0x0
40032697:	68 c8 5b 03 40       	push   $0x40035bc8
4003269c:	e8 44 fb ff ff       	call   400321e5 <mraa_set_pininfo>
400326a1:	59                   	pop    %ecx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400326a2:	ba 0c 00 00 00       	mov    $0xc,%edx
400326a7:	b9 0c 00 00 00       	mov    $0xc,%ecx
400326ac:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  11, 11, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400326b1:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400326b2:	6a 00                	push   $0x0
400326b4:	68 c8 5b 03 40       	push   $0x40035bc8
400326b9:	e8 27 fb ff ff       	call   400321e5 <mraa_set_pininfo>
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400326be:	8a 1d 81 58 03 40    	mov    0x40035881,%bl
400326c4:	b9 04 00 00 00       	mov    $0x4,%ecx
400326c9:	ba 0d 00 00 00       	mov    $0xd,%edx
400326ce:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  12, 12, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400326d3:	5e                   	pop    %esi
400326d4:	5f                   	pop    %edi
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400326d5:	53                   	push   %ebx
400326d6:	68 cc 5b 03 40       	push   $0x40035bcc
400326db:	e8 05 fb ff ff       	call   400321e5 <mraa_set_pininfo>
400326e0:	58                   	pop    %eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326e1:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  13, 4, "AP_GPIO4_ADC4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400326e6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400326e7:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400326ec:	ba 0e 00 00 00       	mov    $0xe,%edx
400326f1:	6a 01                	push   $0x1
400326f3:	68 da 5b 03 40       	push   $0x40035bda
400326f8:	e8 e8 fa ff ff       	call   400321e5 <mraa_set_pininfo>
400326fd:	59                   	pop    %ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
400326fe:	ba 0f 00 00 00       	mov    $0xf,%edx
40032703:	b9 05 00 00 00       	mov    $0x5,%ecx
40032708:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  14, 14, "AP_GPIO_SS2_ADC10",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003270d:	5e                   	pop    %esi
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003270e:	53                   	push   %ebx
4003270f:	68 ec 5b 03 40       	push   $0x40035bec
40032714:	e8 cc fa ff ff       	call   400321e5 <mraa_set_pininfo>
40032719:	5f                   	pop    %edi
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003271a:	b9 10 00 00 00       	mov    $0x10,%ecx
    mraa_set_pininfo(b,  15, 5, "AP_GPIO5_ADC5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003271f:	58                   	pop    %eax
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032720:	ba 10 00 00 00       	mov    $0x10,%edx
40032725:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003272a:	6a 01                	push   $0x1
4003272c:	68 fa 5b 03 40       	push   $0x40035bfa
40032731:	e8 af fa ff ff       	call   400321e5 <mraa_set_pininfo>
40032736:	58                   	pop    %eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032737:	b9 06 00 00 00       	mov    $0x6,%ecx
    mraa_set_pininfo(b,  16, 16, "AP_GPIO_SS3_ADC11",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003273c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
4003273d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032742:	ba 11 00 00 00       	mov    $0x11,%edx
40032747:	53                   	push   %ebx
40032748:	68 0c 5c 03 40       	push   $0x40035c0c
4003274d:	e8 93 fa ff ff       	call   400321e5 <mraa_set_pininfo>
40032752:	59                   	pop    %ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032753:	ba 12 00 00 00       	mov    $0x12,%edx
40032758:	b9 12 00 00 00       	mov    $0x12,%ecx
4003275d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  17, 6, "AP_GPIO6_ADC6_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to GPIO
40032762:	5e                   	pop    %esi
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032763:	6a 01                	push   $0x1
40032765:	68 1e 5c 03 40       	push   $0x40035c1e
4003276a:	e8 76 fa ff ff       	call   400321e5 <mraa_set_pininfo>
4003276f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40032770:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  18, 18, "AP_GPIO_SS4_ADC12",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032775:	58                   	pop    %eax
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40032776:	ba 13 00 00 00       	mov    $0x13,%edx
4003277b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032780:	53                   	push   %ebx
40032781:	68 30 5c 03 40       	push   $0x40035c30
40032786:	e8 5a fa ff ff       	call   400321e5 <mraa_set_pininfo>
4003278b:	58                   	pop    %eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003278c:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  19, 14, "AP_GPIO_SS14_PLT_CLK_0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
40032791:	5a                   	pop    %edx
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032792:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032797:	ba 14 00 00 00       	mov    $0x14,%edx
4003279c:	6a 01                	push   $0x1
4003279e:	68 47 5c 03 40       	push   $0x40035c47
400327a3:	e8 3d fa ff ff       	call   400321e5 <mraa_set_pininfo>
400327a8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400327a9:	ba 15 00 00 00       	mov    $0x15,%edx
400327ae:	b9 0f 00 00 00       	mov    $0xf,%ecx
400327b3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  20, 20, "AP_GPIO_SS5_ADC13",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400327b8:	5e                   	pop    %esi
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400327b9:	53                   	push   %ebx
400327ba:	68 59 5c 03 40       	push   $0x40035c59
400327bf:	e8 21 fa ff ff       	call   400321e5 <mraa_set_pininfo>
400327c4:	5f                   	pop    %edi
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400327c5:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  21, 15, "AP_GPIO_SS15_PLT_CLK_1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });  // defaults to SS GPIO/clk/keep number in mind
400327ca:	58                   	pop    %eax
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400327cb:	ba 16 00 00 00       	mov    $0x16,%edx
400327d0:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400327d5:	6a 01                	push   $0x1
400327d7:	68 70 5c 03 40       	push   $0x40035c70
400327dc:	e8 04 fa ff ff       	call   400321e5 <mraa_set_pininfo>
400327e1:	58                   	pop    %eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400327e2:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  22, 22, "AP_GPIO_SS6_ADC14",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on X86 core
400327e7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400327e8:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400327ed:	ba 17 00 00 00       	mov    $0x17,%edx
400327f2:	6a 00                	push   $0x0
400327f4:	68 1b 5b 03 40       	push   $0x40035b1b
400327f9:	e8 e7 f9 ff ff       	call   400321e5 <mraa_set_pininfo>
400327fe:	59                   	pop    %ecx
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
400327ff:	ba 18 00 00 00       	mov    $0x18,%edx
40032804:	b9 14 00 00 00       	mov    $0x14,%ecx
40032809:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  23, 23, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003280e:	5e                   	pop    %esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
4003280f:	6a 01                	push   $0x1
40032811:	68 82 5c 03 40       	push   $0x40035c82
40032816:	e8 ca f9 ff ff       	call   400321e5 <mraa_set_pininfo>
4003281b:	5f                   	pop    %edi
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003281c:	0f b6 35 82 58 03 40 	movzbl 0x40035882,%esi
    mraa_set_pininfo(b,  24, 20, "AP_GPIO_SS7_ADC15",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 });  // NA on x86 core
40032823:	58                   	pop    %eax
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032824:	31 c9                	xor    %ecx,%ecx
40032826:	ba 19 00 00 00       	mov    $0x19,%edx
4003282b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032830:	56                   	push   %esi
40032831:	68 94 5c 03 40       	push   $0x40035c94
40032836:	e8 aa f9 ff ff       	call   400321e5 <mraa_set_pininfo>
4003283b:	58                   	pop    %eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
4003283c:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  25, 0, "AP_GPIO_SS10_PWM0",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032841:	5a                   	pop    %edx
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032842:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032847:	ba 1a 00 00 00       	mov    $0x1a,%edx
4003284c:	6a 00                	push   $0x0
4003284e:	68 1b 5b 03 40       	push   $0x40035b1b
40032853:	e8 8d f9 ff ff       	call   400321e5 <mraa_set_pininfo>
40032858:	59                   	pop    %ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032859:	ba 1b 00 00 00       	mov    $0x1b,%edx
4003285e:	b9 01 00 00 00       	mov    $0x1,%ecx
40032863:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  26, 26, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032868:	5f                   	pop    %edi
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032869:	56                   	push   %esi
4003286a:	68 a6 5c 03 40       	push   $0x40035ca6
4003286f:	e8 71 f9 ff ff       	call   400321e5 <mraa_set_pininfo>
40032874:	58                   	pop    %eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032875:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  27, 1, "AP_GPIO_SS11_PWM1",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
4003287a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003287b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032880:	ba 1c 00 00 00       	mov    $0x1c,%edx
40032885:	53                   	push   %ebx
40032886:	68 b8 5c 03 40       	push   $0x40035cb8
4003288b:	e8 55 f9 ff ff       	call   400321e5 <mraa_set_pininfo>
40032890:	59                   	pop    %ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
40032891:	ba 1d 00 00 00       	mov    $0x1d,%edx
40032896:	b9 02 00 00 00       	mov    $0x2,%ecx
4003289b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  28, 15, "AP_GPIO15_I2S_RXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328a0:	5f                   	pop    %edi
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400328a1:	56                   	push   %esi
400328a2:	68 ca 5c 03 40       	push   $0x40035cca
400328a7:	e8 39 f9 ff ff       	call   400321e5 <mraa_set_pininfo>
400328ac:	58                   	pop    %eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328ad:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  29, 2, "AP_GPIO_SS12_PWM2",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400328b2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328b3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400328b8:	ba 1e 00 00 00       	mov    $0x1e,%edx
400328bd:	53                   	push   %ebx
400328be:	68 dc 5c 03 40       	push   $0x40035cdc
400328c3:	e8 1d f9 ff ff       	call   400321e5 <mraa_set_pininfo>
400328c8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400328c9:	ba 1f 00 00 00       	mov    $0x1f,%edx
400328ce:	b9 03 00 00 00       	mov    $0x3,%ecx
400328d3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  30, 15, "AP_GPIO16_I2S_RSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328d8:	5f                   	pop    %edi
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400328d9:	56                   	push   %esi
400328da:	68 ef 5c 03 40       	push   $0x40035cef
400328df:	e8 01 f9 ff ff       	call   400321e5 <mraa_set_pininfo>
400328e4:	58                   	pop    %eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328e5:	b9 0f 00 00 00       	mov    $0xf,%ecx
    mraa_set_pininfo(b,  31, 3, "AP_GPIO_SS13_PWM3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
400328ea:	5a                   	pop    %edx
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400328eb:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400328f0:	ba 20 00 00 00       	mov    $0x20,%edx
400328f5:	53                   	push   %ebx
400328f6:	68 01 5d 03 40       	push   $0x40035d01
400328fb:	e8 e5 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
40032900:	59                   	pop    %ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032901:	ba 21 00 00 00       	mov    $0x21,%edx
40032906:	b9 21 00 00 00       	mov    $0x21,%ecx
4003290b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  32, 15, "AP_GPIO17_I2S_RWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032910:	5e                   	pop    %esi
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032911:	6a 00                	push   $0x0
40032913:	68 c8 5b 03 40       	push   $0x40035bc8
40032918:	e8 c8 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
4003291d:	5f                   	pop    %edi
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003291e:	b9 12 00 00 00       	mov    $0x12,%ecx
    mraa_set_pininfo(b,  33, 33, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032923:	58                   	pop    %eax
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032924:	ba 22 00 00 00       	mov    $0x22,%edx
40032929:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003292e:	53                   	push   %ebx
4003292f:	68 13 5d 03 40       	push   $0x40035d13
40032934:	e8 ac f8 ff ff       	call   400321e5 <mraa_set_pininfo>
40032939:	58                   	pop    %eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003293a:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  34, 18, "AP_GPIO18_I2S_TSCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003293c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003293d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032942:	ba 23 00 00 00       	mov    $0x23,%edx
40032947:	53                   	push   %ebx
40032948:	68 26 5d 03 40       	push   $0x40035d26
4003294d:	e8 93 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
40032952:	59                   	pop    %ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032953:	ba 24 00 00 00       	mov    $0x24,%edx
40032958:	b9 13 00 00 00       	mov    $0x13,%ecx
4003295d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  35, 0, "AP_GPIO_AON0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032962:	5e                   	pop    %esi
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032963:	53                   	push   %ebx
40032964:	68 33 5d 03 40       	push   $0x40035d33
40032969:	e8 77 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
4003296e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
4003296f:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  36, 19, "AP_GPIO19_I2S_TWS",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032974:	58                   	pop    %eax
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032975:	ba 25 00 00 00       	mov    $0x25,%edx
4003297a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
4003297f:	53                   	push   %ebx
40032980:	68 45 5d 03 40       	push   $0x40035d45
40032985:	e8 5b f8 ff ff       	call   400321e5 <mraa_set_pininfo>
4003298a:	58                   	pop    %eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
4003298b:	b9 14 00 00 00       	mov    $0x14,%ecx
    mraa_set_pininfo(b,  37, 1, "AP_GPIO_AON1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032990:	5a                   	pop    %edx
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032991:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032996:	ba 26 00 00 00       	mov    $0x26,%edx
4003299b:	53                   	push   %ebx
4003299c:	68 52 5d 03 40       	push   $0x40035d52
400329a1:	e8 3f f8 ff ff       	call   400321e5 <mraa_set_pininfo>
400329a6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329a7:	ba 27 00 00 00       	mov    $0x27,%edx
400329ac:	b9 02 00 00 00       	mov    $0x2,%ecx
400329b1:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  38, 20, "AP_GPIO20_I2S_TXD",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
400329b6:	5e                   	pop    %esi
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329b7:	53                   	push   %ebx
400329b8:	68 64 5d 03 40       	push   $0x40035d64
400329bd:	e8 23 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
400329c2:	5f                   	pop    %edi
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329c3:	b9 28 00 00 00       	mov    $0x28,%ecx
    mraa_set_pininfo(b,  39, 2, "AP_GPIO_AON2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329c8:	58                   	pop    %eax
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329c9:	ba 28 00 00 00       	mov    $0x28,%edx
400329ce:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400329d3:	6a 00                	push   $0x0
400329d5:	68 c8 5b 03 40       	push   $0x40035bc8
400329da:	e8 06 f8 ff ff       	call   400321e5 <mraa_set_pininfo>
400329df:	58                   	pop    %eax
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329e0:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  40, 40, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
400329e5:	5a                   	pop    %edx
    mraa_set_pininfo(b,  41, 3, "AP_GPIO_AON3",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
400329e6:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
400329eb:	ba 29 00 00 00       	mov    $0x29,%edx
400329f0:	53                   	push   %ebx
400329f1:	68 71 5d 03 40       	push   $0x40035d71
400329f6:	e8 ea f7 ff ff       	call   400321e5 <mraa_set_pininfo>
400329fb:	59                   	pop    %ecx
400329fc:	5e                   	pop    %esi
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
400329fd:	b9 01 00 00 00       	mov    $0x1,%ecx
40032a02:	0f b6 35 83 58 03 40 	movzbl 0x40035883,%esi
40032a09:	ba 2a 00 00 00       	mov    $0x2a,%edx
40032a0e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032a13:	56                   	push   %esi
40032a14:	68 7e 5d 03 40       	push   $0x40035d7e
40032a19:	e8 c7 f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032a1e:	5f                   	pop    %edi
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a1f:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  42, 1, "SP_I2C1_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032a24:	58                   	pop    %eax
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a25:	ba 2b 00 00 00       	mov    $0x2b,%edx
40032a2a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032a2f:	53                   	push   %ebx
40032a30:	68 8d 5d 03 40       	push   $0x40035d8d
40032a35:	e8 ab f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032a3a:	58                   	pop    %eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032a3b:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  43, 4, "AP_GPIO_AON4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a40:	5a                   	pop    %edx
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032a41:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032a46:	ba 2c 00 00 00       	mov    $0x2c,%edx
40032a4b:	56                   	push   %esi
40032a4c:	68 9a 5d 03 40       	push   $0x40035d9a
40032a51:	e8 8f f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032a56:	59                   	pop    %ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a57:	ba 2d 00 00 00       	mov    $0x2d,%edx
40032a5c:	b9 05 00 00 00       	mov    $0x5,%ecx
40032a61:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  44, 1, "SP_I2C1_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });  // IMU
40032a66:	5f                   	pop    %edi
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a67:	53                   	push   %ebx
40032a68:	68 a9 5d 03 40       	push   $0x40035da9
40032a6d:	e8 73 f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032a72:	58                   	pop    %eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a73:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  45, 5, "AP_GPIO_AON5",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });    // this does not work|couldn't find mapping
40032a75:	5a                   	pop    %edx
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a76:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032a7b:	ba 2e 00 00 00       	mov    $0x2e,%edx
40032a80:	6a 00                	push   $0x0
40032a82:	68 b6 5d 03 40       	push   $0x40035db6
40032a87:	e8 59 f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032a8c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032a8d:	ba 2f 00 00 00       	mov    $0x2f,%edx
40032a92:	b9 07 00 00 00       	mov    $0x7,%ecx
40032a97:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  46, 0, "XVREF",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032a9c:	5f                   	pop    %edi
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032a9d:	53                   	push   %ebx
40032a9e:	68 bc 5d 03 40       	push   $0x40035dbc
40032aa3:	e8 3d f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032aa8:	58                   	pop    %eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032aa9:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  47, 7, "AP_GPIO7_ADC7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
40032aab:	5a                   	pop    %edx
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032aac:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032ab1:	ba 30 00 00 00       	mov    $0x30,%edx
40032ab6:	6a 00                	push   $0x0
40032ab8:	68 ca 5d 03 40       	push   $0x40035dca
40032abd:	e8 23 f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ac2:	59                   	pop    %ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ac3:	ba 31 00 00 00       	mov    $0x31,%edx
40032ac8:	b9 31 00 00 00       	mov    $0x31,%ecx
40032acd:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  48, 0, "ARD_RESET_N_R",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ad2:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ad3:	6a 00                	push   $0x0
40032ad5:	68 1b 5b 03 40       	push   $0x40035b1b
40032ada:	e8 06 f7 ff ff       	call   400321e5 <mraa_set_pininfo>
40032adf:	5f                   	pop    %edi
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ae0:	b9 32 00 00 00       	mov    $0x32,%ecx
    mraa_set_pininfo(b,  49, 49, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ae5:	58                   	pop    %eax
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ae6:	ba 32 00 00 00       	mov    $0x32,%edx
40032aeb:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032af0:	6a 00                	push   $0x0
40032af2:	68 1b 5b 03 40       	push   $0x40035b1b
40032af7:	e8 e9 f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032afc:	58                   	pop    %eax
#endif
// the other big header - J15
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032afd:	b9 33 00 00 00       	mov    $0x33,%ecx
    mraa_set_pininfo(b,  50, 50, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b02:	5a                   	pop    %edx
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b03:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032b08:	ba 33 00 00 00       	mov    $0x33,%edx
40032b0d:	6a 00                	push   $0x0
40032b0f:	68 1b 5b 03 40       	push   $0x40035b1b
40032b14:	e8 cc f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032b19:	59                   	pop    %ecx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b1a:	ba 34 00 00 00       	mov    $0x34,%edx
40032b1f:	b9 34 00 00 00       	mov    $0x34,%ecx
40032b24:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  51, 51, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b29:	5b                   	pop    %ebx
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b2a:	6a 00                	push   $0x0
40032b2c:	68 1b 5b 03 40       	push   $0x40035b1b
40032b31:	e8 af f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032b36:	5f                   	pop    %edi
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b37:	0f b6 3d 84 58 03 40 	movzbl 0x40035884,%edi
    mraa_set_pininfo(b,  52, 52, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032b3e:	58                   	pop    %eax
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b3f:	31 c9                	xor    %ecx,%ecx
40032b41:	ba 35 00 00 00       	mov    $0x35,%edx
40032b46:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032b4b:	57                   	push   %edi
40032b4c:	68 d8 5d 03 40       	push   $0x40035dd8
40032b51:	e8 8f f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032b56:	58                   	pop    %eax
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b57:	8a 1d 85 58 03 40    	mov    0x40035885,%bl
    mraa_set_pininfo(b,  53, 0, "AP_SPI0_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b5d:	5a                   	pop    %edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b5e:	b9 15 00 00 00       	mov    $0x15,%ecx
40032b63:	ba 36 00 00 00       	mov    $0x36,%edx
40032b68:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032b6d:	53                   	push   %ebx
40032b6e:	68 e7 5d 03 40       	push   $0x40035de7
40032b73:	e8 6d f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032b78:	59                   	pop    %ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b79:	ba 37 00 00 00       	mov    $0x37,%edx
    mraa_set_pininfo(b,  54, 21, "AP_GPIO21_SPI0_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b7e:	58                   	pop    %eax
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b7f:	31 c9                	xor    %ecx,%ecx
40032b81:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032b86:	57                   	push   %edi
40032b87:	68 fc 5d 03 40       	push   $0x40035dfc
40032b8c:	e8 54 f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032b91:	58                   	pop    %eax
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b92:	b9 16 00 00 00       	mov    $0x16,%ecx
    mraa_set_pininfo(b,  55, 0, "AP_SPI0_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032b97:	5a                   	pop    %edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032b98:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032b9d:	ba 38 00 00 00       	mov    $0x38,%edx
40032ba2:	53                   	push   %ebx
40032ba3:	68 0c 5e 03 40       	push   $0x40035e0c
40032ba8:	e8 38 f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032bad:	59                   	pop    %ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032bae:	ba 39 00 00 00       	mov    $0x39,%edx
    mraa_set_pininfo(b,  56, 22, "AP_GPIO22_SPI0_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bb3:	58                   	pop    %eax
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032bb4:	31 c9                	xor    %ecx,%ecx
40032bb6:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032bbb:	57                   	push   %edi
40032bbc:	68 22 5e 03 40       	push   $0x40035e22
40032bc1:	e8 1f f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032bc6:	58                   	pop    %eax
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bc7:	b9 17 00 00 00       	mov    $0x17,%ecx
    mraa_set_pininfo(b,  57, 0, "AP_SPI0_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032bcc:	5a                   	pop    %edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bcd:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032bd2:	ba 3a 00 00 00       	mov    $0x3a,%edx
40032bd7:	53                   	push   %ebx
40032bd8:	68 32 5e 03 40       	push   $0x40035e32
40032bdd:	e8 03 f6 ff ff       	call   400321e5 <mraa_set_pininfo>
40032be2:	59                   	pop    %ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032be3:	ba 3b 00 00 00       	mov    $0x3b,%edx
    mraa_set_pininfo(b,  58, 23, "AP_GPIO23_SPI0_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032be8:	58                   	pop    %eax
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032be9:	31 c9                	xor    %ecx,%ecx
40032beb:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032bf0:	57                   	push   %edi
40032bf1:	68 48 5e 03 40       	push   $0x40035e48
40032bf6:	e8 ea f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032bfb:	58                   	pop    %eax
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032bfc:	b9 18 00 00 00       	mov    $0x18,%ecx
    mraa_set_pininfo(b,  59, 0, "AP_SPI0_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c01:	5a                   	pop    %edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c02:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c07:	ba 3c 00 00 00       	mov    $0x3c,%edx
40032c0c:	53                   	push   %ebx
40032c0d:	68 59 5e 03 40       	push   $0x40035e59
40032c12:	e8 ce f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032c17:	59                   	pop    %ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c18:	ba 3d 00 00 00       	mov    $0x3d,%edx
    mraa_set_pininfo(b,  60, 24, "AP_GPIO24_SPI0_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c1d:	58                   	pop    %eax
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c1e:	31 c9                	xor    %ecx,%ecx
40032c20:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c25:	57                   	push   %edi
40032c26:	68 70 5e 03 40       	push   $0x40035e70
40032c2b:	e8 b5 f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032c30:	58                   	pop    %eax
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c31:	b9 19 00 00 00       	mov    $0x19,%ecx
    mraa_set_pininfo(b,  61, 0, "AP_SPI0_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032c36:	5a                   	pop    %edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c37:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c3c:	ba 3e 00 00 00       	mov    $0x3e,%edx
40032c41:	53                   	push   %ebx
40032c42:	68 81 5e 03 40       	push   $0x40035e81
40032c47:	e8 99 f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032c4c:	59                   	pop    %ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c4d:	ba 3f 00 00 00       	mov    $0x3f,%edx
    mraa_set_pininfo(b,  62, 25, "AP_GPIO25_SPI0_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c52:	58                   	pop    %eax
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c53:	b9 1d 00 00 00       	mov    $0x1d,%ecx
40032c58:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c5d:	53                   	push   %ebx
40032c5e:	68 98 5e 03 40       	push   $0x40035e98
40032c63:	e8 7d f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032c68:	58                   	pop    %eax
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c69:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    mraa_set_pininfo(b,  63, 29, "AP_SPI0_SS_CS2_N_GPIO29",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c6e:	5a                   	pop    %edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c6f:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c74:	ba 40 00 00 00       	mov    $0x40,%edx
40032c79:	53                   	push   %ebx
40032c7a:	68 b0 5e 03 40       	push   $0x40035eb0
40032c7f:	e8 61 f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032c84:	59                   	pop    %ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c85:	ba 41 00 00 00       	mov    $0x41,%edx
    mraa_set_pininfo(b,  64, 26, "AP_GPIO26_SPI0_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c8a:	58                   	pop    %eax
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032c8b:	b9 1e 00 00 00       	mov    $0x1e,%ecx
40032c90:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032c95:	53                   	push   %ebx
40032c96:	68 c7 5e 03 40       	push   $0x40035ec7
40032c9b:	e8 45 f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ca0:	58                   	pop    %eax
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ca1:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    mraa_set_pininfo(b,  65, 30, "AP_SPI0_SS_CS3_N_GPIO30",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ca6:	5a                   	pop    %edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ca7:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032cac:	ba 42 00 00 00       	mov    $0x42,%edx
40032cb1:	53                   	push   %ebx
40032cb2:	68 df 5e 03 40       	push   $0x40035edf
40032cb7:	e8 29 f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032cbc:	59                   	pop    %ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032cbd:	ba 43 00 00 00       	mov    $0x43,%edx
    mraa_set_pininfo(b,  66, 27, "AP_GPIO27_SPI0_M_CS3_N_MUX",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032cc2:	58                   	pop    %eax
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032cc3:	b9 43 00 00 00       	mov    $0x43,%ecx
40032cc8:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032ccd:	6a 00                	push   $0x0
40032ccf:	68 c8 5b 03 40       	push   $0x40035bc8
40032cd4:	e8 0c f5 ff ff       	call   400321e5 <mraa_set_pininfo>
40032cd9:	58                   	pop    %eax
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032cda:	b9 44 00 00 00       	mov    $0x44,%ecx
    mraa_set_pininfo(b,  67, 67, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032cdf:	5a                   	pop    %edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032ce0:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032ce5:	ba 44 00 00 00       	mov    $0x44,%edx
40032cea:	6a 00                	push   $0x0
40032cec:	68 c8 5b 03 40       	push   $0x40035bc8
40032cf1:	e8 ef f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032cf6:	59                   	pop    %ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cf7:	ba 45 00 00 00       	mov    $0x45,%edx
    mraa_set_pininfo(b,  68, 68, "GND",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032cfc:	58                   	pop    %eax
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032cfd:	31 c9                	xor    %ecx,%ecx
40032cff:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d04:	57                   	push   %edi
40032d05:	68 fa 5e 03 40       	push   $0x40035efa
40032d0a:	e8 d6 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d0f:	58                   	pop    %eax
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d10:	b9 08 00 00 00       	mov    $0x8,%ecx
    mraa_set_pininfo(b,  69, 0, "AP_SPI1_SS_SCK",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d15:	5a                   	pop    %edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d16:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d1b:	ba 46 00 00 00       	mov    $0x46,%edx
40032d20:	53                   	push   %ebx
40032d21:	68 09 5f 03 40       	push   $0x40035f09
40032d26:	e8 ba f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d2b:	59                   	pop    %ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d2c:	ba 47 00 00 00       	mov    $0x47,%edx
    mraa_set_pininfo(b,  70, 8, "AP_GPIO8_SPI1_M_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d31:	58                   	pop    %eax
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d32:	31 c9                	xor    %ecx,%ecx
40032d34:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d39:	57                   	push   %edi
40032d3a:	68 1d 5f 03 40       	push   $0x40035f1d
40032d3f:	e8 a1 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d44:	58                   	pop    %eax
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d45:	b9 09 00 00 00       	mov    $0x9,%ecx
    mraa_set_pininfo(b,  71, 0, "AP_SPI1_SS_MISO",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d4a:	5a                   	pop    %edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d4b:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d50:	ba 48 00 00 00       	mov    $0x48,%edx
40032d55:	53                   	push   %ebx
40032d56:	68 2d 5f 03 40       	push   $0x40035f2d
40032d5b:	e8 85 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d60:	59                   	pop    %ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d61:	ba 49 00 00 00       	mov    $0x49,%edx
    mraa_set_pininfo(b,  72, 9, "AP_GPIO9_SPI1_M_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d66:	58                   	pop    %eax
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d67:	31 c9                	xor    %ecx,%ecx
40032d69:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d6e:	57                   	push   %edi
40032d6f:	68 42 5f 03 40       	push   $0x40035f42
40032d74:	e8 6c f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d79:	58                   	pop    %eax
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d7a:	b9 0a 00 00 00       	mov    $0xa,%ecx
    mraa_set_pininfo(b,  73, 0, "AP_SPI1_SS_MOSI",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d7f:	5a                   	pop    %edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d80:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032d85:	ba 4a 00 00 00       	mov    $0x4a,%edx
40032d8a:	53                   	push   %ebx
40032d8b:	68 52 5f 03 40       	push   $0x40035f52
40032d90:	e8 50 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032d95:	59                   	pop    %ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d96:	ba 4b 00 00 00       	mov    $0x4b,%edx
    mraa_set_pininfo(b,  74, 10, "AP_GPIO10_SPI1_M_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032d9b:	58                   	pop    %eax
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032d9c:	31 c9                	xor    %ecx,%ecx
40032d9e:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032da3:	57                   	push   %edi
40032da4:	68 68 5f 03 40       	push   $0x40035f68
40032da9:	e8 37 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032dae:	58                   	pop    %eax
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032daf:	b9 0b 00 00 00       	mov    $0xb,%ecx
    mraa_set_pininfo(b,  75, 0, "AP_SPI1_SS_CS0_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032db4:	5a                   	pop    %edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032db5:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032dba:	ba 4c 00 00 00       	mov    $0x4c,%edx
40032dbf:	53                   	push   %ebx
40032dc0:	68 79 5f 03 40       	push   $0x40035f79
40032dc5:	e8 1b f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032dca:	59                   	pop    %ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032dcb:	ba 4d 00 00 00       	mov    $0x4d,%edx
    mraa_set_pininfo(b,  76, 11, "AP_GPIO11_SPI1_M_CS0_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032dd0:	58                   	pop    %eax
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032dd1:	31 c9                	xor    %ecx,%ecx
40032dd3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032dd8:	57                   	push   %edi
40032dd9:	68 90 5f 03 40       	push   $0x40035f90
40032dde:	e8 02 f4 ff ff       	call   400321e5 <mraa_set_pininfo>
40032de3:	58                   	pop    %eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032de4:	b9 0c 00 00 00       	mov    $0xc,%ecx
    mraa_set_pininfo(b,  77, 0, "AP_SPI1_SS_CS1_N",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 1, 0, 0, 0 });
40032de9:	5a                   	pop    %edx
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032dea:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032def:	ba 4e 00 00 00       	mov    $0x4e,%edx
40032df4:	53                   	push   %ebx
40032df5:	68 a1 5f 03 40       	push   $0x40035fa1
40032dfa:	e8 e6 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032dff:	59                   	pop    %ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032e00:	ba 4f 00 00 00       	mov    $0x4f,%edx
40032e05:	b9 4f 00 00 00       	mov    $0x4f,%ecx
40032e0a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  78, 12, "AP_GPIO12_SPI1_M_CS1_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e0f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032e10:	6a 00                	push   $0x0
40032e12:	68 1b 5b 03 40       	push   $0x40035b1b
40032e17:	e8 c9 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032e1c:	58                   	pop    %eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e1d:	b9 0d 00 00 00       	mov    $0xd,%ecx
    mraa_set_pininfo(b,  79, 79, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032e22:	5a                   	pop    %edx
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e23:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032e28:	ba 50 00 00 00       	mov    $0x50,%edx
40032e2d:	53                   	push   %ebx
40032e2e:	68 b8 5f 03 40       	push   $0x40035fb8
40032e33:	e8 ad f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032e38:	59                   	pop    %ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e39:	ba 51 00 00 00       	mov    $0x51,%edx
40032e3e:	31 c9                	xor    %ecx,%ecx
40032e40:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  80, 13, "AP_GPIO13_SPI1_M_CS2_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e45:	5f                   	pop    %edi
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e46:	56                   	push   %esi
40032e47:	68 cf 5f 03 40       	push   $0x40035fcf
40032e4c:	e8 94 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032e51:	58                   	pop    %eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e52:	b9 0e 00 00 00       	mov    $0xe,%ecx
    mraa_set_pininfo(b,  81, 0, "AP_I2C0_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e57:	5a                   	pop    %edx
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e58:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032e5d:	ba 52 00 00 00       	mov    $0x52,%edx
40032e62:	53                   	push   %ebx
40032e63:	68 db 5f 03 40       	push   $0x40035fdb
40032e68:	e8 78 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032e6d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e6e:	ba 53 00 00 00       	mov    $0x53,%edx
40032e73:	31 c9                	xor    %ecx,%ecx
40032e75:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  82, 14, "AP_GPIO14_SPI1_M_CS3_N",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032e7a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e7b:	56                   	push   %esi
40032e7c:	68 f2 5f 03 40       	push   $0x40035ff2
40032e81:	e8 5f f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032e86:	58                   	pop    %eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032e87:	b9 54 00 00 00       	mov    $0x54,%ecx
    mraa_set_pininfo(b,  83, 0, "AP_I2C0_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032e8c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032e8d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032e92:	ba 54 00 00 00       	mov    $0x54,%edx
40032e97:	6a 00                	push   $0x0
40032e99:	68 1b 5b 03 40       	push   $0x40035b1b
40032e9e:	e8 42 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ea3:	59                   	pop    %ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ea4:	ba 55 00 00 00       	mov    $0x55,%edx
40032ea9:	31 c9                	xor    %ecx,%ecx
40032eab:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  84, 84, "VDD_HDR",  (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 });
40032eb0:	5f                   	pop    %edi
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032eb1:	56                   	push   %esi
40032eb2:	68 fe 5f 03 40       	push   $0x40035ffe
40032eb7:	e8 29 f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ebc:	58                   	pop    %eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ebd:	b9 02 00 00 00       	mov    $0x2,%ecx
    mraa_set_pininfo(b,  85, 0, "AP_I2C0_SS_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ec2:	5a                   	pop    %edx
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ec3:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032ec8:	ba 56 00 00 00       	mov    $0x56,%edx
40032ecd:	53                   	push   %ebx
40032ece:	68 0d 60 03 40       	push   $0x4003600d
40032ed3:	e8 0d f3 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ed8:	59                   	pop    %ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ed9:	ba 57 00 00 00       	mov    $0x57,%edx
40032ede:	31 c9                	xor    %ecx,%ecx
40032ee0:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  86, 2, "AP_GPIO2_ADC2_SPI_S_SCK",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ee5:	5f                   	pop    %edi
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ee6:	56                   	push   %esi
40032ee7:	68 25 60 03 40       	push   $0x40036025
40032eec:	e8 f4 f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032ef1:	58                   	pop    %eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ef2:	b9 01 00 00 00       	mov    $0x1,%ecx
    mraa_set_pininfo(b,  87, 0, "AP_I2C0_SS_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032ef7:	5a                   	pop    %edx
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032ef8:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032efd:	ba 58 00 00 00       	mov    $0x58,%edx
40032f02:	53                   	push   %ebx
40032f03:	68 34 60 03 40       	push   $0x40036034
40032f08:	e8 d8 f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032f0d:	59                   	pop    %ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f0e:	ba 59 00 00 00       	mov    $0x59,%edx
40032f13:	31 c9                	xor    %ecx,%ecx
40032f15:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  88, 1, "AP_GPIO1_ADC1_SPI_S_MISO",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f1a:	5f                   	pop    %edi
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f1b:	56                   	push   %esi
40032f1c:	68 4d 60 03 40       	push   $0x4003604d
40032f21:	e8 bf f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032f26:	58                   	pop    %eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f27:	b9 03 00 00 00       	mov    $0x3,%ecx
    mraa_set_pininfo(b,  89, 0, "AP_I2C1_SCL",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f2c:	5a                   	pop    %edx
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f2d:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032f32:	ba 5a 00 00 00       	mov    $0x5a,%edx
40032f37:	53                   	push   %ebx
40032f38:	68 59 60 03 40       	push   $0x40036059
40032f3d:	e8 a3 f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032f42:	59                   	pop    %ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f43:	ba 5b 00 00 00       	mov    $0x5b,%edx
40032f48:	31 c9                	xor    %ecx,%ecx
40032f4a:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
    mraa_set_pininfo(b,  90, 3, "AP_GPIO3_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f4f:	5f                   	pop    %edi
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f50:	56                   	push   %esi
40032f51:	68 72 60 03 40       	push   $0x40036072
40032f56:	e8 8a f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032f5b:	58                   	pop    %eax
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f5c:	31 c9                	xor    %ecx,%ecx
    mraa_set_pininfo(b,  91, 0, "AP_I2C1_SDA",  (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 1, 0, 0 });
40032f5e:	5a                   	pop    %edx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f5f:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40032f64:	ba 5c 00 00 00       	mov    $0x5c,%edx
40032f69:	53                   	push   %ebx
    b->spi_bus[0].sclk = 13;
    b->spi_bus[0].mosi = 11;
    b->spi_bus[0].miso = 12;
    b->spi_bus[0].cs = 10;

    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032f6a:	8d 7d e4             	lea    -0x1c(%ebp),%edi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f6d:	68 7e 60 03 40       	push   $0x4003607e
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032f72:	be 88 58 03 40       	mov    $0x40035888,%esi
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f77:	e8 69 f2 ff ff       	call   400321e5 <mraa_set_pininfo>
40032f7c:	59                   	pop    %ecx
    struct device* zdev = device_get_binding("GPIO_0");
40032f7d:	b8 52 59 03 40       	mov    $0x40035952,%eax
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032f82:	b9 04 00 00 00       	mov    $0x4,%ecx
    mraa_set_pininfo(b,  92, 0, "AP_GPIO0_ADC3_SPI_S_MOSI",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
40032f87:	5b                   	pop    %ebx
    b->def_i2c_bus = 0;
40032f88:	c6 05 4a 69 00 a8 00 	movb   $0x0,0xa800694a
    b->i2c_bus[0].bus_id = 0;
40032f8f:	c6 05 44 69 00 a8 00 	movb   $0x0,0xa8006944
    b->pins[18].i2c.mux_total = 0;
40032f96:	c6 05 6e 6e 00 a8 00 	movb   $0x0,0xa8006e6e
    b->pins[19].i2c.mux_total = 0;
40032f9d:	c6 05 b2 6e 00 a8 00 	movb   $0x0,0xa8006eb2
    b->i2c_bus[0].sda = 18;
40032fa4:	c6 05 46 69 00 a8 12 	movb   $0x12,0xa8006946
    b->i2c_bus[0].scl = 19;
40032fab:	c6 05 45 69 00 a8 13 	movb   $0x13,0xa8006945
    b->spi_bus[0].bus_id = 0;
40032fb2:	c6 05 4c 69 00 a8 00 	movb   $0x0,0xa800694c
    b->spi_bus[0].sclk = 13;
40032fb9:	c6 05 4f 69 00 a8 0d 	movb   $0xd,0xa800694f
    b->spi_bus[0].mosi = 11;
40032fc0:	c6 05 50 69 00 a8 0b 	movb   $0xb,0xa8006950
    b->spi_bus[0].miso = 12;
40032fc7:	c6 05 51 69 00 a8 0c 	movb   $0xc,0xa8006951
    b->spi_bus[0].cs = 10;
40032fce:	c6 05 52 69 00 a8 0a 	movb   $0xa,0xa8006952
    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
40032fd5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    struct device* zdev = device_get_binding("GPIO_0");
40032fd7:	e8 70 0d 00 00       	call   40033d4c <device_get_binding>
    if (zdev != NULL) {
40032fdc:	85 c0                	test   %eax,%eax
40032fde:	74 1e                	je     40032ffe <mraa_intel_quark_se_devboard+0xab9>
40032fe0:	89 c6                	mov    %eax,%esi
40032fe2:	31 db                	xor    %ebx,%ebx
	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
40032fe4:	0f b6 4c 9d e4       	movzbl -0x1c(%ebp,%ebx,4),%ecx
40032fe9:	8b 7e 04             	mov    0x4(%esi),%edi
40032fec:	31 d2                	xor    %edx,%edx
40032fee:	89 f0                	mov    %esi,%eax
        for (int i = 0; i<4; ++i) {
40032ff0:	43                   	inc    %ebx
40032ff1:	68 00 01 00 00       	push   $0x100
40032ff6:	ff 17                	call   *(%edi)
40032ff8:	58                   	pop    %eax
40032ff9:	83 fb 04             	cmp    $0x4,%ebx
40032ffc:	75 e6                	jne    40032fe4 <mraa_intel_quark_se_devboard+0xa9f>
        return NULL;
    }
#endif

    return b;
}
40032ffe:	8d 65 f4             	lea    -0xc(%ebp),%esp
40033001:	b8 40 69 00 a8       	mov    $0xa8006940,%eax
40033006:	5b                   	pop    %ebx
40033007:	5e                   	pop    %esi
40033008:	5f                   	pop    %edi
40033009:	5d                   	pop    %ebp
4003300a:	c3                   	ret    

4003300b <upm_clock_init>:

#endif
}

void upm_clock_init(upm_clock_t *clock)
{
4003300b:	55                   	push   %ebp
4003300c:	89 e5                	mov    %esp,%ebp
4003300e:	53                   	push   %ebx
4003300f:	89 c3                	mov    %eax,%ebx
#if defined(UPM_PLATFORM_LINUX)

    gettimeofday(clock, NULL);

#elif defined(UPM_PLATFORM_ZEPHYR)
    *clock = k_cycle_get_32();
40033011:	e8 eb da ff ff       	call   40030b01 <_timer_cycle_get_32>
40033016:	89 03                	mov    %eax,(%ebx)
#endif
}
40033018:	5b                   	pop    %ebx
40033019:	5d                   	pop    %ebp
4003301a:	c3                   	ret    

4003301b <upm_elapsed_us>:
    return elapsed;
#endif
}

uint32_t upm_elapsed_us(upm_clock_t *clock)
{
4003301b:	55                   	push   %ebp
4003301c:	89 e5                	mov    %esp,%ebp
4003301e:	56                   	push   %esi
4003301f:	89 c6                	mov    %eax,%esi
40033021:	53                   	push   %ebx
        elapse = 1;

    return elapse;

#elif defined(UPM_PLATFORM_ZEPHYR)
    uint32_t now = k_cycle_get_32();
40033022:	e8 da da ff ff       	call   40030b01 <_timer_cycle_get_32>

    uint32_t elapsed =
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40033027:	2b 06                	sub    (%esi),%eax
40033029:	89 c3                	mov    %eax,%ebx
4003302b:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40033030:	f7 2d f0 66 00 a8    	imull  0xa80066f0
40033036:	89 d1                	mov    %edx,%ecx
40033038:	0f af cb             	imul   %ebx,%ecx
4003303b:	f7 e3                	mul    %ebx
4003303d:	01 ca                	add    %ecx,%edx
4003303f:	8b 0d ec 66 00 a8    	mov    0xa80066ec,%ecx
40033045:	89 cb                	mov    %ecx,%ebx
40033047:	c1 fb 1f             	sar    $0x1f,%ebx
4003304a:	53                   	push   %ebx
4003304b:	51                   	push   %ecx
4003304c:	e8 3f d0 ff ff       	call   40030090 <__udivdi3>
40033051:	59                   	pop    %ecx
40033052:	5b                   	pop    %ebx
40033053:	6a 00                	push   $0x0
40033055:	68 e8 03 00 00       	push   $0x3e8
4003305a:	e8 31 d0 ff ff       	call   40030090 <__udivdi3>
4003305f:	5e                   	pop    %esi
//printf("hello\n");
    // never return 0
    if (elapsed == 0)
40033060:	85 c0                	test   %eax,%eax
        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
40033062:	5a                   	pop    %edx
    if (elapsed == 0)
40033063:	75 05                	jne    4003306a <upm_elapsed_us+0x4f>
        elapsed = 1;
40033065:	b8 01 00 00 00       	mov    $0x1,%eax

    return elapsed;
#endif
}
4003306a:	8d 65 f8             	lea    -0x8(%ebp),%esp
4003306d:	5b                   	pop    %ebx
4003306e:	5e                   	pop    %esi
4003306f:	5d                   	pop    %ebp
40033070:	c3                   	ret    

40033071 <upm_delay_us>:
{
40033071:	55                   	push   %ebp
40033072:	85 c0                	test   %eax,%eax
40033074:	89 e5                	mov    %esp,%ebp
40033076:	53                   	push   %ebx
40033077:	bb 01 00 00 00       	mov    $0x1,%ebx
4003307c:	52                   	push   %edx
4003307d:	7e 02                	jle    40033081 <upm_delay_us+0x10>
4003307f:	89 c3                	mov    %eax,%ebx
    upm_clock_init(&timer);
40033081:	8d 45 f8             	lea    -0x8(%ebp),%eax
40033084:	e8 82 ff ff ff       	call   4003300b <upm_clock_init>
    while (upm_elapsed_us(&timer) < time)
40033089:	8d 45 f8             	lea    -0x8(%ebp),%eax
4003308c:	e8 8a ff ff ff       	call   4003301b <upm_elapsed_us>
40033091:	39 d8                	cmp    %ebx,%eax
40033093:	72 f4                	jb     40033089 <upm_delay_us+0x18>
}
40033095:	58                   	pop    %eax
40033096:	5b                   	pop    %ebx
40033097:	5d                   	pop    %ebp
40033098:	c3                   	ret    

40033099 <LoRaClass>:
  //_ss(LORA_DEFAULT_SS_PIN), _reset(LORA_DEFAULT_RESET_PIN), _dio0(LORA_DEFAULT_DIO0_PIN),
  //_frequency(0),
  //_packetIndex(0),
  //_implicitHeaderMode(0),
  //_onReceive(NULL)
{
40033099:	55                   	push   %ebp
4003309a:	89 e5                	mov    %esp,%ebp
    // initialize MRAA
    int mraa_rv;
    if((mraa_rv = mraa_init()) != MRAA_SUCCESS) {
4003309c:	e8 5f ef ff ff       	call   40032000 <mraa_init>
400330a1:	85 c0                	test   %eax,%eax
400330a3:	74 13                	je     400330b8 <LoRaClass+0x1f>
        printf("%s: mraa_init failed (%d).\n", __FUNCTION__, mraa_rv);
400330a5:	50                   	push   %eax
400330a6:	68 b8 63 03 40       	push   $0x400363b8
400330ab:	68 97 60 03 40       	push   $0x40036097
400330b0:	e8 47 19 00 00       	call   400349fc <iprintf>
400330b5:	83 c4 0c             	add    $0xc,%esp
    }

    if(!(SX1276.spi = mraa_spi_init(0)))
400330b8:	31 c0                	xor    %eax,%eax
400330ba:	e8 ab f3 ff ff       	call   4003246a <mraa_spi_init>
400330bf:	a3 74 78 00 a8       	mov    %eax,0xa8007874
400330c4:	85 c0                	test   %eax,%eax
400330c6:	75 0b                	jne    400330d3 <LoRaClass+0x3a>
        printf("Unable to Initialize Spi bus\n");
400330c8:	68 b3 60 03 40       	push   $0x400360b3
400330cd:	e8 2a 19 00 00       	call   400349fc <iprintf>
400330d2:	5a                   	pop    %edx

    if(mraa_spi_frequency(SX1276.spi, 4000000) != MRAA_SUCCESS) {
400330d3:	ba 00 09 3d 00       	mov    $0x3d0900,%edx
400330d8:	a1 74 78 00 a8       	mov    0xa8007874,%eax
400330dd:	e8 10 f4 ff ff       	call   400324f2 <mraa_spi_frequency>
400330e2:	85 c0                	test   %eax,%eax
400330e4:	74 0b                	je     400330f1 <LoRaClass+0x58>
        printf("sx1276: Unable to set higher frequency\n");
400330e6:	68 d1 60 03 40       	push   $0x400360d1
400330eb:	e8 0c 19 00 00       	call   400349fc <iprintf>
400330f0:	58                   	pop    %eax
    }

    SX1276._frequency  = 0;
400330f1:	c7 05 78 78 00 a8 00 	movl   $0x0,0xa8007878
400330f8:	00 00 00 
    SX1276._packetIndex = 0;
400330fb:	c7 05 7c 78 00 a8 00 	movl   $0x0,0xa800787c
40033102:	00 00 00 
    SX1276._implicitHeaderMode = 0;
40033105:	c7 05 80 78 00 a8 00 	movl   $0x0,0xa8007880
4003310c:	00 00 00 

    SX1276._ss = LORA_DEFAULT_SS_PIN;
4003310f:	c6 05 6c 78 00 a8 0a 	movb   $0xa,0xa800786c
    SX1276._reset = LORA_DEFAULT_RESET_PIN;
40033116:	c6 05 6d 78 00 a8 09 	movb   $0x9,0xa800786d
    SX1276._dio0 = LORA_DEFAULT_DIO0_PIN;
4003311d:	c6 05 6e 78 00 a8 02 	movb   $0x2,0xa800786e
}
40033124:	c9                   	leave  
40033125:	c3                   	ret    

40033126 <setPins>:

int8_t random() {
    return readRegister(REG_RSSI_WIDEBAND);
}

void setPins(int ss, int reset, int dio0) {
40033126:	55                   	push   %ebp
    SX1276._ss = ss;
40033127:	a2 6c 78 00 a8       	mov    %al,0xa800786c
void setPins(int ss, int reset, int dio0) {
4003312c:	89 e5                	mov    %esp,%ebp
    SX1276._reset = reset;
4003312e:	88 15 6d 78 00 a8    	mov    %dl,0xa800786d
    SX1276._dio0 = dio0;
40033134:	88 0d 6e 78 00 a8    	mov    %cl,0xa800786e
}
4003313a:	5d                   	pop    %ebp
4003313b:	c3                   	ret    

4003313c <readRegister>:
        // reset FIFO address
        writeRegister(REG_FIFO_ADDR_PTR, 0);
    }
}

uint8_t readRegister(uint8_t address) {
4003313c:	55                   	push   %ebp
    //return singleTransfer(address & 0x7f, 0x00);

    uint8_t tx_buf[2] = { address & 0x7f, 0 };
4003313d:	83 e0 7f             	and    $0x7f,%eax
uint8_t readRegister(uint8_t address) {
40033140:	89 e5                	mov    %esp,%ebp
40033142:	52                   	push   %edx
    uint8_t rx_buf[2];

    mraa_gpio_write(SX1276.gpio_ss, 0);
40033143:	31 d2                	xor    %edx,%edx
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
40033145:	88 45 fc             	mov    %al,-0x4(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40033148:	a1 60 78 00 a8       	mov    0xa8007860,%eax
    uint8_t tx_buf[2] = { address & 0x7f, 0 };
4003314d:	c6 45 fd 00          	movb   $0x0,-0x3(%ebp)
    mraa_gpio_write(SX1276.gpio_ss, 0);
40033151:	e8 a1 f2 ff ff       	call   400323f7 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, tx_buf, rx_buf, 2) != MRAA_SUCCESS) {
40033156:	8d 4d fe             	lea    -0x2(%ebp),%ecx
40033159:	8d 55 fc             	lea    -0x4(%ebp),%edx
4003315c:	a1 74 78 00 a8       	mov    0xa8007874,%eax
40033161:	6a 02                	push   $0x2
40033163:	e8 c3 f3 ff ff       	call   4003252b <mraa_spi_transfer_buf>
40033168:	59                   	pop    %ecx
40033169:	85 c0                	test   %eax,%eax
4003316b:	74 2a                	je     40033197 <readRegister+0x5b>
        printf("Unable to transfer data over the SPI bus\n");
4003316d:	68 f9 60 03 40       	push   $0x400360f9
40033172:	e8 85 18 00 00       	call   400349fc <iprintf>
        printf("SPI operation failed\n");
40033177:	c7 04 24 23 61 03 40 	movl   $0x40036123,(%esp)
4003317e:	e8 79 18 00 00       	call   400349fc <iprintf>
40033183:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
40033184:	ba 01 00 00 00       	mov    $0x1,%edx
40033189:	a1 60 78 00 a8       	mov    0xa8007860,%eax
4003318e:	e8 64 f2 ff ff       	call   400323f7 <mraa_gpio_write>
40033193:	b0 ff                	mov    $0xff,%al
40033195:	eb 12                	jmp    400331a9 <readRegister+0x6d>
        return -1;
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
40033197:	ba 01 00 00 00       	mov    $0x1,%edx
4003319c:	a1 60 78 00 a8       	mov    0xa8007860,%eax
400331a1:	e8 51 f2 ff ff       	call   400323f7 <mraa_gpio_write>

    return rx_buf[1];
400331a6:	8a 45 ff             	mov    -0x1(%ebp),%al
}
400331a9:	c9                   	leave  
400331aa:	c3                   	ret    

400331ab <packetRssi>:
{
400331ab:	55                   	push   %ebp
    switch(modem) {
400331ac:	85 c0                	test   %eax,%eax
{
400331ae:	89 e5                	mov    %esp,%ebp
400331b0:	53                   	push   %ebx
    switch(modem) {
400331b1:	74 3c                	je     400331ef <packetRssi+0x44>
400331b3:	48                   	dec    %eax
400331b4:	75 4c                	jne    40033202 <packetRssi+0x57>
            rssi = readRegister(REG_PKT_RSSI_VALUE) - (SX1276._frequency < 868E6 ? 164 : 157);
400331b6:	b8 1a 00 00 00       	mov    $0x1a,%eax
400331bb:	e8 7c ff ff ff       	call   4003313c <readRegister>
400331c0:	0f b6 d8             	movzbl %al,%ebx
400331c3:	a1 78 78 00 a8       	mov    0xa8007878,%eax
400331c8:	e8 64 d6 ff ff       	call   40030831 <__floatsidf>
400331cd:	68 50 de c9 41       	push   $0x41c9de50
400331d2:	68 00 00 00 80       	push   $0x80000000
400331d7:	e8 da d4 ff ff       	call   400306b6 <__ledf2>
400331dc:	c1 f8 1f             	sar    $0x1f,%eax
400331df:	5a                   	pop    %edx
400331e0:	83 e0 07             	and    $0x7,%eax
400331e3:	59                   	pop    %ecx
400331e4:	05 9d 00 00 00       	add    $0x9d,%eax
400331e9:	29 c3                	sub    %eax,%ebx
400331eb:	89 d8                	mov    %ebx,%eax
400331ed:	eb 16                	jmp    40033205 <packetRssi+0x5a>
            rssi = -(readRegister(REG_PKT_RSSI_VALUE) >> 1);
400331ef:	b8 1a 00 00 00       	mov    $0x1a,%eax
400331f4:	e8 43 ff ff ff       	call   4003313c <readRegister>
400331f9:	d0 e8                	shr    %al
400331fb:	0f b6 c0             	movzbl %al,%eax
400331fe:	f7 d8                	neg    %eax
            break;
40033200:	eb 03                	jmp    40033205 <packetRssi+0x5a>
            rssi = -1;
40033202:	83 c8 ff             	or     $0xffffffff,%eax
}
40033205:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033208:	c9                   	leave  
40033209:	c3                   	ret    

4003320a <available>:
{
4003320a:	55                   	push   %ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
4003320b:	b8 13 00 00 00       	mov    $0x13,%eax
{
40033210:	89 e5                	mov    %esp,%ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
40033212:	e8 25 ff ff ff       	call   4003313c <readRegister>
}
40033217:	5d                   	pop    %ebp
    return (readRegister(REG_RX_NB_BYTES) - SX1276._packetIndex);
40033218:	0f b6 c0             	movzbl %al,%eax
4003321b:	2b 05 7c 78 00 a8    	sub    0xa800787c,%eax
}
40033221:	c3                   	ret    

40033222 <SX1276read>:
int SX1276read() {
40033222:	55                   	push   %ebp
40033223:	89 e5                	mov    %esp,%ebp
    if (!available()) {
40033225:	e8 e0 ff ff ff       	call   4003320a <available>
4003322a:	83 ca ff             	or     $0xffffffff,%edx
4003322d:	85 c0                	test   %eax,%eax
4003322f:	74 10                	je     40033241 <SX1276read+0x1f>
    return readRegister(REG_FIFO);
40033231:	31 c0                	xor    %eax,%eax
    SX1276._packetIndex++;
40033233:	ff 05 7c 78 00 a8    	incl   0xa800787c
    return readRegister(REG_FIFO);
40033239:	e8 fe fe ff ff       	call   4003313c <readRegister>
4003323e:	0f b6 d0             	movzbl %al,%edx
}
40033241:	89 d0                	mov    %edx,%eax
40033243:	5d                   	pop    %ebp
40033244:	c3                   	ret    

40033245 <dumpRegisters>:
{
40033245:	55                   	push   %ebp
40033246:	89 e5                	mov    %esp,%ebp
40033248:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40033249:	31 db                	xor    %ebx,%ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
4003324b:	89 d8                	mov    %ebx,%eax
4003324d:	e8 ea fe ff ff       	call   4003313c <readRegister>
40033252:	0f b6 c0             	movzbl %al,%eax
40033255:	50                   	push   %eax
40033256:	53                   	push   %ebx
  for (int i = 0; i < 128; i++) {
40033257:	43                   	inc    %ebx
    printf("0x%x: 0x%x\n", i, readRegister(i));
40033258:	68 39 61 03 40       	push   $0x40036139
4003325d:	e8 9a 17 00 00       	call   400349fc <iprintf>
40033262:	83 c4 0c             	add    $0xc,%esp
  for (int i = 0; i < 128; i++) {
40033265:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
4003326b:	75 de                	jne    4003324b <dumpRegisters+0x6>
}
4003326d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033270:	c9                   	leave  
40033271:	c3                   	ret    

40033272 <writeRegister>:

void writeRegister(uint8_t address, uint8_t value) {
40033272:	55                   	push   %ebp
    //singleTransfer(address | 0x80, value);

    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40033273:	83 c8 80             	or     $0xffffff80,%eax
void writeRegister(uint8_t address, uint8_t value) {
40033276:	89 e5                	mov    %esp,%ebp
40033278:	51                   	push   %ecx
    uint8_t pkt[2] = {(uint8_t)(address | 0x80), value};
40033279:	88 45 fe             	mov    %al,-0x2(%ebp)
4003327c:	88 55 ff             	mov    %dl,-0x1(%ebp)

    mraa_gpio_write(SX1276.gpio_ss, 0);
4003327f:	a1 60 78 00 a8       	mov    0xa8007860,%eax
40033284:	31 d2                	xor    %edx,%edx
40033286:	e8 6c f1 ff ff       	call   400323f7 <mraa_gpio_write>
    if (mraa_spi_transfer_buf(SX1276.spi, pkt, NULL, 2) != MRAA_SUCCESS) {
4003328b:	31 c9                	xor    %ecx,%ecx
4003328d:	8d 55 fe             	lea    -0x2(%ebp),%edx
40033290:	a1 74 78 00 a8       	mov    0xa8007874,%eax
40033295:	6a 02                	push   $0x2
40033297:	e8 8f f2 ff ff       	call   4003252b <mraa_spi_transfer_buf>
4003329c:	5a                   	pop    %edx
4003329d:	85 c0                	test   %eax,%eax
4003329f:	74 26                	je     400332c7 <writeRegister+0x55>
        printf("Unable to transfer data over the SPI bus\n");
400332a1:	68 f9 60 03 40       	push   $0x400360f9
400332a6:	e8 51 17 00 00       	call   400349fc <iprintf>
        printf("SPI operation failed\n");
400332ab:	c7 04 24 23 61 03 40 	movl   $0x40036123,(%esp)
400332b2:	e8 45 17 00 00       	call   400349fc <iprintf>
400332b7:	58                   	pop    %eax
        mraa_gpio_write(SX1276.gpio_ss, 1);
400332b8:	ba 01 00 00 00       	mov    $0x1,%edx
400332bd:	a1 60 78 00 a8       	mov    0xa8007860,%eax
400332c2:	e8 30 f1 ff ff       	call   400323f7 <mraa_gpio_write>
    }
    mraa_gpio_write(SX1276.gpio_ss, 1);
400332c7:	ba 01 00 00 00       	mov    $0x1,%edx
400332cc:	a1 60 78 00 a8       	mov    0xa8007860,%eax
400332d1:	e8 21 f1 ff ff       	call   400323f7 <mraa_gpio_write>
}
400332d6:	c9                   	leave  
400332d7:	c3                   	ret    

400332d8 <setTxPower.part.2>:
void setTxPower(int level, int outputPin) {
400332d8:	55                   	push   %ebp
400332d9:	83 f8 11             	cmp    $0x11,%eax
400332dc:	89 e5                	mov    %esp,%ebp
400332de:	53                   	push   %ebx
400332df:	7e 05                	jle    400332e6 <setTxPower.part.2+0xe>
400332e1:	b8 11 00 00 00       	mov    $0x11,%eax
400332e6:	89 c3                	mov    %eax,%ebx
400332e8:	83 f8 02             	cmp    $0x2,%eax
400332eb:	7d 05                	jge    400332f2 <setTxPower.part.2+0x1a>
400332ed:	bb 02 00 00 00       	mov    $0x2,%ebx
        printf("value to be written to REG_PA_CONFIG; %x\n", PA_BOOST | (level - 2));
400332f2:	8d 43 fe             	lea    -0x2(%ebx),%eax
400332f5:	0c 80                	or     $0x80,%al
400332f7:	50                   	push   %eax
400332f8:	68 45 61 03 40       	push   $0x40036145
400332fd:	e8 fa 16 00 00       	call   400349fc <iprintf>
40033302:	58                   	pop    %eax
40033303:	5a                   	pop    %edx
        writeRegister(REG_PA_CONFIG, PA_BOOST | (level - 2));
40033304:	8d 53 fe             	lea    -0x2(%ebx),%edx
40033307:	83 ca 80             	or     $0xffffff80,%edx
4003330a:	b8 09 00 00 00       	mov    $0x9,%eax
4003330f:	0f b6 d2             	movzbl %dl,%edx
40033312:	e8 5b ff ff ff       	call   40033272 <writeRegister>
        printf("REG_PA_CONFIG: %x\n", readRegister(REG_PA_CONFIG));
40033317:	b8 09 00 00 00       	mov    $0x9,%eax
4003331c:	e8 1b fe ff ff       	call   4003313c <readRegister>
40033321:	0f b6 c0             	movzbl %al,%eax
40033324:	50                   	push   %eax
40033325:	68 6f 61 03 40       	push   $0x4003616f
4003332a:	e8 cd 16 00 00       	call   400349fc <iprintf>
4003332f:	59                   	pop    %ecx
40033330:	5b                   	pop    %ebx
}
40033331:	8b 5d fc             	mov    -0x4(%ebp),%ebx
40033334:	c9                   	leave  
40033335:	c3                   	ret    

40033336 <setFrequency>:
void setFrequency(long frequency) {
40033336:	55                   	push   %ebp
40033337:	89 e5                	mov    %esp,%ebp
40033339:	57                   	push   %edi
4003333a:	56                   	push   %esi
4003333b:	89 c6                	mov    %eax,%esi
    printf("setting Frequency to: %d\n", frequency);
4003333d:	50                   	push   %eax
4003333e:	68 82 61 03 40       	push   $0x40036182
40033343:	e8 b4 16 00 00       	call   400349fc <iprintf>
40033348:	58                   	pop    %eax
    frequency = frequency/1.00001732945;
40033349:	89 f0                	mov    %esi,%eax
    printf("setting Frequency to: %d\n", frequency);
4003334b:	5a                   	pop    %edx
    frequency = frequency/1.00001732945;
4003334c:	e8 e0 d4 ff ff       	call   40030831 <__floatsidf>
40033351:	68 12 00 f0 3f       	push   $0x3ff00012
40033356:	68 73 bc d6 2b       	push   $0x2bd6bc73
4003335b:	e8 26 ce ff ff       	call   40030186 <__divdf3>
40033360:	59                   	pop    %ecx
40033361:	5e                   	pop    %esi
40033362:	e8 60 d4 ff ff       	call   400307c7 <__fixdfsi>
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40033367:	6a 00                	push   $0x0
40033369:	99                   	cltd   
    SX1276._frequency = frequency;
4003336a:	a3 78 78 00 a8       	mov    %eax,0xa8007878
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
4003336f:	68 00 48 e8 01       	push   $0x1e84800
40033374:	0f a4 c2 13          	shld   $0x13,%eax,%edx
40033378:	c1 e0 13             	shl    $0x13,%eax
4003337b:	e8 10 cd ff ff       	call   40030090 <__udivdi3>
40033380:	5f                   	pop    %edi
40033381:	89 c6                	mov    %eax,%esi
40033383:	89 d7                	mov    %edx,%edi
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40033385:	0f ac d0 10          	shrd   $0x10,%edx,%eax
40033389:	0f b6 d0             	movzbl %al,%edx
4003338c:	b8 06 00 00 00       	mov    $0x6,%eax
    uint64_t frf = ((uint64_t)frequency << 19) / 32000000;
40033391:	59                   	pop    %ecx
    writeRegister(REG_FRF_MSB, (uint8_t)(frf >> 16));
40033392:	e8 db fe ff ff       	call   40033272 <writeRegister>
    writeRegister(REG_FRF_MID, (uint8_t)(frf >> 8));
40033397:	89 fa                	mov    %edi,%edx
40033399:	89 f0                	mov    %esi,%eax
4003339b:	0f ac d0 08          	shrd   $0x8,%edx,%eax
4003339f:	0f b6 d0             	movzbl %al,%edx
400333a2:	b8 07 00 00 00       	mov    $0x7,%eax
400333a7:	e8 c6 fe ff ff       	call   40033272 <writeRegister>
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400333ac:	89 f0                	mov    %esi,%eax
}
400333ae:	8d 65 f8             	lea    -0x8(%ebp),%esp
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400333b1:	0f b6 d0             	movzbl %al,%edx
400333b4:	b8 08 00 00 00       	mov    $0x8,%eax
}
400333b9:	5e                   	pop    %esi
400333ba:	5f                   	pop    %edi
400333bb:	5d                   	pop    %ebp
    writeRegister(REG_FRF_LSB, (uint8_t)(frf >> 0));
400333bc:	e9 b1 fe ff ff       	jmp    40033272 <writeRegister>

400333c1 <explicitHeaderMode>:
void explicitHeaderMode() {
400333c1:	55                   	push   %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400333c2:	b8 1d 00 00 00       	mov    $0x1d,%eax
void explicitHeaderMode() {
400333c7:	89 e5                	mov    %esp,%ebp
    SX1276._implicitHeaderMode = 0;
400333c9:	c7 05 80 78 00 a8 00 	movl   $0x0,0xa8007880
400333d0:	00 00 00 
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400333d3:	e8 64 fd ff ff       	call   4003313c <readRegister>
}
400333d8:	5d                   	pop    %ebp
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) & 0xfe);
400333d9:	89 c2                	mov    %eax,%edx
400333db:	b8 1d 00 00 00       	mov    $0x1d,%eax
400333e0:	81 e2 fe 00 00 00    	and    $0xfe,%edx
400333e6:	e9 87 fe ff ff       	jmp    40033272 <writeRegister>

400333eb <implicitHeaderMode>:
void implicitHeaderMode() {
400333eb:	55                   	push   %ebp
400333ec:	89 e5                	mov    %esp,%ebp
    printf("inside implicit header mode\n");
400333ee:	68 9c 61 03 40       	push   $0x4003619c
400333f3:	e8 04 16 00 00       	call   400349fc <iprintf>
400333f8:	58                   	pop    %eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
400333f9:	b8 1d 00 00 00       	mov    $0x1d,%eax
    SX1276._implicitHeaderMode = 1;
400333fe:	c7 05 80 78 00 a8 01 	movl   $0x1,0xa8007880
40033405:	00 00 00 
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033408:	e8 2f fd ff ff       	call   4003313c <readRegister>
4003340d:	0f b6 c0             	movzbl %al,%eax
40033410:	50                   	push   %eax
40033411:	68 b9 61 03 40       	push   $0x400361b9
40033416:	e8 e1 15 00 00       	call   400349fc <iprintf>
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
4003341b:	b8 1d 00 00 00       	mov    $0x1d,%eax
    printf("initial value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033420:	5a                   	pop    %edx
40033421:	59                   	pop    %ecx
    writeRegister(REG_MODEM_CONFIG_1, readRegister(REG_MODEM_CONFIG_1) | 0x01);
40033422:	e8 15 fd ff ff       	call   4003313c <readRegister>
40033427:	83 c8 01             	or     $0x1,%eax
4003342a:	0f b6 d0             	movzbl %al,%edx
4003342d:	b8 1d 00 00 00       	mov    $0x1d,%eax
40033432:	e8 3b fe ff ff       	call   40033272 <writeRegister>
    printf("next value of REG_MODEM_CONFIG_1: %x\n", readRegister(REG_MODEM_CONFIG_1));
40033437:	b8 1d 00 00 00       	mov    $0x1d,%eax
4003343c:	e8 fb fc ff ff       	call   4003313c <readRegister>
40033441:	0f b6 c0             	movzbl %al,%eax
40033444:	50                   	push   %eax
40033445:	68 e2 61 03 40       	push   $0x400361e2
4003344a:	e8 ad 15 00 00       	call   400349fc <iprintf>
4003344f:	58                   	pop    %eax
40033450:	5a                   	pop    %edx
}
40033451:	c9                   	leave  
40033452:	c3                   	ret    

40033453 <SX1276SetOpMode>:
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
            break;
    }
}

void SX1276SetOpMode(uint8_t mode) {
40033453:	55                   	push   %ebp
40033454:	89 e5                	mov    %esp,%ebp
40033456:	53                   	push   %ebx
40033457:	89 c3                	mov    %eax,%ebx
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
40033459:	b8 01 00 00 00       	mov    $0x1,%eax
4003345e:	e8 d9 fc ff ff       	call   4003313c <readRegister>
40033463:	83 e0 80             	and    $0xffffff80,%eax
40033466:	09 d8                	or     %ebx,%eax
}
40033468:	5b                   	pop    %ebx
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
40033469:	0f b6 d0             	movzbl %al,%edx
4003346c:	b8 01 00 00 00       	mov    $0x1,%eax
}
40033471:	5d                   	pop    %ebp
    writeRegister(REG_OP_MODE, (readRegister(REG_OP_MODE)&OP_MODE_MASK) | mode);
40033472:	e9 fb fd ff ff       	jmp    40033272 <writeRegister>

40033477 <idle>:
void idle() {
40033477:	55                   	push   %ebp
40033478:	89 e5                	mov    %esp,%ebp
    printf("Setting to idle state\n");
4003347a:	68 08 62 03 40       	push   $0x40036208
4003347f:	e8 78 15 00 00       	call   400349fc <iprintf>
40033484:	58                   	pop    %eax
    SX1276SetOpMode(MODE_STDBY);
40033485:	b8 01 00 00 00       	mov    $0x1,%eax
}
4003348a:	c9                   	leave  
    SX1276SetOpMode(MODE_STDBY);
4003348b:	e9 c3 ff ff ff       	jmp    40033453 <SX1276SetOpMode>

40033490 <parsePacket>:
int parsePacket(int size) {
40033490:	55                   	push   %ebp
40033491:	89 e5                	mov    %esp,%ebp
40033493:	57                   	push   %edi
40033494:	56                   	push   %esi
40033495:	89 c6                	mov    %eax,%esi
    int irqFlags = readRegister(REG_IRQ_FLAGS);
40033497:	b8 12 00 00 00       	mov    $0x12,%eax
int parsePacket(int size) {
4003349c:	53                   	push   %ebx
    int irqFlags = readRegister(REG_IRQ_FLAGS);
4003349d:	e8 9a fc ff ff       	call   4003313c <readRegister>
    if (size > 0) {
400334a2:	85 f6                	test   %esi,%esi
    int irqFlags = readRegister(REG_IRQ_FLAGS);
400334a4:	0f b6 f8             	movzbl %al,%edi
400334a7:	89 fb                	mov    %edi,%ebx
    if (size > 0) {
400334a9:	7e 16                	jle    400334c1 <parsePacket+0x31>
        implicitHeaderMode();
400334ab:	e8 3b ff ff ff       	call   400333eb <implicitHeaderMode>
        writeRegister(REG_PAYLOAD_LENGTH, size & 0xff);
400334b0:	89 f0                	mov    %esi,%eax
400334b2:	0f b6 d0             	movzbl %al,%edx
400334b5:	b8 22 00 00 00       	mov    $0x22,%eax
400334ba:	e8 b3 fd ff ff       	call   40033272 <writeRegister>
400334bf:	eb 05                	jmp    400334c6 <parsePacket+0x36>
        explicitHeaderMode();
400334c1:	e8 fb fe ff ff       	call   400333c1 <explicitHeaderMode>
    writeRegister(REG_IRQ_FLAGS, irqFlags);
400334c6:	89 fa                	mov    %edi,%edx
400334c8:	b8 12 00 00 00       	mov    $0x12,%eax
    if ((irqFlags & RFLR_IRQFLAGS_RXDONE_MASK) && (irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK) == 0) {
400334cd:	83 e3 60             	and    $0x60,%ebx
    writeRegister(REG_IRQ_FLAGS, irqFlags);
400334d0:	e8 9d fd ff ff       	call   40033272 <writeRegister>
    if ((irqFlags & RFLR_IRQFLAGS_RXDONE_MASK) && (irqFlags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK) == 0) {
400334d5:	80 fb 40             	cmp    $0x40,%bl
400334d8:	75 43                	jne    4003351d <parsePacket+0x8d>
        SX1276._packetIndex = 0;
400334da:	c7 05 7c 78 00 a8 00 	movl   $0x0,0xa800787c
400334e1:	00 00 00 
            packetLength = readRegister(REG_PAYLOAD_LENGTH);
400334e4:	b8 22 00 00 00       	mov    $0x22,%eax
        if (SX1276._implicitHeaderMode) {
400334e9:	83 3d 80 78 00 a8 00 	cmpl   $0x0,0xa8007880
400334f0:	75 05                	jne    400334f7 <parsePacket+0x67>
            packetLength = readRegister(REG_RX_NB_BYTES);
400334f2:	b8 13 00 00 00       	mov    $0x13,%eax
400334f7:	e8 40 fc ff ff       	call   4003313c <readRegister>
400334fc:	0f b6 d8             	movzbl %al,%ebx
        writeRegister(REG_FIFO_ADDR_PTR, readRegister(REG_FIFO_RX_CURRENT_ADDR));
400334ff:	b8 10 00 00 00       	mov    $0x10,%eax
40033504:	e8 33 fc ff ff       	call   4003313c <readRegister>
40033509:	0f b6 d0             	movzbl %al,%edx
4003350c:	b8 0d 00 00 00       	mov    $0xd,%eax
40033511:	e8 5c fd ff ff       	call   40033272 <writeRegister>
        idle();
40033516:	e8 5c ff ff ff       	call   40033477 <idle>
4003351b:	eb 26                	jmp    40033543 <parsePacket+0xb3>
    } else if (readRegister(REG_OP_MODE) != (MODE_LONG_RANGE_MODE | MODE_RX_SINGLE)) {
4003351d:	b8 01 00 00 00       	mov    $0x1,%eax
    int packetLength = 0;
40033522:	31 db                	xor    %ebx,%ebx
    } else if (readRegister(REG_OP_MODE) != (MODE_LONG_RANGE_MODE | MODE_RX_SINGLE)) {
40033524:	e8 13 fc ff ff       	call   4003313c <readRegister>
40033529:	3c 86                	cmp    $0x86,%al
4003352b:	74 16                	je     40033543 <parsePacket+0xb3>
        writeRegister(REG_FIFO_ADDR_PTR, 0);
4003352d:	b8 0d 00 00 00       	mov    $0xd,%eax
40033532:	31 d2                	xor    %edx,%edx
40033534:	e8 39 fd ff ff       	call   40033272 <writeRegister>
        SX1276SetOpMode(MODE_RX_SINGLE);
40033539:	b8 06 00 00 00       	mov    $0x6,%eax
4003353e:	e8 10 ff ff ff       	call   40033453 <SX1276SetOpMode>
}
40033543:	89 d8                	mov    %ebx,%eax
40033545:	5b                   	pop    %ebx
40033546:	5e                   	pop    %esi
40033547:	5f                   	pop    %edi
40033548:	5d                   	pop    %ebp
40033549:	c3                   	ret    

4003354a <SX1276sleep>:
void SX1276sleep() {
4003354a:	55                   	push   %ebp
4003354b:	89 e5                	mov    %esp,%ebp
    printf("Setting to sleep/ FIFO not accessible\n");
4003354d:	68 1f 62 03 40       	push   $0x4003621f
40033552:	e8 a5 14 00 00       	call   400349fc <iprintf>
40033557:	58                   	pop    %eax
    SX1276SetOpMode(MODE_SLEEP);
40033558:	31 c0                	xor    %eax,%eax
}
4003355a:	c9                   	leave  
    SX1276SetOpMode(MODE_SLEEP);
4003355b:	e9 f3 fe ff ff       	jmp    40033453 <SX1276SetOpMode>

40033560 <SX1276SetModem.part.3>:
void SX1276SetModem(RadioModems_t modem) {
40033560:	55                   	push   %ebp
40033561:	89 e5                	mov    %esp,%ebp
            SX1276sleep();
40033563:	e8 e2 ff ff ff       	call   4003354a <SX1276sleep>
            writeRegister(REG_OP_MODE, readRegister(REG_OP_MODE) | MODE_LONG_RANGE_MODE);
40033568:	b8 01 00 00 00       	mov    $0x1,%eax
4003356d:	e8 ca fb ff ff       	call   4003313c <readRegister>
40033572:	83 c8 80             	or     $0xffffff80,%eax
40033575:	0f b6 d0             	movzbl %al,%edx
40033578:	b8 01 00 00 00       	mov    $0x1,%eax
4003357d:	e8 f0 fc ff ff       	call   40033272 <writeRegister>
            writeRegister(REG_DIO_MAPPING_1, 0x00);
40033582:	31 d2                	xor    %edx,%edx
40033584:	b8 40 00 00 00       	mov    $0x40,%eax
40033589:	e8 e4 fc ff ff       	call   40033272 <writeRegister>
            writeRegister(REG_DIO_MAPPING_2, 0x00);
4003358e:	31 d2                	xor    %edx,%edx
40033590:	b8 41 00 00 00       	mov    $0x41,%eax
}
40033595:	5d                   	pop    %ebp
            writeRegister(REG_DIO_MAPPING_2, 0x00);
40033596:	e9 d7 fc ff ff       	jmp    40033272 <writeRegister>

4003359b <SX1276SetModem>:
    switch(modem) {
4003359b:	85 c0                	test   %eax,%eax
4003359d:	74 05                	je     400335a4 <SX1276SetModem+0x9>
4003359f:	e9 bc ff ff ff       	jmp    40033560 <SX1276SetModem.part.3>
void SX1276SetModem(RadioModems_t modem) {
400335a4:	55                   	push   %ebp
400335a5:	89 e5                	mov    %esp,%ebp
            SX1276sleep();
400335a7:	e8 9e ff ff ff       	call   4003354a <SX1276sleep>
            writeRegister(REG_OP_MODE, readRegister(REG_OP_MODE) & MODE_LONG_RANGE_MODE_OFF);
400335ac:	b8 01 00 00 00       	mov    $0x1,%eax
400335b1:	e8 86 fb ff ff       	call   4003313c <readRegister>
400335b6:	89 c2                	mov    %eax,%edx
400335b8:	b8 01 00 00 00       	mov    $0x1,%eax
400335bd:	83 e2 7f             	and    $0x7f,%edx
400335c0:	e8 ad fc ff ff       	call   40033272 <writeRegister>
            writeRegister(REG_DIO_MAPPING_1, 0x00);
400335c5:	31 d2                	xor    %edx,%edx
400335c7:	b8 40 00 00 00       	mov    $0x40,%eax
400335cc:	e8 a1 fc ff ff       	call   40033272 <writeRegister>
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
400335d1:	ba 30 00 00 00       	mov    $0x30,%edx
400335d6:	b8 41 00 00 00       	mov    $0x41,%eax
}
400335db:	5d                   	pop    %ebp
            writeRegister(REG_DIO_MAPPING_2, 0x30);    // DIO5 = ModeReady
400335dc:	e9 91 fc ff ff       	jmp    40033272 <writeRegister>

400335e1 <SX1276RxChainCalibration>:

void SX1276RxChainCalibration() {
400335e1:	55                   	push   %ebp
400335e2:	89 e5                	mov    %esp,%ebp
400335e4:	57                   	push   %edi
400335e5:	56                   	push   %esi
400335e6:	53                   	push   %ebx
400335e7:	50                   	push   %eax
    printf("Entering rx chain calibration\n");
400335e8:	68 46 62 03 40       	push   $0x40036246
400335ed:	e8 0a 14 00 00       	call   400349fc <iprintf>
    uint8_t initialFreq_lsb;

    // Save context
    // this part has been changed somewhat from the original semtech/upm driver
    // avoiding a call to the set frequency function would be easier here
    regPaConfigInitVal = readRegister( REG_PA_CONFIG );
400335f2:	b8 09 00 00 00       	mov    $0x9,%eax
    printf("Entering rx chain calibration\n");
400335f7:	5a                   	pop    %edx
    regPaConfigInitVal = readRegister( REG_PA_CONFIG );
400335f8:	e8 3f fb ff ff       	call   4003313c <readRegister>
400335fd:	89 c7                	mov    %eax,%edi
    initialFreq_msb = readRegister(REG_FRF_MSB);
400335ff:	b8 06 00 00 00       	mov    $0x6,%eax
40033604:	e8 33 fb ff ff       	call   4003313c <readRegister>
40033609:	89 c6                	mov    %eax,%esi
    initialFreq_mid = readRegister(REG_FRF_MID);
4003360b:	b8 07 00 00 00       	mov    $0x7,%eax
40033610:	e8 27 fb ff ff       	call   4003313c <readRegister>
40033615:	88 c3                	mov    %al,%bl
    initialFreq_lsb = readRegister(REG_FRF_LSB);
40033617:	b8 08 00 00 00       	mov    $0x8,%eax
4003361c:	e8 1b fb ff ff       	call   4003313c <readRegister>

    // Cut the PA just in case, RFO output, power = -1 dBm
    writeRegister( REG_PA_CONFIG, 0x00 );
40033621:	31 d2                	xor    %edx,%edx
    initialFreq_lsb = readRegister(REG_FRF_LSB);
40033623:	88 45 f3             	mov    %al,-0xd(%ebp)
    writeRegister( REG_PA_CONFIG, 0x00 );
40033626:	b8 09 00 00 00       	mov    $0x9,%eax
4003362b:	e8 42 fc ff ff       	call   40033272 <writeRegister>

    // Launch Rx chain calibration for LF band
    writeRegister( REG_IMAGE_CAL, ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
40033630:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033635:	e8 02 fb ff ff       	call   4003313c <readRegister>
4003363a:	83 c8 40             	or     $0x40,%eax
4003363d:	0f b6 d0             	movzbl %al,%edx
40033640:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033645:	e8 28 fc ff ff       	call   40033272 <writeRegister>
    while( ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
4003364a:	b8 3b 00 00 00       	mov    $0x3b,%eax
4003364f:	e8 e8 fa ff ff       	call   4003313c <readRegister>
40033654:	a8 20                	test   $0x20,%al
40033656:	75 f2                	jne    4003364a <SX1276RxChainCalibration+0x69>
    {}

    // Sets a Frequency in HF band
    setFrequency( 868000000 );
40033658:	b8 00 a1 bc 33       	mov    $0x33bca100,%eax
4003365d:	e8 d4 fc ff ff       	call   40033336 <setFrequency>

    // Launch Rx chain calibration for HF band
    writeRegister( REG_IMAGE_CAL, ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_MASK ) | RF_IMAGECAL_IMAGECAL_START );
40033662:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033667:	e8 d0 fa ff ff       	call   4003313c <readRegister>
4003366c:	83 c8 40             	or     $0x40,%eax
4003366f:	0f b6 d0             	movzbl %al,%edx
40033672:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033677:	e8 f6 fb ff ff       	call   40033272 <writeRegister>
    while( ( readRegister( REG_IMAGE_CAL ) & RF_IMAGECAL_IMAGECAL_RUNNING ) == RF_IMAGECAL_IMAGECAL_RUNNING )
4003367c:	b8 3b 00 00 00       	mov    $0x3b,%eax
40033681:	e8 b6 fa ff ff       	call   4003313c <readRegister>
40033686:	a8 20                	test   $0x20,%al
40033688:	75 f2                	jne    4003367c <SX1276RxChainCalibration+0x9b>
    {}

    // Restore context
    writeRegister( REG_PA_CONFIG, regPaConfigInitVal );
4003368a:	89 f8                	mov    %edi,%eax
4003368c:	0f b6 d0             	movzbl %al,%edx
4003368f:	b8 09 00 00 00       	mov    $0x9,%eax
40033694:	e8 d9 fb ff ff       	call   40033272 <writeRegister>

    writeRegister(REG_FRF_MSB, initialFreq_msb);
40033699:	89 f0                	mov    %esi,%eax
4003369b:	0f b6 d0             	movzbl %al,%edx
4003369e:	b8 06 00 00 00       	mov    $0x6,%eax
400336a3:	e8 ca fb ff ff       	call   40033272 <writeRegister>
    writeRegister(REG_FRF_MID, initialFreq_mid);
400336a8:	b8 07 00 00 00       	mov    $0x7,%eax
400336ad:	0f b6 d3             	movzbl %bl,%edx
400336b0:	e8 bd fb ff ff       	call   40033272 <writeRegister>
    writeRegister(REG_FRF_LSB, initialFreq_lsb);
400336b5:	b8 08 00 00 00       	mov    $0x8,%eax
400336ba:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
}
400336be:	8d 65 f4             	lea    -0xc(%ebp),%esp
400336c1:	5b                   	pop    %ebx
400336c2:	5e                   	pop    %esi
400336c3:	5f                   	pop    %edi
400336c4:	5d                   	pop    %ebp
    writeRegister(REG_FRF_LSB, initialFreq_lsb);
400336c5:	e9 a8 fb ff ff       	jmp    40033272 <writeRegister>

400336ca <init>:
{
400336ca:	55                   	push   %ebp
400336cb:	89 e5                	mov    %esp,%ebp
400336cd:	56                   	push   %esi
400336ce:	89 c6                	mov    %eax,%esi
400336d0:	53                   	push   %ebx
    if(!(SX1276.gpio_ss = mraa_gpio_init(SX1276._ss))) {
400336d1:	0f b6 05 6c 78 00 a8 	movzbl 0xa800786c,%eax
400336d8:	e8 f2 eb ff ff       	call   400322cf <mraa_gpio_init>
400336dd:	a3 60 78 00 a8       	mov    %eax,0xa8007860
400336e2:	85 c0                	test   %eax,%eax
400336e4:	75 0b                	jne    400336f1 <init+0x27>
        printf("sx1276: unable to init SPI CS\n");
400336e6:	68 65 62 03 40       	push   $0x40036265
400336eb:	e8 0c 13 00 00       	call   400349fc <iprintf>
400336f0:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_ss, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
400336f1:	31 d2                	xor    %edx,%edx
400336f3:	a1 60 78 00 a8       	mov    0xa8007860,%eax
400336f8:	e8 84 ec ff ff       	call   40032381 <mraa_gpio_dir>
400336fd:	85 c0                	test   %eax,%eax
400336ff:	74 0b                	je     4003370c <init+0x42>
        printf("sx1276: unable to set direction on SPI CS\n");
40033701:	68 84 62 03 40       	push   $0x40036284
40033706:	e8 f1 12 00 00       	call   400349fc <iprintf>
4003370b:	58                   	pop    %eax
    if(!(SX1276.gpio_reset = mraa_gpio_init(SX1276._reset))) {
4003370c:	0f b6 05 6d 78 00 a8 	movzbl 0xa800786d,%eax
40033713:	e8 b7 eb ff ff       	call   400322cf <mraa_gpio_init>
40033718:	a3 64 78 00 a8       	mov    %eax,0xa8007864
4003371d:	85 c0                	test   %eax,%eax
4003371f:	75 0b                	jne    4003372c <init+0x62>
        printf("sx1276: unable to init chip reset\n");
40033721:	68 af 62 03 40       	push   $0x400362af
40033726:	e8 d1 12 00 00       	call   400349fc <iprintf>
4003372b:	58                   	pop    %eax
    if(mraa_gpio_dir(SX1276.gpio_reset, MRAA_GPIO_OUT) != MRAA_SUCCESS) {
4003372c:	31 d2                	xor    %edx,%edx
4003372e:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40033733:	e8 49 ec ff ff       	call   40032381 <mraa_gpio_dir>
40033738:	85 c0                	test   %eax,%eax
4003373a:	74 0b                	je     40033747 <init+0x7d>
        printf("sx1276: unable to set direction on reset pin\n");
4003373c:	68 d2 62 03 40       	push   $0x400362d2
40033741:	e8 b6 12 00 00       	call   400349fc <iprintf>
40033746:	5b                   	pop    %ebx
    mraa_gpio_write(SX1276.gpio_reset, 1);
40033747:	ba 01 00 00 00       	mov    $0x1,%edx
4003374c:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40033751:	e8 a1 ec ff ff       	call   400323f7 <mraa_gpio_write>
    upm_delay_us(1000);
40033756:	b8 e8 03 00 00       	mov    $0x3e8,%eax
4003375b:	e8 11 f9 ff ff       	call   40033071 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 0);
40033760:	31 d2                	xor    %edx,%edx
40033762:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40033767:	e8 8b ec ff ff       	call   400323f7 <mraa_gpio_write>
    upm_delay_us(1000);
4003376c:	b8 e8 03 00 00       	mov    $0x3e8,%eax
40033771:	e8 fb f8 ff ff       	call   40033071 <upm_delay_us>
    mraa_gpio_write(SX1276.gpio_reset, 1);
40033776:	ba 01 00 00 00       	mov    $0x1,%edx
4003377b:	a1 64 78 00 a8       	mov    0xa8007864,%eax
40033780:	e8 72 ec ff ff       	call   400323f7 <mraa_gpio_write>
    upm_delay_us(15000);
40033785:	b8 98 3a 00 00       	mov    $0x3a98,%eax
4003378a:	e8 e2 f8 ff ff       	call   40033071 <upm_delay_us>
    SX1276RxChainCalibration();
4003378f:	e8 4d fe ff ff       	call   400335e1 <SX1276RxChainCalibration>
    mraa_gpio_write(SX1276.gpio_ss, 1);
40033794:	ba 01 00 00 00       	mov    $0x1,%edx
40033799:	a1 60 78 00 a8       	mov    0xa8007860,%eax
4003379e:	e8 54 ec ff ff       	call   400323f7 <mraa_gpio_write>
    uint8_t version = readRegister(REG_VERSION);
400337a3:	b8 42 00 00 00       	mov    $0x42,%eax
400337a8:	e8 8f f9 ff ff       	call   4003313c <readRegister>
400337ad:	0f b6 d8             	movzbl %al,%ebx
    if (version != 0x12) {
400337b0:	80 fb 12             	cmp    $0x12,%bl
400337b3:	74 0b                	je     400337c0 <init+0xf6>
        printf("wrong version\n");
400337b5:	68 00 63 03 40       	push   $0x40036300
400337ba:	e8 3d 12 00 00       	call   400349fc <iprintf>
400337bf:	59                   	pop    %ecx
    printf("chip version: %x\n", version);
400337c0:	53                   	push   %ebx
400337c1:	68 0f 63 03 40       	push   $0x4003630f
400337c6:	e8 31 12 00 00       	call   400349fc <iprintf>
400337cb:	58                   	pop    %eax
400337cc:	5a                   	pop    %edx
    SX1276sleep();
400337cd:	e8 78 fd ff ff       	call   4003354a <SX1276sleep>
400337d2:	31 db                	xor    %ebx,%ebx
        SX1276SetModem( RadioRegsInit[i].Modem );
400337d4:	8b 83 e0 63 03 40    	mov    0x400363e0(%ebx),%eax
400337da:	83 c3 08             	add    $0x8,%ebx
400337dd:	e8 b9 fd ff ff       	call   4003359b <SX1276SetModem>
        writeRegister( RadioRegsInit[i].Addr, RadioRegsInit[i].Value );
400337e2:	0f b6 93 dd 63 03 40 	movzbl 0x400363dd(%ebx),%edx
400337e9:	0f b6 83 dc 63 03 40 	movzbl 0x400363dc(%ebx),%eax
400337f0:	e8 7d fa ff ff       	call   40033272 <writeRegister>
    for( i = 0; i < sizeof( RadioRegsInit ) / sizeof( RadioRegisters_t ); i++ )
400337f5:	81 fb 80 00 00 00    	cmp    $0x80,%ebx
400337fb:	75 d7                	jne    400337d4 <init+0x10a>
400337fd:	e8 5e fd ff ff       	call   40033560 <SX1276SetModem.part.3>
    setFrequency(frequency);
40033802:	89 f0                	mov    %esi,%eax
40033804:	e8 2d fb ff ff       	call   40033336 <setFrequency>
    printf("setting rx and tx base addresses\n");
40033809:	68 21 63 03 40       	push   $0x40036321
4003380e:	e8 e9 11 00 00       	call   400349fc <iprintf>
40033813:	58                   	pop    %eax
    writeRegister(REG_FIFO_TX_BASE_ADDR, 0);
40033814:	31 d2                	xor    %edx,%edx
40033816:	b8 0e 00 00 00       	mov    $0xe,%eax
4003381b:	e8 52 fa ff ff       	call   40033272 <writeRegister>
    writeRegister(REG_FIFO_RX_BASE_ADDR, 0);
40033820:	31 d2                	xor    %edx,%edx
40033822:	b8 0f 00 00 00       	mov    $0xf,%eax
40033827:	e8 46 fa ff ff       	call   40033272 <writeRegister>
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
4003382c:	b8 0e 00 00 00       	mov    $0xe,%eax
40033831:	e8 06 f9 ff ff       	call   4003313c <readRegister>
40033836:	0f b6 c0             	movzbl %al,%eax
40033839:	50                   	push   %eax
4003383a:	68 43 63 03 40       	push   $0x40036343
4003383f:	e8 b8 11 00 00       	call   400349fc <iprintf>
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40033844:	b8 0f 00 00 00       	mov    $0xf,%eax
    printf("REG_FIFO_TX_BASE_ADDR: %x\n", readRegister(REG_FIFO_TX_BASE_ADDR));
40033849:	5a                   	pop    %edx
4003384a:	59                   	pop    %ecx
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
4003384b:	e8 ec f8 ff ff       	call   4003313c <readRegister>
40033850:	0f b6 c0             	movzbl %al,%eax
40033853:	50                   	push   %eax
40033854:	68 5e 63 03 40       	push   $0x4003635e
40033859:	e8 9e 11 00 00       	call   400349fc <iprintf>
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
4003385e:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("REG_FIFO_RX_BASE_ADDR: %x\n", readRegister(REG_FIFO_RX_BASE_ADDR));
40033863:	5b                   	pop    %ebx
40033864:	5e                   	pop    %esi
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
40033865:	e8 d2 f8 ff ff       	call   4003313c <readRegister>
4003386a:	0f b6 c0             	movzbl %al,%eax
4003386d:	50                   	push   %eax
4003386e:	68 79 63 03 40       	push   $0x40036379
40033873:	e8 84 11 00 00       	call   400349fc <iprintf>
40033878:	58                   	pop    %eax
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
40033879:	b8 0c 00 00 00       	mov    $0xc,%eax
    printf("before REG_LNA: %x\n", readRegister(REG_LNA));
4003387e:	5a                   	pop    %edx
    writeRegister(REG_LNA, readRegister(REG_LNA) | 0x23);
4003387f:	e8 b8 f8 ff ff       	call   4003313c <readRegister>
40033884:	83 c8 23             	or     $0x23,%eax
40033887:	0f b6 d0             	movzbl %al,%edx
4003388a:	b8 0c 00 00 00       	mov    $0xc,%eax
4003388f:	e8 de f9 ff ff       	call   40033272 <writeRegister>
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
40033894:	b8 0c 00 00 00       	mov    $0xc,%eax
40033899:	e8 9e f8 ff ff       	call   4003313c <readRegister>
4003389e:	0f b6 c0             	movzbl %al,%eax
400338a1:	50                   	push   %eax
400338a2:	68 8d 63 03 40       	push   $0x4003638d
400338a7:	e8 50 11 00 00       	call   400349fc <iprintf>
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
400338ac:	ba 04 00 00 00       	mov    $0x4,%edx
400338b1:	b8 26 00 00 00       	mov    $0x26,%eax
    printf("after REG_LNA: %x\n", readRegister(REG_LNA));
400338b6:	59                   	pop    %ecx
400338b7:	5b                   	pop    %ebx
    writeRegister(REG_MODEM_CONFIG_3, 0x04);
400338b8:	e8 b5 f9 ff ff       	call   40033272 <writeRegister>
    printf("REG_MODEM_CONFIG_3; %x\n", readRegister(REG_MODEM_CONFIG_3));
400338bd:	b8 26 00 00 00       	mov    $0x26,%eax
400338c2:	e8 75 f8 ff ff       	call   4003313c <readRegister>
400338c7:	0f b6 c0             	movzbl %al,%eax
400338ca:	50                   	push   %eax
400338cb:	68 a0 63 03 40       	push   $0x400363a0
400338d0:	e8 27 11 00 00       	call   400349fc <iprintf>
400338d5:	5e                   	pop    %esi
400338d6:	58                   	pop    %eax
400338d7:	b8 11 00 00 00       	mov    $0x11,%eax
400338dc:	e8 f7 f9 ff ff       	call   400332d8 <setTxPower.part.2>
    idle();
400338e1:	e8 91 fb ff ff       	call   40033477 <idle>
}
400338e6:	8d 65 f8             	lea    -0x8(%ebp),%esp
400338e9:	b8 01 00 00 00       	mov    $0x1,%eax
400338ee:	5b                   	pop    %ebx
400338ef:	5e                   	pop    %esi
400338f0:	5d                   	pop    %ebp
400338f1:	c3                   	ret    

400338f2 <_arc_init>:
{
	uint32_t *reset_vector;

	ARG_UNUSED(arg);

	if (!SCSS_REG_VAL(SCSS_SS_STS)) {
400338f2:	a1 04 06 80 b0       	mov    0xb0800604,%eax
400338f7:	85 c0                	test   %eax,%eax
400338f9:	75 15                	jne    40033910 <_arc_init+0x1e>
{
400338fb:	55                   	push   %ebp
400338fc:	89 e5                	mov    %esp,%ebp
		/* ARC shouldn't already be running! */
		printk("ARC core already running!");
400338fe:	68 60 64 03 40       	push   $0x40036460
40033903:	e8 f8 de ff ff       	call   40031800 <printk>
40033908:	58                   	pop    %eax
		return -EIO;
40033909:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}

skip_arc_init:

	return 0;
}
4003390e:	c9                   	leave  
4003390f:	c3                   	ret    
	shared_data->arc_start = *reset_vector;
40033910:	a1 00 00 00 40       	mov    0x40000000,%eax
40033915:	a3 00 00 00 a8       	mov    %eax,0xa8000000
	shared_data->flags = 0;
4003391a:	c7 05 04 00 00 a8 00 	movl   $0x0,0xa8000004
40033921:	00 00 00 
	if (!shared_data->arc_start) {
40033924:	a1 00 00 00 a8       	mov    0xa8000000,%eax
40033929:	85 c0                	test   %eax,%eax
4003392b:	75 03                	jne    40033930 <_arc_init+0x3e>
	return 0;
4003392d:	31 c0                	xor    %eax,%eax
4003392f:	c3                   	ret    
	SCSS_REG_VAL(SCSS_SS_CFG) |= ARC_RUN_REQ_A;
40033930:	a1 00 06 80 b0       	mov    0xb0800600,%eax
40033935:	0d 00 00 00 01       	or     $0x1000000,%eax
4003393a:	a3 00 06 80 b0       	mov    %eax,0xb0800600
	while (SCSS_REG_VAL(SCSS_SS_STS) & 0x4000) {
4003393f:	a1 04 06 80 b0       	mov    0xb0800604,%eax
40033944:	0f ba e0 0e          	bt     $0xe,%eax
40033948:	72 f5                	jb     4003393f <_arc_init+0x4d>
	while (!(shared_data->flags & ARC_READY)) {
4003394a:	a1 04 00 00 a8       	mov    0xa8000004,%eax
4003394f:	a8 01                	test   $0x1,%al
40033951:	74 f7                	je     4003394a <_arc_init+0x58>
40033953:	eb d8                	jmp    4003392d <_arc_init+0x3b>

40033955 <_lakemont_eoi>:
#include <arch/x86/irq_controller.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
40033955:	55                   	push   %ebp
40033956:	89 e5                	mov    %esp,%ebp
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
40033958:	e8 a6 d2 ff ff       	call   40030c03 <__irq_controller_isr_vector_get>
4003395d:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
40033962:	31 c0                	xor    %eax,%eax
40033964:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	sys_write32(_irq_controller_isr_vector_get(),
		    CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);

	/* Send EOI to the LOAPIC as well */
	sys_write32(0, CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI);
}
40033969:	5d                   	pop    %ebp
4003396a:	c3                   	ret    

4003396b <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF *pEsf)
{
4003396b:	55                   	push   %ebp
4003396c:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
4003396e:	e8 61 0c 00 00       	call   400345d4 <k_is_in_isr>
40033973:	85 c0                	test   %eax,%eax
40033975:	74 15                	je     4003398c <_SysFatalErrorHandler+0x21>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
40033977:	e8 58 0c 00 00       	call   400345d4 <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
4003397c:	ba 7a 64 03 40       	mov    $0x4003647a,%edx
40033981:	85 c0                	test   %eax,%eax
40033983:	75 2c                	jne    400339b1 <_SysFatalErrorHandler+0x46>
40033985:	ba 7e 64 03 40       	mov    $0x4003647e,%edx
4003398a:	eb 25                	jmp    400339b1 <_SysFatalErrorHandler+0x46>
	if (k_is_in_isr() || _is_thread_essential()) {
4003398c:	e8 54 0c 00 00       	call   400345e5 <_is_thread_essential>
40033991:	85 c0                	test   %eax,%eax
40033993:	75 e2                	jne    40033977 <_SysFatalErrorHandler+0xc>
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
40033995:	ff 35 a8 76 00 a8    	pushl  0xa80076a8
4003399b:	68 af 64 03 40       	push   $0x400364af
400339a0:	e8 5b de ff ff       	call   40031800 <printk>
400339a5:	58                   	pop    %eax
	k_thread_abort(_current);
400339a6:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
	printk("Fatal fault in thread %p! Aborting.\n", _current);
400339ab:	5a                   	pop    %edx
	k_thread_abort(_current);
400339ac:	e8 6f 0d 00 00       	call   40034720 <k_thread_abort>
		printk("Fatal fault in %s! Spinning...\n",
400339b1:	52                   	push   %edx
400339b2:	68 8f 64 03 40       	push   $0x4003648f
400339b7:	e8 44 de ff ff       	call   40031800 <printk>
400339bc:	59                   	pop    %ecx
400339bd:	58                   	pop    %eax
400339be:	eb fe                	jmp    400339be <_SysFatalErrorHandler+0x53>

400339c0 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
400339c0:	53                   	push   %ebx
	movl $1, %eax
400339c1:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
400339c6:	0f a2                	cpuid  
	movl %ebx, %eax
400339c8:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
400339ca:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
400339cf:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
400339d2:	5b                   	pop    %ebx
	ret
400339d3:	c3                   	ret    

400339d4 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
400339d4:	55                   	push   %ebp
400339d5:	89 e5                	mov    %esp,%ebp
	sys_cache_line_size = _cache_line_size_get();
400339d7:	e8 e4 ff ff ff       	call   400339c0 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
400339dc:	5d                   	pop    %ebp
	sys_cache_line_size = _cache_line_size_get();
400339dd:	a3 9c 78 00 a8       	mov    %eax,0xa800789c
}
400339e2:	31 c0                	xor    %eax,%eax
400339e4:	c3                   	ret    

400339e5 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
400339e5:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
400339e6:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
400339e9:	50                   	push   %eax
	pushl	%edx
400339ea:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
400339eb:	57                   	push   %edi
	pushl	%esi
400339ec:	56                   	push   %esi
	pushl	%ebx
400339ed:	53                   	push   %ebx
	pushl	%ebp
400339ee:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
400339ef:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
400339f3:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
400339f4:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
400339fb:	00 
	je	allDone
400339fc:	74 01                	je     400339ff <allDone>
	sti
400339fe:	fb                   	sti    

400339ff <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
400339ff:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
40033a01:	ff d1                	call   *%ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
40033a03:	5d                   	pop    %ebp
	popl	%ebp
40033a04:	5d                   	pop    %ebp
	popl	%ebx
40033a05:	5b                   	pop    %ebx
	popl	%esi
40033a06:	5e                   	pop    %esi
	popl	%edi
40033a07:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
40033a08:	5a                   	pop    %edx
	popl	%eax
40033a09:	58                   	pop    %eax
	popl	%ecx
40033a0a:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
40033a0b:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033a0e:	cf                   	iret   

40033a0f <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
40033a0f:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
40033a10:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
40033a14:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
40033a17:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
40033a18:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
40033a19:	b9 a0 76 00 a8       	mov    $0xa80076a0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
40033a1e:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
40033a20:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
40033a23:	75 06                	jne    40033a2b <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
40033a25:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
40033a27:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
40033a2a:	57                   	push   %edi

40033a2b <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
40033a2b:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
40033a2c:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
40033a2e:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
40033a2f:	e8 21 ff ff ff       	call   40033955 <_lakemont_eoi>
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
40033a34:	b9 a0 76 00 a8       	mov    $0xa80076a0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
40033a39:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
40033a3b:	75 1e                	jne    40033a5b <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
40033a3d:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
40033a40:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
40033a46:	73 12                	jae    40033a5a <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
40033a48:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
40033a4b:	74 0d                	je     40033a5a <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
40033a4d:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
40033a4e:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
40033a4f:	58                   	pop    %eax
#endif
	call	_Swap
40033a50:	e8 27 00 00 00       	call   40033a7c <_Swap>

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
40033a55:	5f                   	pop    %edi
	popl	%ecx
40033a56:	59                   	pop    %ecx
	popl	%edx
40033a57:	5a                   	pop    %edx
	popl	%eax
40033a58:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033a59:	cf                   	iret   

40033a5a <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
40033a5a:	5c                   	pop    %esp

40033a5b <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
40033a5b:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
40033a5c:	59                   	pop    %ecx
	popl	%edx
40033a5d:	5a                   	pop    %edx
	popl	%eax
40033a5e:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
40033a5f:	cf                   	iret   

40033a60 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
40033a60:	6a 00                	push   $0x0

40033a62 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
40033a62:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
40033a63:	50                   	push   %eax
	pushl %ecx
40033a64:	51                   	push   %ecx
	pushl %edx
40033a65:	52                   	push   %edx
	pushl %edi
40033a66:	57                   	push   %edi
	pushl %esi
40033a67:	56                   	push   %esi
	pushl %ebx
40033a68:	53                   	push   %ebx
	pushl %ebp
40033a69:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
40033a6a:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
40033a6e:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
40033a6f:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
40033a71:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
40033a72:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
40033a77:	e8 9b 00 00 00       	call   40033b17 <_NanoFatalErrorHandler>

40033a7c <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
40033a7c:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
40033a7f:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
40033a83:	57                   	push   %edi

	movl	$_kernel, %edi
40033a84:	bf a0 76 00 a8       	mov    $0xa80076a0,%edi

	pushl	%esi
40033a89:	56                   	push   %esi
	pushl	%ebx
40033a8a:	53                   	push   %ebx
	pushl	%ebp
40033a8b:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
40033a8c:	ff 35 a4 66 03 40    	pushl  0x400366a4


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
40033a92:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
40033a95:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
40033a98:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
40033a9b:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
40033a9e:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
40033aa1:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
40033aa2:	5d                   	pop    %ebp
	popl	%ebx
40033aa3:	5b                   	pop    %ebx
	popl	%esi
40033aa4:	5e                   	pop    %esi
	popl	%edi
40033aa5:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
40033aa6:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
40033aaa:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
40033aab:	5a                   	pop    %edx
	movl	%edx, (%esp)
40033aac:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
40033aaf:	c3                   	ret    

40033ab0 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
40033ab0:	55                   	push   %ebp
40033ab1:	89 e5                	mov    %esp,%ebp
40033ab3:	56                   	push   %esi
40033ab4:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
40033ab5:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
40033ab8:	83 e3 fc             	and    $0xfffffffc,%ebx
{
40033abb:	89 c6                	mov    %eax,%esi
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
40033abd:	8b 45 10             	mov    0x10(%ebp),%eax
40033ac0:	89 43 fc             	mov    %eax,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
40033ac3:	8b 45 0c             	mov    0xc(%ebp),%eax
40033ac6:	89 43 f8             	mov    %eax,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
40033ac9:	8b 45 08             	mov    0x8(%ebp),%eax
40033acc:	89 43 f4             	mov    %eax,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
40033acf:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
40033ad2:	9c                   	pushf  
40033ad3:	58                   	pop    %eax

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033ad4:	80 e4 cd             	and    $0xcd,%ah
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
40033ad7:	c7 43 e8 60 00 03 40 	movl   $0x40030060,-0x18(%ebx)
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033ade:	80 cc 02             	or     $0x2,%ah
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033ae1:	8b 55 14             	mov    0x14(%ebp),%edx
	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40033ae4:	89 43 ec             	mov    %eax,-0x14(%ebx)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033ae7:	b9 04 00 00 00       	mov    $0x4,%ecx
40033aec:	ff 75 18             	pushl  0x18(%ebp)
40033aef:	89 f0                	mov    %esi,%eax
	pInitialCtx -= 11;
40033af1:	83 eb 2c             	sub    $0x2c,%ebx
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033af4:	e8 f4 0b 00 00       	call   400346ed <_init_thread_base>
	pInitialCtx -= 11;
40033af9:	89 5e 28             	mov    %ebx,0x28(%esi)
	thread->init_data = NULL;
40033afc:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
	thread->fn_abort = NULL;
40033b03:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
40033b0a:	58                   	pop    %eax
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
40033b0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
40033b0e:	5b                   	pop    %ebx
40033b0f:	5e                   	pop    %esi
40033b10:	5d                   	pop    %ebp
40033b11:	c3                   	ret    

40033b12 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
40033b12:	55                   	push   %ebp
40033b13:	89 e5                	mov    %esp,%ebp
40033b15:	5d                   	pop    %ebp
40033b16:	c3                   	ret    

40033b17 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
40033b17:	55                   	push   %ebp
40033b18:	89 e5                	mov    %esp,%ebp
40033b1a:	57                   	push   %edi
40033b1b:	56                   	push   %esi
40033b1c:	53                   	push   %ebx
40033b1d:	83 ec 28             	sub    $0x28,%esp
40033b20:	89 c6                	mov    %eax,%esi
	_debug_fatal_hook(pEsf);
40033b22:	89 d0                	mov    %edx,%eax
{
40033b24:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
40033b26:	e8 e7 ff ff ff       	call   40033b12 <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
40033b2b:	83 fe 03             	cmp    $0x3,%esi
40033b2e:	74 3e                	je     40033b6e <_NanoFatalErrorHandler+0x57>
40033b30:	77 06                	ja     40033b38 <_NanoFatalErrorHandler+0x21>
40033b32:	85 f6                	test   %esi,%esi
40033b34:	74 0e                	je     40033b44 <_NanoFatalErrorHandler+0x2d>
40033b36:	eb 4a                	jmp    40033b82 <_NanoFatalErrorHandler+0x6b>
40033b38:	83 fe 05             	cmp    $0x5,%esi
40033b3b:	74 3e                	je     40033b7b <_NanoFatalErrorHandler+0x64>
40033b3d:	83 fe 06             	cmp    $0x6,%esi
40033b40:	74 4d                	je     40033b8f <_NanoFatalErrorHandler+0x78>
40033b42:	eb 3e                	jmp    40033b82 <_NanoFatalErrorHandler+0x6b>
40033b44:	e8 ba d0 ff ff       	call   40030c03 <__irq_controller_isr_vector_get>
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
40033b49:	68 d4 64 03 40       	push   $0x400364d4
40033b4e:	89 c3                	mov    %eax,%ebx
40033b50:	e8 ab dc ff ff       	call   40031800 <printk>
40033b55:	58                   	pop    %eax
		if (vector >= 0) {
40033b56:	85 db                	test   %ebx,%ebx
40033b58:	78 0d                	js     40033b67 <_NanoFatalErrorHandler+0x50>
			printk("%d ", vector);
40033b5a:	53                   	push   %ebx
40033b5b:	68 f6 64 03 40       	push   $0x400364f6
40033b60:	e8 9b dc ff ff       	call   40031800 <printk>
40033b65:	5b                   	pop    %ebx
40033b66:	58                   	pop    %eax
		}
		printk("*****\n");
40033b67:	68 1d 65 03 40       	push   $0x4003651d
40033b6c:	eb 05                	jmp    40033b73 <_NanoFatalErrorHandler+0x5c>
		break;
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
40033b6e:	68 fa 64 03 40       	push   $0x400364fa
40033b73:	e8 88 dc ff ff       	call   40031800 <printk>
40033b78:	59                   	pop    %ecx
		break;
40033b79:	eb 14                	jmp    40033b8f <_NanoFatalErrorHandler+0x78>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40033b7b:	68 24 65 03 40       	push   $0x40036524
40033b80:	eb f1                	jmp    40033b73 <_NanoFatalErrorHandler+0x5c>
		break;

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
40033b82:	56                   	push   %esi
40033b83:	68 4a 65 03 40       	push   $0x4003654a
40033b88:	e8 73 dc ff ff       	call   40031800 <printk>
40033b8d:	58                   	pop    %eax
40033b8e:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = %p\n"
40033b8f:	8b 47 04             	mov    0x4(%edi),%eax
40033b92:	8b 4f 2c             	mov    0x2c(%edi),%ecx
40033b95:	89 45 f0             	mov    %eax,-0x10(%ebp)
40033b98:	8b 47 10             	mov    0x10(%edi),%eax
40033b9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
40033b9e:	8b 47 0c             	mov    0xc(%edi),%eax
40033ba1:	89 45 e8             	mov    %eax,-0x18(%ebp)
40033ba4:	8b 47 14             	mov    0x14(%edi),%eax
40033ba7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40033baa:	8b 47 1c             	mov    0x1c(%edi),%eax
40033bad:	89 45 e0             	mov    %eax,-0x20(%ebp)
40033bb0:	8b 47 08             	mov    0x8(%edi),%eax
40033bb3:	89 45 dc             	mov    %eax,-0x24(%ebp)
40033bb6:	8b 47 18             	mov    0x18(%edi),%eax
40033bb9:	8b 17                	mov    (%edi),%edx
40033bbb:	89 45 d8             	mov    %eax,-0x28(%ebp)
40033bbe:	8b 47 24             	mov    0x24(%edi),%eax
40033bc1:	89 4d cc             	mov    %ecx,-0x34(%ebp)
40033bc4:	89 55 d0             	mov    %edx,-0x30(%ebp)
40033bc7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
40033bca:	0f b7 5f 28          	movzwl 0x28(%edi),%ebx
40033bce:	e8 b3 05 00 00       	call   40034186 <k_current_get>
40033bd3:	8b 55 d0             	mov    -0x30(%ebp),%edx
40033bd6:	8b 4d cc             	mov    -0x34(%ebp),%ecx
40033bd9:	51                   	push   %ecx
40033bda:	52                   	push   %edx
40033bdb:	ff 75 f0             	pushl  -0x10(%ebp)
40033bde:	ff 75 ec             	pushl  -0x14(%ebp)
40033be1:	ff 75 e8             	pushl  -0x18(%ebp)
40033be4:	ff 75 e4             	pushl  -0x1c(%ebp)
40033be7:	ff 75 e0             	pushl  -0x20(%ebp)
40033bea:	ff 75 dc             	pushl  -0x24(%ebp)
40033bed:	ff 75 d8             	pushl  -0x28(%ebp)
40033bf0:	ff 75 d4             	pushl  -0x2c(%ebp)
40033bf3:	53                   	push   %ebx
40033bf4:	50                   	push   %eax
40033bf5:	68 6d 65 03 40       	push   $0x4003656d
40033bfa:	e8 01 dc ff ff       	call   40031800 <printk>
40033bff:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
40033c02:	89 fa                	mov    %edi,%edx
40033c04:	89 f0                	mov    %esi,%eax
40033c06:	e8 60 fd ff ff       	call   4003396b <_SysFatalErrorHandler>

40033c0b <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
40033c0b:	55                   	push   %ebp
40033c0c:	89 e5                	mov    %esp,%ebp
40033c0e:	56                   	push   %esi
40033c0f:	89 c6                	mov    %eax,%esi
40033c11:	53                   	push   %ebx
40033c12:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
40033c14:	50                   	push   %eax
40033c15:	68 0c 66 03 40       	push   $0x4003660c
40033c1a:	e8 e1 db ff ff       	call   40031800 <printk>
40033c1f:	59                   	pop    %ecx
40033c20:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
40033c21:	b8 00 7d 02 00       	mov    $0x27d00,%eax
40033c26:	0f a3 f0             	bt     %esi,%eax
40033c29:	73 0f                	jae    40033c3a <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
40033c2b:	ff 73 20             	pushl  0x20(%ebx)
40033c2e:	68 24 66 03 40       	push   $0x40036624
40033c33:	e8 c8 db ff ff       	call   40031800 <printk>
40033c38:	58                   	pop    %eax
40033c39:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
40033c3a:	89 da                	mov    %ebx,%edx
40033c3c:	b8 06 00 00 00       	mov    $0x6,%eax
40033c41:	e8 d1 fe ff ff       	call   40033b17 <_NanoFatalErrorHandler>

40033c46 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
40033c46:	55                   	push   %ebp
40033c47:	89 c2                	mov    %eax,%edx
40033c49:	89 e5                	mov    %esp,%ebp
40033c4b:	31 c0                	xor    %eax,%eax
40033c4d:	e8 b9 ff ff ff       	call   40033c0b <generic_exc_handle>

40033c52 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
40033c52:	55                   	push   %ebp
40033c53:	89 c2                	mov    %eax,%edx
40033c55:	89 e5                	mov    %esp,%ebp
40033c57:	b8 02 00 00 00       	mov    $0x2,%eax
40033c5c:	e8 aa ff ff ff       	call   40033c0b <generic_exc_handle>

40033c61 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
40033c61:	55                   	push   %ebp
40033c62:	89 c2                	mov    %eax,%edx
40033c64:	89 e5                	mov    %esp,%ebp
40033c66:	b8 04 00 00 00       	mov    $0x4,%eax
40033c6b:	e8 9b ff ff ff       	call   40033c0b <generic_exc_handle>

40033c70 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
40033c70:	55                   	push   %ebp
40033c71:	89 c2                	mov    %eax,%edx
40033c73:	89 e5                	mov    %esp,%ebp
40033c75:	b8 05 00 00 00       	mov    $0x5,%eax
40033c7a:	e8 8c ff ff ff       	call   40033c0b <generic_exc_handle>

40033c7f <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
40033c7f:	55                   	push   %ebp
40033c80:	89 c2                	mov    %eax,%edx
40033c82:	89 e5                	mov    %esp,%ebp
40033c84:	b8 06 00 00 00       	mov    $0x6,%eax
40033c89:	e8 7d ff ff ff       	call   40033c0b <generic_exc_handle>

40033c8e <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
40033c8e:	55                   	push   %ebp
40033c8f:	89 c2                	mov    %eax,%edx
40033c91:	89 e5                	mov    %esp,%ebp
40033c93:	b8 07 00 00 00       	mov    $0x7,%eax
40033c98:	e8 6e ff ff ff       	call   40033c0b <generic_exc_handle>

40033c9d <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
40033c9d:	55                   	push   %ebp
40033c9e:	89 c2                	mov    %eax,%edx
40033ca0:	89 e5                	mov    %esp,%ebp
40033ca2:	b8 08 00 00 00       	mov    $0x8,%eax
40033ca7:	e8 5f ff ff ff       	call   40033c0b <generic_exc_handle>

40033cac <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
40033cac:	55                   	push   %ebp
40033cad:	89 c2                	mov    %eax,%edx
40033caf:	89 e5                	mov    %esp,%ebp
40033cb1:	b8 0a 00 00 00       	mov    $0xa,%eax
40033cb6:	e8 50 ff ff ff       	call   40033c0b <generic_exc_handle>

40033cbb <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
40033cbb:	55                   	push   %ebp
40033cbc:	89 c2                	mov    %eax,%edx
40033cbe:	89 e5                	mov    %esp,%ebp
40033cc0:	b8 0b 00 00 00       	mov    $0xb,%eax
40033cc5:	e8 41 ff ff ff       	call   40033c0b <generic_exc_handle>

40033cca <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
40033cca:	55                   	push   %ebp
40033ccb:	89 c2                	mov    %eax,%edx
40033ccd:	89 e5                	mov    %esp,%ebp
40033ccf:	b8 0c 00 00 00       	mov    $0xc,%eax
40033cd4:	e8 32 ff ff ff       	call   40033c0b <generic_exc_handle>

40033cd9 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
40033cd9:	55                   	push   %ebp
40033cda:	89 c2                	mov    %eax,%edx
40033cdc:	89 e5                	mov    %esp,%ebp
40033cde:	b8 0d 00 00 00       	mov    $0xd,%eax
40033ce3:	e8 23 ff ff ff       	call   40033c0b <generic_exc_handle>

40033ce8 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
40033ce8:	55                   	push   %ebp
40033ce9:	89 c2                	mov    %eax,%edx
40033ceb:	89 e5                	mov    %esp,%ebp
40033ced:	b8 0e 00 00 00       	mov    $0xe,%eax
40033cf2:	e8 14 ff ff ff       	call   40033c0b <generic_exc_handle>

40033cf7 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
40033cf7:	55                   	push   %ebp
40033cf8:	89 c2                	mov    %eax,%edx
40033cfa:	89 e5                	mov    %esp,%ebp
40033cfc:	b8 10 00 00 00       	mov    $0x10,%eax
40033d01:	e8 05 ff ff ff       	call   40033c0b <generic_exc_handle>

40033d06 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
40033d06:	55                   	push   %ebp
40033d07:	89 c2                	mov    %eax,%edx
40033d09:	89 e5                	mov    %esp,%ebp
40033d0b:	b8 11 00 00 00       	mov    $0x11,%eax
40033d10:	e8 f6 fe ff ff       	call   40033c0b <generic_exc_handle>

40033d15 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
40033d15:	55                   	push   %ebp
40033d16:	89 c2                	mov    %eax,%edx
40033d18:	89 e5                	mov    %esp,%ebp
40033d1a:	b8 12 00 00 00       	mov    $0x12,%eax
40033d1f:	e8 e7 fe ff ff       	call   40033c0b <generic_exc_handle>

40033d24 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
40033d24:	55                   	push   %ebp
40033d25:	89 e5                	mov    %esp,%ebp
40033d27:	56                   	push   %esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033d28:	8d 70 01             	lea    0x1(%eax),%esi
{
40033d2b:	53                   	push   %ebx
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033d2c:	8b 1c 85 80 66 03 40 	mov    0x40036680(,%eax,4),%ebx
40033d33:	3b 1c b5 80 66 03 40 	cmp    0x40036680(,%esi,4),%ebx
40033d3a:	73 0c                	jae    40033d48 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
40033d3c:	8b 13                	mov    (%ebx),%edx
40033d3e:	89 d8                	mov    %ebx,%eax
	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40033d40:	83 c3 0c             	add    $0xc,%ebx
		device->init(info);
40033d43:	ff 52 04             	call   *0x4(%edx)
40033d46:	eb eb                	jmp    40033d33 <_sys_device_do_config_level+0xf>
	}
}
40033d48:	5b                   	pop    %ebx
40033d49:	5e                   	pop    %esi
40033d4a:	5d                   	pop    %ebp
40033d4b:	c3                   	ret    

40033d4c <device_get_binding>:

struct device *device_get_binding(const char *name)
{
40033d4c:	55                   	push   %ebp
40033d4d:	89 e5                	mov    %esp,%ebp
40033d4f:	56                   	push   %esi
40033d50:	89 c6                	mov    %eax,%esi
40033d52:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40033d53:	bb f4 66 00 a8       	mov    $0xa80066f4,%ebx
40033d58:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40033d5e:	74 1c                	je     40033d7c <device_get_binding+0x30>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033d60:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
40033d64:	75 05                	jne    40033d6b <device_get_binding+0x1f>
	for (info = __device_init_start; info != __device_init_end; info++) {
40033d66:	83 c3 0c             	add    $0xc,%ebx
40033d69:	eb ed                	jmp    40033d58 <device_get_binding+0xc>
		if (info->driver_api && !strcmp(name, info->config->name)) {
40033d6b:	8b 03                	mov    (%ebx),%eax
40033d6d:	8b 10                	mov    (%eax),%edx
40033d6f:	89 f0                	mov    %esi,%eax
40033d71:	e8 c5 0c 00 00       	call   40034a3b <strcmp>
40033d76:	85 c0                	test   %eax,%eax
40033d78:	75 ec                	jne    40033d66 <device_get_binding+0x1a>
40033d7a:	eb 02                	jmp    40033d7e <device_get_binding+0x32>
			return info;
		}
	}

	return NULL;
40033d7c:	31 db                	xor    %ebx,%ebx
}
40033d7e:	89 d8                	mov    %ebx,%eax
40033d80:	5b                   	pop    %ebx
40033d81:	5e                   	pop    %esi
40033d82:	5d                   	pop    %ebp
40033d83:	c3                   	ret    

40033d84 <device_busy_set>:
40033d84:	55                   	push   %ebp
40033d85:	89 e5                	mov    %esp,%ebp
40033d87:	5d                   	pop    %ebp
40033d88:	c3                   	ret    

40033d89 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
40033d89:	55                   	push   %ebp
40033d8a:	89 e5                	mov    %esp,%ebp
	atomic_clear_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
40033d8c:	5d                   	pop    %ebp
40033d8d:	c3                   	ret    

40033d8e <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void *unused1, void *unused2, void *unused3)
{
40033d8e:	55                   	push   %ebp
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40033d8f:	b8 02 00 00 00       	mov    $0x2,%eax
{
40033d94:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
40033d96:	e8 89 ff ff ff       	call   40033d24 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40033d9b:	b8 05 00 00 00       	mov    $0x5,%eax
40033da0:	e8 7f ff ff ff       	call   40033d24 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
40033da5:	b8 06 00 00 00       	mov    $0x6,%eax
40033daa:	e8 75 ff ff ff       	call   40033d24 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
40033daf:	b8 07 00 00 00       	mov    $0x7,%eax
40033db4:	e8 6b ff ff ff       	call   40033d24 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
40033db9:	b8 03 00 00 00       	mov    $0x3,%eax
40033dbe:	e8 61 ff ff ff       	call   40033d24 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
40033dc3:	e8 ac 08 00 00       	call   40034674 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
40033dc8:	e8 f1 ca ff ff       	call   400308be <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
}
40033dcd:	5d                   	pop    %ebp
	_main_thread->base.user_options &= ~K_ESSENTIAL;
40033dce:	80 25 c4 81 00 a8 fe 	andb   $0xfe,0xa80081c4
}
40033dd5:	c3                   	ret    

40033dd6 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40033dd6:	55                   	push   %ebp
40033dd7:	89 e5                	mov    %esp,%ebp
40033dd9:	83 ec 38             	sub    $0x38,%esp
	_current = dummy_thread;
40033ddc:	8d 45 c8             	lea    -0x38(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
40033ddf:	c6 45 d0 01          	movb   $0x1,-0x30(%ebp)
	_current = dummy_thread;
40033de3:	a3 a8 76 00 a8       	mov    %eax,0xa80076a8
	dummy_thread->base.user_options = K_ESSENTIAL;
40033de8:	b8 1c 00 00 00       	mov    $0x1c,%eax
40033ded:	8d 90 a0 76 00 a8    	lea    -0x57ff8960(%eax),%edx
40033df3:	83 c0 08             	add    $0x8,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
40033df6:	89 90 98 76 00 a8    	mov    %edx,-0x57ff8968(%eax)
	list->tail = (sys_dnode_t *)list;
40033dfc:	89 90 9c 76 00 a8    	mov    %edx,-0x57ff8964(%eax)
	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
40033e02:	3d 1c 01 00 00       	cmp    $0x11c,%eax
40033e07:	75 e4                	jne    40033ded <_Cstart+0x17>
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033e09:	6a 01                	push   $0x1
40033e0b:	b9 8e 3d 03 40       	mov    $0x40033d8e,%ecx
40033e10:	6a 00                	push   $0x0
40033e12:	ba 00 04 00 00       	mov    $0x400,%edx
40033e17:	6a 00                	push   $0x0
40033e19:	b8 bc 81 00 a8       	mov    $0xa80081bc,%eax
40033e1e:	6a 00                	push   $0x0
40033e20:	6a 00                	push   $0x0
	_ready_q.cache = _main_thread;
40033e22:	c7 05 b4 76 00 a8 bc 	movl   $0xa80081bc,0xa80076b4
40033e29:	81 00 a8 
	_new_thread(_main_stack, MAIN_STACK_SIZE,
40033e2c:	e8 7f fc ff ff       	call   40033ab0 <_new_thread>
40033e31:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_main_thread);
40033e34:	b8 bc 81 00 a8       	mov    $0xa80081bc,%eax
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40033e39:	80 25 c5 81 00 a8 fb 	andb   $0xfb,0xa80081c5
40033e40:	e8 2c 01 00 00       	call   40033f71 <_add_thread_to_ready_q>
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
40033e45:	b9 77 34 03 40       	mov    $0x40033477,%ecx
40033e4a:	ba 00 01 00 00       	mov    $0x100,%edx
40033e4f:	6a 01                	push   $0x1
40033e51:	b8 bc 80 00 a8       	mov    $0xa80080bc,%eax
40033e56:	6a 0f                	push   $0xf
40033e58:	6a 00                	push   $0x0
40033e5a:	6a 00                	push   $0x0
40033e5c:	6a 00                	push   $0x0
40033e5e:	e8 4d fc ff ff       	call   40033ab0 <_new_thread>
40033e63:	83 c4 14             	add    $0x14,%esp
	_add_thread_to_ready_q(_idle_thread);
40033e66:	b8 bc 80 00 a8       	mov    $0xa80080bc,%eax
40033e6b:	80 25 c5 80 00 a8 fb 	andb   $0xfb,0xa80080c5
40033e72:	e8 fa 00 00 00       	call   40033f71 <_add_thread_to_ready_q>
	 */

	prepare_multithreading(dummy_thread);

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
40033e77:	b8 04 00 00 00       	mov    $0x4,%eax
	list->head = (sys_dnode_t *)list;
40033e7c:	c7 05 ac 76 00 a8 ac 	movl   $0xa80076ac,0xa80076ac
40033e83:	76 00 a8 
	list->tail = (sys_dnode_t *)list;
40033e86:	c7 05 b0 76 00 a8 ac 	movl   $0xa80076ac,0xa80076b0
40033e8d:	76 00 a8 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
40033e90:	c7 05 a0 76 00 a8 00 	movl   $0x0,0xa80076a0
40033e97:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
40033e9a:	c7 05 a4 76 00 a8 bc 	movl   $0xa80080bc,0xa80076a4
40033ea1:	80 00 a8 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
40033ea4:	c7 05 a0 78 00 a8 00 	movl   $0x800,0xa80078a0
40033eab:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
40033eae:	c7 05 84 78 00 a8 e5 	movl   $0x400339e5,0xa8007884
40033eb5:	39 03 40 
40033eb8:	e8 67 fe ff ff       	call   40033d24 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40033ebd:	31 c0                	xor    %eax,%eax
40033ebf:	e8 60 fe ff ff       	call   40033d24 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
40033ec4:	b8 01 00 00 00       	mov    $0x1,%eax
40033ec9:	e8 56 fe ff ff       	call   40033d24 <_sys_device_do_config_level>
	__stack_chk_guard = (void *)sys_rand32_get();
#endif

	/* display boot banner */

	PRINT_BOOT_BANNER();
40033ece:	68 a8 66 03 40       	push   $0x400366a8
40033ed3:	68 c4 66 03 40       	push   $0x400366c4
40033ed8:	e8 23 d9 ff ff       	call   40031800 <printk>
40033edd:	58                   	pop    %eax
40033ede:	5a                   	pop    %edx
	__asm__ volatile (
40033edf:	9c                   	pushf  
40033ee0:	fa                   	cli    
40033ee1:	58                   	pop    %eax
	_Swap(irq_lock());
40033ee2:	e8 95 fb ff ff       	call   40033a7c <_Swap>

40033ee7 <_get_highest_ready_prio>:
{
40033ee7:	55                   	push   %ebp
40033ee8:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40033eea:	0f bc 05 b8 76 00 a8 	bsf    0xa80076b8,%eax
40033ef1:	75 05                	jne    40033ef8 <_get_highest_ready_prio+0x11>
40033ef3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return abs_prio - _NUM_COOP_PRIO;
40033ef8:	83 e8 10             	sub    $0x10,%eax
}
40033efb:	5d                   	pop    %ebp
40033efc:	c3                   	ret    

40033efd <_add_timeout>:

static inline void _add_timeout(struct k_thread *thread,
				struct _timeout *timeout,
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
40033efd:	55                   	push   %ebp
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
	timeout->thread = thread;
40033efe:	89 42 08             	mov    %eax,0x8(%edx)
{
40033f01:	89 e5                	mov    %esp,%ebp
	timeout->wait_q = (sys_dlist_t *)wait_q;
40033f03:	89 4a 0c             	mov    %ecx,0xc(%edx)
{
40033f06:	53                   	push   %ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
40033f07:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033f0c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033f0f:	85 c0                	test   %eax,%eax
	timeout->delta_ticks_from_prev = timeout_in_ticks;
40033f11:	89 5a 10             	mov    %ebx,0x10(%edx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033f14:	74 07                	je     40033f1d <_add_timeout+0x20>
40033f16:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40033f1b:	75 1d                	jne    40033f3a <_add_timeout+0x3d>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
40033f1d:	c7 02 ac 76 00 a8    	movl   $0xa80076ac,(%edx)
	node->prev = list->tail;
40033f23:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40033f28:	89 42 04             	mov    %eax,0x4(%edx)

	list->tail->next = node;
40033f2b:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40033f30:	89 10                	mov    %edx,(%eax)
	list->tail = node;
40033f32:	89 15 b0 76 00 a8    	mov    %edx,0xa80076b0
40033f38:	eb 34                	jmp    40033f6e <_add_timeout+0x71>
		if (*delta <= in_q->delta_ticks_from_prev) {
40033f3a:	8b 4a 10             	mov    0x10(%edx),%ecx
40033f3d:	8b 58 10             	mov    0x10(%eax),%ebx
40033f40:	39 d9                	cmp    %ebx,%ecx
40033f42:	7f 17                	jg     40033f5b <_add_timeout+0x5e>
			in_q->delta_ticks_from_prev -= *delta;
40033f44:	29 cb                	sub    %ecx,%ebx
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
40033f46:	8b 48 04             	mov    0x4(%eax),%ecx
40033f49:	89 58 10             	mov    %ebx,0x10(%eax)
40033f4c:	89 4a 04             	mov    %ecx,0x4(%edx)
		node->next = insert_point;
40033f4f:	89 02                	mov    %eax,(%edx)
		insert_point->prev->next = node;
40033f51:	8b 48 04             	mov    0x4(%eax),%ecx
40033f54:	89 11                	mov    %edx,(%ecx)
		insert_point->prev = node;
40033f56:	89 50 04             	mov    %edx,0x4(%eax)
40033f59:	eb 13                	jmp    40033f6e <_add_timeout+0x71>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
40033f5b:	29 d9                	sub    %ebx,%ecx
40033f5d:	89 4a 10             	mov    %ecx,0x10(%edx)
	return (node == list->tail) ? NULL : node->next;
40033f60:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
40033f66:	74 b5                	je     40033f1d <_add_timeout+0x20>
40033f68:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40033f6a:	85 c0                	test   %eax,%eax
40033f6c:	eb ad                	jmp    40033f1b <_add_timeout+0x1e>

inserted:
	K_DEBUG("after adding timeout %p\n", timeout);
	_dump_timeout(timeout, 0);
	_dump_timeout_q();
}
40033f6e:	5b                   	pop    %ebx
40033f6f:	5d                   	pop    %ebp
40033f70:	c3                   	ret    

40033f71 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
40033f71:	55                   	push   %ebp
40033f72:	89 e5                	mov    %esp,%ebp
40033f74:	56                   	push   %esi
40033f75:	53                   	push   %ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033f76:	bb 01 00 00 00       	mov    $0x1,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033f7b:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	return prio + _NUM_COOP_PRIO;
40033f7f:	8d 4a 10             	lea    0x10(%edx),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033f82:	89 ce                	mov    %ecx,%esi
40033f84:	c1 fe 05             	sar    $0x5,%esi
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033f87:	d3 e3                	shl    %cl,%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
40033f89:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx
	node->prev = list->tail;
40033f90:	83 c2 14             	add    $0x14,%edx
	*bmap |= _get_ready_q_prio_bit(prio);
40033f93:	09 1c b5 b8 76 00 a8 	or     %ebx,-0x57ff8948(,%esi,4)
	sys_dlist_t *q = &_ready_q.q[q_index];
40033f9a:	89 08                	mov    %ecx,(%eax)
40033f9c:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
40033fa3:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40033fa6:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
40033fad:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
40033faf:	89 04 d5 a0 76 00 a8 	mov    %eax,-0x57ff8960(,%edx,8)
	_set_ready_q_prio_bit(thread->base.prio);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033fb6:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
40033fbc:	8a 5a 0a             	mov    0xa(%edx),%bl
40033fbf:	38 58 0a             	cmp    %bl,0xa(%eax)
40033fc2:	7c 02                	jl     40033fc6 <_add_thread_to_ready_q+0x55>
40033fc4:	89 d0                	mov    %edx,%eax
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
40033fc6:	5b                   	pop    %ebx
	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
40033fc7:	a3 b4 76 00 a8       	mov    %eax,0xa80076b4
}
40033fcc:	5e                   	pop    %esi
40033fcd:	5d                   	pop    %ebp
40033fce:	c3                   	ret    

40033fcf <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
40033fcf:	55                   	push   %ebp
40033fd0:	89 e5                	mov    %esp,%ebp
40033fd2:	53                   	push   %ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40033fd3:	8b 48 04             	mov    0x4(%eax),%ecx
40033fd6:	8b 18                	mov    (%eax),%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40033fd8:	0f be 50 0a          	movsbl 0xa(%eax),%edx
40033fdc:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
40033fde:	8b 18                	mov    (%eax),%ebx
40033fe0:	89 4b 04             	mov    %ecx,0x4(%ebx)
	sys_dlist_t *q = &_ready_q.q[q_index];
40033fe3:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
40033fea:	3b 0c d5 3c 77 00 a8 	cmp    -0x57ff88c4(,%edx,8),%ecx
40033ff1:	75 1c                	jne    4003400f <_remove_thread_from_ready_q+0x40>
		_clear_ready_q_prio_bit(thread->base.prio);
40033ff3:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033ff7:	83 c1 10             	add    $0x10,%ecx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40033ffa:	ba 01 00 00 00       	mov    $0x1,%edx
	return (prio + _NUM_COOP_PRIO) >> 5;
40033fff:	89 cb                	mov    %ecx,%ebx
40034001:	c1 fb 05             	sar    $0x5,%ebx
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
40034004:	d3 e2                	shl    %cl,%edx
	*bmap &= ~_get_ready_q_prio_bit(prio);
40034006:	f7 d2                	not    %edx
40034008:	21 14 9d b8 76 00 a8 	and    %edx,-0x57ff8948(,%ebx,4)
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
4003400f:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
40034015:	39 d0                	cmp    %edx,%eax
40034017:	75 0c                	jne    40034025 <_remove_thread_from_ready_q+0x56>
	int prio = _get_highest_ready_prio();
40034019:	e8 c9 fe ff ff       	call   40033ee7 <_get_highest_ready_prio>
4003401e:	8b 14 c5 3c 77 00 a8 	mov    -0x57ff88c4(,%eax,8),%edx
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
40034025:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40034026:	89 15 b4 76 00 a8    	mov    %edx,0xa80076b4
}
4003402c:	5d                   	pop    %ebp
4003402d:	c3                   	ret    

4003402e <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
4003402e:	55                   	push   %ebp
4003402f:	89 e5                	mov    %esp,%ebp
40034031:	57                   	push   %edi
40034032:	56                   	push   %esi
40034033:	53                   	push   %ebx
	return list->head == list;
40034034:	8b 1a                	mov    (%edx),%ebx
40034036:	89 cf                	mov    %ecx,%edi
	return sys_dlist_is_empty(list) ? NULL : list->head;
40034038:	39 da                	cmp    %ebx,%edx
4003403a:	75 0b                	jne    40034047 <_pend_thread+0x19>
4003403c:	31 db                	xor    %ebx,%ebx
4003403e:	eb 07                	jmp    40034047 <_pend_thread+0x19>
	return (node == list->tail) ? NULL : node->next;
40034040:	3b 5a 04             	cmp    0x4(%edx),%ebx
40034043:	74 20                	je     40034065 <_pend_thread+0x37>
40034045:	8b 1b                	mov    (%ebx),%ebx
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
40034047:	85 db                	test   %ebx,%ebx
40034049:	74 1a                	je     40034065 <_pend_thread+0x37>
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
4003404b:	8a 4b 0a             	mov    0xa(%ebx),%cl
4003404e:	38 48 0a             	cmp    %cl,0xa(%eax)
40034051:	7d ed                	jge    40034040 <_pend_thread+0x12>
		node->prev = insert_point->prev;
40034053:	8b 73 04             	mov    0x4(%ebx),%esi
		node->next = insert_point;
40034056:	89 18                	mov    %ebx,(%eax)
		node->prev = insert_point->prev;
40034058:	89 70 04             	mov    %esi,0x4(%eax)
		insert_point->prev->next = node;
4003405b:	8b 73 04             	mov    0x4(%ebx),%esi
4003405e:	89 06                	mov    %eax,(%esi)
		insert_point->prev = node;
40034060:	89 43 04             	mov    %eax,0x4(%ebx)
40034063:	eb 10                	jmp    40034075 <_pend_thread+0x47>
	node->next = list;
40034065:	89 10                	mov    %edx,(%eax)
	node->prev = list->tail;
40034067:	8b 5a 04             	mov    0x4(%edx),%ebx
4003406a:	89 58 04             	mov    %ebx,0x4(%eax)
	list->tail->next = node;
4003406d:	8b 5a 04             	mov    0x4(%edx),%ebx
40034070:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
40034072:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state |= _THREAD_PENDING;
40034075:	80 48 09 02          	orb    $0x2,0x9(%eax)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
40034079:	83 ff ff             	cmp    $0xffffffff,%edi
4003407c:	74 1f                	je     4003409d <_pend_thread+0x6f>
4003407e:	89 d1                	mov    %edx,%ecx
40034080:	89 c3                	mov    %eax,%ebx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
40034082:	8d 70 10             	lea    0x10(%eax),%esi
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40034085:	31 d2                	xor    %edx,%edx
40034087:	8d 47 09             	lea    0x9(%edi),%eax
4003408a:	bf 0a 00 00 00       	mov    $0xa,%edi
4003408f:	f7 f7                	div    %edi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
40034091:	40                   	inc    %eax
40034092:	89 f2                	mov    %esi,%edx
40034094:	50                   	push   %eax
40034095:	89 d8                	mov    %ebx,%eax
40034097:	e8 61 fe ff ff       	call   40033efd <_add_timeout>
4003409c:	58                   	pop    %eax

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
4003409d:	8d 65 f4             	lea    -0xc(%ebp),%esp
400340a0:	5b                   	pop    %ebx
400340a1:	5e                   	pop    %esi
400340a2:	5f                   	pop    %edi
400340a3:	5d                   	pop    %ebp
400340a4:	c3                   	ret    

400340a5 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
400340a5:	55                   	push   %ebp
400340a6:	89 e5                	mov    %esp,%ebp
400340a8:	56                   	push   %esi
400340a9:	53                   	push   %ebx
400340aa:	89 c3                	mov    %eax,%ebx
	_remove_thread_from_ready_q(_current);
400340ac:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
400340b1:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
400340b3:	e8 17 ff ff ff       	call   40033fcf <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
400340b8:	89 f1                	mov    %esi,%ecx
400340ba:	89 da                	mov    %ebx,%edx
400340bc:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
}
400340c1:	5b                   	pop    %ebx
400340c2:	5e                   	pop    %esi
400340c3:	5d                   	pop    %ebp
	_pend_thread(_current, wait_q, timeout);
400340c4:	e9 65 ff ff ff       	jmp    4003402e <_pend_thread>

400340c9 <__must_switch_threads>:
/*
 * Check if there is a thread of higher prio than the current one. Should only
 * be called if we already know that the current thread is preemptible.
 */
int __must_switch_threads(void)
{
400340c9:	55                   	push   %ebp
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
400340ca:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
400340cf:	89 e5                	mov    %esp,%ebp
	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
400340d1:	0f be 50 0a          	movsbl 0xa(%eax),%edx
400340d5:	e8 0d fe ff ff       	call   40033ee7 <_get_highest_ready_prio>
#else
	return 0;
#endif
}
400340da:	5d                   	pop    %ebp
	return prio1 < prio2;
400340db:	39 c2                	cmp    %eax,%edx
400340dd:	0f 9f c0             	setg   %al
400340e0:	0f b6 c0             	movzbl %al,%eax
400340e3:	c3                   	ret    

400340e4 <_reschedule_threads>:
{
400340e4:	89 c1                	mov    %eax,%ecx
	return _is_preempt(_current) && __must_switch_threads();
400340e6:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
400340eb:	55                   	push   %ebp
400340ec:	89 e5                	mov    %esp,%ebp
400340ee:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
400340f3:	77 09                	ja     400340fe <_reschedule_threads+0x1a>
400340f5:	e8 cf ff ff ff       	call   400340c9 <__must_switch_threads>
400340fa:	85 c0                	test   %eax,%eax
400340fc:	75 09                	jne    40034107 <_reschedule_threads+0x23>
400340fe:	0f ba e1 09          	bt     $0x9,%ecx
40034102:	73 0b                	jae    4003410f <_reschedule_threads+0x2b>
	__asm__ volatile (
40034104:	fb                   	sti    
}
40034105:	eb 08                	jmp    4003410f <_reschedule_threads+0x2b>
		_Swap(key);
40034107:	89 c8                	mov    %ecx,%eax
}
40034109:	5d                   	pop    %ebp
		_Swap(key);
4003410a:	e9 6d f9 ff ff       	jmp    40033a7c <_Swap>
}
4003410f:	5d                   	pop    %ebp
40034110:	c3                   	ret    

40034111 <k_sched_unlock>:
{
40034111:	55                   	push   %ebp
40034112:	89 e5                	mov    %esp,%ebp
	__asm__ volatile (
40034114:	9c                   	pushf  
40034115:	fa                   	cli    
40034116:	58                   	pop    %eax
	++_current->base.sched_locked;
40034117:	8b 15 a8 76 00 a8    	mov    0xa80076a8,%edx
4003411d:	fe 42 0b             	incb   0xb(%edx)
}
40034120:	5d                   	pop    %ebp
	_reschedule_threads(key);
40034121:	e9 be ff ff ff       	jmp    400340e4 <_reschedule_threads>

40034126 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
40034126:	0f be 50 0a          	movsbl 0xa(%eax),%edx
	sys_dlist_t *q = &_ready_q.q[q_index];
4003412a:	8d 0c d5 3c 77 00 a8 	lea    -0x57ff88c4(,%edx,8),%ecx

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
40034131:	3b 41 04             	cmp    0x4(%ecx),%eax
40034134:	74 4f                	je     40034185 <_move_thread_to_end_of_prio_q+0x5f>
{
40034136:	55                   	push   %ebp
	node->prev = list->tail;
40034137:	83 c2 14             	add    $0x14,%edx
4003413a:	89 e5                	mov    %esp,%ebp
4003413c:	56                   	push   %esi
4003413d:	53                   	push   %ebx
	node->prev->next = node->next;
4003413e:	8b 58 04             	mov    0x4(%eax),%ebx
40034141:	8b 30                	mov    (%eax),%esi
40034143:	89 33                	mov    %esi,(%ebx)
	node->next->prev = node->prev;
40034145:	8b 30                	mov    (%eax),%esi
40034147:	89 5e 04             	mov    %ebx,0x4(%esi)
	node->next = list;
4003414a:	89 08                	mov    %ecx,(%eax)
	node->prev = list->tail;
4003414c:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
40034153:	89 48 04             	mov    %ecx,0x4(%eax)
	list->tail->next = node;
40034156:	8b 0c d5 a0 76 00 a8 	mov    -0x57ff8960(,%edx,8),%ecx
4003415d:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
4003415f:	89 04 d5 a0 76 00 a8 	mov    %eax,-0x57ff8960(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
40034166:	8b 15 b4 76 00 a8    	mov    0xa80076b4,%edx
4003416c:	39 d0                	cmp    %edx,%eax
4003416e:	75 0c                	jne    4003417c <_move_thread_to_end_of_prio_q+0x56>
	int prio = _get_highest_ready_prio();
40034170:	e8 72 fd ff ff       	call   40033ee7 <_get_highest_ready_prio>
40034175:	8b 14 c5 3c 77 00 a8 	mov    -0x57ff88c4(,%eax,8),%edx
#endif
}
4003417c:	5b                   	pop    %ebx
	*cache = *cache == thread ? _get_ready_q_head() : *cache;
4003417d:	89 15 b4 76 00 a8    	mov    %edx,0xa80076b4
}
40034183:	5e                   	pop    %esi
40034184:	5d                   	pop    %ebp
40034185:	c3                   	ret    

40034186 <k_current_get>:
		_reschedule_threads(key);
	}
}

k_tid_t k_current_get(void)
{
40034186:	55                   	push   %ebp
	return _current;
}
40034187:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
4003418c:	89 e5                	mov    %esp,%ebp
}
4003418e:	5d                   	pop    %ebp
4003418f:	c3                   	ret    

40034190 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034190:	8a 50 09             	mov    0x9(%eax),%dl
 * blocked for another reason (eg. suspended).
 *
 * Must be called with interrupts locked.
 */
static inline void _ready_thread(struct k_thread *thread)
{
40034193:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034194:	88 d1                	mov    %dl,%cl
{
40034196:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034198:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
4003419b:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003419e:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
400341a1:	75 0c                	jne    400341af <_ready_thread+0x1f>
400341a3:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
400341a7:	75 06                	jne    400341af <_ready_thread+0x1f>
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
		_add_thread_to_ready_q(thread);
	}
}
400341a9:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
400341aa:	e9 c2 fd ff ff       	jmp    40033f71 <_add_thread_to_ready_q>
}
400341af:	5d                   	pop    %ebp
400341b0:	c3                   	ret    

400341b1 <_unpend_first_thread>:
}

/* unpend the first thread from a wait queue */
/* must be called with interrupts locked */
static inline struct k_thread *_unpend_first_thread(_wait_q_t *wait_q)
{
400341b1:	55                   	push   %ebp
	if (_handling_timeouts) {
400341b2:	8b 15 a4 78 00 a8    	mov    0xa80078a4,%edx
{
400341b8:	89 e5                	mov    %esp,%ebp
	if (_handling_timeouts) {
400341ba:	85 d2                	test   %edx,%edx
400341bc:	8b 08                	mov    (%eax),%ecx
400341be:	74 1f                	je     400341df <_unpend_first_thread+0x2e>
	return list->head == list;
400341c0:	89 ca                	mov    %ecx,%edx
	return sys_dlist_is_empty(list) ? NULL : list->head;
400341c2:	39 c8                	cmp    %ecx,%eax
400341c4:	75 11                	jne    400341d7 <_unpend_first_thread+0x26>
400341c6:	31 d2                	xor    %edx,%edx
400341c8:	eb 0d                	jmp    400341d7 <_unpend_first_thread+0x26>
			if (_is_thread_timeout_expired(thread)) {
400341ca:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
400341ce:	75 1b                	jne    400341eb <_unpend_first_thread+0x3a>
	return (node == list->tail) ? NULL : node->next;
400341d0:	3b 50 04             	cmp    0x4(%eax),%edx
400341d3:	74 06                	je     400341db <_unpend_first_thread+0x2a>
400341d5:	8b 12                	mov    (%edx),%edx
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
400341d7:	85 d2                	test   %edx,%edx
400341d9:	75 ef                	jne    400341ca <_unpend_first_thread+0x19>
400341db:	31 d2                	xor    %edx,%edx
400341dd:	eb 1c                	jmp    400341fb <_unpend_first_thread+0x4a>
	return sys_dlist_is_empty(list) ? NULL : list->head;
400341df:	31 d2                	xor    %edx,%edx
400341e1:	39 c8                	cmp    %ecx,%eax
400341e3:	74 16                	je     400341fb <_unpend_first_thread+0x4a>
	struct k_thread *thread = _find_first_thread_to_unpend(wait_q, NULL);

	if (thread) {
400341e5:	85 c9                	test   %ecx,%ecx
400341e7:	74 12                	je     400341fb <_unpend_first_thread+0x4a>
400341e9:	89 ca                	mov    %ecx,%edx
	node->prev->next = node->next;
400341eb:	8b 42 04             	mov    0x4(%edx),%eax
400341ee:	8b 0a                	mov    (%edx),%ecx
400341f0:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
400341f2:	8b 0a                	mov    (%edx),%ecx
400341f4:	89 41 04             	mov    %eax,0x4(%ecx)
	thread->base.thread_state &= ~_THREAD_PENDING;
400341f7:	80 62 09 fd          	andb   $0xfd,0x9(%edx)
		_unpend_thread(thread);
	}

	return thread;
}
400341fb:	89 d0                	mov    %edx,%eax
400341fd:	5d                   	pop    %ebp
400341fe:	c3                   	ret    

400341ff <_abort_timeout>:
{
400341ff:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40034200:	8b 48 10             	mov    0x10(%eax),%ecx
{
40034203:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
40034205:	83 f9 ff             	cmp    $0xffffffff,%ecx
40034208:	74 24                	je     4003422e <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
4003420a:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
40034210:	74 05                	je     40034217 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
40034212:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
40034214:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
40034217:	8b 50 04             	mov    0x4(%eax),%edx
4003421a:	8b 08                	mov    (%eax),%ecx
4003421c:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
4003421e:	8b 08                	mov    (%eax),%ecx
40034220:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
40034223:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
4003422a:	31 c0                	xor    %eax,%eax
4003422c:	eb 03                	jmp    40034231 <_abort_timeout+0x32>
		return _INACTIVE;
4003422e:	83 c8 ff             	or     $0xffffffff,%eax
}
40034231:	5d                   	pop    %ebp
40034232:	c3                   	ret    

40034233 <k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
40034233:	55                   	push   %ebp
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
40034234:	89 50 08             	mov    %edx,0x8(%eax)
{
40034237:	89 e5                	mov    %esp,%ebp
	sem->limit = limit;
40034239:	89 48 0c             	mov    %ecx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
4003423c:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
4003423e:	89 40 04             	mov    %eax,0x4(%eax)
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
}
40034241:	5d                   	pop    %ebp
40034242:	c3                   	ret    

40034243 <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
40034243:	55                   	push   %ebp
40034244:	89 e5                	mov    %esp,%ebp
40034246:	57                   	push   %edi
40034247:	56                   	push   %esi
40034248:	89 c6                	mov    %eax,%esi
4003424a:	53                   	push   %ebx
4003424b:	9c                   	pushf  
4003424c:	fa                   	cli    
4003424d:	5f                   	pop    %edi
	struct k_thread *thread = _unpend_first_thread(&sem->wait_q);
4003424e:	e8 5e ff ff ff       	call   400341b1 <_unpend_first_thread>
	if (!thread) {
40034253:	85 c0                	test   %eax,%eax
40034255:	75 12                	jne    40034269 <k_sem_give+0x26>
	sem->count += (sem->count != sem->limit);
40034257:	8b 56 08             	mov    0x8(%esi),%edx
4003425a:	31 c0                	xor    %eax,%eax
4003425c:	39 56 0c             	cmp    %edx,0xc(%esi)
4003425f:	0f 95 c0             	setne  %al
40034262:	01 d0                	add    %edx,%eax
40034264:	89 46 08             	mov    %eax,0x8(%esi)
40034267:	eb 43                	jmp    400342ac <k_sem_give+0x69>
40034269:	89 c3                	mov    %eax,%ebx
	return _abort_timeout(&thread->base.timeout);
4003426b:	8d 40 10             	lea    0x10(%eax),%eax
4003426e:	e8 8c ff ff ff       	call   400341ff <_abort_timeout>
	_ready_thread(thread);
40034273:	89 d8                	mov    %ebx,%eax
40034275:	e8 16 ff ff ff       	call   40034190 <_ready_thread>
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
4003427a:	8b 43 28             	mov    0x28(%ebx),%eax
4003427d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return !_is_in_isr() && _must_switch_threads();
40034283:	83 3d a0 76 00 a8 00 	cmpl   $0x0,0xa80076a0
4003428a:	75 20                	jne    400342ac <k_sem_give+0x69>
	return _is_preempt(_current) && __must_switch_threads();
4003428c:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40034291:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
40034296:	77 14                	ja     400342ac <k_sem_give+0x69>
40034298:	e8 2c fe ff ff       	call   400340c9 <__must_switch_threads>
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
4003429d:	85 c0                	test   %eax,%eax
4003429f:	74 0b                	je     400342ac <k_sem_give+0x69>
		_Swap(key);
400342a1:	89 f8                	mov    %edi,%eax
	} else {
		irq_unlock(key);
	}
}
400342a3:	5b                   	pop    %ebx
400342a4:	5e                   	pop    %esi
400342a5:	5f                   	pop    %edi
400342a6:	5d                   	pop    %ebp
		_Swap(key);
400342a7:	e9 d0 f7 ff ff       	jmp    40033a7c <_Swap>
400342ac:	0f ba e7 09          	bt     $0x9,%edi
400342b0:	73 01                	jae    400342b3 <k_sem_give+0x70>
	__asm__ volatile (
400342b2:	fb                   	sti    
}
400342b3:	5b                   	pop    %ebx
400342b4:	5e                   	pop    %esi
400342b5:	5f                   	pop    %edi
400342b6:	5d                   	pop    %ebp
400342b7:	c3                   	ret    

400342b8 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
400342b8:	55                   	push   %ebp
400342b9:	89 e5                	mov    %esp,%ebp
400342bb:	53                   	push   %ebx
	__asm__ volatile (
400342bc:	9c                   	pushf  
400342bd:	fa                   	cli    
400342be:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
400342bf:	8b 48 08             	mov    0x8(%eax),%ecx
400342c2:	85 c9                	test   %ecx,%ecx
400342c4:	74 08                	je     400342ce <k_sem_take+0x16>
		sem->count--;
400342c6:	49                   	dec    %ecx
400342c7:	89 48 08             	mov    %ecx,0x8(%eax)
		irq_unlock(key);
		return 0;
400342ca:	31 c0                	xor    %eax,%eax
400342cc:	eb 09                	jmp    400342d7 <k_sem_take+0x1f>
	}

	if (timeout == K_NO_WAIT) {
400342ce:	85 d2                	test   %edx,%edx
400342d0:	75 0e                	jne    400342e0 <k_sem_take+0x28>
		irq_unlock(key);
		return -EBUSY;
400342d2:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
400342d7:	0f ba e3 09          	bt     $0x9,%ebx
400342db:	73 11                	jae    400342ee <k_sem_take+0x36>
	__asm__ volatile (
400342dd:	fb                   	sti    
400342de:	eb 0e                	jmp    400342ee <k_sem_take+0x36>
	}

	_pend_current_thread(&sem->wait_q, timeout);
400342e0:	e8 c0 fd ff ff       	call   400340a5 <_pend_current_thread>

	return _Swap(key);
400342e5:	89 d8                	mov    %ebx,%eax
}
400342e7:	5b                   	pop    %ebx
400342e8:	5d                   	pop    %ebp
	return _Swap(key);
400342e9:	e9 8e f7 ff ff       	jmp    40033a7c <_Swap>
}
400342ee:	5b                   	pop    %ebx
400342ef:	5d                   	pop    %ebp
400342f0:	c3                   	ret    

400342f1 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
400342f1:	55                   	push   %ebp
400342f2:	89 e5                	mov    %esp,%ebp
400342f4:	57                   	push   %edi
400342f5:	56                   	push   %esi
400342f6:	53                   	push   %ebx
400342f7:	83 ec 08             	sub    $0x8,%esp
400342fa:	89 c3                	mov    %eax,%ebx
	__asm__ volatile (
400342fc:	9c                   	pushf  
400342fd:	fa                   	cli    
400342fe:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
400342ff:	89 df                	mov    %ebx,%edi
40034301:	c1 ff 1f             	sar    $0x1f,%edi
40034304:	01 1d ac 78 00 a8    	add    %ebx,0xa80078ac
4003430a:	11 3d b0 78 00 a8    	adc    %edi,0xa80078b0
40034310:	0f ba e0 09          	bt     $0x9,%eax
40034314:	73 01                	jae    40034317 <_nano_sys_clock_tick_announce+0x26>
	__asm__ volatile (
40034316:	fb                   	sti    
	list->head = (sys_dnode_t *)list;
40034317:	8d 4d ec             	lea    -0x14(%ebp),%ecx
4003431a:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	list->tail = (sys_dnode_t *)list;
4003431d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	__asm__ volatile (
40034320:	9c                   	pushf  
40034321:	fa                   	cli    
40034322:	5e                   	pop    %esi
	return list->head == list;
40034323:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
40034328:	89 f2                	mov    %esi,%edx
	if (!head) {
4003432a:	85 c0                	test   %eax,%eax
4003432c:	74 07                	je     40034335 <_nano_sys_clock_tick_announce+0x44>
4003432e:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40034333:	75 10                	jne    40034345 <_nano_sys_clock_tick_announce+0x54>
40034335:	0f ba e6 09          	bt     $0x9,%esi
40034339:	0f 83 07 01 00 00    	jae    40034446 <_nano_sys_clock_tick_announce+0x155>
	__asm__ volatile (
4003433f:	fb                   	sti    
40034340:	e9 01 01 00 00       	jmp    40034446 <_nano_sys_clock_tick_announce+0x155>
	head->delta_ticks_from_prev -= ticks;
40034345:	29 58 10             	sub    %ebx,0x10(%eax)
	_handling_timeouts = 1;
40034348:	c7 05 a4 78 00 a8 01 	movl   $0x1,0xa80078a4
4003434f:	00 00 00 
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40034352:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
40034356:	75 3e                	jne    40034396 <_nano_sys_clock_tick_announce+0xa5>
	node->prev->next = node->next;
40034358:	8b 70 04             	mov    0x4(%eax),%esi
4003435b:	8b 38                	mov    (%eax),%edi
4003435d:	0f ba e2 09          	bt     $0x9,%edx
40034361:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
40034363:	8b 38                	mov    (%eax),%edi
40034365:	89 77 04             	mov    %esi,0x4(%edi)
	node->next = list->head;
40034368:	8b 75 ec             	mov    -0x14(%ebp),%esi
4003436b:	89 30                	mov    %esi,(%eax)
	node->prev = list;
4003436d:	89 48 04             	mov    %ecx,0x4(%eax)
	list->head->prev = node;
40034370:	8b 75 ec             	mov    -0x14(%ebp),%esi
	list->head = node;
40034373:	89 45 ec             	mov    %eax,-0x14(%ebp)
	list->head->prev = node;
40034376:	89 46 04             	mov    %eax,0x4(%esi)
		timeout->delta_ticks_from_prev = _EXPIRED;
40034379:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
40034380:	73 01                	jae    40034383 <_nano_sys_clock_tick_announce+0x92>
40034382:	fb                   	sti    
	__asm__ volatile (
40034383:	9c                   	pushf  
40034384:	fa                   	cli    
40034385:	5a                   	pop    %edx
	return list->head == list;
40034386:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	return sys_dlist_is_empty(list) ? NULL : list->head;
4003438b:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40034390:	74 04                	je     40034396 <_nano_sys_clock_tick_announce+0xa5>
	while (timeout && timeout->delta_ticks_from_prev == 0) {
40034392:	85 c0                	test   %eax,%eax
40034394:	75 bc                	jne    40034352 <_nano_sys_clock_tick_announce+0x61>
40034396:	0f ba e2 09          	bt     $0x9,%edx
4003439a:	73 01                	jae    4003439d <_nano_sys_clock_tick_announce+0xac>
	__asm__ volatile (
4003439c:	fb                   	sti    
	return list->head == list;
4003439d:	8b 55 ec             	mov    -0x14(%ebp),%edx
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
400343a0:	39 ca                	cmp    %ecx,%edx
400343a2:	74 04                	je     400343a8 <_nano_sys_clock_tick_announce+0xb7>
400343a4:	85 d2                	test   %edx,%edx
400343a6:	75 0f                	jne    400343b7 <_nano_sys_clock_tick_announce+0xc6>
	_handling_timeouts = 0;
400343a8:	c7 05 a4 78 00 a8 00 	movl   $0x0,0xa80078a4
400343af:	00 00 00 
400343b2:	e9 8f 00 00 00       	jmp    40034446 <_nano_sys_clock_tick_announce+0x155>
	return (node == list->tail) ? NULL : node->next;
400343b7:	31 f6                	xor    %esi,%esi
400343b9:	3b 55 f0             	cmp    -0x10(%ebp),%edx
400343bc:	74 4d                	je     4003440b <_nano_sys_clock_tick_announce+0x11a>
400343be:	8b 32                	mov    (%edx),%esi
400343c0:	eb 49                	jmp    4003440b <_nano_sys_clock_tick_announce+0x11a>
	if (timeout_obj->wait_q) {
400343c2:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
400343c6:	74 17                	je     400343df <_nano_sys_clock_tick_announce+0xee>
	node->prev->next = node->next;
400343c8:	8b 50 04             	mov    0x4(%eax),%edx
400343cb:	8b 08                	mov    (%eax),%ecx
400343cd:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
400343cf:	8b 08                	mov    (%eax),%ecx
400343d1:	89 51 04             	mov    %edx,0x4(%ecx)
		thread->base.timeout.wait_q = NULL;
400343d4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread->base.thread_state &= ~_THREAD_PENDING;
400343db:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
	thread->base.thread_state &= ~_THREAD_PRESTART;
400343df:	8a 50 09             	mov    0x9(%eax),%dl
400343e2:	88 d1                	mov    %dl,%cl
400343e4:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
400343e7:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
400343ea:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
400343ed:	74 3b                	je     4003442a <_nano_sys_clock_tick_announce+0x139>
400343ef:	0f ba e7 09          	bt     $0x9,%edi
400343f3:	73 01                	jae    400343f6 <_nano_sys_clock_tick_announce+0x105>
400343f5:	fb                   	sti    
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
400343f6:	85 f6                	test   %esi,%esi
400343f8:	74 ae                	je     400343a8 <_nano_sys_clock_tick_announce+0xb7>
	return (node == list->tail) ? NULL : node->next;
400343fa:	31 c0                	xor    %eax,%eax
400343fc:	39 75 f0             	cmp    %esi,-0x10(%ebp)
400343ff:	74 02                	je     40034403 <_nano_sys_clock_tick_announce+0x112>
40034401:	8b 06                	mov    (%esi),%eax
	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
40034403:	85 f6                	test   %esi,%esi
40034405:	74 a1                	je     400343a8 <_nano_sys_clock_tick_announce+0xb7>
40034407:	89 f2                	mov    %esi,%edx
40034409:	89 c6                	mov    %eax,%esi
	node->prev->next = node->next;
4003440b:	8b 42 04             	mov    0x4(%edx),%eax
4003440e:	8b 0a                	mov    (%edx),%ecx
40034410:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
40034412:	8b 0a                	mov    (%edx),%ecx
40034414:	89 41 04             	mov    %eax,0x4(%ecx)
	struct k_thread *thread = timeout->thread;
40034417:	8b 42 08             	mov    0x8(%edx),%eax
	__asm__ volatile (
4003441a:	9c                   	pushf  
4003441b:	fa                   	cli    
4003441c:	5f                   	pop    %edi
	timeout->delta_ticks_from_prev = _INACTIVE;
4003441d:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
	if (thread) {
40034424:	85 c0                	test   %eax,%eax
40034426:	75 9a                	jne    400343c2 <_nano_sys_clock_tick_announce+0xd1>
40034428:	eb 08                	jmp    40034432 <_nano_sys_clock_tick_announce+0x141>
4003442a:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003442e:	75 bf                	jne    400343ef <_nano_sys_clock_tick_announce+0xfe>
40034430:	eb 64                	jmp    40034496 <_nano_sys_clock_tick_announce+0x1a5>
40034432:	0f ba e7 09          	bt     $0x9,%edi
40034436:	73 01                	jae    40034439 <_nano_sys_clock_tick_announce+0x148>
	__asm__ volatile (
40034438:	fb                   	sti    
		if (timeout->func) {
40034439:	8b 4a 14             	mov    0x14(%edx),%ecx
4003443c:	85 c9                	test   %ecx,%ecx
4003443e:	74 b6                	je     400343f6 <_nano_sys_clock_tick_announce+0x105>
			timeout->func(timeout);
40034440:	89 d0                	mov    %edx,%eax
40034442:	ff d1                	call   *%ecx
40034444:	eb b0                	jmp    400343f6 <_nano_sys_clock_tick_announce+0x105>
	if (_time_slice_duration == 0) {
40034446:	a1 c0 77 00 a8       	mov    0xa80077c0,%eax
4003444b:	85 c0                	test   %eax,%eax
4003444d:	74 51                	je     400344a0 <_nano_sys_clock_tick_announce+0x1af>
	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
4003444f:	8b 15 a8 76 00 a8    	mov    0xa80076a8,%edx
40034455:	0f be 52 0a          	movsbl 0xa(%edx),%edx
40034459:	39 15 bc 77 00 a8    	cmp    %edx,0xa80077bc
4003445f:	7f 3f                	jg     400344a0 <_nano_sys_clock_tick_announce+0x1af>
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
40034461:	6b db 0a             	imul   $0xa,%ebx,%ebx
	_time_slice_elapsed += __ticks_to_ms(ticks);
40034464:	03 1d a8 78 00 a8    	add    0xa80078a8,%ebx
	if (_time_slice_elapsed >= _time_slice_duration) {
4003446a:	39 d8                	cmp    %ebx,%eax
4003446c:	7e 08                	jle    40034476 <_nano_sys_clock_tick_announce+0x185>
	_time_slice_elapsed += __ticks_to_ms(ticks);
4003446e:	89 1d a8 78 00 a8    	mov    %ebx,0xa80078a8
40034474:	eb 2a                	jmp    400344a0 <_nano_sys_clock_tick_announce+0x1af>
		_time_slice_elapsed = 0;
40034476:	c7 05 a8 78 00 a8 00 	movl   $0x0,0xa80078a8
4003447d:	00 00 00 
	__asm__ volatile (
40034480:	9c                   	pushf  
40034481:	fa                   	cli    
40034482:	5b                   	pop    %ebx
		_move_thread_to_end_of_prio_q(_current);
40034483:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40034488:	e8 99 fc ff ff       	call   40034126 <_move_thread_to_end_of_prio_q>
4003448d:	0f ba e3 09          	bt     $0x9,%ebx
40034491:	73 0d                	jae    400344a0 <_nano_sys_clock_tick_announce+0x1af>
	__asm__ volatile (
40034493:	fb                   	sti    

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
}
40034494:	eb 0a                	jmp    400344a0 <_nano_sys_clock_tick_announce+0x1af>
		_add_thread_to_ready_q(thread);
40034496:	e8 d6 fa ff ff       	call   40033f71 <_add_thread_to_ready_q>
4003449b:	e9 4f ff ff ff       	jmp    400343ef <_nano_sys_clock_tick_announce+0xfe>
400344a0:	58                   	pop    %eax
400344a1:	5a                   	pop    %edx
400344a2:	5b                   	pop    %ebx
400344a3:	5e                   	pop    %esi
400344a4:	5f                   	pop    %edi
400344a5:	5d                   	pop    %ebp
400344a6:	c3                   	ret    

400344a7 <_is_thread_ready>:
{
400344a7:	55                   	push   %ebp
400344a8:	89 e5                	mov    %esp,%ebp
	return !(_is_thread_prevented_from_running(thread) ||
400344aa:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
400344ae:	75 09                	jne    400344b9 <_is_thread_ready+0x12>
400344b0:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
400344b4:	0f 94 c0             	sete   %al
400344b7:	eb 02                	jmp    400344bb <_is_thread_ready+0x14>
400344b9:	31 c0                	xor    %eax,%eax
400344bb:	0f b6 c0             	movzbl %al,%eax
}
400344be:	5d                   	pop    %ebp
400344bf:	c3                   	ret    

400344c0 <_abort_timeout>:
{
400344c0:	55                   	push   %ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
400344c1:	8b 48 10             	mov    0x10(%eax),%ecx
{
400344c4:	89 e5                	mov    %esp,%ebp
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
400344c6:	83 f9 ff             	cmp    $0xffffffff,%ecx
400344c9:	74 24                	je     400344ef <_abort_timeout+0x2f>
	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
400344cb:	3b 05 b0 76 00 a8    	cmp    0xa80076b0,%eax
400344d1:	74 05                	je     400344d8 <_abort_timeout+0x18>
	return (node == list->tail) ? NULL : node->next;
400344d3:	8b 10                	mov    (%eax),%edx
		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
400344d5:	01 4a 10             	add    %ecx,0x10(%edx)
	node->prev->next = node->next;
400344d8:	8b 50 04             	mov    0x4(%eax),%edx
400344db:	8b 08                	mov    (%eax),%ecx
400344dd:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
400344df:	8b 08                	mov    (%eax),%ecx
400344e1:	89 51 04             	mov    %edx,0x4(%ecx)
	timeout->delta_ticks_from_prev = _INACTIVE;
400344e4:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	return 0;
400344eb:	31 c0                	xor    %eax,%eax
400344ed:	eb 03                	jmp    400344f2 <_abort_timeout+0x32>
		return _INACTIVE;
400344ef:	83 c8 ff             	or     $0xffffffff,%eax
}
400344f2:	5d                   	pop    %ebp
400344f3:	c3                   	ret    

400344f4 <schedule_new_thread>:
}
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
400344f4:	55                   	push   %ebp
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
400344f5:	85 d2                	test   %edx,%edx
{
400344f7:	89 e5                	mov    %esp,%ebp
400344f9:	57                   	push   %edi
400344fa:	56                   	push   %esi
400344fb:	53                   	push   %ebx
400344fc:	51                   	push   %ecx
400344fd:	89 c1                	mov    %eax,%ecx
	if (delay == 0) {
400344ff:	75 41                	jne    40034542 <schedule_new_thread+0x4e>
	__asm__ volatile (
40034501:	9c                   	pushf  
40034502:	fa                   	cli    
40034503:	5b                   	pop    %ebx
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034504:	80 60 09 fb          	andb   $0xfb,0x9(%eax)
	if (_is_thread_ready(thread)) {
40034508:	e8 9a ff ff ff       	call   400344a7 <_is_thread_ready>
4003450d:	85 c0                	test   %eax,%eax
4003450f:	75 09                	jne    4003451a <schedule_new_thread+0x26>
40034511:	0f ba e3 09          	bt     $0x9,%ebx
40034515:	e9 b1 00 00 00       	jmp    400345cb <schedule_new_thread+0xd7>
		_add_thread_to_ready_q(thread);
4003451a:	89 c8                	mov    %ecx,%eax
4003451c:	e8 50 fa ff ff       	call   40033f71 <_add_thread_to_ready_q>
	return _is_preempt(_current) && __must_switch_threads();
40034521:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40034526:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
4003452b:	77 e4                	ja     40034511 <schedule_new_thread+0x1d>
4003452d:	e8 97 fb ff ff       	call   400340c9 <__must_switch_threads>
40034532:	85 c0                	test   %eax,%eax
40034534:	74 db                	je     40034511 <schedule_new_thread+0x1d>
			_Swap(key);
40034536:	89 d8                	mov    %ebx,%eax
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
40034538:	5a                   	pop    %edx
40034539:	5b                   	pop    %ebx
4003453a:	5e                   	pop    %esi
4003453b:	5f                   	pop    %edi
4003453c:	5d                   	pop    %ebp
			_Swap(key);
4003453d:	e9 3a f5 ff ff       	jmp    40033a7c <_Swap>
40034542:	9c                   	pushf  
40034543:	fa                   	cli    
40034544:	8f 45 f0             	popl   -0x10(%ebp)
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
40034547:	be 0a 00 00 00       	mov    $0xa,%esi
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
4003454c:	8d 58 10             	lea    0x10(%eax),%ebx
4003454f:	8d 42 09             	lea    0x9(%edx),%eax
40034552:	31 d2                	xor    %edx,%edx
40034554:	f7 f6                	div    %esi
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
40034556:	40                   	inc    %eax
	timeout->thread = thread;
40034557:	89 49 18             	mov    %ecx,0x18(%ecx)
4003455a:	89 41 20             	mov    %eax,0x20(%ecx)
	return list->head == list;
4003455d:	a1 ac 76 00 a8       	mov    0xa80076ac,%eax
	timeout->wait_q = (sys_dlist_t *)wait_q;
40034562:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
40034569:	85 c0                	test   %eax,%eax
4003456b:	74 0d                	je     4003457a <schedule_new_thread+0x86>
4003456d:	8b 3d b0 76 00 a8    	mov    0xa80076b0,%edi
40034573:	3d ac 76 00 a8       	cmp    $0xa80076ac,%eax
40034578:	75 19                	jne    40034593 <schedule_new_thread+0x9f>
	node->next = list;
4003457a:	c7 41 10 ac 76 00 a8 	movl   $0xa80076ac,0x10(%ecx)
	node->prev = list->tail;
40034581:	a1 b0 76 00 a8       	mov    0xa80076b0,%eax
40034586:	89 41 14             	mov    %eax,0x14(%ecx)
	list->tail->next = node;
40034589:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
4003458b:	89 1d b0 76 00 a8    	mov    %ebx,0xa80076b0
40034591:	eb 31                	jmp    400345c4 <schedule_new_thread+0xd0>
		if (*delta <= in_q->delta_ticks_from_prev) {
40034593:	8b 51 20             	mov    0x20(%ecx),%edx
40034596:	8b 70 10             	mov    0x10(%eax),%esi
40034599:	39 f2                	cmp    %esi,%edx
4003459b:	7f 18                	jg     400345b5 <schedule_new_thread+0xc1>
			in_q->delta_ticks_from_prev -= *delta;
4003459d:	29 d6                	sub    %edx,%esi
		node->prev = insert_point->prev;
4003459f:	8b 50 04             	mov    0x4(%eax),%edx
400345a2:	89 70 10             	mov    %esi,0x10(%eax)
400345a5:	89 51 14             	mov    %edx,0x14(%ecx)
		node->next = insert_point;
400345a8:	89 41 10             	mov    %eax,0x10(%ecx)
		insert_point->prev->next = node;
400345ab:	8b 50 04             	mov    0x4(%eax),%edx
400345ae:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
400345b0:	89 58 04             	mov    %ebx,0x4(%eax)
400345b3:	eb 0f                	jmp    400345c4 <schedule_new_thread+0xd0>
		*delta -= in_q->delta_ticks_from_prev;
400345b5:	29 f2                	sub    %esi,%edx
	return (node == list->tail) ? NULL : node->next;
400345b7:	39 f8                	cmp    %edi,%eax
400345b9:	89 51 20             	mov    %edx,0x20(%ecx)
400345bc:	74 bc                	je     4003457a <schedule_new_thread+0x86>
400345be:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
400345c0:	85 c0                	test   %eax,%eax
400345c2:	eb b4                	jmp    40034578 <schedule_new_thread+0x84>
400345c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
400345c7:	0f ba e0 09          	bt     $0x9,%eax
400345cb:	73 01                	jae    400345ce <schedule_new_thread+0xda>
	__asm__ volatile (
400345cd:	fb                   	sti    
}
400345ce:	58                   	pop    %eax
400345cf:	5b                   	pop    %ebx
400345d0:	5e                   	pop    %esi
400345d1:	5f                   	pop    %edi
400345d2:	5d                   	pop    %ebp
400345d3:	c3                   	ret    

400345d4 <k_is_in_isr>:
{
400345d4:	55                   	push   %ebp
	return _is_in_isr();
400345d5:	31 c0                	xor    %eax,%eax
{
400345d7:	89 e5                	mov    %esp,%ebp
}
400345d9:	5d                   	pop    %ebp
	return _is_in_isr();
400345da:	83 3d a0 76 00 a8 00 	cmpl   $0x0,0xa80076a0
400345e1:	0f 95 c0             	setne  %al
}
400345e4:	c3                   	ret    

400345e5 <_is_thread_essential>:
	return _current->base.user_options & K_ESSENTIAL;
400345e5:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
{
400345ea:	55                   	push   %ebp
400345eb:	89 e5                	mov    %esp,%ebp
}
400345ed:	5d                   	pop    %ebp
	return _current->base.user_options & K_ESSENTIAL;
400345ee:	8a 40 08             	mov    0x8(%eax),%al
400345f1:	83 e0 01             	and    $0x1,%eax
}
400345f4:	c3                   	ret    

400345f5 <_thread_entry>:
{
400345f5:	55                   	push   %ebp
400345f6:	89 e5                	mov    %esp,%ebp
400345f8:	53                   	push   %ebx
400345f9:	89 c3                	mov    %eax,%ebx
400345fb:	89 d0                	mov    %edx,%eax
400345fd:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
400345ff:	8b 4d 08             	mov    0x8(%ebp),%ecx
40034602:	ff d3                	call   *%ebx
	if (_is_thread_essential()) {
40034604:	e8 dc ff ff ff       	call   400345e5 <_is_thread_essential>
40034609:	85 c0                	test   %eax,%eax
4003460b:	74 0f                	je     4003461c <_thread_entry+0x27>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
4003460d:	ba 40 66 03 40       	mov    $0x40036640,%edx
40034612:	b8 03 00 00 00       	mov    $0x3,%eax
40034617:	e8 fb f4 ff ff       	call   40033b17 <_NanoFatalErrorHandler>
	k_thread_abort(_current);
4003461c:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
40034621:	e8 fa 00 00 00       	call   40034720 <k_thread_abort>

40034626 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
40034626:	55                   	push   %ebp
40034627:	89 e5                	mov    %esp,%ebp
40034629:	53                   	push   %ebx
4003462a:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
4003462c:	8b 40 30             	mov    0x30(%eax),%eax
4003462f:	85 c0                	test   %eax,%eax
40034631:	74 02                	je     40034635 <_k_thread_single_abort+0xf>
		thread->fn_abort();
40034633:	ff d0                	call   *%eax
	}

	if (_is_thread_ready(thread)) {
40034635:	89 d8                	mov    %ebx,%eax
40034637:	e8 6b fe ff ff       	call   400344a7 <_is_thread_ready>
4003463c:	85 c0                	test   %eax,%eax
4003463e:	74 09                	je     40034649 <_k_thread_single_abort+0x23>
		_remove_thread_from_ready_q(thread);
40034640:	89 d8                	mov    %ebx,%eax
40034642:	e8 88 f9 ff ff       	call   40033fcf <_remove_thread_from_ready_q>
40034647:	eb 24                	jmp    4003466d <_k_thread_single_abort+0x47>
	} else {
		if (_is_thread_pending(thread)) {
40034649:	f6 43 09 02          	testb  $0x2,0x9(%ebx)
4003464d:	74 10                	je     4003465f <_k_thread_single_abort+0x39>
	node->prev->next = node->next;
4003464f:	8b 43 04             	mov    0x4(%ebx),%eax
40034652:	8b 13                	mov    (%ebx),%edx
40034654:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
40034656:	8b 13                	mov    (%ebx),%edx
40034658:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
4003465b:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
4003465f:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
40034663:	74 08                	je     4003466d <_k_thread_single_abort+0x47>
	return _abort_timeout(&thread->base.timeout);
40034665:	8d 43 10             	lea    0x10(%ebx),%eax
40034668:	e8 53 fe ff ff       	call   400344c0 <_abort_timeout>
	thread->base.thread_state |= _THREAD_DEAD;
4003466d:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
40034671:	5b                   	pop    %ebx
40034672:	5d                   	pop    %ebp
40034673:	c3                   	ret    

40034674 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
40034674:	55                   	push   %ebp
40034675:	89 e5                	mov    %esp,%ebp
40034677:	56                   	push   %esi
40034678:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
40034679:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
4003467e:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
40034684:	73 29                	jae    400346af <_init_static_threads+0x3b>
		_task_group_adjust(thread_data);
		_new_thread(
40034686:	ff 73 1c             	pushl  0x1c(%ebx)
40034689:	ff 73 18             	pushl  0x18(%ebx)
4003468c:	ff 73 14             	pushl  0x14(%ebx)
4003468f:	ff 73 10             	pushl  0x10(%ebx)
40034692:	ff 73 0c             	pushl  0xc(%ebx)
40034695:	8b 03                	mov    (%ebx),%eax
40034697:	8b 4b 08             	mov    0x8(%ebx),%ecx
4003469a:	8b 53 04             	mov    0x4(%ebx),%edx
4003469d:	e8 0e f4 ff ff       	call   40033ab0 <_new_thread>
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
400346a2:	8b 03                	mov    (%ebx),%eax
		_new_thread(
400346a4:	83 c4 14             	add    $0x14,%esp
		thread_data->thread->init_data = thread_data;
400346a7:	89 58 2c             	mov    %ebx,0x2c(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
400346aa:	83 c3 2c             	add    $0x2c,%ebx
400346ad:	eb cf                	jmp    4003467e <_init_static_threads+0xa>
	--_current->base.sched_locked;
400346af:	a1 a8 76 00 a8       	mov    0xa80076a8,%eax
400346b4:	fe 48 0b             	decb   0xb(%eax)
	__asm__ volatile (
400346b7:	9c                   	pushf  
400346b8:	fa                   	cli    
400346b9:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
400346ba:	bb 9c 67 00 a8       	mov    $0xa800679c,%ebx
400346bf:	81 fb 9c 67 00 a8    	cmp    $0xa800679c,%ebx
400346c5:	73 14                	jae    400346db <_init_static_threads+0x67>
		if (thread_data->init_delay != K_FOREVER) {
400346c7:	8b 53 20             	mov    0x20(%ebx),%edx
400346ca:	83 fa ff             	cmp    $0xffffffff,%edx
400346cd:	74 07                	je     400346d6 <_init_static_threads+0x62>
			schedule_new_thread(thread_data->thread,
400346cf:	8b 03                	mov    (%ebx),%eax
400346d1:	e8 1e fe ff ff       	call   400344f4 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
400346d6:	83 c3 2c             	add    $0x2c,%ebx
400346d9:	eb e4                	jmp    400346bf <_init_static_threads+0x4b>
400346db:	0f ba e6 09          	bt     $0x9,%esi
400346df:	73 01                	jae    400346e2 <_init_static_threads+0x6e>
	__asm__ volatile (
400346e1:	fb                   	sti    
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
}
400346e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
400346e5:	5b                   	pop    %ebx
400346e6:	5e                   	pop    %esi
400346e7:	5d                   	pop    %ebp
	k_sched_unlock();
400346e8:	e9 24 fa ff ff       	jmp    40034111 <k_sched_unlock>

400346ed <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
400346ed:	55                   	push   %ebp
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
	thread_base->thread_state = (uint8_t)initial_state;
400346ee:	88 48 09             	mov    %cl,0x9(%eax)
{
400346f1:	89 e5                	mov    %esp,%ebp
400346f3:	53                   	push   %ebx

	thread_base->prio = priority;
400346f4:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
400346f7:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	thread_base->user_options = (uint8_t)options;
400346fb:	8a 5d 08             	mov    0x8(%ebp),%bl
	t->delta_ticks_from_prev = _INACTIVE;
400346fe:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
40034705:	88 58 08             	mov    %bl,0x8(%eax)
	t->wait_q = NULL;
40034708:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
4003470f:	5b                   	pop    %ebx
	t->thread = NULL;
40034710:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	t->func = func;
40034717:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
4003471e:	5d                   	pop    %ebp
4003471f:	c3                   	ret    

40034720 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
40034720:	55                   	push   %ebp
40034721:	89 e5                	mov    %esp,%ebp
40034723:	56                   	push   %esi
40034724:	89 c6                	mov    %eax,%esi
40034726:	53                   	push   %ebx
	__asm__ volatile (
40034727:	9c                   	pushf  
40034728:	fa                   	cli    
40034729:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
4003472a:	e8 f7 fe ff ff       	call   40034626 <_k_thread_single_abort>
	_thread_monitor_exit(thread);

	if (_current == thread) {
		_Swap(key);
4003472f:	89 d8                	mov    %ebx,%eax
	if (_current == thread) {
40034731:	3b 35 a8 76 00 a8    	cmp    0xa80076a8,%esi
40034737:	75 05                	jne    4003473e <k_thread_abort+0x1e>
		_Swap(key);
40034739:	e8 3e f3 ff ff       	call   40033a7c <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
}
4003473e:	5b                   	pop    %ebx
4003473f:	5e                   	pop    %esi
40034740:	5d                   	pop    %ebp
	_reschedule_threads(key);
40034741:	e9 9e f9 ff ff       	jmp    400340e4 <_reschedule_threads>

40034746 <_ready_thread>:
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034746:	8a 50 09             	mov    0x9(%eax),%dl
{
40034749:	55                   	push   %ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003474a:	88 d1                	mov    %dl,%cl
{
4003474c:	89 e5                	mov    %esp,%ebp
	thread->base.thread_state &= ~_THREAD_PRESTART;
4003474e:	83 e1 fb             	and    $0xfffffffb,%ecx
	return !(_is_thread_prevented_from_running(thread) ||
40034751:	80 e2 1b             	and    $0x1b,%dl
	thread->base.thread_state &= ~_THREAD_PRESTART;
40034754:	88 48 09             	mov    %cl,0x9(%eax)
	return !(_is_thread_prevented_from_running(thread) ||
40034757:	75 0c                	jne    40034765 <_ready_thread+0x1f>
40034759:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
4003475d:	75 06                	jne    40034765 <_ready_thread+0x1f>
}
4003475f:	5d                   	pop    %ebp
		_add_thread_to_ready_q(thread);
40034760:	e9 0c f8 ff ff       	jmp    40033f71 <_add_thread_to_ready_q>
}
40034765:	5d                   	pop    %ebp
40034766:	c3                   	ret    

40034767 <_add_timeout.constprop.7>:
	timeout->thread = thread;
40034767:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
4003476e:	89 50 0c             	mov    %edx,0xc(%eax)
static inline void _add_timeout(struct k_thread *thread,
40034771:	55                   	push   %ebp
	return list->head == list;
40034772:	8b 15 ac 76 00 a8    	mov    0xa80076ac,%edx
40034778:	89 e5                	mov    %esp,%ebp
	timeout->delta_ticks_from_prev = timeout_in_ticks;
4003477a:	89 48 10             	mov    %ecx,0x10(%eax)
static inline void _add_timeout(struct k_thread *thread,
4003477d:	53                   	push   %ebx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
4003477e:	85 d2                	test   %edx,%edx
40034780:	74 08                	je     4003478a <_add_timeout.constprop.7+0x23>
40034782:	81 fa ac 76 00 a8    	cmp    $0xa80076ac,%edx
40034788:	75 1e                	jne    400347a8 <_add_timeout.constprop.7+0x41>
	node->next = list;
4003478a:	c7 00 ac 76 00 a8    	movl   $0xa80076ac,(%eax)
	node->prev = list->tail;
40034790:	8b 15 b0 76 00 a8    	mov    0xa80076b0,%edx
40034796:	89 50 04             	mov    %edx,0x4(%eax)
	list->tail->next = node;
40034799:	8b 15 b0 76 00 a8    	mov    0xa80076b0,%edx
4003479f:	89 02                	mov    %eax,(%edx)
	list->tail = node;
400347a1:	a3 b0 76 00 a8       	mov    %eax,0xa80076b0
400347a6:	eb 34                	jmp    400347dc <_add_timeout.constprop.7+0x75>
		if (*delta <= in_q->delta_ticks_from_prev) {
400347a8:	8b 48 10             	mov    0x10(%eax),%ecx
400347ab:	8b 5a 10             	mov    0x10(%edx),%ebx
400347ae:	39 d9                	cmp    %ebx,%ecx
400347b0:	7f 17                	jg     400347c9 <_add_timeout.constprop.7+0x62>
			in_q->delta_ticks_from_prev -= *delta;
400347b2:	29 cb                	sub    %ecx,%ebx
		node->prev = insert_point->prev;
400347b4:	8b 4a 04             	mov    0x4(%edx),%ecx
400347b7:	89 5a 10             	mov    %ebx,0x10(%edx)
400347ba:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
400347bd:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
400347bf:	8b 4a 04             	mov    0x4(%edx),%ecx
400347c2:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
400347c4:	89 42 04             	mov    %eax,0x4(%edx)
400347c7:	eb 13                	jmp    400347dc <_add_timeout.constprop.7+0x75>
		*delta -= in_q->delta_ticks_from_prev;
400347c9:	29 d9                	sub    %ebx,%ecx
400347cb:	89 48 10             	mov    %ecx,0x10(%eax)
	return (node == list->tail) ? NULL : node->next;
400347ce:	3b 15 b0 76 00 a8    	cmp    0xa80076b0,%edx
400347d4:	74 b4                	je     4003478a <_add_timeout.constprop.7+0x23>
400347d6:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
400347d8:	85 d2                	test   %edx,%edx
400347da:	eb ac                	jmp    40034788 <_add_timeout.constprop.7+0x21>
}
400347dc:	5b                   	pop    %ebx
400347dd:	5d                   	pop    %ebp
400347de:	c3                   	ret    

400347df <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
400347df:	55                   	push   %ebp
400347e0:	89 e5                	mov    %esp,%ebp
400347e2:	56                   	push   %esi
400347e3:	53                   	push   %ebx
400347e4:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
400347e6:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
400347ea:	7e 15                	jle    40034801 <_timer_expiration_handler+0x22>
400347ec:	9c                   	pushf  
400347ed:	fa                   	cli    
400347ee:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
400347ef:	8b 48 28             	mov    0x28(%eax),%ecx
400347f2:	8d 50 18             	lea    0x18(%eax),%edx
400347f5:	e8 6d ff ff ff       	call   40034767 <_add_timeout.constprop.7>
400347fa:	0f ba e6 09          	bt     $0x9,%esi
400347fe:	73 01                	jae    40034801 <_timer_expiration_handler+0x22>
	__asm__ volatile (
40034800:	fb                   	sti    

	/* update timer's status */
	timer->status += 1;

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
40034801:	8b 53 20             	mov    0x20(%ebx),%edx
	timer->status += 1;
40034804:	ff 43 2c             	incl   0x2c(%ebx)
	if (timer->expiry_fn) {
40034807:	85 d2                	test   %edx,%edx
40034809:	74 04                	je     4003480f <_timer_expiration_handler+0x30>
		timer->expiry_fn(timer);
4003480b:	89 d8                	mov    %ebx,%eax
4003480d:	ff d2                	call   *%edx
	return list->head == list;
4003480f:	8b 73 18             	mov    0x18(%ebx),%esi
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);

	if (!thread) {
40034812:	85 f6                	test   %esi,%esi
40034814:	74 31                	je     40034847 <_timer_expiration_handler+0x68>
	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
40034816:	83 c3 18             	add    $0x18,%ebx
	if (!thread) {
40034819:	39 de                	cmp    %ebx,%esi
4003481b:	74 2a                	je     40034847 <_timer_expiration_handler+0x68>
	node->prev->next = node->next;
4003481d:	8b 46 04             	mov    0x4(%esi),%eax
40034820:	8b 16                	mov    (%esi),%edx
40034822:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
40034824:	8b 16                	mov    (%esi),%edx
40034826:	89 42 04             	mov    %eax,0x4(%edx)
	thread->base.thread_state &= ~_THREAD_PENDING;
40034829:	80 66 09 fd          	andb   $0xfd,0x9(%esi)
	__asm__ volatile (
4003482d:	9c                   	pushf  
4003482e:	fa                   	cli    
4003482f:	5b                   	pop    %ebx
	 * cannot interrupt the current context.
	 */
	_unpend_thread(thread);

	key = irq_lock();
	_ready_thread(thread);
40034830:	89 f0                	mov    %esi,%eax
40034832:	e8 0f ff ff ff       	call   40034746 <_ready_thread>
40034837:	0f ba e3 09          	bt     $0x9,%ebx
4003483b:	73 01                	jae    4003483e <_timer_expiration_handler+0x5f>
	__asm__ volatile (
4003483d:	fb                   	sti    
4003483e:	8b 46 28             	mov    0x28(%esi),%eax
40034841:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
40034847:	5b                   	pop    %ebx
40034848:	5e                   	pop    %esi
40034849:	5d                   	pop    %ebp
4003484a:	c3                   	ret    

4003484b <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
4003484b:	55                   	push   %ebp
4003484c:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
4003484e:	5d                   	pop    %ebp
4003484f:	c3                   	ret    

40034850 <malloc>:
40034850:	53                   	push   %ebx
40034851:	89 c3                	mov    %eax,%ebx
40034853:	e8 fa 01 00 00       	call   40034a52 <__getreent>
40034858:	89 da                	mov    %ebx,%edx
4003485a:	5b                   	pop    %ebx
4003485b:	e9 c9 00 00 00       	jmp    40034929 <_malloc_r>

40034860 <free>:
40034860:	53                   	push   %ebx
40034861:	89 c3                	mov    %eax,%ebx
40034863:	e8 ea 01 00 00       	call   40034a52 <__getreent>
40034868:	89 da                	mov    %ebx,%edx
4003486a:	5b                   	pop    %ebx
4003486b:	e9 00 00 00 00       	jmp    40034870 <_free_r>

40034870 <_free_r>:
40034870:	85 d2                	test   %edx,%edx
40034872:	0f 84 b0 00 00 00    	je     40034928 <_free_r+0xb8>
40034878:	8d 4a fc             	lea    -0x4(%edx),%ecx
4003487b:	8b 52 fc             	mov    -0x4(%edx),%edx
4003487e:	85 d2                	test   %edx,%edx
40034880:	79 02                	jns    40034884 <_free_r+0x14>
40034882:	01 d1                	add    %edx,%ecx
40034884:	8b 15 e4 67 00 a8    	mov    0xa80067e4,%edx
4003488a:	85 d2                	test   %edx,%edx
4003488c:	75 0e                	jne    4003489c <_free_r+0x2c>
4003488e:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
40034895:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
4003489b:	c3                   	ret    
4003489c:	57                   	push   %edi
4003489d:	39 ca                	cmp    %ecx,%edx
4003489f:	56                   	push   %esi
400348a0:	53                   	push   %ebx
400348a1:	53                   	push   %ebx
400348a2:	76 20                	jbe    400348c4 <_free_r+0x54>
400348a4:	8b 01                	mov    (%ecx),%eax
400348a6:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
400348a9:	39 da                	cmp    %ebx,%edx
400348ab:	75 0c                	jne    400348b9 <_free_r+0x49>
400348ad:	03 02                	add    (%edx),%eax
400348af:	89 01                	mov    %eax,(%ecx)
400348b1:	8b 42 04             	mov    0x4(%edx),%eax
400348b4:	89 41 04             	mov    %eax,0x4(%ecx)
400348b7:	eb 03                	jmp    400348bc <_free_r+0x4c>
400348b9:	89 51 04             	mov    %edx,0x4(%ecx)
400348bc:	89 0d e4 67 00 a8    	mov    %ecx,0xa80067e4
400348c2:	eb 60                	jmp    40034924 <_free_r+0xb4>
400348c4:	8b 72 04             	mov    0x4(%edx),%esi
400348c7:	85 f6                	test   %esi,%esi
400348c9:	0f 95 44 24 03       	setne  0x3(%esp)
400348ce:	39 ce                	cmp    %ecx,%esi
400348d0:	0f 96 c3             	setbe  %bl
400348d3:	84 5c 24 03          	test   %bl,0x3(%esp)
400348d7:	74 04                	je     400348dd <_free_r+0x6d>
400348d9:	89 f2                	mov    %esi,%edx
400348db:	eb e7                	jmp    400348c4 <_free_r+0x54>
400348dd:	8b 1a                	mov    (%edx),%ebx
400348df:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
400348e2:	39 cf                	cmp    %ecx,%edi
400348e4:	75 19                	jne    400348ff <_free_r+0x8f>
400348e6:	8b 01                	mov    (%ecx),%eax
400348e8:	01 d8                	add    %ebx,%eax
400348ea:	89 02                	mov    %eax,(%edx)
400348ec:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
400348ef:	39 ce                	cmp    %ecx,%esi
400348f1:	75 31                	jne    40034924 <_free_r+0xb4>
400348f3:	03 06                	add    (%esi),%eax
400348f5:	89 02                	mov    %eax,(%edx)
400348f7:	8b 46 04             	mov    0x4(%esi),%eax
400348fa:	89 42 04             	mov    %eax,0x4(%edx)
400348fd:	eb 25                	jmp    40034924 <_free_r+0xb4>
400348ff:	76 08                	jbe    40034909 <_free_r+0x99>
40034901:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
40034907:	eb 1b                	jmp    40034924 <_free_r+0xb4>
40034909:	8b 01                	mov    (%ecx),%eax
4003490b:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
4003490e:	39 de                	cmp    %ebx,%esi
40034910:	75 0c                	jne    4003491e <_free_r+0xae>
40034912:	03 06                	add    (%esi),%eax
40034914:	89 01                	mov    %eax,(%ecx)
40034916:	8b 46 04             	mov    0x4(%esi),%eax
40034919:	89 41 04             	mov    %eax,0x4(%ecx)
4003491c:	eb 03                	jmp    40034921 <_free_r+0xb1>
4003491e:	89 71 04             	mov    %esi,0x4(%ecx)
40034921:	89 4a 04             	mov    %ecx,0x4(%edx)
40034924:	58                   	pop    %eax
40034925:	5b                   	pop    %ebx
40034926:	5e                   	pop    %esi
40034927:	5f                   	pop    %edi
40034928:	c3                   	ret    

40034929 <_malloc_r>:
40034929:	57                   	push   %edi
4003492a:	8d 7a 03             	lea    0x3(%edx),%edi
4003492d:	83 e7 fc             	and    $0xfffffffc,%edi
40034930:	56                   	push   %esi
40034931:	83 c7 08             	add    $0x8,%edi
40034934:	53                   	push   %ebx
40034935:	89 c6                	mov    %eax,%esi
40034937:	83 ff 0c             	cmp    $0xc,%edi
4003493a:	73 05                	jae    40034941 <_malloc_r+0x18>
4003493c:	bf 0c 00 00 00       	mov    $0xc,%edi
40034941:	89 f8                	mov    %edi,%eax
40034943:	c1 e8 1f             	shr    $0x1f,%eax
40034946:	75 0c                	jne    40034954 <_malloc_r+0x2b>
40034948:	8b 0d e4 67 00 a8    	mov    0xa80067e4,%ecx
4003494e:	39 fa                	cmp    %edi,%edx
40034950:	89 c8                	mov    %ecx,%eax
40034952:	76 18                	jbe    4003496c <_malloc_r+0x43>
40034954:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
4003495a:	31 c0                	xor    %eax,%eax
4003495c:	e9 97 00 00 00       	jmp    400349f8 <_malloc_r+0xcf>
40034961:	8b 10                	mov    (%eax),%edx
40034963:	29 fa                	sub    %edi,%edx
40034965:	79 0b                	jns    40034972 <_malloc_r+0x49>
40034967:	89 c1                	mov    %eax,%ecx
40034969:	8b 40 04             	mov    0x4(%eax),%eax
4003496c:	85 c0                	test   %eax,%eax
4003496e:	75 f1                	jne    40034961 <_malloc_r+0x38>
40034970:	eb 26                	jmp    40034998 <_malloc_r+0x6f>
40034972:	83 fa 0b             	cmp    $0xb,%edx
40034975:	76 09                	jbe    40034980 <_malloc_r+0x57>
40034977:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
4003497a:	89 10                	mov    %edx,(%eax)
4003497c:	89 39                	mov    %edi,(%ecx)
4003497e:	eb 4d                	jmp    400349cd <_malloc_r+0xa4>
40034980:	39 c1                	cmp    %eax,%ecx
40034982:	75 0a                	jne    4003498e <_malloc_r+0x65>
40034984:	8b 41 04             	mov    0x4(%ecx),%eax
40034987:	a3 e4 67 00 a8       	mov    %eax,0xa80067e4
4003498c:	eb 3f                	jmp    400349cd <_malloc_r+0xa4>
4003498e:	8b 50 04             	mov    0x4(%eax),%edx
40034991:	89 51 04             	mov    %edx,0x4(%ecx)
40034994:	89 c1                	mov    %eax,%ecx
40034996:	eb 35                	jmp    400349cd <_malloc_r+0xa4>
40034998:	83 3d e0 67 00 a8 00 	cmpl   $0x0,0xa80067e0
4003499f:	75 0e                	jne    400349af <_malloc_r+0x86>
400349a1:	31 d2                	xor    %edx,%edx
400349a3:	89 f0                	mov    %esi,%eax
400349a5:	e8 6a 00 00 00       	call   40034a14 <_sbrk_r>
400349aa:	a3 e0 67 00 a8       	mov    %eax,0xa80067e0
400349af:	89 fa                	mov    %edi,%edx
400349b1:	89 f0                	mov    %esi,%eax
400349b3:	e8 5c 00 00 00       	call   40034a14 <_sbrk_r>
400349b8:	83 f8 ff             	cmp    $0xffffffff,%eax
400349bb:	74 97                	je     40034954 <_malloc_r+0x2b>
400349bd:	8d 48 03             	lea    0x3(%eax),%ecx
400349c0:	89 cb                	mov    %ecx,%ebx
400349c2:	83 e3 fc             	and    $0xfffffffc,%ebx
400349c5:	39 d8                	cmp    %ebx,%eax
400349c7:	75 1c                	jne    400349e5 <_malloc_r+0xbc>
400349c9:	89 3b                	mov    %edi,(%ebx)
400349cb:	89 d9                	mov    %ebx,%ecx
400349cd:	8d 41 0b             	lea    0xb(%ecx),%eax
400349d0:	8d 51 04             	lea    0x4(%ecx),%edx
400349d3:	83 e0 f8             	and    $0xfffffff8,%eax
400349d6:	89 c6                	mov    %eax,%esi
400349d8:	29 d6                	sub    %edx,%esi
400349da:	74 1c                	je     400349f8 <_malloc_r+0xcf>
400349dc:	89 f3                	mov    %esi,%ebx
400349de:	f7 db                	neg    %ebx
400349e0:	89 1c 31             	mov    %ebx,(%ecx,%esi,1)
400349e3:	eb 13                	jmp    400349f8 <_malloc_r+0xcf>
400349e5:	89 da                	mov    %ebx,%edx
400349e7:	29 c2                	sub    %eax,%edx
400349e9:	89 f0                	mov    %esi,%eax
400349eb:	e8 24 00 00 00       	call   40034a14 <_sbrk_r>
400349f0:	40                   	inc    %eax
400349f1:	75 d6                	jne    400349c9 <_malloc_r+0xa0>
400349f3:	e9 5c ff ff ff       	jmp    40034954 <_malloc_r+0x2b>
400349f8:	5b                   	pop    %ebx
400349f9:	5e                   	pop    %esi
400349fa:	5f                   	pop    %edi
400349fb:	c3                   	ret    

400349fc <iprintf>:
400349fc:	e8 51 00 00 00       	call   40034a52 <__getreent>
40034a01:	8d 4c 24 08          	lea    0x8(%esp),%ecx
40034a05:	8b 50 08             	mov    0x8(%eax),%edx
40034a08:	51                   	push   %ecx
40034a09:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40034a0d:	e8 9f 00 00 00       	call   40034ab1 <_vfiprintf_r>
40034a12:	5a                   	pop    %edx
40034a13:	c3                   	ret    

40034a14 <_sbrk_r>:
40034a14:	53                   	push   %ebx
40034a15:	89 c3                	mov    %eax,%ebx
40034a17:	89 d0                	mov    %edx,%eax
40034a19:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40034a20:	00 00 00 
40034a23:	e8 97 ca ff ff       	call   400314bf <_sbrk>
40034a28:	83 f8 ff             	cmp    $0xffffffff,%eax
40034a2b:	75 0c                	jne    40034a39 <_sbrk_r+0x25>
40034a2d:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40034a33:	85 d2                	test   %edx,%edx
40034a35:	74 02                	je     40034a39 <_sbrk_r+0x25>
40034a37:	89 13                	mov    %edx,(%ebx)
40034a39:	5b                   	pop    %ebx
40034a3a:	c3                   	ret    

40034a3b <strcmp>:
40034a3b:	8a 08                	mov    (%eax),%cl
40034a3d:	84 c9                	test   %cl,%cl
40034a3f:	74 08                	je     40034a49 <strcmp+0xe>
40034a41:	3a 0a                	cmp    (%edx),%cl
40034a43:	75 04                	jne    40034a49 <strcmp+0xe>
40034a45:	40                   	inc    %eax
40034a46:	42                   	inc    %edx
40034a47:	eb f2                	jmp    40034a3b <strcmp>
40034a49:	0f b6 12             	movzbl (%edx),%edx
40034a4c:	0f b6 c1             	movzbl %cl,%eax
40034a4f:	29 d0                	sub    %edx,%eax
40034a51:	c3                   	ret    

40034a52 <__getreent>:
40034a52:	a1 00 64 00 a8       	mov    0xa8006400,%eax
40034a57:	c3                   	ret    

40034a58 <__sfputc_r>:
40034a58:	53                   	push   %ebx
40034a59:	8b 59 08             	mov    0x8(%ecx),%ebx
40034a5c:	4b                   	dec    %ebx
40034a5d:	89 59 08             	mov    %ebx,0x8(%ecx)
40034a60:	85 db                	test   %ebx,%ebx
40034a62:	79 10                	jns    40034a74 <__sfputc_r+0x1c>
40034a64:	3b 59 18             	cmp    0x18(%ecx),%ebx
40034a67:	7c 05                	jl     40034a6e <__sfputc_r+0x16>
40034a69:	80 fa 0a             	cmp    $0xa,%dl
40034a6c:	75 06                	jne    40034a74 <__sfputc_r+0x1c>
40034a6e:	5b                   	pop    %ebx
40034a6f:	e9 cf 02 00 00       	jmp    40034d43 <__swbuf_r>
40034a74:	8b 01                	mov    (%ecx),%eax
40034a76:	8d 58 01             	lea    0x1(%eax),%ebx
40034a79:	89 19                	mov    %ebx,(%ecx)
40034a7b:	88 10                	mov    %dl,(%eax)
40034a7d:	5b                   	pop    %ebx
40034a7e:	0f b6 c2             	movzbl %dl,%eax
40034a81:	c3                   	ret    

40034a82 <__sfputs_r>:
40034a82:	55                   	push   %ebp
40034a83:	57                   	push   %edi
40034a84:	56                   	push   %esi
40034a85:	53                   	push   %ebx
40034a86:	8b 74 24 14          	mov    0x14(%esp),%esi
40034a8a:	89 c7                	mov    %eax,%edi
40034a8c:	89 d5                	mov    %edx,%ebp
40034a8e:	89 cb                	mov    %ecx,%ebx
40034a90:	01 ce                	add    %ecx,%esi
40034a92:	39 f3                	cmp    %esi,%ebx
40034a94:	74 14                	je     40034aaa <__sfputs_r+0x28>
40034a96:	0f be 13             	movsbl (%ebx),%edx
40034a99:	89 e9                	mov    %ebp,%ecx
40034a9b:	89 f8                	mov    %edi,%eax
40034a9d:	e8 b6 ff ff ff       	call   40034a58 <__sfputc_r>
40034aa2:	43                   	inc    %ebx
40034aa3:	83 f8 ff             	cmp    $0xffffffff,%eax
40034aa6:	75 ea                	jne    40034a92 <__sfputs_r+0x10>
40034aa8:	eb 02                	jmp    40034aac <__sfputs_r+0x2a>
40034aaa:	31 c0                	xor    %eax,%eax
40034aac:	5b                   	pop    %ebx
40034aad:	5e                   	pop    %esi
40034aae:	5f                   	pop    %edi
40034aaf:	5d                   	pop    %ebp
40034ab0:	c3                   	ret    

40034ab1 <_vfiprintf_r>:
40034ab1:	55                   	push   %ebp
40034ab2:	57                   	push   %edi
40034ab3:	56                   	push   %esi
40034ab4:	53                   	push   %ebx
40034ab5:	83 ec 68             	sub    $0x68,%esp
40034ab8:	89 c5                	mov    %eax,%ebp
40034aba:	89 d6                	mov    %edx,%esi
40034abc:	89 cf                	mov    %ecx,%edi
40034abe:	85 c0                	test   %eax,%eax
40034ac0:	74 0b                	je     40034acd <_vfiprintf_r+0x1c>
40034ac2:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034ac6:	75 05                	jne    40034acd <_vfiprintf_r+0x1c>
40034ac8:	e8 93 05 00 00       	call   40035060 <__sinit>
40034acd:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
40034ad1:	74 1d                	je     40034af0 <_vfiprintf_r+0x3f>
40034ad3:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
40034ad7:	74 17                	je     40034af0 <_vfiprintf_r+0x3f>
40034ad9:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
40034ae0:	00 
40034ae1:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
40034ae6:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
40034aeb:	e9 9b 00 00 00       	jmp    40034b8b <_vfiprintf_r+0xda>
40034af0:	89 f2                	mov    %esi,%edx
40034af2:	89 e8                	mov    %ebp,%eax
40034af4:	e8 d8 02 00 00       	call   40034dd1 <__swsetup_r>
40034af9:	85 c0                	test   %eax,%eax
40034afb:	74 dc                	je     40034ad9 <_vfiprintf_r+0x28>
40034afd:	83 c8 ff             	or     $0xffffffff,%eax
40034b00:	e9 36 02 00 00       	jmp    40034d3b <_vfiprintf_r+0x28a>
40034b05:	8b 54 24 7c          	mov    0x7c(%esp),%edx
40034b09:	8d 4a 04             	lea    0x4(%edx),%ecx
40034b0c:	8b 12                	mov    (%edx),%edx
40034b0e:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
40034b12:	85 d2                	test   %edx,%edx
40034b14:	0f 88 39 01 00 00    	js     40034c53 <_vfiprintf_r+0x1a2>
40034b1a:	89 54 24 18          	mov    %edx,0x18(%esp)
40034b1e:	43                   	inc    %ebx
40034b1f:	80 3b 2e             	cmpb   $0x2e,(%ebx)
40034b22:	0f 84 63 01 00 00    	je     40034c8b <_vfiprintf_r+0x1da>
40034b28:	0f be 13             	movsbl (%ebx),%edx
40034b2b:	b9 03 00 00 00       	mov    $0x3,%ecx
40034b30:	b8 f8 66 03 40       	mov    $0x400366f8,%eax
40034b35:	e8 3e b5 ff ff       	call   40030078 <memchr>
40034b3a:	85 c0                	test   %eax,%eax
40034b3c:	74 13                	je     40034b51 <_vfiprintf_r+0xa0>
40034b3e:	2d f8 66 03 40       	sub    $0x400366f8,%eax
40034b43:	ba 40 00 00 00       	mov    $0x40,%edx
40034b48:	88 c1                	mov    %al,%cl
40034b4a:	43                   	inc    %ebx
40034b4b:	d3 e2                	shl    %cl,%edx
40034b4d:	09 54 24 0c          	or     %edx,0xc(%esp)
40034b51:	0f be 13             	movsbl (%ebx),%edx
40034b54:	b9 06 00 00 00       	mov    $0x6,%ecx
40034b59:	b8 fc 66 03 40       	mov    $0x400366fc,%eax
40034b5e:	88 54 24 24          	mov    %dl,0x24(%esp)
40034b62:	e8 11 b5 ff ff       	call   40030078 <memchr>
40034b67:	8d 7b 01             	lea    0x1(%ebx),%edi
40034b6a:	85 c0                	test   %eax,%eax
40034b6c:	0f 84 94 01 00 00    	je     40034d06 <_vfiprintf_r+0x255>
40034b72:	b8 00 00 00 00       	mov    $0x0,%eax
40034b77:	85 c0                	test   %eax,%eax
40034b79:	0f 85 6e 01 00 00    	jne    40034ced <_vfiprintf_r+0x23c>
40034b7f:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
40034b84:	8b 04 24             	mov    (%esp),%eax
40034b87:	01 44 24 20          	add    %eax,0x20(%esp)
40034b8b:	89 fb                	mov    %edi,%ebx
40034b8d:	8a 03                	mov    (%ebx),%al
40034b8f:	84 c0                	test   %al,%al
40034b91:	0f 95 c2             	setne  %dl
40034b94:	3c 25                	cmp    $0x25,%al
40034b96:	0f 95 c0             	setne  %al
40034b99:	20 c2                	and    %al,%dl
40034b9b:	88 54 24 07          	mov    %dl,0x7(%esp)
40034b9f:	74 03                	je     40034ba4 <_vfiprintf_r+0xf3>
40034ba1:	43                   	inc    %ebx
40034ba2:	eb e9                	jmp    40034b8d <_vfiprintf_r+0xdc>
40034ba4:	89 d8                	mov    %ebx,%eax
40034ba6:	29 f8                	sub    %edi,%eax
40034ba8:	89 44 24 08          	mov    %eax,0x8(%esp)
40034bac:	74 1c                	je     40034bca <_vfiprintf_r+0x119>
40034bae:	50                   	push   %eax
40034baf:	89 f9                	mov    %edi,%ecx
40034bb1:	89 f2                	mov    %esi,%edx
40034bb3:	89 e8                	mov    %ebp,%eax
40034bb5:	e8 c8 fe ff ff       	call   40034a82 <__sfputs_r>
40034bba:	59                   	pop    %ecx
40034bbb:	40                   	inc    %eax
40034bbc:	0f 84 6b 01 00 00    	je     40034d2d <_vfiprintf_r+0x27c>
40034bc2:	8b 44 24 08          	mov    0x8(%esp),%eax
40034bc6:	01 44 24 20          	add    %eax,0x20(%esp)
40034bca:	80 3b 00             	cmpb   $0x0,(%ebx)
40034bcd:	0f 84 5a 01 00 00    	je     40034d2d <_vfiprintf_r+0x27c>
40034bd3:	43                   	inc    %ebx
40034bd4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
40034bdb:	00 
40034bdc:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
40034be3:	00 
40034be4:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034beb:	ff 
40034bec:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
40034bf3:	00 
40034bf4:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
40034bf9:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
40034c00:	00 
40034c01:	0f be 13             	movsbl (%ebx),%edx
40034c04:	b9 05 00 00 00       	mov    $0x5,%ecx
40034c09:	b8 f2 66 03 40       	mov    $0x400366f2,%eax
40034c0e:	e8 65 b4 ff ff       	call   40030078 <memchr>
40034c13:	85 c0                	test   %eax,%eax
40034c15:	74 15                	je     40034c2c <_vfiprintf_r+0x17b>
40034c17:	2d f2 66 03 40       	sub    $0x400366f2,%eax
40034c1c:	ba 01 00 00 00       	mov    $0x1,%edx
40034c21:	88 c1                	mov    %al,%cl
40034c23:	43                   	inc    %ebx
40034c24:	d3 e2                	shl    %cl,%edx
40034c26:	09 54 24 0c          	or     %edx,0xc(%esp)
40034c2a:	eb d5                	jmp    40034c01 <_vfiprintf_r+0x150>
40034c2c:	8b 44 24 0c          	mov    0xc(%esp),%eax
40034c30:	a8 10                	test   $0x10,%al
40034c32:	74 05                	je     40034c39 <_vfiprintf_r+0x188>
40034c34:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
40034c39:	a8 08                	test   $0x8,%al
40034c3b:	74 05                	je     40034c42 <_vfiprintf_r+0x191>
40034c3d:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
40034c42:	80 3b 2a             	cmpb   $0x2a,(%ebx)
40034c45:	0f 84 ba fe ff ff    	je     40034b05 <_vfiprintf_r+0x54>
40034c4b:	8b 44 24 18          	mov    0x18(%esp),%eax
40034c4f:	31 c9                	xor    %ecx,%ecx
40034c51:	eb 12                	jmp    40034c65 <_vfiprintf_r+0x1b4>
40034c53:	f7 da                	neg    %edx
40034c55:	83 c8 02             	or     $0x2,%eax
40034c58:	89 54 24 18          	mov    %edx,0x18(%esp)
40034c5c:	89 44 24 0c          	mov    %eax,0xc(%esp)
40034c60:	e9 b9 fe ff ff       	jmp    40034b1e <_vfiprintf_r+0x6d>
40034c65:	0f be 13             	movsbl (%ebx),%edx
40034c68:	83 ea 30             	sub    $0x30,%edx
40034c6b:	83 fa 09             	cmp    $0x9,%edx
40034c6e:	77 0a                	ja     40034c7a <_vfiprintf_r+0x1c9>
40034c70:	6b c0 0a             	imul   $0xa,%eax,%eax
40034c73:	43                   	inc    %ebx
40034c74:	01 d0                	add    %edx,%eax
40034c76:	b1 01                	mov    $0x1,%cl
40034c78:	eb eb                	jmp    40034c65 <_vfiprintf_r+0x1b4>
40034c7a:	84 c9                	test   %cl,%cl
40034c7c:	0f 84 9d fe ff ff    	je     40034b1f <_vfiprintf_r+0x6e>
40034c82:	89 44 24 18          	mov    %eax,0x18(%esp)
40034c86:	e9 94 fe ff ff       	jmp    40034b1f <_vfiprintf_r+0x6e>
40034c8b:	8d 43 01             	lea    0x1(%ebx),%eax
40034c8e:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
40034c92:	75 21                	jne    40034cb5 <_vfiprintf_r+0x204>
40034c94:	8b 44 24 7c          	mov    0x7c(%esp),%eax
40034c98:	83 c3 02             	add    $0x2,%ebx
40034c9b:	8d 50 04             	lea    0x4(%eax),%edx
40034c9e:	8b 00                	mov    (%eax),%eax
40034ca0:	89 54 24 7c          	mov    %edx,0x7c(%esp)
40034ca4:	85 c0                	test   %eax,%eax
40034ca6:	79 3c                	jns    40034ce4 <_vfiprintf_r+0x233>
40034ca8:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
40034caf:	ff 
40034cb0:	e9 73 fe ff ff       	jmp    40034b28 <_vfiprintf_r+0x77>
40034cb5:	89 c3                	mov    %eax,%ebx
40034cb7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
40034cbe:	00 
40034cbf:	31 c0                	xor    %eax,%eax
40034cc1:	0f be 13             	movsbl (%ebx),%edx
40034cc4:	83 ea 30             	sub    $0x30,%edx
40034cc7:	83 fa 09             	cmp    $0x9,%edx
40034cca:	77 0d                	ja     40034cd9 <_vfiprintf_r+0x228>
40034ccc:	6b c0 0a             	imul   $0xa,%eax,%eax
40034ccf:	43                   	inc    %ebx
40034cd0:	01 d0                	add    %edx,%eax
40034cd2:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
40034cd7:	eb e8                	jmp    40034cc1 <_vfiprintf_r+0x210>
40034cd9:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
40034cde:	0f 84 44 fe ff ff    	je     40034b28 <_vfiprintf_r+0x77>
40034ce4:	89 44 24 10          	mov    %eax,0x10(%esp)
40034ce8:	e9 3b fe ff ff       	jmp    40034b28 <_vfiprintf_r+0x77>
40034ced:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034cf1:	89 f1                	mov    %esi,%ecx
40034cf3:	50                   	push   %eax
40034cf4:	68 82 4a 03 40       	push   $0x40034a82
40034cf9:	8d 54 24 14          	lea    0x14(%esp),%edx
40034cfd:	89 e8                	mov    %ebp,%eax
40034cff:	e8 fc b2 fc bf       	call   0 <CONFIG_CACHE_LINE_SIZE>
40034d04:	eb 17                	jmp    40034d1d <_vfiprintf_r+0x26c>
40034d06:	8d 44 24 7c          	lea    0x7c(%esp),%eax
40034d0a:	89 f1                	mov    %esi,%ecx
40034d0c:	50                   	push   %eax
40034d0d:	68 82 4a 03 40       	push   $0x40034a82
40034d12:	8d 54 24 14          	lea    0x14(%esp),%edx
40034d16:	89 e8                	mov    %ebp,%eax
40034d18:	e8 e7 05 00 00       	call   40035304 <_printf_i>
40034d1d:	89 44 24 08          	mov    %eax,0x8(%esp)
40034d21:	58                   	pop    %eax
40034d22:	5a                   	pop    %edx
40034d23:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
40034d27:	0f 85 57 fe ff ff    	jne    40034b84 <_vfiprintf_r+0xd3>
40034d2d:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
40034d31:	0f 85 c6 fd ff ff    	jne    40034afd <_vfiprintf_r+0x4c>
40034d37:	8b 44 24 20          	mov    0x20(%esp),%eax
40034d3b:	83 c4 68             	add    $0x68,%esp
40034d3e:	5b                   	pop    %ebx
40034d3f:	5e                   	pop    %esi
40034d40:	5f                   	pop    %edi
40034d41:	5d                   	pop    %ebp
40034d42:	c3                   	ret    

40034d43 <__swbuf_r>:
40034d43:	55                   	push   %ebp
40034d44:	85 c0                	test   %eax,%eax
40034d46:	57                   	push   %edi
40034d47:	89 d5                	mov    %edx,%ebp
40034d49:	56                   	push   %esi
40034d4a:	89 c6                	mov    %eax,%esi
40034d4c:	53                   	push   %ebx
40034d4d:	89 cb                	mov    %ecx,%ebx
40034d4f:	74 0b                	je     40034d5c <__swbuf_r+0x19>
40034d51:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034d55:	75 05                	jne    40034d5c <__swbuf_r+0x19>
40034d57:	e8 04 03 00 00       	call   40035060 <__sinit>
40034d5c:	8b 43 18             	mov    0x18(%ebx),%eax
40034d5f:	f6 43 0c 08          	testb  $0x8,0xc(%ebx)
40034d63:	89 43 08             	mov    %eax,0x8(%ebx)
40034d66:	74 17                	je     40034d7f <__swbuf_r+0x3c>
40034d68:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034d6c:	74 11                	je     40034d7f <__swbuf_r+0x3c>
40034d6e:	89 e8                	mov    %ebp,%eax
40034d70:	0f b6 f8             	movzbl %al,%edi
40034d73:	8b 03                	mov    (%ebx),%eax
40034d75:	2b 43 10             	sub    0x10(%ebx),%eax
40034d78:	3b 43 14             	cmp    0x14(%ebx),%eax
40034d7b:	7c 21                	jl     40034d9e <__swbuf_r+0x5b>
40034d7d:	eb 12                	jmp    40034d91 <__swbuf_r+0x4e>
40034d7f:	89 da                	mov    %ebx,%edx
40034d81:	89 f0                	mov    %esi,%eax
40034d83:	e8 49 00 00 00       	call   40034dd1 <__swsetup_r>
40034d88:	85 c0                	test   %eax,%eax
40034d8a:	74 e2                	je     40034d6e <__swbuf_r+0x2b>
40034d8c:	83 cf ff             	or     $0xffffffff,%edi
40034d8f:	eb 39                	jmp    40034dca <__swbuf_r+0x87>
40034d91:	89 da                	mov    %ebx,%edx
40034d93:	89 f0                	mov    %esi,%eax
40034d95:	e8 23 02 00 00       	call   40034fbd <_fflush_r>
40034d9a:	85 c0                	test   %eax,%eax
40034d9c:	75 ee                	jne    40034d8c <__swbuf_r+0x49>
40034d9e:	8b 13                	mov    (%ebx),%edx
40034da0:	ff 4b 08             	decl   0x8(%ebx)
40034da3:	8d 4a 01             	lea    0x1(%edx),%ecx
40034da6:	40                   	inc    %eax
40034da7:	89 0b                	mov    %ecx,(%ebx)
40034da9:	89 e9                	mov    %ebp,%ecx
40034dab:	88 0a                	mov    %cl,(%edx)
40034dad:	3b 43 14             	cmp    0x14(%ebx),%eax
40034db0:	74 0b                	je     40034dbd <__swbuf_r+0x7a>
40034db2:	83 ff 0a             	cmp    $0xa,%edi
40034db5:	75 13                	jne    40034dca <__swbuf_r+0x87>
40034db7:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
40034dbb:	74 0d                	je     40034dca <__swbuf_r+0x87>
40034dbd:	89 da                	mov    %ebx,%edx
40034dbf:	89 f0                	mov    %esi,%eax
40034dc1:	e8 f7 01 00 00       	call   40034fbd <_fflush_r>
40034dc6:	85 c0                	test   %eax,%eax
40034dc8:	75 c2                	jne    40034d8c <__swbuf_r+0x49>
40034dca:	5b                   	pop    %ebx
40034dcb:	89 f8                	mov    %edi,%eax
40034dcd:	5e                   	pop    %esi
40034dce:	5f                   	pop    %edi
40034dcf:	5d                   	pop    %ebp
40034dd0:	c3                   	ret    

40034dd1 <__swsetup_r>:
40034dd1:	56                   	push   %esi
40034dd2:	89 c6                	mov    %eax,%esi
40034dd4:	53                   	push   %ebx
40034dd5:	89 d3                	mov    %edx,%ebx
40034dd7:	e8 76 fc ff ff       	call   40034a52 <__getreent>
40034ddc:	85 c0                	test   %eax,%eax
40034dde:	74 0b                	je     40034deb <__swsetup_r+0x1a>
40034de0:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034de4:	75 05                	jne    40034deb <__swsetup_r+0x1a>
40034de6:	e8 75 02 00 00       	call   40035060 <__sinit>
40034deb:	8b 43 0c             	mov    0xc(%ebx),%eax
40034dee:	a8 08                	test   $0x8,%al
40034df0:	75 4c                	jne    40034e3e <__swsetup_r+0x6d>
40034df2:	a8 10                	test   $0x10,%al
40034df4:	75 12                	jne    40034e08 <__swsetup_r+0x37>
40034df6:	83 c8 40             	or     $0x40,%eax
40034df9:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
40034dff:	66 89 43 0c          	mov    %ax,0xc(%ebx)
40034e03:	e9 8c 00 00 00       	jmp    40034e94 <__swsetup_r+0xc3>
40034e08:	a8 04                	test   $0x4,%al
40034e0a:	74 2d                	je     40034e39 <__swsetup_r+0x68>
40034e0c:	8b 53 30             	mov    0x30(%ebx),%edx
40034e0f:	85 d2                	test   %edx,%edx
40034e11:	74 15                	je     40034e28 <__swsetup_r+0x57>
40034e13:	8d 43 40             	lea    0x40(%ebx),%eax
40034e16:	39 c2                	cmp    %eax,%edx
40034e18:	74 07                	je     40034e21 <__swsetup_r+0x50>
40034e1a:	89 f0                	mov    %esi,%eax
40034e1c:	e8 4f fa ff ff       	call   40034870 <_free_r>
40034e21:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40034e28:	66 83 63 0c db       	andw   $0xffdb,0xc(%ebx)
40034e2d:	8b 43 10             	mov    0x10(%ebx),%eax
40034e30:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40034e37:	89 03                	mov    %eax,(%ebx)
40034e39:	66 83 4b 0c 08       	orw    $0x8,0xc(%ebx)
40034e3e:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034e42:	75 16                	jne    40034e5a <__swsetup_r+0x89>
40034e44:	8b 43 0c             	mov    0xc(%ebx),%eax
40034e47:	66 25 80 02          	and    $0x280,%ax
40034e4b:	66 3d 00 02          	cmp    $0x200,%ax
40034e4f:	74 09                	je     40034e5a <__swsetup_r+0x89>
40034e51:	89 da                	mov    %ebx,%edx
40034e53:	89 f0                	mov    %esi,%eax
40034e55:	e8 2e 03 00 00       	call   40035188 <__smakebuf_r>
40034e5a:	8b 53 0c             	mov    0xc(%ebx),%edx
40034e5d:	f6 c2 01             	test   $0x1,%dl
40034e60:	74 11                	je     40034e73 <__swsetup_r+0xa2>
40034e62:	8b 43 14             	mov    0x14(%ebx),%eax
40034e65:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
40034e6c:	f7 d8                	neg    %eax
40034e6e:	89 43 18             	mov    %eax,0x18(%ebx)
40034e71:	eb 0d                	jmp    40034e80 <__swsetup_r+0xaf>
40034e73:	31 c0                	xor    %eax,%eax
40034e75:	f6 c2 02             	test   $0x2,%dl
40034e78:	75 03                	jne    40034e7d <__swsetup_r+0xac>
40034e7a:	8b 43 14             	mov    0x14(%ebx),%eax
40034e7d:	89 43 08             	mov    %eax,0x8(%ebx)
40034e80:	31 c0                	xor    %eax,%eax
40034e82:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
40034e86:	75 0f                	jne    40034e97 <__swsetup_r+0xc6>
40034e88:	f6 c2 80             	test   $0x80,%dl
40034e8b:	74 0a                	je     40034e97 <__swsetup_r+0xc6>
40034e8d:	83 ca 40             	or     $0x40,%edx
40034e90:	66 89 53 0c          	mov    %dx,0xc(%ebx)
40034e94:	83 c8 ff             	or     $0xffffffff,%eax
40034e97:	5b                   	pop    %ebx
40034e98:	5e                   	pop    %esi
40034e99:	c3                   	ret    

40034e9a <__sflush_r>:
40034e9a:	55                   	push   %ebp
40034e9b:	57                   	push   %edi
40034e9c:	56                   	push   %esi
40034e9d:	53                   	push   %ebx
40034e9e:	89 c6                	mov    %eax,%esi
40034ea0:	8b 42 0c             	mov    0xc(%edx),%eax
40034ea3:	89 d3                	mov    %edx,%ebx
40034ea5:	a8 08                	test   $0x8,%al
40034ea7:	0f 85 cc 00 00 00    	jne    40034f79 <__sflush_r+0xdf>
40034ead:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
40034eb1:	7f 0a                	jg     40034ebd <__sflush_r+0x23>
40034eb3:	83 7a 3c 00          	cmpl   $0x0,0x3c(%edx)
40034eb7:	0f 8e b8 00 00 00    	jle    40034f75 <__sflush_r+0xdb>
40034ebd:	8b 6b 28             	mov    0x28(%ebx),%ebp
40034ec0:	85 ed                	test   %ebp,%ebp
40034ec2:	0f 84 ad 00 00 00    	je     40034f75 <__sflush_r+0xdb>
40034ec8:	8b 3e                	mov    (%esi),%edi
40034eca:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40034ed0:	f6 c4 10             	test   $0x10,%ah
40034ed3:	74 05                	je     40034eda <__sflush_r+0x40>
40034ed5:	8b 43 50             	mov    0x50(%ebx),%eax
40034ed8:	eb 29                	jmp    40034f03 <__sflush_r+0x69>
40034eda:	31 c9                	xor    %ecx,%ecx
40034edc:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034edf:	89 f0                	mov    %esi,%eax
40034ee1:	6a 01                	push   $0x1
40034ee3:	ff d5                	call   *%ebp
40034ee5:	5d                   	pop    %ebp
40034ee6:	83 f8 ff             	cmp    $0xffffffff,%eax
40034ee9:	75 18                	jne    40034f03 <__sflush_r+0x69>
40034eeb:	8b 16                	mov    (%esi),%edx
40034eed:	85 d2                	test   %edx,%edx
40034eef:	74 12                	je     40034f03 <__sflush_r+0x69>
40034ef1:	83 fa 1d             	cmp    $0x1d,%edx
40034ef4:	74 09                	je     40034eff <__sflush_r+0x65>
40034ef6:	83 fa 16             	cmp    $0x16,%edx
40034ef9:	0f 85 95 00 00 00    	jne    40034f94 <__sflush_r+0xfa>
40034eff:	89 3e                	mov    %edi,(%esi)
40034f01:	eb 72                	jmp    40034f75 <__sflush_r+0xdb>
40034f03:	f6 43 0c 04          	testb  $0x4,0xc(%ebx)
40034f07:	74 0c                	je     40034f15 <__sflush_r+0x7b>
40034f09:	2b 43 04             	sub    0x4(%ebx),%eax
40034f0c:	83 7b 30 00          	cmpl   $0x0,0x30(%ebx)
40034f10:	74 03                	je     40034f15 <__sflush_r+0x7b>
40034f12:	2b 43 3c             	sub    0x3c(%ebx),%eax
40034f15:	89 c1                	mov    %eax,%ecx
40034f17:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034f1a:	89 f0                	mov    %esi,%eax
40034f1c:	6a 00                	push   $0x0
40034f1e:	ff 53 28             	call   *0x28(%ebx)
40034f21:	59                   	pop    %ecx
40034f22:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f25:	75 11                	jne    40034f38 <__sflush_r+0x9e>
40034f27:	8b 16                	mov    (%esi),%edx
40034f29:	83 fa 1d             	cmp    $0x1d,%edx
40034f2c:	77 66                	ja     40034f94 <__sflush_r+0xfa>
40034f2e:	b9 01 00 40 20       	mov    $0x20400001,%ecx
40034f33:	0f a3 d1             	bt     %edx,%ecx
40034f36:	73 5c                	jae    40034f94 <__sflush_r+0xfa>
40034f38:	8b 53 10             	mov    0x10(%ebx),%edx
40034f3b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
40034f42:	89 13                	mov    %edx,(%ebx)
40034f44:	f6 43 0d 10          	testb  $0x10,0xd(%ebx)
40034f48:	74 0d                	je     40034f57 <__sflush_r+0xbd>
40034f4a:	83 f8 ff             	cmp    $0xffffffff,%eax
40034f4d:	75 05                	jne    40034f54 <__sflush_r+0xba>
40034f4f:	83 3e 00             	cmpl   $0x0,(%esi)
40034f52:	75 03                	jne    40034f57 <__sflush_r+0xbd>
40034f54:	89 43 50             	mov    %eax,0x50(%ebx)
40034f57:	8b 53 30             	mov    0x30(%ebx),%edx
40034f5a:	89 3e                	mov    %edi,(%esi)
40034f5c:	85 d2                	test   %edx,%edx
40034f5e:	74 15                	je     40034f75 <__sflush_r+0xdb>
40034f60:	8d 43 40             	lea    0x40(%ebx),%eax
40034f63:	39 c2                	cmp    %eax,%edx
40034f65:	74 07                	je     40034f6e <__sflush_r+0xd4>
40034f67:	89 f0                	mov    %esi,%eax
40034f69:	e8 02 f9 ff ff       	call   40034870 <_free_r>
40034f6e:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
40034f75:	31 c0                	xor    %eax,%eax
40034f77:	eb 3f                	jmp    40034fb8 <__sflush_r+0x11e>
40034f79:	8b 6a 10             	mov    0x10(%edx),%ebp
40034f7c:	85 ed                	test   %ebp,%ebp
40034f7e:	74 f5                	je     40034f75 <__sflush_r+0xdb>
40034f80:	8b 3a                	mov    (%edx),%edi
40034f82:	89 2a                	mov    %ebp,(%edx)
40034f84:	29 ef                	sub    %ebp,%edi
40034f86:	31 d2                	xor    %edx,%edx
40034f88:	a8 03                	test   $0x3,%al
40034f8a:	75 03                	jne    40034f8f <__sflush_r+0xf5>
40034f8c:	8b 53 14             	mov    0x14(%ebx),%edx
40034f8f:	89 53 08             	mov    %edx,0x8(%ebx)
40034f92:	eb 1e                	jmp    40034fb2 <__sflush_r+0x118>
40034f94:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
40034f99:	83 c8 ff             	or     $0xffffffff,%eax
40034f9c:	eb 1a                	jmp    40034fb8 <__sflush_r+0x11e>
40034f9e:	8b 53 1c             	mov    0x1c(%ebx),%edx
40034fa1:	89 e9                	mov    %ebp,%ecx
40034fa3:	89 f0                	mov    %esi,%eax
40034fa5:	57                   	push   %edi
40034fa6:	ff 53 24             	call   *0x24(%ebx)
40034fa9:	5a                   	pop    %edx
40034faa:	85 c0                	test   %eax,%eax
40034fac:	7e e6                	jle    40034f94 <__sflush_r+0xfa>
40034fae:	01 c5                	add    %eax,%ebp
40034fb0:	29 c7                	sub    %eax,%edi
40034fb2:	85 ff                	test   %edi,%edi
40034fb4:	7f e8                	jg     40034f9e <__sflush_r+0x104>
40034fb6:	eb bd                	jmp    40034f75 <__sflush_r+0xdb>
40034fb8:	5b                   	pop    %ebx
40034fb9:	5e                   	pop    %esi
40034fba:	5f                   	pop    %edi
40034fbb:	5d                   	pop    %ebp
40034fbc:	c3                   	ret    

40034fbd <_fflush_r>:
40034fbd:	53                   	push   %ebx
40034fbe:	85 c0                	test   %eax,%eax
40034fc0:	53                   	push   %ebx
40034fc1:	89 c3                	mov    %eax,%ebx
40034fc3:	74 11                	je     40034fd6 <_fflush_r+0x19>
40034fc5:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40034fc9:	75 0b                	jne    40034fd6 <_fflush_r+0x19>
40034fcb:	89 14 24             	mov    %edx,(%esp)
40034fce:	e8 8d 00 00 00       	call   40035060 <__sinit>
40034fd3:	8b 14 24             	mov    (%esp),%edx
40034fd6:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
40034fdb:	74 09                	je     40034fe6 <_fflush_r+0x29>
40034fdd:	89 d8                	mov    %ebx,%eax
40034fdf:	59                   	pop    %ecx
40034fe0:	5b                   	pop    %ebx
40034fe1:	e9 b4 fe ff ff       	jmp    40034e9a <__sflush_r>
40034fe6:	31 c0                	xor    %eax,%eax
40034fe8:	5a                   	pop    %edx
40034fe9:	5b                   	pop    %ebx
40034fea:	c3                   	ret    

40034feb <_cleanup_r>:
40034feb:	ba bd 4f 03 40       	mov    $0x40034fbd,%edx
40034ff0:	e9 d7 00 00 00       	jmp    400350cc <_fwalk_reent>

40034ff5 <std.isra.0>:
40034ff5:	53                   	push   %ebx
40034ff6:	89 c3                	mov    %eax,%ebx
40034ff8:	66 89 50 0c          	mov    %dx,0xc(%eax)
40034ffc:	66 89 48 0e          	mov    %cx,0xe(%eax)
40035000:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
40035006:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
4003500d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
40035014:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
4003501b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
40035022:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
40035029:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
40035030:	b9 08 00 00 00       	mov    $0x8,%ecx
40035035:	8d 40 5c             	lea    0x5c(%eax),%eax
40035038:	31 d2                	xor    %edx,%edx
4003503a:	e8 2b b0 ff ff       	call   4003006a <memset>
4003503f:	89 5b 1c             	mov    %ebx,0x1c(%ebx)
40035042:	c7 43 20 9d 55 03 40 	movl   $0x4003559d,0x20(%ebx)
40035049:	c7 43 24 bf 55 03 40 	movl   $0x400355bf,0x24(%ebx)
40035050:	c7 43 28 fc 55 03 40 	movl   $0x400355fc,0x28(%ebx)
40035057:	c7 43 2c 25 56 03 40 	movl   $0x40035625,0x2c(%ebx)
4003505e:	5b                   	pop    %ebx
4003505f:	c3                   	ret    

40035060 <__sinit>:
40035060:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
40035064:	75 65                	jne    400350cb <__sinit+0x6b>
40035066:	53                   	push   %ebx
40035067:	89 c3                	mov    %eax,%ebx
40035069:	c7 40 3c eb 4f 03 40 	movl   $0x40034feb,0x3c(%eax)
40035070:	c7 80 4c 01 00 00 00 	movl   $0x0,0x14c(%eax)
40035077:	00 00 00 
4003507a:	c7 80 50 01 00 00 03 	movl   $0x3,0x150(%eax)
40035081:	00 00 00 
40035084:	8d 80 58 01 00 00    	lea    0x158(%eax),%eax
4003508a:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
40035090:	31 c9                	xor    %ecx,%ecx
40035092:	8b 43 04             	mov    0x4(%ebx),%eax
40035095:	ba 04 00 00 00       	mov    $0x4,%edx
4003509a:	e8 56 ff ff ff       	call   40034ff5 <std.isra.0>
4003509f:	8b 43 08             	mov    0x8(%ebx),%eax
400350a2:	b9 01 00 00 00       	mov    $0x1,%ecx
400350a7:	ba 09 00 00 00       	mov    $0x9,%edx
400350ac:	e8 44 ff ff ff       	call   40034ff5 <std.isra.0>
400350b1:	8b 43 0c             	mov    0xc(%ebx),%eax
400350b4:	b9 02 00 00 00       	mov    $0x2,%ecx
400350b9:	ba 12 00 00 00       	mov    $0x12,%edx
400350be:	e8 32 ff ff ff       	call   40034ff5 <std.isra.0>
400350c3:	c7 43 38 01 00 00 00 	movl   $0x1,0x38(%ebx)
400350ca:	5b                   	pop    %ebx
400350cb:	c3                   	ret    

400350cc <_fwalk_reent>:
400350cc:	55                   	push   %ebp
400350cd:	57                   	push   %edi
400350ce:	56                   	push   %esi
400350cf:	53                   	push   %ebx
400350d0:	83 ec 08             	sub    $0x8,%esp
400350d3:	89 c5                	mov    %eax,%ebp
400350d5:	89 d1                	mov    %edx,%ecx
400350d7:	8d 98 4c 01 00 00    	lea    0x14c(%eax),%ebx
400350dd:	31 ff                	xor    %edi,%edi
400350df:	85 db                	test   %ebx,%ebx
400350e1:	74 35                	je     40035118 <_fwalk_reent+0x4c>
400350e3:	8b 43 04             	mov    0x4(%ebx),%eax
400350e6:	8b 73 08             	mov    0x8(%ebx),%esi
400350e9:	89 04 24             	mov    %eax,(%esp)
400350ec:	ff 0c 24             	decl   (%esp)
400350ef:	78 23                	js     40035114 <_fwalk_reent+0x48>
400350f1:	66 83 7e 0c 01       	cmpw   $0x1,0xc(%esi)
400350f6:	76 17                	jbe    4003510f <_fwalk_reent+0x43>
400350f8:	66 83 7e 0e ff       	cmpw   $0xffff,0xe(%esi)
400350fd:	74 10                	je     4003510f <_fwalk_reent+0x43>
400350ff:	89 f2                	mov    %esi,%edx
40035101:	89 e8                	mov    %ebp,%eax
40035103:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40035107:	ff d1                	call   *%ecx
40035109:	8b 4c 24 04          	mov    0x4(%esp),%ecx
4003510d:	09 c7                	or     %eax,%edi
4003510f:	83 c6 68             	add    $0x68,%esi
40035112:	eb d8                	jmp    400350ec <_fwalk_reent+0x20>
40035114:	8b 1b                	mov    (%ebx),%ebx
40035116:	eb c7                	jmp    400350df <_fwalk_reent+0x13>
40035118:	83 c4 08             	add    $0x8,%esp
4003511b:	89 f8                	mov    %edi,%eax
4003511d:	5b                   	pop    %ebx
4003511e:	5e                   	pop    %esi
4003511f:	5f                   	pop    %edi
40035120:	5d                   	pop    %ebp
40035121:	c3                   	ret    

40035122 <__swhatbuf_r>:
40035122:	57                   	push   %edi
40035123:	56                   	push   %esi
40035124:	53                   	push   %ebx
40035125:	89 d7                	mov    %edx,%edi
40035127:	83 ec 3c             	sub    $0x3c,%esp
4003512a:	89 cb                	mov    %ecx,%ebx
4003512c:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035130:	66 85 d2             	test   %dx,%dx
40035133:	8b 74 24 4c          	mov    0x4c(%esp),%esi
40035137:	79 1f                	jns    40035158 <__swhatbuf_r+0x36>
40035139:	8b 47 0c             	mov    0xc(%edi),%eax
4003513c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
40035142:	66 25 80 00          	and    $0x80,%ax
40035146:	66 83 f8 01          	cmp    $0x1,%ax
4003514a:	19 c0                	sbb    %eax,%eax
4003514c:	25 c0 03 00 00       	and    $0x3c0,%eax
40035151:	83 c0 40             	add    $0x40,%eax
40035154:	89 03                	mov    %eax,(%ebx)
40035156:	eb 27                	jmp    4003517f <__swhatbuf_r+0x5d>
40035158:	89 e1                	mov    %esp,%ecx
4003515a:	e8 23 05 00 00       	call   40035682 <_fstat_r>
4003515f:	85 c0                	test   %eax,%eax
40035161:	78 d6                	js     40035139 <__swhatbuf_r+0x17>
40035163:	8b 44 24 04          	mov    0x4(%esp),%eax
40035167:	25 00 f0 00 00       	and    $0xf000,%eax
4003516c:	3d 00 20 00 00       	cmp    $0x2000,%eax
40035171:	0f 94 c0             	sete   %al
40035174:	0f b6 c0             	movzbl %al,%eax
40035177:	89 06                	mov    %eax,(%esi)
40035179:	c7 03 00 04 00 00    	movl   $0x400,(%ebx)
4003517f:	83 c4 3c             	add    $0x3c,%esp
40035182:	31 c0                	xor    %eax,%eax
40035184:	5b                   	pop    %ebx
40035185:	5e                   	pop    %esi
40035186:	5f                   	pop    %edi
40035187:	c3                   	ret    

40035188 <__smakebuf_r>:
40035188:	f6 42 0c 02          	testb  $0x2,0xc(%edx)
4003518c:	74 10                	je     4003519e <__smakebuf_r+0x16>
4003518e:	8d 42 43             	lea    0x43(%edx),%eax
40035191:	c7 42 14 01 00 00 00 	movl   $0x1,0x14(%edx)
40035198:	89 02                	mov    %eax,(%edx)
4003519a:	89 42 10             	mov    %eax,0x10(%edx)
4003519d:	c3                   	ret    
4003519e:	57                   	push   %edi
4003519f:	56                   	push   %esi
400351a0:	53                   	push   %ebx
400351a1:	89 c6                	mov    %eax,%esi
400351a3:	83 ec 08             	sub    $0x8,%esp
400351a6:	89 d3                	mov    %edx,%ebx
400351a8:	8d 44 24 04          	lea    0x4(%esp),%eax
400351ac:	50                   	push   %eax
400351ad:	89 f0                	mov    %esi,%eax
400351af:	8d 4c 24 04          	lea    0x4(%esp),%ecx
400351b3:	e8 6a ff ff ff       	call   40035122 <__swhatbuf_r>
400351b8:	8b 54 24 04          	mov    0x4(%esp),%edx
400351bc:	89 c7                	mov    %eax,%edi
400351be:	89 f0                	mov    %esi,%eax
400351c0:	e8 64 f7 ff ff       	call   40034929 <_malloc_r>
400351c5:	5a                   	pop    %edx
400351c6:	85 c0                	test   %eax,%eax
400351c8:	75 20                	jne    400351ea <__smakebuf_r+0x62>
400351ca:	8b 43 0c             	mov    0xc(%ebx),%eax
400351cd:	f6 c4 02             	test   $0x2,%ah
400351d0:	75 4f                	jne    40035221 <__smakebuf_r+0x99>
400351d2:	83 c8 02             	or     $0x2,%eax
400351d5:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
400351dc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
400351e0:	8d 43 43             	lea    0x43(%ebx),%eax
400351e3:	89 03                	mov    %eax,(%ebx)
400351e5:	89 43 10             	mov    %eax,0x10(%ebx)
400351e8:	eb 37                	jmp    40035221 <__smakebuf_r+0x99>
400351ea:	c7 46 3c eb 4f 03 40 	movl   $0x40034feb,0x3c(%esi)
400351f1:	89 03                	mov    %eax,(%ebx)
400351f3:	89 43 10             	mov    %eax,0x10(%ebx)
400351f6:	8b 04 24             	mov    (%esp),%eax
400351f9:	66 81 4b 0c 80 00    	orw    $0x80,0xc(%ebx)
400351ff:	89 43 14             	mov    %eax,0x14(%ebx)
40035202:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
40035207:	74 14                	je     4003521d <__smakebuf_r+0x95>
40035209:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
4003520d:	89 f0                	mov    %esi,%eax
4003520f:	e8 97 04 00 00       	call   400356ab <_isatty_r>
40035214:	85 c0                	test   %eax,%eax
40035216:	74 05                	je     4003521d <__smakebuf_r+0x95>
40035218:	66 83 4b 0c 01       	orw    $0x1,0xc(%ebx)
4003521d:	66 09 7b 0c          	or     %di,0xc(%ebx)
40035221:	83 c4 08             	add    $0x8,%esp
40035224:	5b                   	pop    %ebx
40035225:	5e                   	pop    %esi
40035226:	5f                   	pop    %edi
40035227:	c3                   	ret    

40035228 <_printf_common>:
40035228:	55                   	push   %ebp
40035229:	57                   	push   %edi
4003522a:	56                   	push   %esi
4003522b:	53                   	push   %ebx
4003522c:	53                   	push   %ebx
4003522d:	89 d3                	mov    %edx,%ebx
4003522f:	89 c5                	mov    %eax,%ebp
40035231:	8b 52 08             	mov    0x8(%edx),%edx
40035234:	8b 43 10             	mov    0x10(%ebx),%eax
40035237:	89 ce                	mov    %ecx,%esi
40035239:	39 d0                	cmp    %edx,%eax
4003523b:	7d 02                	jge    4003523f <_printf_common+0x17>
4003523d:	89 d0                	mov    %edx,%eax
4003523f:	89 06                	mov    %eax,(%esi)
40035241:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40035245:	74 03                	je     4003524a <_printf_common+0x22>
40035247:	40                   	inc    %eax
40035248:	89 06                	mov    %eax,(%esi)
4003524a:	f6 03 20             	testb  $0x20,(%ebx)
4003524d:	74 03                	je     40035252 <_printf_common+0x2a>
4003524f:	83 06 02             	addl   $0x2,(%esi)
40035252:	8b 3b                	mov    (%ebx),%edi
40035254:	83 e7 06             	and    $0x6,%edi
40035257:	75 26                	jne    4003527f <_printf_common+0x57>
40035259:	8d 43 19             	lea    0x19(%ebx),%eax
4003525c:	89 04 24             	mov    %eax,(%esp)
4003525f:	eb 15                	jmp    40035276 <_printf_common+0x4e>
40035261:	6a 01                	push   $0x1
40035263:	89 e8                	mov    %ebp,%eax
40035265:	8b 4c 24 04          	mov    0x4(%esp),%ecx
40035269:	8b 54 24 1c          	mov    0x1c(%esp),%edx
4003526d:	ff 54 24 20          	call   *0x20(%esp)
40035271:	5a                   	pop    %edx
40035272:	40                   	inc    %eax
40035273:	74 3c                	je     400352b1 <_printf_common+0x89>
40035275:	47                   	inc    %edi
40035276:	8b 43 0c             	mov    0xc(%ebx),%eax
40035279:	2b 06                	sub    (%esi),%eax
4003527b:	39 c7                	cmp    %eax,%edi
4003527d:	7c e2                	jl     40035261 <_printf_common+0x39>
4003527f:	31 c0                	xor    %eax,%eax
40035281:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
40035285:	0f 95 c0             	setne  %al
40035288:	f6 03 20             	testb  $0x20,(%ebx)
4003528b:	74 12                	je     4003529f <_printf_common+0x77>
4003528d:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
40035292:	8d 50 01             	lea    0x1(%eax),%edx
40035295:	8a 4b 45             	mov    0x45(%ebx),%cl
40035298:	83 c0 02             	add    $0x2,%eax
4003529b:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
4003529f:	50                   	push   %eax
400352a0:	8d 4b 43             	lea    0x43(%ebx),%ecx
400352a3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
400352a7:	89 e8                	mov    %ebp,%eax
400352a9:	ff 54 24 20          	call   *0x20(%esp)
400352ad:	5f                   	pop    %edi
400352ae:	40                   	inc    %eax
400352af:	75 05                	jne    400352b6 <_printf_common+0x8e>
400352b1:	83 c8 ff             	or     $0xffffffff,%eax
400352b4:	eb 48                	jmp    400352fe <_printf_common+0xd6>
400352b6:	8b 43 0c             	mov    0xc(%ebx),%eax
400352b9:	2b 06                	sub    (%esi),%eax
400352bb:	89 c6                	mov    %eax,%esi
400352bd:	8b 03                	mov    (%ebx),%eax
400352bf:	83 e0 06             	and    $0x6,%eax
400352c2:	83 f8 04             	cmp    $0x4,%eax
400352c5:	75 07                	jne    400352ce <_printf_common+0xa6>
400352c7:	89 f0                	mov    %esi,%eax
400352c9:	c1 e8 1f             	shr    $0x1f,%eax
400352cc:	74 02                	je     400352d0 <_printf_common+0xa8>
400352ce:	31 f6                	xor    %esi,%esi
400352d0:	8b 43 08             	mov    0x8(%ebx),%eax
400352d3:	8b 53 10             	mov    0x10(%ebx),%edx
400352d6:	39 d0                	cmp    %edx,%eax
400352d8:	7e 04                	jle    400352de <_printf_common+0xb6>
400352da:	29 d0                	sub    %edx,%eax
400352dc:	01 c6                	add    %eax,%esi
400352de:	31 ff                	xor    %edi,%edi
400352e0:	83 c3 1a             	add    $0x1a,%ebx
400352e3:	39 fe                	cmp    %edi,%esi
400352e5:	74 15                	je     400352fc <_printf_common+0xd4>
400352e7:	6a 01                	push   $0x1
400352e9:	89 d9                	mov    %ebx,%ecx
400352eb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
400352ef:	89 e8                	mov    %ebp,%eax
400352f1:	ff 54 24 20          	call   *0x20(%esp)
400352f5:	59                   	pop    %ecx
400352f6:	40                   	inc    %eax
400352f7:	74 b8                	je     400352b1 <_printf_common+0x89>
400352f9:	47                   	inc    %edi
400352fa:	eb e7                	jmp    400352e3 <_printf_common+0xbb>
400352fc:	31 c0                	xor    %eax,%eax
400352fe:	5a                   	pop    %edx
400352ff:	5b                   	pop    %ebx
40035300:	5e                   	pop    %esi
40035301:	5f                   	pop    %edi
40035302:	5d                   	pop    %ebp
40035303:	c3                   	ret    

40035304 <_printf_i>:
40035304:	55                   	push   %ebp
40035305:	57                   	push   %edi
40035306:	56                   	push   %esi
40035307:	53                   	push   %ebx
40035308:	83 ec 0c             	sub    $0xc,%esp
4003530b:	89 d3                	mov    %edx,%ebx
4003530d:	8d 6a 43             	lea    0x43(%edx),%ebp
40035310:	89 4c 24 04          	mov    %ecx,0x4(%esp)
40035314:	8a 4a 18             	mov    0x18(%edx),%cl
40035317:	89 04 24             	mov    %eax,(%esp)
4003531a:	80 f9 6e             	cmp    $0x6e,%cl
4003531d:	8b 44 24 24          	mov    0x24(%esp),%eax
40035321:	0f 84 83 01 00 00    	je     400354aa <_printf_i+0x1a6>
40035327:	7f 35                	jg     4003535e <_printf_i+0x5a>
40035329:	80 f9 63             	cmp    $0x63,%cl
4003532c:	74 60                	je     4003538e <_printf_i+0x8a>
4003532e:	7f 1f                	jg     4003534f <_printf_i+0x4b>
40035330:	84 c9                	test   %cl,%cl
40035332:	0f 84 9d 01 00 00    	je     400354d5 <_printf_i+0x1d1>
40035338:	80 f9 58             	cmp    $0x58,%cl
4003533b:	0f 85 c5 01 00 00    	jne    40035506 <_printf_i+0x202>
40035341:	c6 42 45 58          	movb   $0x58,0x45(%edx)
40035345:	bf 03 67 03 40       	mov    $0x40036703,%edi
4003534a:	e9 c2 00 00 00       	jmp    40035411 <_printf_i+0x10d>
4003534f:	80 f9 64             	cmp    $0x64,%cl
40035352:	74 4e                	je     400353a2 <_printf_i+0x9e>
40035354:	80 f9 69             	cmp    $0x69,%cl
40035357:	74 49                	je     400353a2 <_printf_i+0x9e>
40035359:	e9 a8 01 00 00       	jmp    40035506 <_printf_i+0x202>
4003535e:	80 f9 73             	cmp    $0x73,%cl
40035361:	0f 84 79 01 00 00    	je     400354e0 <_printf_i+0x1dc>
40035367:	7f 16                	jg     4003537f <_printf_i+0x7b>
40035369:	80 f9 6f             	cmp    $0x6f,%cl
4003536c:	74 65                	je     400353d3 <_printf_i+0xcf>
4003536e:	80 f9 70             	cmp    $0x70,%cl
40035371:	0f 85 8f 01 00 00    	jne    40035506 <_printf_i+0x202>
40035377:	83 0a 20             	orl    $0x20,(%edx)
4003537a:	e9 89 00 00 00       	jmp    40035408 <_printf_i+0x104>
4003537f:	80 f9 75             	cmp    $0x75,%cl
40035382:	74 4f                	je     400353d3 <_printf_i+0xcf>
40035384:	80 f9 78             	cmp    $0x78,%cl
40035387:	74 7f                	je     40035408 <_printf_i+0x104>
40035389:	e9 78 01 00 00       	jmp    40035506 <_printf_i+0x202>
4003538e:	8d 72 42             	lea    0x42(%edx),%esi
40035391:	8b 10                	mov    (%eax),%edx
40035393:	8d 4a 04             	lea    0x4(%edx),%ecx
40035396:	89 08                	mov    %ecx,(%eax)
40035398:	8b 02                	mov    (%edx),%eax
4003539a:	88 43 42             	mov    %al,0x42(%ebx)
4003539d:	e9 6a 01 00 00       	jmp    4003550c <_printf_i+0x208>
400353a2:	8b 0b                	mov    (%ebx),%ecx
400353a4:	8b 10                	mov    (%eax),%edx
400353a6:	f6 c1 80             	test   $0x80,%cl
400353a9:	74 07                	je     400353b2 <_printf_i+0xae>
400353ab:	8d 4a 04             	lea    0x4(%edx),%ecx
400353ae:	89 08                	mov    %ecx,(%eax)
400353b0:	eb 0f                	jmp    400353c1 <_printf_i+0xbd>
400353b2:	80 e1 40             	and    $0x40,%cl
400353b5:	8d 4a 04             	lea    0x4(%edx),%ecx
400353b8:	89 08                	mov    %ecx,(%eax)
400353ba:	74 05                	je     400353c1 <_printf_i+0xbd>
400353bc:	0f bf 02             	movswl (%edx),%eax
400353bf:	eb 02                	jmp    400353c3 <_printf_i+0xbf>
400353c1:	8b 02                	mov    (%edx),%eax
400353c3:	85 c0                	test   %eax,%eax
400353c5:	0f 89 83 00 00 00    	jns    4003544e <_printf_i+0x14a>
400353cb:	f7 d8                	neg    %eax
400353cd:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
400353d1:	eb 7b                	jmp    4003544e <_printf_i+0x14a>
400353d3:	8b 33                	mov    (%ebx),%esi
400353d5:	8b 10                	mov    (%eax),%edx
400353d7:	f7 c6 80 00 00 00    	test   $0x80,%esi
400353dd:	74 07                	je     400353e6 <_printf_i+0xe2>
400353df:	8d 72 04             	lea    0x4(%edx),%esi
400353e2:	89 30                	mov    %esi,(%eax)
400353e4:	eb 0f                	jmp    400353f5 <_printf_i+0xf1>
400353e6:	83 e6 40             	and    $0x40,%esi
400353e9:	8d 72 04             	lea    0x4(%edx),%esi
400353ec:	89 30                	mov    %esi,(%eax)
400353ee:	74 05                	je     400353f5 <_printf_i+0xf1>
400353f0:	0f b7 02             	movzwl (%edx),%eax
400353f3:	eb 02                	jmp    400353f7 <_printf_i+0xf3>
400353f5:	8b 02                	mov    (%edx),%eax
400353f7:	bf 03 67 03 40       	mov    $0x40036703,%edi
400353fc:	80 f9 6f             	cmp    $0x6f,%cl
400353ff:	74 42                	je     40035443 <_printf_i+0x13f>
40035401:	b9 0a 00 00 00       	mov    $0xa,%ecx
40035406:	eb 40                	jmp    40035448 <_printf_i+0x144>
40035408:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
4003540c:	bf 14 67 03 40       	mov    $0x40036714,%edi
40035411:	8b 08                	mov    (%eax),%ecx
40035413:	8b 13                	mov    (%ebx),%edx
40035415:	f6 c2 80             	test   $0x80,%dl
40035418:	8d 71 04             	lea    0x4(%ecx),%esi
4003541b:	89 30                	mov    %esi,(%eax)
4003541d:	75 0a                	jne    40035429 <_printf_i+0x125>
4003541f:	f6 c2 40             	test   $0x40,%dl
40035422:	74 05                	je     40035429 <_printf_i+0x125>
40035424:	0f b7 01             	movzwl (%ecx),%eax
40035427:	eb 02                	jmp    4003542b <_printf_i+0x127>
40035429:	8b 01                	mov    (%ecx),%eax
4003542b:	f6 c2 01             	test   $0x1,%dl
4003542e:	74 05                	je     40035435 <_printf_i+0x131>
40035430:	83 ca 20             	or     $0x20,%edx
40035433:	89 13                	mov    %edx,(%ebx)
40035435:	b9 10 00 00 00       	mov    $0x10,%ecx
4003543a:	85 c0                	test   %eax,%eax
4003543c:	75 0a                	jne    40035448 <_printf_i+0x144>
4003543e:	83 23 df             	andl   $0xffffffdf,(%ebx)
40035441:	eb 05                	jmp    40035448 <_printf_i+0x144>
40035443:	b9 08 00 00 00       	mov    $0x8,%ecx
40035448:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
4003544c:	eb 0a                	jmp    40035458 <_printf_i+0x154>
4003544e:	bf 03 67 03 40       	mov    $0x40036703,%edi
40035453:	b9 0a 00 00 00       	mov    $0xa,%ecx
40035458:	8b 53 04             	mov    0x4(%ebx),%edx
4003545b:	89 53 08             	mov    %edx,0x8(%ebx)
4003545e:	85 d2                	test   %edx,%edx
40035460:	78 12                	js     40035474 <_printf_i+0x170>
40035462:	83 23 fb             	andl   $0xfffffffb,(%ebx)
40035465:	85 c0                	test   %eax,%eax
40035467:	75 13                	jne    4003547c <_printf_i+0x178>
40035469:	89 ee                	mov    %ebp,%esi
4003546b:	85 d2                	test   %edx,%edx
4003546d:	74 1d                	je     4003548c <_printf_i+0x188>
4003546f:	e9 14 01 00 00       	jmp    40035588 <_printf_i+0x284>
40035474:	85 c0                	test   %eax,%eax
40035476:	0f 84 0c 01 00 00    	je     40035588 <_printf_i+0x284>
4003547c:	89 ee                	mov    %ebp,%esi
4003547e:	31 d2                	xor    %edx,%edx
40035480:	4e                   	dec    %esi
40035481:	f7 f1                	div    %ecx
40035483:	85 c0                	test   %eax,%eax
40035485:	8a 14 17             	mov    (%edi,%edx,1),%dl
40035488:	88 16                	mov    %dl,(%esi)
4003548a:	75 f2                	jne    4003547e <_printf_i+0x17a>
4003548c:	83 f9 08             	cmp    $0x8,%ecx
4003548f:	75 12                	jne    400354a3 <_printf_i+0x19f>
40035491:	f6 03 01             	testb  $0x1,(%ebx)
40035494:	74 0d                	je     400354a3 <_printf_i+0x19f>
40035496:	8b 43 10             	mov    0x10(%ebx),%eax
40035499:	39 43 04             	cmp    %eax,0x4(%ebx)
4003549c:	7f 05                	jg     400354a3 <_printf_i+0x19f>
4003549e:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
400354a2:	4e                   	dec    %esi
400354a3:	29 f5                	sub    %esi,%ebp
400354a5:	89 6b 10             	mov    %ebp,0x10(%ebx)
400354a8:	eb 6d                	jmp    40035517 <_printf_i+0x213>
400354aa:	8b 32                	mov    (%edx),%esi
400354ac:	8b 4b 14             	mov    0x14(%ebx),%ecx
400354af:	f7 c6 80 00 00 00    	test   $0x80,%esi
400354b5:	8b 10                	mov    (%eax),%edx
400354b7:	74 09                	je     400354c2 <_printf_i+0x1be>
400354b9:	8d 72 04             	lea    0x4(%edx),%esi
400354bc:	89 30                	mov    %esi,(%eax)
400354be:	8b 02                	mov    (%edx),%eax
400354c0:	eb 11                	jmp    400354d3 <_printf_i+0x1cf>
400354c2:	83 e6 40             	and    $0x40,%esi
400354c5:	8d 72 04             	lea    0x4(%edx),%esi
400354c8:	89 30                	mov    %esi,(%eax)
400354ca:	8b 02                	mov    (%edx),%eax
400354cc:	74 05                	je     400354d3 <_printf_i+0x1cf>
400354ce:	66 89 08             	mov    %cx,(%eax)
400354d1:	eb 02                	jmp    400354d5 <_printf_i+0x1d1>
400354d3:	89 08                	mov    %ecx,(%eax)
400354d5:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
400354dc:	89 ee                	mov    %ebp,%esi
400354de:	eb 37                	jmp    40035517 <_printf_i+0x213>
400354e0:	8b 10                	mov    (%eax),%edx
400354e2:	8d 4a 04             	lea    0x4(%edx),%ecx
400354e5:	89 08                	mov    %ecx,(%eax)
400354e7:	8b 4b 04             	mov    0x4(%ebx),%ecx
400354ea:	8b 32                	mov    (%edx),%esi
400354ec:	31 d2                	xor    %edx,%edx
400354ee:	89 f0                	mov    %esi,%eax
400354f0:	e8 83 ab ff ff       	call   40030078 <memchr>
400354f5:	85 c0                	test   %eax,%eax
400354f7:	74 05                	je     400354fe <_printf_i+0x1fa>
400354f9:	29 f0                	sub    %esi,%eax
400354fb:	89 43 04             	mov    %eax,0x4(%ebx)
400354fe:	8b 43 04             	mov    0x4(%ebx),%eax
40035501:	89 43 10             	mov    %eax,0x10(%ebx)
40035504:	eb 0d                	jmp    40035513 <_printf_i+0x20f>
40035506:	8d 73 42             	lea    0x42(%ebx),%esi
40035509:	88 4b 42             	mov    %cl,0x42(%ebx)
4003550c:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
40035513:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
40035517:	ff 74 24 20          	pushl  0x20(%esp)
4003551b:	ff 74 24 08          	pushl  0x8(%esp)
4003551f:	89 da                	mov    %ebx,%edx
40035521:	8d 4c 24 10          	lea    0x10(%esp),%ecx
40035525:	8b 44 24 08          	mov    0x8(%esp),%eax
40035529:	e8 fa fc ff ff       	call   40035228 <_printf_common>
4003552e:	5f                   	pop    %edi
4003552f:	40                   	inc    %eax
40035530:	5d                   	pop    %ebp
40035531:	75 05                	jne    40035538 <_printf_i+0x234>
40035533:	83 c8 ff             	or     $0xffffffff,%eax
40035536:	eb 5d                	jmp    40035595 <_printf_i+0x291>
40035538:	ff 73 10             	pushl  0x10(%ebx)
4003553b:	89 f1                	mov    %esi,%ecx
4003553d:	8b 54 24 08          	mov    0x8(%esp),%edx
40035541:	8b 44 24 04          	mov    0x4(%esp),%eax
40035545:	ff 54 24 24          	call   *0x24(%esp)
40035549:	59                   	pop    %ecx
4003554a:	40                   	inc    %eax
4003554b:	74 e6                	je     40035533 <_printf_i+0x22f>
4003554d:	f6 03 02             	testb  $0x2,(%ebx)
40035550:	74 27                	je     40035579 <_printf_i+0x275>
40035552:	31 f6                	xor    %esi,%esi
40035554:	8d 7b 19             	lea    0x19(%ebx),%edi
40035557:	eb 15                	jmp    4003556e <_printf_i+0x26a>
40035559:	6a 01                	push   $0x1
4003555b:	89 f9                	mov    %edi,%ecx
4003555d:	8b 54 24 08          	mov    0x8(%esp),%edx
40035561:	8b 44 24 04          	mov    0x4(%esp),%eax
40035565:	ff 54 24 24          	call   *0x24(%esp)
40035569:	5a                   	pop    %edx
4003556a:	40                   	inc    %eax
4003556b:	74 c6                	je     40035533 <_printf_i+0x22f>
4003556d:	46                   	inc    %esi
4003556e:	8b 43 0c             	mov    0xc(%ebx),%eax
40035571:	2b 44 24 08          	sub    0x8(%esp),%eax
40035575:	39 c6                	cmp    %eax,%esi
40035577:	7c e0                	jl     40035559 <_printf_i+0x255>
40035579:	8b 54 24 08          	mov    0x8(%esp),%edx
4003557d:	8b 43 0c             	mov    0xc(%ebx),%eax
40035580:	39 d0                	cmp    %edx,%eax
40035582:	7d 11                	jge    40035595 <_printf_i+0x291>
40035584:	89 d0                	mov    %edx,%eax
40035586:	eb 0d                	jmp    40035595 <_printf_i+0x291>
40035588:	8a 07                	mov    (%edi),%al
4003558a:	8d 73 42             	lea    0x42(%ebx),%esi
4003558d:	88 43 42             	mov    %al,0x42(%ebx)
40035590:	e9 f7 fe ff ff       	jmp    4003548c <_printf_i+0x188>
40035595:	83 c4 0c             	add    $0xc,%esp
40035598:	5b                   	pop    %ebx
40035599:	5e                   	pop    %esi
4003559a:	5f                   	pop    %edi
4003559b:	5d                   	pop    %ebp
4003559c:	c3                   	ret    

4003559d <__sread>:
4003559d:	53                   	push   %ebx
4003559e:	89 d3                	mov    %edx,%ebx
400355a0:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400355a4:	ff 74 24 08          	pushl  0x8(%esp)
400355a8:	e8 52 01 00 00       	call   400356ff <_read_r>
400355ad:	5a                   	pop    %edx
400355ae:	85 c0                	test   %eax,%eax
400355b0:	78 05                	js     400355b7 <__sread+0x1a>
400355b2:	01 43 50             	add    %eax,0x50(%ebx)
400355b5:	eb 06                	jmp    400355bd <__sread+0x20>
400355b7:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400355bd:	5b                   	pop    %ebx
400355be:	c3                   	ret    

400355bf <__swrite>:
400355bf:	55                   	push   %ebp
400355c0:	57                   	push   %edi
400355c1:	56                   	push   %esi
400355c2:	53                   	push   %ebx
400355c3:	89 c6                	mov    %eax,%esi
400355c5:	89 d3                	mov    %edx,%ebx
400355c7:	89 cf                	mov    %ecx,%edi
400355c9:	8b 6c 24 14          	mov    0x14(%esp),%ebp
400355cd:	f6 42 0d 01          	testb  $0x1,0xd(%edx)
400355d1:	74 0e                	je     400355e1 <__swrite+0x22>
400355d3:	0f bf 52 0e          	movswl 0xe(%edx),%edx
400355d7:	31 c9                	xor    %ecx,%ecx
400355d9:	6a 02                	push   $0x2
400355db:	e8 f2 00 00 00       	call   400356d2 <_lseek_r>
400355e0:	58                   	pop    %eax
400355e1:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
400355e7:	0f bf 53 0e          	movswl 0xe(%ebx),%edx
400355eb:	89 f9                	mov    %edi,%ecx
400355ed:	89 f0                	mov    %esi,%eax
400355ef:	89 6c 24 14          	mov    %ebp,0x14(%esp)
400355f3:	5b                   	pop    %ebx
400355f4:	5e                   	pop    %esi
400355f5:	5f                   	pop    %edi
400355f6:	5d                   	pop    %ebp
400355f7:	e9 32 00 00 00       	jmp    4003562e <_write_r>

400355fc <__sseek>:
400355fc:	53                   	push   %ebx
400355fd:	89 d3                	mov    %edx,%ebx
400355ff:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035603:	ff 74 24 08          	pushl  0x8(%esp)
40035607:	e8 c6 00 00 00       	call   400356d2 <_lseek_r>
4003560c:	5a                   	pop    %edx
4003560d:	83 f8 ff             	cmp    $0xffffffff,%eax
40035610:	75 08                	jne    4003561a <__sseek+0x1e>
40035612:	66 81 63 0c ff ef    	andw   $0xefff,0xc(%ebx)
40035618:	eb 09                	jmp    40035623 <__sseek+0x27>
4003561a:	66 81 4b 0c 00 10    	orw    $0x1000,0xc(%ebx)
40035620:	89 43 50             	mov    %eax,0x50(%ebx)
40035623:	5b                   	pop    %ebx
40035624:	c3                   	ret    

40035625 <__sclose>:
40035625:	0f bf 52 0e          	movswl 0xe(%edx),%edx
40035629:	e9 2d 00 00 00       	jmp    4003565b <_close_r>

4003562e <_write_r>:
4003562e:	53                   	push   %ebx
4003562f:	89 c3                	mov    %eax,%ebx
40035631:	89 d0                	mov    %edx,%eax
40035633:	89 ca                	mov    %ecx,%edx
40035635:	8b 4c 24 08          	mov    0x8(%esp),%ecx
40035639:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40035640:	00 00 00 
40035643:	e8 1b be ff ff       	call   40031463 <_write>
40035648:	83 f8 ff             	cmp    $0xffffffff,%eax
4003564b:	75 0c                	jne    40035659 <_write_r+0x2b>
4003564d:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40035653:	85 d2                	test   %edx,%edx
40035655:	74 02                	je     40035659 <_write_r+0x2b>
40035657:	89 13                	mov    %edx,(%ebx)
40035659:	5b                   	pop    %ebx
4003565a:	c3                   	ret    

4003565b <_close_r>:
4003565b:	53                   	push   %ebx
4003565c:	89 c3                	mov    %eax,%ebx
4003565e:	89 d0                	mov    %edx,%eax
40035660:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40035667:	00 00 00 
4003566a:	e8 41 be ff ff       	call   400314b0 <_close>
4003566f:	83 f8 ff             	cmp    $0xffffffff,%eax
40035672:	75 0c                	jne    40035680 <_close_r+0x25>
40035674:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
4003567a:	85 d2                	test   %edx,%edx
4003567c:	74 02                	je     40035680 <_close_r+0x25>
4003567e:	89 13                	mov    %edx,(%ebx)
40035680:	5b                   	pop    %ebx
40035681:	c3                   	ret    

40035682 <_fstat_r>:
40035682:	53                   	push   %ebx
40035683:	89 c3                	mov    %eax,%ebx
40035685:	89 d0                	mov    %edx,%eax
40035687:	89 ca                	mov    %ecx,%edx
40035689:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40035690:	00 00 00 
40035693:	e8 0a be ff ff       	call   400314a2 <_fstat>
40035698:	83 f8 ff             	cmp    $0xffffffff,%eax
4003569b:	75 0c                	jne    400356a9 <_fstat_r+0x27>
4003569d:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
400356a3:	85 d2                	test   %edx,%edx
400356a5:	74 02                	je     400356a9 <_fstat_r+0x27>
400356a7:	89 13                	mov    %edx,(%ebx)
400356a9:	5b                   	pop    %ebx
400356aa:	c3                   	ret    

400356ab <_isatty_r>:
400356ab:	53                   	push   %ebx
400356ac:	89 c3                	mov    %eax,%ebx
400356ae:	89 d0                	mov    %edx,%eax
400356b0:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
400356b7:	00 00 00 
400356ba:	e8 d9 bd ff ff       	call   40031498 <_isatty>
400356bf:	83 f8 ff             	cmp    $0xffffffff,%eax
400356c2:	75 0c                	jne    400356d0 <_isatty_r+0x25>
400356c4:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
400356ca:	85 d2                	test   %edx,%edx
400356cc:	74 02                	je     400356d0 <_isatty_r+0x25>
400356ce:	89 13                	mov    %edx,(%ebx)
400356d0:	5b                   	pop    %ebx
400356d1:	c3                   	ret    

400356d2 <_lseek_r>:
400356d2:	53                   	push   %ebx
400356d3:	89 c3                	mov    %eax,%ebx
400356d5:	89 d0                	mov    %edx,%eax
400356d7:	89 ca                	mov    %ecx,%edx
400356d9:	8b 4c 24 08          	mov    0x8(%esp),%ecx
400356dd:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
400356e4:	00 00 00 
400356e7:	e8 cc bd ff ff       	call   400314b8 <_lseek>
400356ec:	83 f8 ff             	cmp    $0xffffffff,%eax
400356ef:	75 0c                	jne    400356fd <_lseek_r+0x2b>
400356f1:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
400356f7:	85 d2                	test   %edx,%edx
400356f9:	74 02                	je     400356fd <_lseek_r+0x2b>
400356fb:	89 13                	mov    %edx,(%ebx)
400356fd:	5b                   	pop    %ebx
400356fe:	c3                   	ret    

400356ff <_read_r>:
400356ff:	53                   	push   %ebx
40035700:	89 c3                	mov    %eax,%ebx
40035702:	89 d0                	mov    %edx,%eax
40035704:	89 ca                	mov    %ecx,%edx
40035706:	8b 4c 24 08          	mov    0x8(%esp),%ecx
4003570a:	c7 05 b4 78 00 a8 00 	movl   $0x0,0xa80078b4
40035711:	00 00 00 
40035714:	e8 1f bd ff ff       	call   40031438 <_read>
40035719:	83 f8 ff             	cmp    $0xffffffff,%eax
4003571c:	75 0c                	jne    4003572a <_read_r+0x2b>
4003571e:	8b 15 b4 78 00 a8    	mov    0xa80078b4,%edx
40035724:	85 d2                	test   %edx,%edx
40035726:	74 02                	je     4003572a <_read_r+0x2b>
40035728:	89 13                	mov    %edx,(%ebx)
4003572a:	5b                   	pop    %ebx
4003572b:	c3                   	ret    

4003572c <_handle_exc_0_vector_0_stub>:
4003572c:	6a 00                	push   $0x0
4003572e:	68 46 3c 03 40       	push   $0x40033c46
40035733:	e9 ad e2 ff ff       	jmp    400339e5 <_exception_enter>

40035738 <_handle_exc_2_vector_2_stub>:
40035738:	6a 00                	push   $0x0
4003573a:	68 52 3c 03 40       	push   $0x40033c52
4003573f:	e9 a1 e2 ff ff       	jmp    400339e5 <_exception_enter>

40035744 <_handle_exc_4_vector_4_stub>:
40035744:	6a 00                	push   $0x0
40035746:	68 61 3c 03 40       	push   $0x40033c61
4003574b:	e9 95 e2 ff ff       	jmp    400339e5 <_exception_enter>

40035750 <_handle_exc_5_vector_5_stub>:
40035750:	6a 00                	push   $0x0
40035752:	68 70 3c 03 40       	push   $0x40033c70
40035757:	e9 89 e2 ff ff       	jmp    400339e5 <_exception_enter>

4003575c <_handle_exc_6_vector_6_stub>:
4003575c:	6a 00                	push   $0x0
4003575e:	68 7f 3c 03 40       	push   $0x40033c7f
40035763:	e9 7d e2 ff ff       	jmp    400339e5 <_exception_enter>

40035768 <_handle_exc_7_vector_7_stub>:
40035768:	6a 00                	push   $0x0
4003576a:	68 8e 3c 03 40       	push   $0x40033c8e
4003576f:	e9 71 e2 ff ff       	jmp    400339e5 <_exception_enter>

40035774 <_handle_exc_8_vector_8_stub>:
40035774:	68 9d 3c 03 40       	push   $0x40033c9d
40035779:	e9 67 e2 ff ff       	jmp    400339e5 <_exception_enter>

4003577e <_handle_exc_10_vector_10_stub>:
4003577e:	68 ac 3c 03 40       	push   $0x40033cac
40035783:	e9 5d e2 ff ff       	jmp    400339e5 <_exception_enter>

40035788 <_handle_exc_11_vector_11_stub>:
40035788:	68 bb 3c 03 40       	push   $0x40033cbb
4003578d:	e9 53 e2 ff ff       	jmp    400339e5 <_exception_enter>

40035792 <_handle_exc_12_vector_12_stub>:
40035792:	68 ca 3c 03 40       	push   $0x40033cca
40035797:	e9 49 e2 ff ff       	jmp    400339e5 <_exception_enter>

4003579c <_handle_exc_13_vector_13_stub>:
4003579c:	68 d9 3c 03 40       	push   $0x40033cd9
400357a1:	e9 3f e2 ff ff       	jmp    400339e5 <_exception_enter>

400357a6 <_handle_exc_14_vector_14_stub>:
400357a6:	68 e8 3c 03 40       	push   $0x40033ce8
400357ab:	e9 35 e2 ff ff       	jmp    400339e5 <_exception_enter>

400357b0 <_handle_exc_16_vector_16_stub>:
400357b0:	6a 00                	push   $0x0
400357b2:	68 f7 3c 03 40       	push   $0x40033cf7
400357b7:	e9 29 e2 ff ff       	jmp    400339e5 <_exception_enter>

400357bc <_handle_exc_17_vector_17_stub>:
400357bc:	68 06 3d 03 40       	push   $0x40033d06
400357c1:	e9 1f e2 ff ff       	jmp    400339e5 <_exception_enter>

400357c6 <_handle_exc_18_vector_18_stub>:
400357c6:	6a 00                	push   $0x0
400357c8:	68 15 3d 03 40       	push   $0x40033d15
400357cd:	e9 13 e2 ff ff       	jmp    400339e5 <_exception_enter>
